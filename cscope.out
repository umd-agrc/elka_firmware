cscope 15 $HOME/Dropbox/Boxifier/elkastm32f4_test_spektrum_snapdragon1 -c -q 0000016241 0001875348
	@FreeRTOS/croutine.c

54 #include 
	~"FreeRTOS.h
"

55 #include 
	~"task.h
"

56 #include 
	~"croutine.h
"

62 #ifdef 
portREMOVE_STATIC_QUALIFIER


63 #define static

	)

68 static 
xList
 
	gpxReadyCoRoutineLists
[ 
configMAX_CO_ROUTINE_PRIORITIES
 ];

69 static 
xList
 
	gxDelayedCoRoutineList1
;

70 static 
xList
 
	gxDelayedCoRoutineList2
;

71 static 
xList
 * 
	gpxDelayedCoRoutineList
;

72 static 
xList
 * 
	gpxOverflowDelayedCoRoutineList
;

73 static 
xList
 
	gxPendingReadyCoRoutineList
;

76 
corCRCB
 * 
	gpxCurrentCoRoutine
 = 
NULL
;

77 static unsigned 
portBASE_TYPE
 
	guxTopCoRoutineReadyPriority
 = 0;

78 static 
portTickType
 
	gxCoRoutineTickCount
 = 0, 
	gxLastTickCount
 = 0, 
	gxPassedTicks
 = 0;

81 #define 
	#corINITIAL_STATE
 ( 0 )

	)

90 #define 
	#prvAddCoRoutineToReadyQueue
( 
pxCRCB
 ) \

	)

92 if( 
	gpxCRCB
->
	guxPriority
 > 
	guxTopCoRoutineReadyPriority
 ) \

94 
	guxTopCoRoutineReadyPriority
 = 
pxCRCB
->
uxPriority
; \

96 
vListInsertEnd
( ( 
xList
 * ) &( 
pxReadyCoRoutineLists
[ 
pxCRCB
->
uxPriority
 ] ), &( pxCRCB->
xGenericListItem
 ) ); \

103 static void 
prvInitialiseCoRoutineLists
( void );

111 static void 
prvCheckPendingReadyList
( void );

121 static void 
prvCheckDelayedList
( void );

125 signed 
portBASE_TYPE
 
	$xCoRoutineCreate
( 
crCOROUTINE_CODE
 
pxCoRoutineCode
, unsigned 
portBASE_TYPE
 
uxPriority
, unsigned portBASE_TYPE 
uxIndex
 )

127 signed 
portBASE_TYPE
 
xReturn
;

128 
corCRCB
 *
pxCoRoutine
;

131 
pxCoRoutine
 = ( 
corCRCB
 * ) 
	`pvPortMalloc
( sizeof( corCRCB ) );

132 if( 
pxCoRoutine
 )

136 if( 
pxCurrentCoRoutine
 == 
NULL
 )

138 
pxCurrentCoRoutine
 = 
pxCoRoutine
;

139 
	`prvInitialiseCoRoutineLists
();

143 if( 
uxPriority
 >= 
configMAX_CO_ROUTINE_PRIORITIES
 )

145 
uxPriority
 = 
configMAX_CO_ROUTINE_PRIORITIES
 - 1;

149 
pxCoRoutine
->
uxState
 = 
corINITIAL_STATE
;

150 
pxCoRoutine
->
uxPriority
 = uxPriority;

151 
pxCoRoutine
->
uxIndex
 = uxIndex;

152 
pxCoRoutine
->
pxCoRoutineFunction
 = 
pxCoRoutineCode
;

155 
	`vListInitialiseItem
( &( 
pxCoRoutine
->
xGenericListItem
 ) );

156 
	`vListInitialiseItem
( &( 
pxCoRoutine
->
xEventListItem
 ) );

161 
	`listSET_LIST_ITEM_OWNER
( &( 
pxCoRoutine
->
xGenericListItem
 ), pxCoRoutine );

162 
	`listSET_LIST_ITEM_OWNER
( &( 
pxCoRoutine
->
xEventListItem
 ), pxCoRoutine );

165 
	`listSET_LIST_ITEM_VALUE
( &( 
pxCoRoutine
->
xEventListItem
 ), 
configMAX_PRIORITIES
 - ( 
portTickType
 ) 
uxPriority
 );

169 
	`prvAddCoRoutineToReadyQueue
( 
pxCoRoutine
 );

171 
xReturn
 = 
pdPASS
;

175 
xReturn
 = 
errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
;

178 return 
xReturn
;

179 
	}
}

182 void 
	$vCoRoutineAddToDelayedList
( 
portTickType
 
xTicksToDelay
, 
xList
 *
pxEventList
 )

184 
portTickType
 
xTimeToWake
;

188 
xTimeToWake
 = 
xCoRoutineTickCount
 + 
xTicksToDelay
;

193 
	`vListRemove
( ( 
xListItem
 * ) &( 
pxCurrentCoRoutine
->
xGenericListItem
 ) );

196 
	`listSET_LIST_ITEM_VALUE
( &( 
pxCurrentCoRoutine
->
xGenericListItem
 ), 
xTimeToWake
 );

198 if( 
xTimeToWake
 < 
xCoRoutineTickCount
 )

202 
	`vListInsert
( ( 
xList
 * ) 
pxOverflowDelayedCoRoutineList
, ( 
xListItem
 * ) &( 
pxCurrentCoRoutine
->
xGenericListItem
 ) );

208 
	`vListInsert
( ( 
xList
 * ) 
pxDelayedCoRoutineList
, ( 
xListItem
 * ) &( 
pxCurrentCoRoutine
->
xGenericListItem
 ) );

211 if( 
pxEventList
 )

215 
	`vListInsert
( 
pxEventList
, &( 
pxCurrentCoRoutine
->
xEventListItem
 ) );

217 
	}
}

220 static void 
	$prvCheckPendingReadyList
( void )

225 while( 
	`listLIST_IS_EMPTY
( &
xPendingReadyCoRoutineList
 ) == 
pdFALSE
 )

227 
corCRCB
 *
pxUnblockedCRCB
;

230 
	`portDISABLE_INTERRUPTS
();

232 
pxUnblockedCRCB
 = ( 
corCRCB
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( (&
xPendingReadyCoRoutineList
) );

233 
	`vListRemove
( &( 
pxUnblockedCRCB
->
xEventListItem
 ) );

235 
	`portENABLE_INTERRUPTS
();

237 
	`vListRemove
( &( 
pxUnblockedCRCB
->
xGenericListItem
 ) );

238 
	`prvAddCoRoutineToReadyQueue
( 
pxUnblockedCRCB
 );

240 
	}
}

243 static void 
	$prvCheckDelayedList
( void )

245 
corCRCB
 *
pxCRCB
;

247 
xPassedTicks
 = 
	`xTaskGetTickCount
() - 
xLastTickCount
;

248 while( 
xPassedTicks
 )

250 
xCoRoutineTickCount
++;

251 
xPassedTicks
--;

254 if( 
xCoRoutineTickCount
 == 0 )

256 
xList
 * 
pxTemp
;

260 
pxTemp
 = 
pxDelayedCoRoutineList
;

261 
pxDelayedCoRoutineList
 = 
pxOverflowDelayedCoRoutineList
;

262 
pxOverflowDelayedCoRoutineList
 = 
pxTemp
;

266 while( 
	`listLIST_IS_EMPTY
( 
pxDelayedCoRoutineList
 ) == 
pdFALSE
 )

268 
pxCRCB
 = ( 
corCRCB
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( 
pxDelayedCoRoutineList
 );

270 if( 
xCoRoutineTickCount
 < 
	`listGET_LIST_ITEM_VALUE
( &( 
pxCRCB
->
xGenericListItem
 ) ) )

276 
	`portDISABLE_INTERRUPTS
();

283 
	`vListRemove
( &( 
pxCRCB
->
xGenericListItem
 ) );

286 if( 
pxCRCB
->
xEventListItem
.
pvContainer
 )

288 
	`vListRemove
( &( 
pxCRCB
->
xEventListItem
 ) );

291 
	`portENABLE_INTERRUPTS
();

293 
	`prvAddCoRoutineToReadyQueue
( 
pxCRCB
 );

297 
xLastTickCount
 = 
xCoRoutineTickCount
;

298 
	}
}

301 void 
	$vCoRoutineSchedule
( void )

304 
	`prvCheckPendingReadyList
();

307 
	`prvCheckDelayedList
();

310 while( 
	`listLIST_IS_EMPTY
( &( 
pxReadyCoRoutineLists
[ 
uxTopCoRoutineReadyPriority
 ] ) ) )

312 if( 
uxTopCoRoutineReadyPriority
 == 0 )

317 --
uxTopCoRoutineReadyPriority
;

322 
	`listGET_OWNER_OF_NEXT_ENTRY
( 
pxCurrentCoRoutine
, &( 
pxReadyCoRoutineLists
[ 
uxTopCoRoutineReadyPriority
 ] ) );

325 ( 
pxCurrentCoRoutine
->
pxCoRoutineFunction
 )( pxCurrentCoRoutine, pxCurrentCoRoutine->
uxIndex
 );

328 
	}
}

331 static void 
	$prvInitialiseCoRoutineLists
( void )

333 unsigned 
portBASE_TYPE
 
uxPriority
;

335 for( 
uxPriority
 = 0; uxPriority < 
configMAX_CO_ROUTINE_PRIORITIES
; uxPriority++ )

337 
	`vListInitialise
( ( 
xList
 * ) &( 
pxReadyCoRoutineLists
[ 
uxPriority
 ] ) );

340 
	`vListInitialise
( ( 
xList
 * ) &
xDelayedCoRoutineList1
 );

341 
	`vListInitialise
( ( 
xList
 * ) &
xDelayedCoRoutineList2
 );

342 
	`vListInitialise
( ( 
xList
 * ) &
xPendingReadyCoRoutineList
 );

346 
pxDelayedCoRoutineList
 = &
xDelayedCoRoutineList1
;

347 
pxOverflowDelayedCoRoutineList
 = &
xDelayedCoRoutineList2
;

348 
	}
}

351 signed 
portBASE_TYPE
 
	$xCoRoutineRemoveFromEventList
( const 
xList
 *
pxEventList
 )

353 
corCRCB
 *
pxUnblockedCRCB
;

354 signed 
portBASE_TYPE
 
xReturn
;

359 
pxUnblockedCRCB
 = ( 
corCRCB
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( 
pxEventList
 );

360 
	`vListRemove
( &( 
pxUnblockedCRCB
->
xEventListItem
 ) );

361 
	`vListInsertEnd
( ( 
xList
 * ) &( 
xPendingReadyCoRoutineList
 ), &( 
pxUnblockedCRCB
->
xEventListItem
 ) );

363 if( 
pxUnblockedCRCB
->
uxPriority
 >= 
pxCurrentCoRoutine
->uxPriority )

365 
xReturn
 = 
pdTRUE
;

369 
xReturn
 = 
pdFALSE
;

372 return 
xReturn
;

373 
	}
}

	@FreeRTOS/include/FreeRTOS.h

54 #ifndef 
INC_FREERTOS_H


55 #define 
	#INC_FREERTOS_H


	)

61 #include 
	~<stddef.h
>

64 #include 
	~"projdefs.h
"

67 #include 
	~"FreeRTOSConfig.h
"

70 #include 
	~"portable.h
"

75 typedef 
	$portBASE_TYPE
 (*
	tpdTASK_HOOK_CODE
)( void * );

87 #ifndef 
configUSE_PREEMPTION


88 #error 
Missing
 
definition
: 
configUSE_PREEMPTION
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

91 #ifndef 
configUSE_IDLE_HOOK


92 #error 
Missing
 
definition
: 
configUSE_IDLE_HOOK
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

95 #ifndef 
configUSE_TICK_HOOK


96 #error 
Missing
 
definition
: 
configUSE_TICK_HOOK
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

99 #ifndef 
configUSE_CO_ROUTINES


100 #error 
Missing
 
definition
: 
configUSE_CO_ROUTINES
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

103 #ifndef 
INCLUDE_vTaskPrioritySet


104 #error 
Missing
 
definition
: 
INCLUDE_vTaskPrioritySet
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

107 #ifndef 
INCLUDE_uxTaskPriorityGet


108 #error 
Missing
 
definition
: 
INCLUDE_uxTaskPriorityGet
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

111 #ifndef 
INCLUDE_vTaskDelete


112 #error 
Missing
 
definition
: 
INCLUDE_vTaskDelete
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

115 #ifndef 
INCLUDE_vTaskSuspend


116 #error 
Missing
 
definition
: 
INCLUDE_vTaskSuspend
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

119 #ifndef 
INCLUDE_vTaskDelayUntil


120 #error 
Missing
 
definition
: 
INCLUDE_vTaskDelayUntil
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

123 #ifndef 
INCLUDE_vTaskDelay


124 #error 
Missing
 
definition
: 
INCLUDE_vTaskDelay
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

127 #ifndef 
configUSE_16_BIT_TICKS


128 #error 
Missing
 
definition
: 
configUSE_16_BIT_TICKS
 
should
 
be
 
defined
 
in
 
FreeRTOSConfig
.
h
 
as
 
either
 1 
or
 0. 
See
 
the
 
Configuration
 
section
 
of
 the 
FreeRTOS
 
API
 
documentation
 for 
details
.

131 #ifndef 
INCLUDE_xTaskGetIdleTaskHandle


132 #define 
	#INCLUDE_xTaskGetIdleTaskHandle
 0

	)

135 #ifndef 
INCLUDE_xTimerGetTimerDaemonTaskHandle


136 #define 
	#INCLUDE_xTimerGetTimerDaemonTaskHandle
 0

	)

139 #ifndef 
INCLUDE_pcTaskGetTaskName


140 #define 
	#INCLUDE_pcTaskGetTaskName
 0

	)

143 #ifndef 
configUSE_APPLICATION_TASK_TAG


144 #define 
	#configUSE_APPLICATION_TASK_TAG
 0

	)

147 #ifndef 
INCLUDE_uxTaskGetStackHighWaterMark


148 #define 
	#INCLUDE_uxTaskGetStackHighWaterMark
 0

	)

151 #ifndef 
configUSE_RECURSIVE_MUTEXES


152 #define 
	#configUSE_RECURSIVE_MUTEXES
 0

	)

155 #ifndef 
configUSE_MUTEXES


156 #define 
	#configUSE_MUTEXES
 0

	)

159 #ifndef 
configUSE_TIMERS


160 #define 
	#configUSE_TIMERS
 0

	)

163 #ifndef 
configUSE_COUNTING_SEMAPHORES


164 #define 
	#configUSE_COUNTING_SEMAPHORES
 0

	)

167 #ifndef 
configUSE_ALTERNATIVE_API


168 #define 
	#configUSE_ALTERNATIVE_API
 0

	)

171 #ifndef 
portCRITICAL_NESTING_IN_TCB


172 #define 
	#portCRITICAL_NESTING_IN_TCB
 0

	)

175 #ifndef 
configMAX_TASK_NAME_LEN


176 #define 
	#configMAX_TASK_NAME_LEN
 16

	)

179 #ifndef 
configIDLE_SHOULD_YIELD


180 #define 
	#configIDLE_SHOULD_YIELD
 1

	)

183 #if 
configMAX_TASK_NAME_LEN
 < 1

184 #error 
configMAX_TASK_NAME_LEN
 
must
 
be
 
set
 
to
 
a
 
minimum
 
of
 1 
in
 
FreeRTOSConfig
.
h


187 #ifndef 
INCLUDE_xTaskResumeFromISR


188 #define 
	#INCLUDE_xTaskResumeFromISR
 1

	)

191 #ifndef 
configASSERT


192 #define 
	#configASSERT
( 
x
 )

	)

195 #ifndef 
portALIGNMENT_ASSERT_pxCurrentTCB


196 #define 
	#portALIGNMENT_ASSERT_pxCurrentTCB
 
configASSERT


	)

200 #if 
configUSE_TIMERS
 == 1

202 #ifndef 
configTIMER_TASK_PRIORITY


203 #error 
If
 
configUSE_TIMERS
 
is
 
set
 
to
 1 
then
 
configTIMER_TASK_PRIORITY
 
must
 
also
 
be
 
defined
.

206 #ifndef 
configTIMER_QUEUE_LENGTH


207 #error 
If
 
configUSE_TIMERS
 
is
 
set
 
to
 1 
then
 
configTIMER_QUEUE_LENGTH
 
must
 
also
 
be
 
defined
.

210 #ifndef 
configTIMER_TASK_STACK_DEPTH


211 #error 
If
 
configUSE_TIMERS
 
is
 
set
 
to
 1 
then
 
configTIMER_TASK_STACK_DEPTH
 
must
 
also
 
be
 
defined
.

216 #ifndef 
INCLUDE_xTaskGetSchedulerState


217 #define 
	#INCLUDE_xTaskGetSchedulerState
 0

	)

220 #ifndef 
INCLUDE_xTaskGetCurrentTaskHandle


221 #define 
	#INCLUDE_xTaskGetCurrentTaskHandle
 0

	)

225 #ifndef 
portSET_INTERRUPT_MASK_FROM_ISR


226 #define 
	#portSET_INTERRUPT_MASK_FROM_ISR
() 0

	)

229 #ifndef 
portCLEAR_INTERRUPT_MASK_FROM_ISR


230 #define 
	#portCLEAR_INTERRUPT_MASK_FROM_ISR
( 
uxSavedStatusValue
 ) ( void ) 
	)
uxSavedStatusValue

233 #ifndef 
portCLEAN_UP_TCB


234 #define 
	#portCLEAN_UP_TCB
( 
pxTCB
 ) ( void ) 
	)
pxTCB

237 #ifndef 
configQUEUE_REGISTRY_SIZE


238 #define 
	#configQUEUE_REGISTRY_SIZE
 0U

	)

241 #if ( 
configQUEUE_REGISTRY_SIZE
 < 1 )

242 #define 
	#vQueueAddToRegistry
( 
xQueue
, 
pcName
 )

	)

243 #define 
	#vQueueUnregisterQueue
( 
xQueue
 )

	)

246 #ifndef 
portPOINTER_SIZE_TYPE


247 #define 
	#portPOINTER_SIZE_TYPE
 unsigned long

	)

251 #ifndef 
traceSTART


254 #define 
	#traceSTART
()

	)

257 #ifndef 
traceEND


260 #define 
	#traceEND
()

	)

263 #ifndef 
traceTASK_SWITCHED_IN


266 #define 
	#traceTASK_SWITCHED_IN
()

	)

269 #ifndef 
traceTASK_SWITCHED_OUT


272 #define 
	#traceTASK_SWITCHED_OUT
()

	)

275 #ifndef 
traceTASK_PRIORITY_INHERIT


281 #define 
	#traceTASK_PRIORITY_INHERIT
( 
pxTCBOfMutexHolder
, 
uxInheritedPriority
 )

	)

284 #ifndef 
traceTASK_PRIORITY_DISINHERIT


289 #define 
	#traceTASK_PRIORITY_DISINHERIT
( 
pxTCBOfMutexHolder
, 
uxOriginalPriority
 )

	)

292 #ifndef 
traceBLOCKING_ON_QUEUE_RECEIVE


297 #define 
	#traceBLOCKING_ON_QUEUE_RECEIVE
( 
pxQueue
 )

	)

300 #ifndef 
traceBLOCKING_ON_QUEUE_SEND


305 #define 
	#traceBLOCKING_ON_QUEUE_SEND
( 
pxQueue
 )

	)

308 #ifndef 
configCHECK_FOR_STACK_OVERFLOW


309 #define 
	#configCHECK_FOR_STACK_OVERFLOW
 0

	)

314 #ifndef 
traceQUEUE_CREATE


315 #define 
	#traceQUEUE_CREATE
( 
pxNewQueue
 )

	)

318 #ifndef 
traceQUEUE_CREATE_FAILED


319 #define 
	#traceQUEUE_CREATE_FAILED
( 
ucQueueType
 )

	)

322 #ifndef 
traceCREATE_MUTEX


323 #define 
	#traceCREATE_MUTEX
( 
pxNewQueue
 )

	)

326 #ifndef 
traceCREATE_MUTEX_FAILED


327 #define 
	#traceCREATE_MUTEX_FAILED
()

	)

330 #ifndef 
traceGIVE_MUTEX_RECURSIVE


331 #define 
	#traceGIVE_MUTEX_RECURSIVE
( 
pxMutex
 )

	)

334 #ifndef 
traceGIVE_MUTEX_RECURSIVE_FAILED


335 #define 
	#traceGIVE_MUTEX_RECURSIVE_FAILED
( 
pxMutex
 )

	)

338 #ifndef 
traceTAKE_MUTEX_RECURSIVE


339 #define 
	#traceTAKE_MUTEX_RECURSIVE
( 
pxMutex
 )

	)

342 #ifndef 
traceTAKE_MUTEX_RECURSIVE_FAILED


343 #define 
	#traceTAKE_MUTEX_RECURSIVE_FAILED
( 
pxMutex
 )

	)

346 #ifndef 
traceCREATE_COUNTING_SEMAPHORE


347 #define 
	#traceCREATE_COUNTING_SEMAPHORE
()

	)

350 #ifndef 
traceCREATE_COUNTING_SEMAPHORE_FAILED


351 #define 
	#traceCREATE_COUNTING_SEMAPHORE_FAILED
()

	)

354 #ifndef 
traceQUEUE_SEND


355 #define 
	#traceQUEUE_SEND
( 
pxQueue
 )

	)

358 #ifndef 
traceQUEUE_SEND_FAILED


359 #define 
	#traceQUEUE_SEND_FAILED
( 
pxQueue
 )

	)

362 #ifndef 
traceQUEUE_RECEIVE


363 #define 
	#traceQUEUE_RECEIVE
( 
pxQueue
 )

	)

366 #ifndef 
traceQUEUE_PEEK


367 #define 
	#traceQUEUE_PEEK
( 
pxQueue
 )

	)

370 #ifndef 
traceQUEUE_RECEIVE_FAILED


371 #define 
	#traceQUEUE_RECEIVE_FAILED
( 
pxQueue
 )

	)

374 #ifndef 
traceQUEUE_SEND_FROM_ISR


375 #define 
	#traceQUEUE_SEND_FROM_ISR
( 
pxQueue
 )

	)

378 #ifndef 
traceQUEUE_SEND_FROM_ISR_FAILED


379 #define 
	#traceQUEUE_SEND_FROM_ISR_FAILED
( 
pxQueue
 )

	)

382 #ifndef 
traceQUEUE_RECEIVE_FROM_ISR


383 #define 
	#traceQUEUE_RECEIVE_FROM_ISR
( 
pxQueue
 )

	)

386 #ifndef 
traceQUEUE_RECEIVE_FROM_ISR_FAILED


387 #define 
	#traceQUEUE_RECEIVE_FROM_ISR_FAILED
( 
pxQueue
 )

	)

390 #ifndef 
traceQUEUE_DELETE


391 #define 
	#traceQUEUE_DELETE
( 
pxQueue
 )

	)

394 #ifndef 
traceTASK_CREATE


395 #define 
	#traceTASK_CREATE
( 
pxNewTCB
 )

	)

398 #ifndef 
traceTASK_CREATE_FAILED


399 #define 
	#traceTASK_CREATE_FAILED
()

	)

402 #ifndef 
traceTASK_DELETE


403 #define 
	#traceTASK_DELETE
( 
pxTaskToDelete
 )

	)

406 #ifndef 
traceTASK_DELAY_UNTIL


407 #define 
	#traceTASK_DELAY_UNTIL
()

	)

410 #ifndef 
traceTASK_DELAY


411 #define 
	#traceTASK_DELAY
()

	)

414 #ifndef 
traceTASK_PRIORITY_SET


415 #define 
	#traceTASK_PRIORITY_SET
( 
pxTask
, 
uxNewPriority
 )

	)

418 #ifndef 
traceTASK_SUSPEND


419 #define 
	#traceTASK_SUSPEND
( 
pxTaskToSuspend
 )

	)

422 #ifndef 
traceTASK_RESUME


423 #define 
	#traceTASK_RESUME
( 
pxTaskToResume
 )

	)

426 #ifndef 
traceTASK_RESUME_FROM_ISR


427 #define 
	#traceTASK_RESUME_FROM_ISR
( 
pxTaskToResume
 )

	)

430 #ifndef 
traceTASK_INCREMENT_TICK


431 #define 
	#traceTASK_INCREMENT_TICK
( 
xTickCount
 )

	)

434 #ifndef 
traceTIMER_CREATE


435 #define 
	#traceTIMER_CREATE
( 
pxNewTimer
 )

	)

438 #ifndef 
traceTIMER_CREATE_FAILED


439 #define 
	#traceTIMER_CREATE_FAILED
()

	)

442 #ifndef 
traceTIMER_COMMAND_SEND


443 #define 
	#traceTIMER_COMMAND_SEND
( 
xTimer
, 
xMessageID
, 
xMessageValueValue
, 
xReturn
 )

	)

446 #ifndef 
traceTIMER_EXPIRED


447 #define 
	#traceTIMER_EXPIRED
( 
pxTimer
 )

	)

450 #ifndef 
traceTIMER_COMMAND_RECEIVED


451 #define 
	#traceTIMER_COMMAND_RECEIVED
( 
pxTimer
, 
xMessageID
, 
xMessageValue
 )

	)

454 #ifndef 
configGENERATE_RUN_TIME_STATS


455 #define 
	#configGENERATE_RUN_TIME_STATS
 0

	)

458 #if ( 
configGENERATE_RUN_TIME_STATS
 == 1 )

460 #ifndef 
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS


461 #error 
If
 
configGENERATE_RUN_TIME_STATS
 
is
 
defined
 
then
 
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
 
must
 
also
 
be
 defined. portCONFIGURE_TIMER_FOR_RUN_TIME_STATS 
should
 
call
 
a
 
port
 
layer
 
function
 
to
 
setup
 a 
peripheral
 
timer
/
counter
 
that
 
can
 then be 
used
 
as
 
the
 
run
 
time
 counter time 
base
.

464 #ifndef 
portGET_RUN_TIME_COUNTER_VALUE


465 #ifndef 
portALT_GET_RUN_TIME_COUNTER_VALUE


466 #error 
If
 
configGENERATE_RUN_TIME_STATS
 
is
 
defined
 
then
 
either
 
portGET_RUN_TIME_COUNTER_VALUE
 
or
 
portALT_GET_RUN_TIME_COUNTER_VALUE
 
must
 
also
 
be
 defined. 
See
 
the
 
examples
 
provided
 
and
 the 
FreeRTOS
 
web
 
site
 for 
more
 
information
.

472 #ifndef 
portCONFIGURE_TIMER_FOR_RUN_TIME_STATS


473 #define 
	#portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
()

	)

476 #ifndef 
configUSE_MALLOC_FAILED_HOOK


477 #define 
	#configUSE_MALLOC_FAILED_HOOK
 0

	)

480 #ifndef 
portPRIVILEGE_BIT


481 #define 
	#portPRIVILEGE_BIT
 ( ( unsigned 
portBASE_TYPE
 ) 0x00 )

	)

484 #ifndef 
portYIELD_WITHIN_API


485 #define 
	#portYIELD_WITHIN_API
 
portYIELD


	)

488 #ifndef 
pvPortMallocAligned


489 #define 
	#pvPortMallocAligned
( 
x
, 
puxStackBuffer
 ) ( ( ( puxStackBuffer ) == 
NULL
 ) ? ( 
	`pvPortMalloc
( ( x ) ) ) : ( puxStackBuffer ) )

	)

492 #ifndef 
vPortFreeAligned


493 #define 
	#vPortFreeAligned
( 
pvBlockToFree
 ) 
	`vPortFree
( pvBlockToFree )

	)

	@FreeRTOS/include/FreeRTOSConfig.h

55 #ifndef 
FREERTOS_CONFIG_H


56 #define 
	#FREERTOS_CONFIG_H


	)

70 #include 
	~"stm32f4xx.h
"

73 #define 
	#GCC_ARMCM4F


	)

76 #ifdef 
__ICCARM__


77 #include 
	~<stdint.h
>

78 extern 
uint32_t
 
SystemCoreClock
;

81 #define 
	#M2T
(
X
) ((unsigned int)(X*(
configTICK_RATE_HZ
/1000.0)))

	)

82 #define 
	#F2T
(
X
) ((unsigned int)((
configTICK_RATE_HZ
/X)))

	)

84 #define 
	#configUSE_PREEMPTION
 1

	)

85 #define 
	#configUSE_IDLE_HOOK
 0

	)

86 #define 
	#configUSE_TICK_HOOK
 0

	)

87 #define 
	#configCPU_CLOCK_HZ
 ( 
SystemCoreClock
 )

	)

88 #define 
	#configTICK_RATE_HZ
 2000

89 #define 
	#configMAX_PRIORITIES
 ( ( unsigned 
portBASE_TYPE
 ) 5 )

	)

90 #define 
	#configMINIMAL_STACK_SIZE
 ( ( unsigned short ) 400 )

	)

91 #define 
	#configTOTAL_HEAP_SIZE
 ( ( 
size_t
 ) ( 29000 ) )

	)

92 #define 
	#configMAX_TASK_NAME_LEN
 ( 10 )

	)

93 #define 
	#configUSE_TRACE_FACILITY
 1

	)

94 #define 
	#configUSE_16_BIT_TICKS
 0

	)

95 #define 
	#configIDLE_SHOULD_YIELD
 1

	)

96 #define 
	#configUSE_MUTEXES
 1

	)

97 #define 
	#configQUEUE_REGISTRY_SIZE
 8

	)

98 #define 
	#configCHECK_FOR_STACK_OVERFLOW
 0

	)

99 #define 
	#configUSE_RECURSIVE_MUTEXES
 1

	)

100 #define 
	#configUSE_MALLOC_FAILED_HOOK
 1

	)

101 #define 
	#configUSE_APPLICATION_TASK_TAG
 0

	)

102 #define 
	#configUSE_COUNTING_SEMAPHORES
 1

	)

103 #define 
	#configGENERATE_RUN_TIME_STATS
 0

	)

106 #define 
	#configUSE_CO_ROUTINES
 0

	)

107 #define 
	#configMAX_CO_ROUTINE_PRIORITIES
 ( 2 )

	)

110 #define 
	#configUSE_TIMERS
 1

	)

111 #define 
	#configTIMER_TASK_PRIORITY
 ( 2 )

	)

112 #define 
	#configTIMER_QUEUE_LENGTH
 10

	)

113 #define 
	#configTIMER_TASK_STACK_DEPTH
 ( 
configMINIMAL_STACK_SIZE
 * 2 )

	)

117 #define 
	#INCLUDE_vTaskPrioritySet
 1

	)

118 #define 
	#INCLUDE_uxTaskPriorityGet
 1

	)

119 #define 
	#INCLUDE_vTaskDelete
 0

	)

120 #define 
	#INCLUDE_vTaskCleanUpResources
 0

	)

121 #define 
	#INCLUDE_vTaskSuspend
 0

	)

122 #define 
	#INCLUDE_vTaskDelayUntil
 1

	)

123 #define 
	#INCLUDE_vTaskDelay
 1

	)

126 #define 
	#portALIGNMENT_ASSERT_pxCurrentTCB


	)

129 #ifdef 
__NVIC_PRIO_BITS


131 #define 
	#configPRIO_BITS
 
__NVIC_PRIO_BITS


	)

133 #define 
	#configPRIO_BITS
 4

	)

138 #define 
	#configLIBRARY_LOWEST_INTERRUPT_PRIORITY
 0xf

	)

144 #define 
	#configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY
 5

	)

148 #define 
	#configKERNEL_INTERRUPT_PRIORITY
 255

149 #define 
	#configMAX_SYSCALL_INTERRUPT_PRIORITY
 159

150 

	)

153 #define 
	#configASSERT
( 
x
 ) if( ( x ) == 0 ) { 
	`taskDISABLE_INTERRUPTS
(); for( ;; ); }

	)

157 #define 
	#vPortSVCHandler
 
SVC_Handler


	)

158 #define 
	#xPortPendSVHandler
 
PendSV_Handler


	)

159 #define 
	#xPortSysTickHandler
 
SysTick_Handler


	)

	@FreeRTOS/include/StackMacros.h

54 #ifndef 
STACK_MACROS_H


55 #define 
	#STACK_MACROS_H


	)

73 #if( 
configCHECK_FOR_STACK_OVERFLOW
 == 0 )

76 #define 
	#taskFIRST_CHECK_FOR_STACK_OVERFLOW
()

	)

77 #define 
	#taskSECOND_CHECK_FOR_STACK_OVERFLOW
()

	)

82 #if( 
configCHECK_FOR_STACK_OVERFLOW
 == 1 )

86 #define 
	#taskSECOND_CHECK_FOR_STACK_OVERFLOW
()

	)

91 #if( ( 
configCHECK_FOR_STACK_OVERFLOW
 > 0 ) && ( 
portSTACK_GROWTH
 < 0 ) )

94 #define 
	#taskFIRST_CHECK_FOR_STACK_OVERFLOW
() \

	)

97 if( 
	gpxCurrentTCB
->
	gpxTopOfStack
 <= 
pxCurrentTCB
->
pxStack
 ) \

99 
vApplicationStackOverflowHook
( ( 
xTaskHandle
 ) 
pxCurrentTCB
, pxCurrentTCB->
pcTaskName
 ); \

106 #if( ( 
configCHECK_FOR_STACK_OVERFLOW
 > 0 ) && ( 
portSTACK_GROWTH
 > 0 ) )

109 #define 
	#taskFIRST_CHECK_FOR_STACK_OVERFLOW
() \

	)

113 if( 
	gpxCurrentTCB
->
	gpxTopOfStack
 >= 
pxCurrentTCB
->
pxEndOfStack
 ) \

115 
vApplicationStackOverflowHook
( ( 
xTaskHandle
 ) 
pxCurrentTCB
, pxCurrentTCB->
pcTaskName
 ); \

122 #if( ( 
configCHECK_FOR_STACK_OVERFLOW
 > 1 ) && ( 
portSTACK_GROWTH
 < 0 ) )

124 #define 
	#taskSECOND_CHECK_FOR_STACK_OVERFLOW
() \

	)

126 static const unsigned char 
	gucExpectedStackBytes
[] = { 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

127 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

128 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

129 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

130 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE }; \

134 if( 
memcmp
( ( void * ) 
pxCurrentTCB
->
pxStack
, ( void * ) 
ucExpectedStackBytes
, sizeof( ucExpectedStackBytes ) ) != 0 ) \

136 
vApplicationStackOverflowHook
( ( 
xTaskHandle
 ) 
pxCurrentTCB
, pxCurrentTCB->
pcTaskName
 ); \

143 #if( ( 
configCHECK_FOR_STACK_OVERFLOW
 > 1 ) && ( 
portSTACK_GROWTH
 > 0 ) )

145 #define 
	#taskSECOND_CHECK_FOR_STACK_OVERFLOW
() \

	)

147 char *
	gpcEndOfStack
 = ( char * ) 
pxCurrentTCB
->
pxEndOfStack
; \

148 static const unsigned char 
	gucExpectedStackBytes
[] = { 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

149 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

150 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

151 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, \

152 
tskSTACK_FILL_BYTE
, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE, tskSTACK_FILL_BYTE }; \

155 
	gpcEndOfStack
 -= sizeof( 
ucExpectedStackBytes
 ); \

158 if( 
memcmp
( ( void * ) 
pcEndOfStack
, ( void * ) 
ucExpectedStackBytes
, sizeof( ucExpectedStackBytes ) ) != 0 ) \

160 
vApplicationStackOverflowHook
( ( 
xTaskHandle
 ) 
pxCurrentTCB
, pxCurrentTCB->
pcTaskName
 ); \

	@FreeRTOS/include/croutine.h

54 #ifndef 
CO_ROUTINE_H


55 #define 
	#CO_ROUTINE_H


	)

57 #ifndef 
INC_FREERTOS_H


61 #include 
	~"list.h
"

63 #ifdef 
__cplusplus


70 typedef void * 
	txCoRoutineHandle
;

73 typedef void (*
crCOROUTINE_CODE
)( 
	txCoRoutineHandle
, unsigned 
	tportBASE_TYPE
 );

75 typedef struct 
	scorCoRoutineControlBlock


77 
crCOROUTINE_CODE
 
pxCoRoutineFunction
;

78 
xListItem
 
xGenericListItem
;

79 
xListItem
 
xEventListItem
;

80 unsigned 
portBASE_TYPE
 
uxPriority
;

81 unsigned 
portBASE_TYPE
 
uxIndex
;

82 unsigned short 
uxState
;

83 } 
	tcorCRCB
;

157 signed 
portBASE_TYPE
 
xCoRoutineCreate
( 
crCOROUTINE_CODE
 
pxCoRoutineCode
, unsigned portBASE_TYPE 
uxPriority
, unsigned portBASE_TYPE 
uxIndex
 );

199 void 
vCoRoutineSchedule
( void );

230 #define 
	#crSTART
( 
pxCRCB
 ) switch( ( ( 
corCRCB
 * )( pxCRCB ) )->
uxState
 ) { case 0:

	)

261 #define 
	#crEND
() }

	)

267 #define 
	#crSET_STATE0
( 
xHandle
 ) ( ( 
corCRCB
 * )( xHandle ) )->
uxState
 = (
__LINE__
 * 2); return; case (__LINE__ * 2):

	)

268 #define 
	#crSET_STATE1
( 
xHandle
 ) ( ( 
corCRCB
 * )( xHandle ) )->
uxState
 = ((
__LINE__
 * 2)+1); return; case ((__LINE__ * 2)+1):

	)

316 #define 
	#crDELAY
( 
xHandle
, 
xTicksToDelay
 ) \

	)

317 if( ( 
xTicksToDelay
 ) > 0 ) \

319 
vCoRoutineAddToDelayedList
( ( 
xTicksToDelay
 ), 
NULL
 ); \

321 
crSET_STATE0
( ( 
xHandle
 ) );

406 #define 
	#crQUEUE_SEND
( 
xHandle
, 
pxQueue
, 
pvItemToQueue
, 
xTicksToWait
, 
pxResult
 ) \

	)

408 *( 
pxResult
 ) = 
xQueueCRSend
( ( 
pxQueue
) , ( 
pvItemToQueue
) , ( 
xTicksToWait
 ) ); \

409 if( *( 
pxResult
 ) == 
errQUEUE_BLOCKED
 ) \

411 
crSET_STATE0
( ( 
xHandle
 ) ); \

412 *
pxResult
 = 
xQueueCRSend
( ( 
pxQueue
 ), ( 
pvItemToQueue
 ), 0 ); \

414 if( *
pxResult
 == 
errQUEUE_YIELD
 ) \

416 
crSET_STATE1
( ( 
xHandle
 ) ); \

417 *
pxResult
 = 
pdPASS
; \

498 #define 
	#crQUEUE_RECEIVE
( 
xHandle
, 
pxQueue
, 
pvBuffer
, 
xTicksToWait
, 
pxResult
 ) \

	)

500 *( 
pxResult
 ) = 
xQueueCRReceive
( ( 
pxQueue
) , ( 
pvBuffer
 ), ( 
xTicksToWait
 ) ); \

501 if( *( 
pxResult
 ) == 
errQUEUE_BLOCKED
 ) \

503 
crSET_STATE0
( ( 
xHandle
 ) ); \

504 *( 
pxResult
 ) = 
xQueueCRReceive
( ( 
pxQueue
) , ( 
pvBuffer
 ), 0 ); \

506 if( *( 
pxResult
 ) == 
errQUEUE_YIELD
 ) \

508 
crSET_STATE1
( ( 
xHandle
 ) ); \

509 *( 
pxResult
 ) = 
pdPASS
; \

607 #define 
	#crQUEUE_SEND_FROM_ISR
( 
pxQueue
, 
pvItemToQueue
, 
xCoRoutinePreviouslyWoken
 ) 
	`xQueueCRSendFromISR
( ( pxQueue ), ( pvItemToQueue ), ( xCoRoutinePreviouslyWoken ) )

	)

720 #define 
	#crQUEUE_RECEIVE_FROM_ISR
( 
pxQueue
, 
pvBuffer
, 
pxCoRoutineWoken
 ) 
	`xQueueCRReceiveFromISR
( ( pxQueue ), ( pvBuffer ), ( pxCoRoutineWoken ) )

	)

731 void 
vCoRoutineAddToDelayedList
( 
portTickType
 
xTicksToDelay
, 
xList
 *
pxEventList
 );

740 signed 
portBASE_TYPE
 
xCoRoutineRemoveFromEventList
( const 
xList
 *
pxEventList
 );

742 #ifdef 
__cplusplus


	@FreeRTOS/include/list.h

83 #ifndef 
LIST_H


84 #define 
	#LIST_H


	)

86 #ifdef 
__cplusplus


92 struct 
	sxLIST_ITEM


94 
portTickType
 
xItemValue
;

95 volatile struct 
xLIST_ITEM
 * 
pxNext
;

96 volatile struct 
xLIST_ITEM
 * 
pxPrevious
;

97 void * 
pvOwner
;

98 void * 
pvContainer
;

100 typedef struct 
xLIST_ITEM
 
	txListItem
;

102 struct 
	sxMINI_LIST_ITEM


104 
portTickType
 
xItemValue
;

105 volatile struct 
xLIST_ITEM
 *
pxNext
;

106 volatile struct 
xLIST_ITEM
 *
pxPrevious
;

108 typedef struct 
xMINI_LIST_ITEM
 
	txMiniListItem
;

113 typedef struct 
	sxLIST


115 volatile unsigned 
portBASE_TYPE
 
uxNumberOfItems
;

116 volatile 
xListItem
 * 
pxIndex
;

117 volatile 
xMiniListItem
 
xListEnd
;

118 } 
	txList
;

127 #define 
	#listSET_LIST_ITEM_OWNER
( 
pxListItem
, 
pxOwner
 ) ( pxListItem )->
pvOwner
 = ( void * ) ( pxOwner )

	)

136 #define 
	#listSET_LIST_ITEM_VALUE
( 
pxListItem
, 
xValue
 ) ( pxListItem )->
xItemValue
 = ( xValue )

	)

146 #define 
	#listGET_LIST_ITEM_VALUE
( 
pxListItem
 ) ( ( pxListItem )->
xItemValue
 )

	)

155 #define 
	#listGET_ITEM_VALUE_OF_HEAD_ENTRY
( 
pxList
 ) ( (&( ( pxList )->
xListEnd
 ))->
pxNext
->
xItemValue
 )

	)

164 #define 
	#listLIST_IS_EMPTY
( 
pxList
 ) ( ( pxList )->
uxNumberOfItems
 == ( unsigned 
portBASE_TYPE
 ) 0 )

	)

169 #define 
	#listCURRENT_LIST_LENGTH
( 
pxList
 ) ( ( pxList )->
uxNumberOfItems
 )

	)

190 #define 
	#listGET_OWNER_OF_NEXT_ENTRY
( 
pxTCB
, 
pxList
 ) \

	)

192 
xList
 * const 
pxConstList
 = ( 
pxList
 ); \

195 ( 
pxConstList
 )->
pxIndex
 = ( pxConstList )->pxIndex->
pxNext
; \

196 if( ( 
pxConstList
 )->
pxIndex
 == ( 
xListItem
 * ) &( ( pxConstList )->
xListEnd
 ) ) \

198 ( 
pxConstList
 )->
pxIndex
 = ( pxConstList )->pxIndex->
pxNext
; \

200 ( 
pxTCB
 ) = ( 
pxConstList
 )->
pxIndex
->
pvOwner
; \

220 #define 
	#listGET_OWNER_OF_HEAD_ENTRY
( 
pxList
 ) ( (&( ( pxList )->
xListEnd
 ))->
pxNext
->
pvOwner
 )

	)

232 #define 
	#listIS_CONTAINED_WITHIN
( 
pxList
, 
pxListItem
 ) ( ( pxListItem )->
pvContainer
 == ( void * ) ( pxList ) )

	)

244 void 
vListInitialise
( 
xList
 *
pxList
 );

255 void 
vListInitialiseItem
( 
xListItem
 *
pxItem
 );

268 void 
vListInsert
( 
xList
 *
pxList
, 
xListItem
 *
pxNewListItem
 );

289 void 
vListInsertEnd
( 
xList
 *
pxList
, 
xListItem
 *
pxNewListItem
 );

301 void 
vListRemove
( 
xListItem
 *
pxItemToRemove
 );

303 #ifdef 
__cplusplus


	@FreeRTOS/include/mpu_wrappers.h

54 #ifndef 
MPU_WRAPPERS_H


55 #define 
	#MPU_WRAPPERS_H


	)

59 #ifdef 
portUSING_MPU_WRAPPERS


64 #ifndef 
MPU_WRAPPERS_INCLUDED_FROM_API_FILE


66 #define 
	#xTaskGenericCreate
 
MPU_xTaskGenericCreate


	)

67 #define 
	#vTaskAllocateMPURegions
 
MPU_vTaskAllocateMPURegions


	)

68 #define 
	#vTaskDelete
 
MPU_vTaskDelete


	)

69 #define 
	#vTaskDelayUntil
 
MPU_vTaskDelayUntil


	)

70 #define 
	#vTaskDelay
 
MPU_vTaskDelay


	)

71 #define 
	#uxTaskPriorityGet
 
MPU_uxTaskPriorityGet


	)

72 #define 
	#vTaskPrioritySet
 
MPU_vTaskPrioritySet


	)

73 #define 
	#vTaskSuspend
 
MPU_vTaskSuspend


	)

74 #define 
	#xTaskIsTaskSuspended
 
MPU_xTaskIsTaskSuspended


	)

75 #define 
	#vTaskResume
 
MPU_vTaskResume


	)

76 #define 
	#vTaskSuspendAll
 
MPU_vTaskSuspendAll


	)

77 #define 
	#xTaskResumeAll
 
MPU_xTaskResumeAll


	)

78 #define 
	#xTaskGetTickCount
 
MPU_xTaskGetTickCount


	)

79 #define 
	#uxTaskGetNumberOfTasks
 
MPU_uxTaskGetNumberOfTasks


	)

80 #define 
	#vTaskList
 
MPU_vTaskList


	)

81 #define 
	#vTaskGetRunTimeStats
 
MPU_vTaskGetRunTimeStats


	)

82 #define 
	#vTaskStartTrace
 
MPU_vTaskStartTrace


	)

83 #define 
	#ulTaskEndTrace
 
MPU_ulTaskEndTrace


	)

84 #define 
	#vTaskSetApplicationTaskTag
 
MPU_vTaskSetApplicationTaskTag


	)

85 #define 
	#xTaskGetApplicationTaskTag
 
MPU_xTaskGetApplicationTaskTag


	)

86 #define 
	#xTaskCallApplicationTaskHook
 
MPU_xTaskCallApplicationTaskHook


	)

87 #define 
	#uxTaskGetStackHighWaterMark
 
MPU_uxTaskGetStackHighWaterMark


	)

88 #define 
	#xTaskGetCurrentTaskHandle
 
MPU_xTaskGetCurrentTaskHandle


	)

89 #define 
	#xTaskGetSchedulerState
 
MPU_xTaskGetSchedulerState


	)

91 #define 
	#xQueueCreate
 
MPU_xQueueCreate


	)

92 #define 
	#xQueueCreateMutex
 
MPU_xQueueCreateMutex


	)

93 #define 
	#xQueueGiveMutexRecursive
 
MPU_xQueueGiveMutexRecursive


	)

94 #define 
	#xQueueTakeMutexRecursive
 
MPU_xQueueTakeMutexRecursive


	)

95 #define 
	#xQueueCreateCountingSemaphore
 
MPU_xQueueCreateCountingSemaphore


	)

96 #define 
	#xQueueGenericSend
 
MPU_xQueueGenericSend


	)

97 #define 
	#xQueueAltGenericSend
 
MPU_xQueueAltGenericSend


	)

98 #define 
	#xQueueAltGenericReceive
 
MPU_xQueueAltGenericReceive


	)

99 #define 
	#xQueueGenericReceive
 
MPU_xQueueGenericReceive


	)

100 #define 
	#uxQueueMessagesWaiting
 
MPU_uxQueueMessagesWaiting


	)

101 #define 
	#vQueueDelete
 
MPU_vQueueDelete


	)

103 #define 
	#pvPortMalloc
 
MPU_pvPortMalloc


	)

104 #define 
	#vPortFree
 
MPU_vPortFree


	)

105 #define 
	#xPortGetFreeHeapSize
 
MPU_xPortGetFreeHeapSize


	)

106 #define 
	#vPortInitialiseBlocks
 
MPU_vPortInitialiseBlocks


	)

108 #if 
configQUEUE_REGISTRY_SIZE
 > 0

109 #define 
	#vQueueAddToRegistry
 
MPU_vQueueAddToRegistry


	)

110 #define 
	#vQueueUnregisterQueue
 
MPU_vQueueUnregisterQueue


	)

114 #define 
	#PRIVILEGED_FUNCTION


	)

119 #define 
	#PRIVILEGED_FUNCTION
 
	`__attribute__
((
	`section
("privileged_functions")))

	)

120 #define 
	#PRIVILEGED_DATA
 
	`__attribute__
((
	`section
("privileged_data")))

	)

127 #define 
	#PRIVILEGED_FUNCTION


	)

128 #define 
	#PRIVILEGED_DATA


	)

129 #define 
	#portUSING_MPU_WRAPPERS
 0

	)

	@FreeRTOS/include/portable.h

58 #ifndef 
PORTABLE_H


59 #define 
	#PORTABLE_H


	)

63 #ifdef 
OPEN_WATCOM_INDUSTRIAL_PC_PORT


64 #include 
	~"..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h
"

65 typedef void ( 
__interrupt
 
	t__far
 *
	tpxISR
 )();

68 #ifdef 
OPEN_WATCOM_FLASH_LITE_186_PORT


69 #include 
	~"..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h
"

70 typedef void ( 
__interrupt
 
	t__far
 *
	tpxISR
 )();

73 #ifdef 
GCC_MEGA_AVR


74 #include 
	~"../portable/GCC/ATMega323/portmacro.h
"

77 #ifdef 
IAR_MEGA_AVR


78 #include 
	~"../portable/IAR/ATMega323/portmacro.h
"

81 #ifdef 
MPLAB_PIC24_PORT


82 #include 
	~"..\..\Source\portable\MPLAB\PIC24_dsPIC\portmacro.h
"

85 #ifdef 
MPLAB_DSPIC_PORT


86 #include 
	~"..\..\Source\portable\MPLAB\PIC24_dsPIC\portmacro.h
"

89 #ifdef 
MPLAB_PIC18F_PORT


90 #include 
	~"..\..\Source\portable\MPLAB\PIC18F\portmacro.h
"

93 #ifdef 
MPLAB_PIC32MX_PORT


94 #include 
	~"..\..\Source\portable\MPLAB\PIC32MX\portmacro.h
"

97 #ifdef 
_FEDPICC


98 #include 
	~"libFreeRTOS/Include/portmacro.h
"

101 #ifdef 
SDCC_CYGNAL


102 #include 
	~"../../Source/portable/SDCC/Cygnal/portmacro.h
"

105 #ifdef 
GCC_ARM7


106 #include 
	~"../../Source/portable/GCC/ARM7_LPC2000/portmacro.h
"

109 #ifdef 
GCC_ARM7_ECLIPSE


110 #include 
	~"portmacro.h
"

113 #ifdef 
ROWLEY_LPC23xx


114 #include 
	~"../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h
"

117 #ifdef 
IAR_MSP430


118 #include 
	~"..\..\Source\portable\IAR\MSP430\portmacro.h
"

121 #ifdef 
GCC_MSP430


122 #include 
	~"../../Source/portable/GCC/MSP430F449/portmacro.h
"

125 #ifdef 
ROWLEY_MSP430


126 #include 
	~"../../Source/portable/Rowley/MSP430F449/portmacro.h
"

129 #ifdef 
ARM7_LPC21xx_KEIL_RVDS


130 #include 
	~"..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h
"

133 #ifdef 
SAM7_GCC


134 #include 
	~"../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h
"

137 #ifdef 
SAM7_IAR


138 #include 
	~"..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h
"

141 #ifdef 
SAM9XE_IAR


142 #include 
	~"..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h
"

145 #ifdef 
LPC2000_IAR


146 #include 
	~"..\..\Source\portable\IAR\LPC2000\portmacro.h
"

149 #ifdef 
STR71X_IAR


150 #include 
	~"..\..\Source\portable\IAR\STR71x\portmacro.h
"

153 #ifdef 
STR75X_IAR


154 #include 
	~"..\..\Source\portable\IAR\STR75x\portmacro.h
"

157 #ifdef 
STR75X_GCC


158 #include 
	~"..\..\Source\portable\GCC\STR75x\portmacro.h
"

161 #ifdef 
STR91X_IAR


162 #include 
	~"..\..\Source\portable\IAR\STR91x\portmacro.h
"

165 #ifdef 
GCC_H8S


166 #include 
	~"../../Source/portable/GCC/H8S2329/portmacro.h
"

169 #ifdef 
GCC_AT91FR40008


170 #include 
	~"../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h
"

173 #ifdef 
RVDS_ARMCM3_LM3S102


174 #include 
	~"../../Source/portable/RVDS/ARM_CM3/portmacro.h
"

177 #ifdef 
GCC_ARMCM3_LM3S102


178 #include 
	~"../../Source/portable/GCC/ARM_CM3/portmacro.h
"

181 #ifdef 
GCC_ARMCM3


182 #include 
	~"../../Source/portable/GCC/ARM_CM3/portmacro.h
"

185 #ifdef 
GCC_ARMCM4F


187 #include 
	~"../../FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h
"

190 #ifdef 
IAR_ARM_CM3


191 #include 
	~"../../Source/portable/IAR/ARM_CM3/portmacro.h
"

194 #ifdef 
IAR_ARMCM3_LM


195 #include 
	~"../../Source/portable/IAR/ARM_CM3/portmacro.h
"

198 #ifdef 
HCS12_CODE_WARRIOR


199 #include 
	~"../../Source/portable/CodeWarrior/HCS12/portmacro.h
"

202 #ifdef 
MICROBLAZE_GCC


203 #include 
	~"../../Source/portable/GCC/MicroBlaze/portmacro.h
"

206 #ifdef 
TERN_EE


207 #include 
	~"..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h
"

210 #ifdef 
GCC_HCS12


211 #include 
	~"../../Source/portable/GCC/HCS12/portmacro.h
"

214 #ifdef 
GCC_MCF5235


215 #include 
	~"../../Source/portable/GCC/MCF5235/portmacro.h
"

218 #ifdef 
COLDFIRE_V2_GCC


219 #include 
	~"../../../Source/portable/GCC/ColdFire_V2/portmacro.h
"

222 #ifdef 
COLDFIRE_V2_CODEWARRIOR


223 #include 
	~"../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h
"

226 #ifdef 
GCC_PPC405


227 #include 
	~"../../Source/portable/GCC/PPC405_Xilinx/portmacro.h
"

230 #ifdef 
GCC_PPC440


231 #include 
	~"../../Source/portable/GCC/PPC440_Xilinx/portmacro.h
"

234 #ifdef 
_16FX_SOFTUNE


235 #include 
	~"..\..\Source\portable\Softune\MB96340\portmacro.h
"

238 #ifdef 
BCC_INDUSTRIAL_PC_PORT


241 #include 
	~"frconfig.h
"

242 #include 
	~"..\portable\BCC\16BitDOS\PC\prtmacro.h
"

243 typedef void ( 
__interrupt
 
	t__far
 *
	tpxISR
 )();

246 #ifdef 
BCC_FLASH_LITE_186_PORT


249 #include 
	~"frconfig.h
"

250 #include 
	~"..\portable\BCC\16BitDOS\flsh186\prtmacro.h
"

251 typedef void ( 
__interrupt
 
	t__far
 *
	tpxISR
 )();

254 #ifdef 
__GNUC__


255 #ifdef 
__AVR32_AVR32A__


256 #include 
	~"portmacro.h
"

260 #ifdef 
__ICCAVR32__


261 #ifdef 
__CORE__


262 #if 
__CORE__
 == 
__AVR32A__


263 #include 
	~"portmacro.h
"

268 #ifdef 
__91467D


269 #include 
	~"portmacro.h
"

272 #ifdef 
__96340


273 #include 
	~"portmacro.h
"

277 #ifdef 
__IAR_V850ES_Fx3__


278 #include 
	~"../../Source/portable/IAR/V850ES/portmacro.h
"

281 #ifdef 
__IAR_V850ES_Jx3__


282 #include 
	~"../../Source/portable/IAR/V850ES/portmacro.h
"

285 #ifdef 
__IAR_V850ES_Jx3_L__


286 #include 
	~"../../Source/portable/IAR/V850ES/portmacro.h
"

289 #ifdef 
__IAR_V850ES_Jx2__


290 #include 
	~"../../Source/portable/IAR/V850ES/portmacro.h
"

293 #ifdef 
__IAR_V850ES_Hx2__


294 #include 
	~"../../Source/portable/IAR/V850ES/portmacro.h
"

297 #ifdef 
__IAR_78K0R_Kx3__


298 #include 
	~"../../Source/portable/IAR/78K0R/portmacro.h
"

301 #ifdef 
__IAR_78K0R_Kx3L__


302 #include 
	~"../../Source/portable/IAR/78K0R/portmacro.h
"

311 #ifndef 
portENTER_CRITICAL


312 #include 
	~"portmacro.h
"

315 #if 
portBYTE_ALIGNMENT
 == 8

316 #define 
	#portBYTE_ALIGNMENT_MASK
 ( 0x0007 )

	)

319 #if 
portBYTE_ALIGNMENT
 == 4

320 #define 
	#portBYTE_ALIGNMENT_MASK
 ( 0x0003 )

	)

323 #if 
portBYTE_ALIGNMENT
 == 2

324 #define 
	#portBYTE_ALIGNMENT_MASK
 ( 0x0001 )

	)

327 #if 
portBYTE_ALIGNMENT
 == 1

328 #define 
	#portBYTE_ALIGNMENT_MASK
 ( 0x0000 )

	)

331 #ifndef 
portBYTE_ALIGNMENT_MASK


335 #ifndef 
portNUM_CONFIGURABLE_REGIONS


336 #define 
	#portNUM_CONFIGURABLE_REGIONS
 1

	)

339 #ifdef 
__cplusplus


343 #include 
	~"mpu_wrappers.h
"

351 #if( 
portUSING_MPU_WRAPPERS
 == 1 )

352 
portSTACK_TYPE
 *
pxPortInitialiseStack
( portSTACK_TYPE *
pxTopOfStack
, 
pdTASK_CODE
 
pxCode
, void *
pvParameters
, 
portBASE_TYPE
 
xRunPrivileged
 ) 
PRIVILEGED_FUNCTION
;

354 
portSTACK_TYPE
 *
pxPortInitialiseStack
( portSTACK_TYPE *
pxTopOfStack
, 
pdTASK_CODE
 
pxCode
, void *
pvParameters
 );

360 void *
pvPortMalloc
( 
size_t
 
xSize
 ) 
	gPRIVILEGED_FUNCTION
;

361 void 
vPortFree
( void *
pv
 ) 
	gPRIVILEGED_FUNCTION
;

362 void 
vPortInitialiseBlocks
( void ) 
	gPRIVILEGED_FUNCTION
;

363 
size_t
 
xPortGetFreeHeapSize
( void ) 
	gPRIVILEGED_FUNCTION
;

369 
portBASE_TYPE
 
xPortStartScheduler
( void ) 
	gPRIVILEGED_FUNCTION
;

376 void 
vPortEndScheduler
( void ) 
	gPRIVILEGED_FUNCTION
;

385 #if( 
portUSING_MPU_WRAPPERS
 == 1 )

386 struct 
	gxMEMORY_REGION
;

387 void 
vPortStoreTaskMPUSettings
( 
xMPU_SETTINGS
 *
xMPUSettings
, const struct 
xMEMORY_REGION
 * const 
xRegions
, 
portSTACK_TYPE
 *
pxBottomOfStack
, unsigned short 
usStackDepth
 ) 
	gPRIVILEGED_FUNCTION
;

390 #ifdef 
__cplusplus


	@FreeRTOS/include/projdefs.h

54 #ifndef 
PROJDEFS_H


55 #define 
	#PROJDEFS_H


	)

58 typedef void (*
	tpdTASK_CODE
)( void * );

60 #define 
	#pdTRUE
 ( 1 )

	)

61 #define 
	#pdFALSE
 ( 0 )

	)

63 #define 
	#pdPASS
 ( 1 )

	)

64 #define 
	#pdFAIL
 ( 0 )

	)

65 #define 
	#errQUEUE_EMPTY
 ( 0 )

	)

66 #define 
	#errQUEUE_FULL
 ( 0 )

	)

69 #define 
	#errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
 ( -1 )

	)

70 #define 
	#errNO_TASK_TO_RUN
 ( -2 )

	)

71 #define 
	#errQUEUE_BLOCKED
 ( -4 )

	)

72 #define 
	#errQUEUE_YIELD
 ( -5 )

	)

	@FreeRTOS/include/queue.h

55 #ifndef 
QUEUE_H


56 #define 
	#QUEUE_H


	)

58 #ifndef 
INC_FREERTOS_H


59 #error "#include FreeRTOS.h" 
must
 
appear
 
in
 
source
 
files
 
before
 "#include queue.h"

62 #ifdef 
__cplusplus


67 #include 
	~"mpu_wrappers.h
"

74 typedef void * 
	txQueueHandle
;

78 #define 
	#queueSEND_TO_BACK
 ( 0 )

	)

79 #define 
	#queueSEND_TO_FRONT
 ( 1 )

	)

82 #define 
	#queueQUEUE_TYPE_BASE
 ( 0U )

	)

83 #define 
	#queueQUEUE_TYPE_MUTEX
 ( 1U )

	)

84 #define 
	#queueQUEUE_TYPE_COUNTING_SEMAPHORE
 ( 2U )

	)

85 #define 
	#queueQUEUE_TYPE_BINARY_SEMAPHORE
 ( 3U )

	)

86 #define 
	#queueQUEUE_TYPE_RECURSIVE_MUTEX
 ( 4U )

	)

144 #define 
	#xQueueCreate
( 
uxQueueLength
, 
uxItemSize
 ) 
	`xQueueGenericCreate
( uxQueueLength, uxItemSize, 
queueQUEUE_TYPE_BASE
 )

	)

226 #define 
	#xQueueSendToFront
( 
xQueue
, 
pvItemToQueue
, 
xTicksToWait
 ) 
	`xQueueGenericSend
( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), 
queueSEND_TO_FRONT
 )

	)

308 #define 
	#xQueueSendToBack
( 
xQueue
, 
pvItemToQueue
, 
xTicksToWait
 ) 
	`xQueueGenericSend
( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), 
queueSEND_TO_BACK
 )

	)

392 #define 
	#xQueueSend
( 
xQueue
, 
pvItemToQueue
, 
xTicksToWait
 ) 
	`xQueueGenericSend
( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), 
queueSEND_TO_BACK
 )

	)

480 signed 
portBASE_TYPE
 
xQueueGenericSend
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, 
portTickType
 
xTicksToWait
, portBASE_TYPE 
xCopyPosition
 );

574 #define 
	#xQueuePeek
( 
xQueue
, 
pvBuffer
, 
xTicksToWait
 ) 
	`xQueueGenericReceive
( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), 
pdTRUE
 )

	)

667 #define 
	#xQueueReceive
( 
xQueue
, 
pvBuffer
, 
xTicksToWait
 ) 
	`xQueueGenericReceive
( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), 
pdFALSE
 )

	)

766 signed 
portBASE_TYPE
 
xQueueGenericReceive
( 
xQueueHandle
 
xQueue
, void * const 
pvBuffer
, 
portTickType
 
xTicksToWait
, portBASE_TYPE 
xJustPeek
 );

781 unsigned 
portBASE_TYPE
 
uxQueueMessagesWaiting
( const 
xQueueHandle
 
xQueue
 );

795 void 
vQueueDelete
( 
xQueueHandle
 
pxQueue
 );

865 #define 
	#xQueueSendToFrontFromISR
( 
pxQueue
, 
pvItemToQueue
, 
pxHigherPriorityTaskWoken
 ) 
	`xQueueGenericSendFromISR
( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), 
queueSEND_TO_FRONT
 )

	)

936 #define 
	#xQueueSendToBackFromISR
( 
pxQueue
, 
pvItemToQueue
, 
pxHigherPriorityTaskWoken
 ) 
	`xQueueGenericSendFromISR
( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), 
queueSEND_TO_BACK
 )

	)

1010 #define 
	#xQueueSendFromISR
( 
pxQueue
, 
pvItemToQueue
, 
pxHigherPriorityTaskWoken
 ) 
	`xQueueGenericSendFromISR
( ( pxQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), 
queueSEND_TO_BACK
 )

	)

1088 signed 
portBASE_TYPE
 
xQueueGenericSendFromISR
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, signed portBASE_TYPE *
pxHigherPriorityTaskWoken
, portBASE_TYPE 
xCopyPosition
 );

1177 signed 
portBASE_TYPE
 
xQueueReceiveFromISR
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, signed portBASE_TYPE *
pxTaskWoken
 );

1183 signed 
portBASE_TYPE
 
xQueueIsQueueEmptyFromISR
( const 
xQueueHandle
 
pxQueue
 );

1184 signed 
portBASE_TYPE
 
xQueueIsQueueFullFromISR
( const 
xQueueHandle
 
pxQueue
 );

1185 unsigned 
portBASE_TYPE
 
uxQueueMessagesWaitingFromISR
( const 
xQueueHandle
 
pxQueue
 );

1202 signed 
portBASE_TYPE
 
xQueueAltGenericSend
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, 
portTickType
 
xTicksToWait
, portBASE_TYPE 
xCopyPosition
 );

1203 signed 
portBASE_TYPE
 
xQueueAltGenericReceive
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, 
portTickType
 
xTicksToWait
, portBASE_TYPE 
xJustPeeking
 );

1204 #define 
	#xQueueAltSendToFront
( 
xQueue
, 
pvItemToQueue
, 
xTicksToWait
 ) 
	`xQueueAltGenericSend
( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), 
queueSEND_TO_FRONT
 )

	)

1205 #define 
	#xQueueAltSendToBack
( 
xQueue
, 
pvItemToQueue
, 
xTicksToWait
 ) 
	`xQueueAltGenericSend
( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), 
queueSEND_TO_BACK
 )

	)

1206 #define 
	#xQueueAltReceive
( 
xQueue
, 
pvBuffer
, 
xTicksToWait
 ) 
	`xQueueAltGenericReceive
( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), 
pdFALSE
 )

	)

1207 #define 
	#xQueueAltPeek
( 
xQueue
, 
pvBuffer
, 
xTicksToWait
 ) 
	`xQueueAltGenericReceive
( ( xQueue ), ( pvBuffer ), ( xTicksToWait ), 
pdTRUE
 )

	)

1218 signed 
portBASE_TYPE
 
xQueueCRSendFromISR
( 
xQueueHandle
 
pxQueue
, const void *
pvItemToQueue
, signed portBASE_TYPE 
xCoRoutinePreviouslyWoken
 );

1219 signed 
portBASE_TYPE
 
xQueueCRReceiveFromISR
( 
xQueueHandle
 
pxQueue
, void *
pvBuffer
, signed portBASE_TYPE *
pxTaskWoken
 );

1220 signed 
portBASE_TYPE
 
xQueueCRSend
( 
xQueueHandle
 
pxQueue
, const void *
pvItemToQueue
, 
portTickType
 
xTicksToWait
 );

1221 signed 
portBASE_TYPE
 
xQueueCRReceive
( 
xQueueHandle
 
pxQueue
, void *
pvBuffer
, 
portTickType
 
xTicksToWait
 );

1227 
xQueueHandle
 
xQueueCreateMutex
( unsigned char 
ucQueueType
 );

1228 
xQueueHandle
 
xQueueCreateCountingSemaphore
( unsigned 
portBASE_TYPE
 
uxCountValue
, unsigned portBASE_TYPE 
uxInitialCount
 );

1234 
portBASE_TYPE
 
xQueueTakeMutexRecursive
( 
xQueueHandle
 
pxMutex
, 
portTickType
 
xBlockTime
 );

1235 
portBASE_TYPE
 
xQueueGiveMutexRecursive
( 
xQueueHandle
 
pxMutex
 );

1257 #if 
configQUEUE_REGISTRY_SIZE
 > 0U

1258 void 
vQueueAddToRegistry
( 
xQueueHandle
 
xQueue
, signed char *
pcName
 );

1265 
xQueueHandle
 
xQueueGenericCreate
( unsigned 
portBASE_TYPE
 
uxQueueLength
, unsigned portBASE_TYPE 
uxItemSize
, unsigned char 
ucQueueType
 );

1270 void 
vQueueWaitForMessageRestricted
( 
xQueueHandle
 
pxQueue
, 
portTickType
 
xTicksToWait
 );

1273 #ifdef 
__cplusplus


	@FreeRTOS/include/semphr.h

54 #ifndef 
SEMAPHORE_H


55 #define 
	#SEMAPHORE_H


	)

57 #ifndef 
INC_FREERTOS_H


58 #error "#include FreeRTOS.h" 
must
 
appear
 
in
 
source
 
files
 
before
 "#include semphr.h"

61 #include 
	~"queue.h
"

63 typedef 
xQueueHandle
 
	txSemaphoreHandle
;

65 #define 
	#semBINARY_SEMAPHORE_QUEUE_LENGTH
 ( ( unsigned char ) 1U )

	)

66 #define 
	#semSEMAPHORE_QUEUE_ITEM_LENGTH
 ( ( unsigned char ) 0U )

	)

67 #define 
	#semGIVE_BLOCK_TIME
 ( ( 
portTickType
 ) 0U )

	)

108 #define 
	#vSemaphoreCreateBinary
( 
xSemaphore
 ) \

	)

110 ( 
	gxSemaphore
 ) = 
xQueueGenericCreate
( ( unsigned 
portBASE_TYPE
 ) 1, 
semSEMAPHORE_QUEUE_ITEM_LENGTH
, 
queueQUEUE_TYPE_BINARY_SEMAPHORE
 ); \

111 if( ( 
	gxSemaphore
 ) != 
NULL
 ) \

113 
xSemaphoreGive
( ( 
xSemaphore
 ) ); \

182 #define 
	#xSemaphoreTake
( 
xSemaphore
, 
xBlockTime
 ) 
	`xQueueGenericReceive
( ( 
xQueueHandle
 ) ( xSemaphore ), 
NULL
, ( xBlockTime ), 
pdFALSE
 )

	)

275 #define 
	#xSemaphoreTakeRecursive
( 
xMutex
, 
xBlockTime
 ) 
	`xQueueTakeMutexRecursive
( ( xMutex ), ( xBlockTime ) )

	)

290 #define 
	#xSemaphoreAltTake
( 
xSemaphore
, 
xBlockTime
 ) 
	`xQueueAltGenericReceive
( ( 
xQueueHandle
 ) ( xSemaphore ), 
NULL
, ( xBlockTime ), 
pdFALSE
 )

	)

353 #define 
	#xSemaphoreGive
( 
xSemaphore
 ) 
	`xQueueGenericSend
( ( 
xQueueHandle
 ) ( xSemaphore ), 
NULL
, 
semGIVE_BLOCK_TIME
, 
queueSEND_TO_BACK
 )

	)

437 #define 
	#xSemaphoreGiveRecursive
( 
xMutex
 ) 
	`xQueueGiveMutexRecursive
( ( xMutex ) )

	)

451 #define 
	#xSemaphoreAltGive
( 
xSemaphore
 ) 
	`xQueueAltGenericSend
( ( 
xQueueHandle
 ) ( xSemaphore ), 
NULL
, 
semGIVE_BLOCK_TIME
, 
queueSEND_TO_BACK
 )

	)

542 #define 
	#xSemaphoreGiveFromISR
( 
xSemaphore
, 
pxHigherPriorityTaskWoken
 ) 
	`xQueueGenericSendFromISR
( ( 
xQueueHandle
 ) ( xSemaphore ), 
NULL
, ( pxHigherPriorityTaskWoken ), 
queueSEND_TO_BACK
 )

	)

589 #define 
	#xSemaphoreCreateMutex
() 
	`xQueueCreateMutex
( 
queueQUEUE_TYPE_MUTEX
 )

	)

644 #define 
	#xSemaphoreCreateRecursiveMutex
() 
	`xQueueCreateMutex
( 
queueQUEUE_TYPE_RECURSIVE_MUTEX
 )

	)

707 #define 
	#xSemaphoreCreateCounting
( 
uxMaxCount
, 
uxInitialCount
 ) 
	`xQueueCreateCountingSemaphore
( ( uxMaxCount ), ( uxInitialCount ) )

	)

721 #define 
	#vSemaphoreDelete
( 
xSemaphore
 ) 
	`vQueueDelete
( ( 
xQueueHandle
 ) xSemaphore )

	)

	@FreeRTOS/include/task.h

55 #ifndef 
TASK_H


56 #define 
	#TASK_H


	)

58 #ifndef 
INC_FREERTOS_H


62 #include 
	~"portable.h
"

63 #include 
	~"list.h
"

65 #ifdef 
__cplusplus


73 #define 
	#tskKERNEL_VERSION_NUMBER
 "V7.1.0"

	)

85 typedef void * 
	txTaskHandle
;

90 typedef struct 
	sxTIME_OUT


92 
portBASE_TYPE
 
xOverflowCount
;

93 
portTickType
 
xTimeOnEntering
;

94 } 
	txTimeOutType
;

99 typedef struct 
	sxMEMORY_REGION


101 void *
pvBaseAddress
;

102 unsigned long 
ulLengthInBytes
;

103 unsigned long 
ulParameters
;

104 } 
	txMemoryRegion
;

109 typedef struct 
	sxTASK_PARAMTERS


111 
pdTASK_CODE
 
pvTaskCode
;

112 const signed char * const 
pcName
;

113 unsigned short 
usStackDepth
;

114 void *
pvParameters
;

115 unsigned 
portBASE_TYPE
 
uxPriority
;

116 
portSTACK_TYPE
 *
puxStackBuffer
;

117 
xMemoryRegion
 
xRegions
[ 
portNUM_CONFIGURABLE_REGIONS
 ];

118 } 
	txTaskParameters
;

125 #define 
	#tskIDLE_PRIORITY
 ( ( unsigned 
portBASE_TYPE
 ) 0U )

	)

135 #define 
	#taskYIELD
() 
	`portYIELD
()

	)

149 #define 
	#taskENTER_CRITICAL
() 
	`portENTER_CRITICAL
()

	)

163 #define 
	#taskEXIT_CRITICAL
() 
	`portEXIT_CRITICAL
()

	)

173 #define 
	#taskDISABLE_INTERRUPTS
() 
	`portDISABLE_INTERRUPTS
()

	)

183 #define 
	#taskENABLE_INTERRUPTS
() 
	`portENABLE_INTERRUPTS
()

	)

186 #define 
	#taskSCHEDULER_NOT_STARTED
 0

	)

187 #define 
	#taskSCHEDULER_RUNNING
 1

	)

188 #define 
	#taskSCHEDULER_SUSPENDED
 2

	)

270 #define 
	#xTaskCreate
( 
pvTaskCode
, 
pcName
, 
usStackDepth
, 
pvParameters
, 
uxPriority
, 
pxCreatedTask
 ) 
	`xTaskGenericCreate
( ( pvTaskCode ), ( pcName ), ( usStackDepth ), ( pvParameters ), ( uxPriority ), ( pxCreatedTask ), ( 
NULL
 ), ( NULL ) )

	)

339 #define 
	#xTaskCreateRestricted
( 
x
, 
pxCreatedTask
 ) 
	`xTaskGenericCreate
( ((x)->
pvTaskCode
), ((x)->
pcName
), ((x)->
usStackDepth
), ((x)->
pvParameters
), ((x)->
uxPriority
), (pxCreatedTask), ((x)->
puxStackBuffer
), ((x)->
xRegions
) )

	)

387 void 
vTaskAllocateMPURegions
( 
xTaskHandle
 
xTask
, const 
xMemoryRegion
 * const 
pxRegions
 ) 
PRIVILEGED_FUNCTION
;

428 void 
vTaskDelete
( 
xTaskHandle
 
pxTaskToDelete
 ) 
PRIVILEGED_FUNCTION
;

482 void 
vTaskDelay
( 
portTickType
 
xTicksToDelay
 ) 
PRIVILEGED_FUNCTION
;

541 void 
vTaskDelayUntil
( 
portTickType
 * const 
pxPreviousWakeTime
, portTickType 
xTimeIncrement
 ) 
PRIVILEGED_FUNCTION
;

588 unsigned 
portBASE_TYPE
 
uxTaskPriorityGet
( 
xTaskHandle
 
pxTask
 ) 
PRIVILEGED_FUNCTION
;

630 void 
vTaskPrioritySet
( 
xTaskHandle
 
pxTask
, unsigned 
portBASE_TYPE
 
uxNewPriority
 ) 
PRIVILEGED_FUNCTION
;

681 void 
vTaskSuspend
( 
xTaskHandle
 
pxTaskToSuspend
 ) 
PRIVILEGED_FUNCTION
;

730 void 
vTaskResume
( 
xTaskHandle
 
pxTaskToResume
 ) 
PRIVILEGED_FUNCTION
;

750 
portBASE_TYPE
 
xTaskResumeFromISR
( 
xTaskHandle
 
pxTaskToResume
 ) 
PRIVILEGED_FUNCTION
;

788 void 
vTaskStartScheduler
( void ) 
PRIVILEGED_FUNCTION
;

841 void 
vTaskEndScheduler
( void ) 
PRIVILEGED_FUNCTION
;

892 void 
vTaskSuspendAll
( void ) 
PRIVILEGED_FUNCTION
;

944 signed 
portBASE_TYPE
 
xTaskResumeAll
( void ) 
PRIVILEGED_FUNCTION
;

955 signed 
portBASE_TYPE
 
xTaskIsTaskSuspended
( 
xTaskHandle
 
xTask
 ) 
PRIVILEGED_FUNCTION
;

970 
portTickType
 
xTaskGetTickCount
( void ) 
PRIVILEGED_FUNCTION
;

986 
portTickType
 
xTaskGetTickCountFromISR
( void ) 
PRIVILEGED_FUNCTION
;

1000 unsigned 
portBASE_TYPE
 
uxTaskGetNumberOfTasks
( void ) 
PRIVILEGED_FUNCTION
;

1014 signed char *
pcTaskGetTaskName
( 
xTaskHandle
 
xTaskToQuery
 );

1040 void 
vTaskList
( signed char *
pcWriteBuffer
 ) 
PRIVILEGED_FUNCTION
;

1072 void 
vTaskGetRunTimeStats
( signed char *
pcWriteBuffer
 ) 
PRIVILEGED_FUNCTION
;

1093 void 
vTaskStartTrace
( signed char * 
pcBuffer
, unsigned long 
ulBufferSize
 ) 
PRIVILEGED_FUNCTION
;

1106 unsigned long 
ulTaskEndTrace
( void ) 
PRIVILEGED_FUNCTION
;

1126 unsigned 
portBASE_TYPE
 
uxTaskGetStackHighWaterMark
( 
xTaskHandle
 
xTask
 ) 
PRIVILEGED_FUNCTION
;

1134 #ifdef 
configUSE_APPLICATION_TASK_TAG


1135 #if 
configUSE_APPLICATION_TASK_TAG
 == 1

1144 void 
vTaskSetApplicationTaskTag
( 
xTaskHandle
 
xTask
, 
pdTASK_HOOK_CODE
 
pxHookFunction
 ) 
PRIVILEGED_FUNCTION
;

1152 
pdTASK_HOOK_CODE
 
xTaskGetApplicationTaskTag
( 
xTaskHandle
 
xTask
 ) 
PRIVILEGED_FUNCTION
;

1166 
portBASE_TYPE
 
xTaskCallApplicationTaskHook
( 
xTaskHandle
 
xTask
, void *
pvParameter
 ) 
PRIVILEGED_FUNCTION
;

1175 
xTaskHandle
 
xTaskGetIdleTaskHandle
( void );

1191 void 
vTaskIncrementTick
( void ) 
PRIVILEGED_FUNCTION
;

1214 void 
vTaskPlaceOnEventList
( const 
xList
 * const 
pxEventList
, 
portTickType
 
xTicksToWait
 ) 
PRIVILEGED_FUNCTION
;

1229 void 
vTaskPlaceOnEventListRestricted
( const 
xList
 * const 
pxEventList
, 
portTickType
 
xTicksToWait
 ) 
PRIVILEGED_FUNCTION
;

1246 signed 
portBASE_TYPE
 
xTaskRemoveFromEventList
( const 
xList
 * const 
pxEventList
 ) 
PRIVILEGED_FUNCTION
;

1256 void 
vTaskSwitchContext
( void ) 
PRIVILEGED_FUNCTION
;

1261 
xTaskHandle
 
xTaskGetCurrentTaskHandle
( void ) 
PRIVILEGED_FUNCTION
;

1266 void 
vTaskSetTimeOutState
( 
xTimeOutType
 * const 
pxTimeOut
 ) 
PRIVILEGED_FUNCTION
;

1272 
portBASE_TYPE
 
xTaskCheckForTimeOut
( 
xTimeOutType
 * const 
pxTimeOut
, 
portTickType
 * const 
pxTicksToWait
 ) 
PRIVILEGED_FUNCTION
;

1278 void 
vTaskMissedYield
( void ) 
PRIVILEGED_FUNCTION
;

1284 
portBASE_TYPE
 
xTaskGetSchedulerState
( void ) 
PRIVILEGED_FUNCTION
;

1290 void 
vTaskPriorityInherit
( 
xTaskHandle
 * const 
pxMutexHolder
 ) 
PRIVILEGED_FUNCTION
;

1296 void 
vTaskPriorityDisinherit
( 
xTaskHandle
 * const 
pxMutexHolder
 ) 
PRIVILEGED_FUNCTION
;

1302 signed 
portBASE_TYPE
 
xTaskGenericCreate
( 
pdTASK_CODE
 
pxTaskCode
, const signed char * const 
pcName
, unsigned short 
usStackDepth
, void *
pvParameters
, unsigned portBASE_TYPE 
uxPriority
, 
xTaskHandle
 *
pxCreatedTask
, 
portSTACK_TYPE
 *
puxStackBuffer
, const 
xMemoryRegion
 * const 
xRegions
 ) 
PRIVILEGED_FUNCTION
;

1307 unsigned 
portBASE_TYPE
 
uxTaskGetTaskNumber
( 
xTaskHandle
 
xTask
 );

1313 void 
vTaskSetTaskNumber
( 
xTaskHandle
 
xTask
, unsigned 
portBASE_TYPE
 
uxHandle
 );

1316 #ifdef 
__cplusplus


	@FreeRTOS/include/timers.h

55 #ifndef 
TIMERS_H


56 #define 
	#TIMERS_H


	)

58 #ifndef 
INC_FREERTOS_H


62 #include 
	~"portable.h
"

63 #include 
	~"list.h
"

64 #include 
	~"task.h
"

66 #ifdef 
__cplusplus


73 #define 
	#tmrCOMMAND_START
 0

	)

74 #define 
	#tmrCOMMAND_STOP
 1

	)

75 #define 
	#tmrCOMMAND_CHANGE_PERIOD
 2

	)

76 #define 
	#tmrCOMMAND_DELETE
 3

	)

88 typedef void * 
	txTimerHandle
;

91 typedef void (*
tmrTIMER_CALLBACK
)( 
	txTimerHandle
 
	txTimer
 );

220 
xTimerHandle
 
xTimerCreate
( const signed char *
pcTimerName
, 
portTickType
 
xTimerPeriodInTicks
, unsigned 
portBASE_TYPE
 
uxAutoReload
, void * 
pvTimerID
, 
tmrTIMER_CALLBACK
 
pxCallbackFunction
 ) 
PRIVILEGED_FUNCTION
;

242 void *
pvTimerGetTimerID
( 
xTimerHandle
 
xTimer
 ) 
PRIVILEGED_FUNCTION
;

278 
portBASE_TYPE
 
xTimerIsTimerActive
( 
xTimerHandle
 
xTimer
 ) 
PRIVILEGED_FUNCTION
;

287 
xTaskHandle
 
xTimerGetTimerDaemonTaskHandle
( void );

339 #define 
	#xTimerStart
( 
xTimer
, 
xBlockTime
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_START
, ( 
	`xTaskGetTickCount
() ), 
NULL
, ( xBlockTime ) )

	)

381 #define 
	#xTimerStop
( 
xTimer
, 
xBlockTime
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_STOP
, 0U, 
NULL
, ( xBlockTime ) )

	)

460 #define 
	#xTimerChangePeriod
( 
xTimer
, 
xNewPeriod
, 
xBlockTime
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_CHANGE_PERIOD
, ( xNewPeriod ), 
NULL
, ( xBlockTime ) )

	)

498 #define 
	#xTimerDelete
( 
xTimer
, 
xBlockTime
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_DELETE
, 0U, 
NULL
, ( xBlockTime ) )

	)

621 #define 
	#xTimerReset
( 
xTimer
, 
xBlockTime
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_START
, ( 
	`xTaskGetTickCount
() ), 
NULL
, ( xBlockTime ) )

	)

705 #define 
	#xTimerStartFromISR
( 
xTimer
, 
pxHigherPriorityTaskWoken
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_START
, ( 
	`xTaskGetTickCountFromISR
() ), ( pxHigherPriorityTaskWoken ), 0U )

	)

767 #define 
	#xTimerStopFromISR
( 
xTimer
, 
pxHigherPriorityTaskWoken
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_STOP
, 0, ( pxHigherPriorityTaskWoken ), 0U )

	)

839 #define 
	#xTimerChangePeriodFromISR
( 
xTimer
, 
xNewPeriod
, 
pxHigherPriorityTaskWoken
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_CHANGE_PERIOD
, ( xNewPeriod ), ( pxHigherPriorityTaskWoken ), 0U )

	)

924 #define 
	#xTimerResetFromISR
( 
xTimer
, 
pxHigherPriorityTaskWoken
 ) 
	`xTimerGenericCommand
( ( xTimer ), 
tmrCOMMAND_START
, ( 
	`xTaskGetTickCountFromISR
() ), ( pxHigherPriorityTaskWoken ), 0U )

	)

930 
portBASE_TYPE
 
xTimerCreateTimerTask
( void ) 
PRIVILEGED_FUNCTION
;

931 
portBASE_TYPE
 
xTimerGenericCommand
( 
xTimerHandle
 
xTimer
, portBASE_TYPE 
xCommandID
, 
portTickType
 
xOptionalValue
, signed portBASE_TYPE *
pxHigherPriorityTaskWoken
, portTickType 
xBlockTime
 ) 
PRIVILEGED_FUNCTION
;

933 #ifdef 
__cplusplus


	@FreeRTOS/list.c

55 #include 
	~<stdlib.h
>

56 #include 
	~"FreeRTOS.h
"

57 #include 
	~"list.h
"

63 void 
	$vListInitialise
( 
xList
 *
pxList
 )

68 
pxList
->
pxIndex
 = ( 
xListItem
 * ) &( pxList->
xListEnd
 );

72 
pxList
->
xListEnd
.
xItemValue
 = 
portMAX_DELAY
;

76 
pxList
->
xListEnd
.
pxNext
 = ( 
xListItem
 * ) &( pxList->xListEnd );

77 
pxList
->
xListEnd
.
pxPrevious
 = ( 
xListItem
 * ) &( pxList->xListEnd );

79 
pxList
->
uxNumberOfItems
 = ( unsigned 
portBASE_TYPE
 ) 0U;

80 
	}
}

83 void 
	$vListInitialiseItem
( 
xListItem
 *
pxItem
 )

86 
pxItem
->
pvContainer
 = 
NULL
;

87 
	}
}

90 void 
	$vListInsertEnd
( 
xList
 *
pxList
, 
xListItem
 *
pxNewListItem
 )

92 volatile 
xListItem
 * 
pxIndex
;

98 
pxIndex
 = 
pxList
->pxIndex;

100 
pxNewListItem
->
pxNext
 = 
pxIndex
->pxNext;

101 
pxNewListItem
->
pxPrevious
 = 
pxList
->
pxIndex
;

102 
pxIndex
->
pxNext
->
pxPrevious
 = ( volatile 
xListItem
 * ) 
pxNewListItem
;

103 
pxIndex
->
pxNext
 = ( volatile 
xListItem
 * ) 
pxNewListItem
;

104 
pxList
->
pxIndex
 = ( volatile 
xListItem
 * ) 
pxNewListItem
;

107 
pxNewListItem
->
pvContainer
 = ( void * ) 
pxList
;

109 ( 
pxList
->
uxNumberOfItems
 )++;

110 
	}
}

113 void 
	$vListInsert
( 
xList
 *
pxList
, 
xListItem
 *
pxNewListItem
 )

115 volatile 
xListItem
 *
pxIterator
;

116 
portTickType
 
xValueOfInsertion
;

119 
xValueOfInsertion
 = 
pxNewListItem
->
xItemValue
;

128 if( 
xValueOfInsertion
 == 
portMAX_DELAY
 )

130 
pxIterator
 = 
pxList
->
xListEnd
.
pxPrevious
;

150 for( 
pxIterator
 = ( 
xListItem
 * ) &( 
pxList
->
xListEnd
 ); pxIterator->
pxNext
->
xItemValue
 <= 
xValueOfInsertion
; pxIterator = pxIterator->pxNext )

157 
pxNewListItem
->
pxNext
 = 
pxIterator
->pxNext;

158 
pxNewListItem
->
pxNext
->
pxPrevious
 = ( volatile 
xListItem
 * ) pxNewListItem;

159 
pxNewListItem
->
pxPrevious
 = 
pxIterator
;

160 
pxIterator
->
pxNext
 = ( volatile 
xListItem
 * ) 
pxNewListItem
;

164 
pxNewListItem
->
pvContainer
 = ( void * ) 
pxList
;

166 ( 
pxList
->
uxNumberOfItems
 )++;

167 
	}
}

170 void 
	$vListRemove
( 
xListItem
 *
pxItemToRemove
 )

172 
xList
 * 
pxList
;

174 
pxItemToRemove
->
pxNext
->
pxPrevious
 = pxItemToRemove->pxPrevious;

175 
pxItemToRemove
->
pxPrevious
->
pxNext
 = pxItemToRemove->pxNext;

179 
pxList
 = ( 
xList
 * ) 
pxItemToRemove
->
pvContainer
;

182 if( 
pxList
->
pxIndex
 == 
pxItemToRemove
 )

184 
pxList
->
pxIndex
 = 
pxItemToRemove
->
pxPrevious
;

187 
pxItemToRemove
->
pvContainer
 = 
NULL
;

188 ( 
pxList
->
uxNumberOfItems
 )--;

189 
	}
}

	@FreeRTOS/portable/GCC/ARM_CM4F/port.c

59 #include 
	~"FreeRTOS.h
"

60 #include 
	~"task.h
"

65 #ifndef 
configKERNEL_INTERRUPT_PRIORITY


66 #define 
	#configKERNEL_INTERRUPT_PRIORITY
 255

	)

70 #define 
	#portNVIC_SYSTICK_CTRL
 ( ( volatile unsigned long *) 0xe000e010 )

	)

71 #define 
	#portNVIC_SYSTICK_LOAD
 ( ( volatile unsigned long *) 0xe000e014 )

	)

72 #define 
	#portNVIC_INT_CTRL
 ( ( volatile unsigned long *) 0xe000ed04 )

	)

73 #define 
	#portNVIC_SYSPRI2
 ( ( volatile unsigned long *) 0xe000ed20 )

	)

74 #define 
	#portNVIC_SYSTICK_CLK
 0x00000004

	)

75 #define 
	#portNVIC_SYSTICK_INT
 0x00000002

	)

76 #define 
	#portNVIC_SYSTICK_ENABLE
 0x00000001

	)

77 #define 
	#portNVIC_PENDSVSET
 0x10000000

	)

78 #define 
	#portNVIC_PENDSV_PRI
 ( ( ( unsigned long ) 
configKERNEL_INTERRUPT_PRIORITY
 ) << 16 )

	)

79 #define 
	#portNVIC_SYSTICK_PRI
 ( ( ( unsigned long ) 
configKERNEL_INTERRUPT_PRIORITY
 ) << 24 )

	)

82 #define 
	#portINITIAL_XPSR
 ( 0x01000000 )

	)

83 #define 
	#portINITIAL_EXC_RETURN
 ( 0xFFFFFFFD )

	)

87 const unsigned long 
	gulKernelPriority
 = 
configKERNEL_INTERRUPT_PRIORITY
;

91 static unsigned 
portBASE_TYPE
 
	guxCriticalNesting
 = 0xaaaaaaaa;

96 static void 
prvSetupTimerInterrupt
( void );

101 void 
	$xPortPendSVHandler
( void ) 
	`__attribute__
 (( 
naked
 ));

102 void 
	`xPortSysTickHandler
( void );

103 void 
	$vPortSVCHandler
( void ) 
	`__attribute__
 (( 
naked
 ));

108 void 
	$vPortStartFirstTask
( void ) 
	`__attribute__
 (( 
naked
 ));

115 
portSTACK_TYPE
 *
	$pxPortInitialiseStack
( 
portSTACK_TYPE
 *
pxTopOfStack
, 
pdTASK_CODE
 
pxCode
, void *
pvParameters
 )

119 
pxTopOfStack
--;

120 *
pxTopOfStack
 = 
portINITIAL_XPSR
;

121 
pxTopOfStack
--;

122 *
pxTopOfStack
 = ( 
portSTACK_TYPE
 ) 
pxCode
;

123 
pxTopOfStack
--;

124 *
pxTopOfStack
 = 0;

125 
pxTopOfStack
 -= 5;

126 *
pxTopOfStack
 = ( 
portSTACK_TYPE
 ) 
pvParameters
;

127 
pxTopOfStack
 -= 9;

128 *
pxTopOfStack
 = ( 
portSTACK_TYPE
 ) 
portINITIAL_EXC_RETURN
;

129 return 
pxTopOfStack
;

130 
	}
}

133 void 
	$vPortSVCHandler
( void )

135 
__asm
 volatile (

149 
	}
}

152 void 
	$vPortStartFirstTask
( void )

154 
__asm
 volatile(

163 
	}
}

169 
portBASE_TYPE
 
	$xPortStartScheduler
( void )

172 *(
portNVIC_SYSPRI2
) |= 
portNVIC_PENDSV_PRI
;

173 *(
portNVIC_SYSPRI2
) |= 
portNVIC_SYSTICK_PRI
;

177 
	`prvSetupTimerInterrupt
();

180 
uxCriticalNesting
 = 0;

183 
	`vPortStartFirstTask
();

187 
	}
}

190 void 
	$vPortEndScheduler
( void )

194 
	}
}

197 void 
	$vPortYieldFromISR
( void )

200 *(
portNVIC_INT_CTRL
) = 
portNVIC_PENDSVSET
;

201 
	}
}

204 void 
	$vPortEnterCritical
( void )

206 
	`portDISABLE_INTERRUPTS
();

207 
uxCriticalNesting
++;

208 
	}
}

211 void 
	$vPortExitCritical
( void )

213 
uxCriticalNesting
--;

214 if( 
uxCriticalNesting
 == 0 )

216 
	`portENABLE_INTERRUPTS
();

218 
	}
}

221 void 
	$xPortPendSVHandler
( void )

225 
__asm
 volatile

259 ::"i"(
configMAX_SYSCALL_INTERRUPT_PRIORITY
)

261 
	}
}

264 void 
	$xPortSysTickHandler
( void )

266 unsigned long 
ulDummy
;

269 #if 
configUSE_PREEMPTION
 == 1

270 *(
portNVIC_INT_CTRL
) = 
portNVIC_PENDSVSET
;

273 
ulDummy
 = 
	`portSET_INTERRUPT_MASK_FROM_ISR
();

275 
	`vTaskIncrementTick
();

277 
	`portCLEAR_INTERRUPT_MASK_FROM_ISR
( 
ulDummy
 );

278 
	}
}

285 void 
	$prvSetupTimerInterrupt
( void )

288 *(
portNVIC_SYSTICK_LOAD
) = ( 
configCPU_CLOCK_HZ
 / 
configTICK_RATE_HZ
 ) - 1UL;

289 *(
portNVIC_SYSTICK_CTRL
) = 
portNVIC_SYSTICK_CLK
 | 
portNVIC_SYSTICK_INT
 | 
portNVIC_SYSTICK_ENABLE
;

290 
	}
}

	@FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h

55 #ifndef 
PORTMACRO_H


56 #define 
	#PORTMACRO_H


	)

58 #ifdef 
__cplusplus


73 #define 
	#portCHAR
 char

	)

74 #define 
	#portFLOAT
 float

	)

75 #define 
	#portDOUBLE
 double

	)

76 #define 
	#portLONG
 long

	)

77 #define 
	#portSHORT
 short

	)

78 #define 
	#portSTACK_TYPE
 unsigned 
portLONG


	)

79 #define 
	#portBASE_TYPE
 long

	)

81 #if( 
configUSE_16_BIT_TICKS
 == 1 )

82 typedef unsigned 
	tportSHORT
 
	tportTickType
;

83 #define 
	#portMAX_DELAY
 ( 
portTickType
 ) 0xffff

	)

85 typedef unsigned 
	tportLONG
 
	tportTickType
;

86 #define 
	#portMAX_DELAY
 ( 
portTickType
 ) 0xffffffff

	)

91 #define 
	#portSTACK_GROWTH
 ( -1 )

	)

93 #define 
	#portBYTE_ALIGNMENT
 8

	)

98 extern void 
vPortYieldFromISR
( void );

100 #define 
	#portYIELD
() 
	`vPortYieldFromISR
()

	)

102 #define 
	#portEND_SWITCHING_ISR
( 
xSwitchRequired
 ) if( xSwitchRequired ) 
	`vPortYieldFromISR
()

	)

112 #define 
	#portSET_INTERRUPT_MASK
() \

	)

113 
__asm
 volatile \

117 ::"i"(
configMAX_SYSCALL_INTERRUPT_PRIORITY
):"r0" \

124 #define 
	#portCLEAR_INTERRUPT_MASK
() \

	)

125 
__asm
 volatile \

132 #define 
	#portSET_INTERRUPT_MASK_FROM_ISR
() 0;
	`portSET_INTERRUPT_MASK
()

	)

133 #define 
	#portCLEAR_INTERRUPT_MASK_FROM_ISR
(
x
) 
	`portCLEAR_INTERRUPT_MASK
();(void)
	)
x

136 extern void 
vPortEnterCritical
( void );

137 extern void 
vPortExitCritical
( void );

139 #define 
	#portDISABLE_INTERRUPTS
() 
	`portSET_INTERRUPT_MASK
()

	)

140 #define 
	#portENABLE_INTERRUPTS
() 
	`portCLEAR_INTERRUPT_MASK
()

	)

141 #define 
	#portENTER_CRITICAL
() 
	`vPortEnterCritical
()

	)

142 #define 
	#portEXIT_CRITICAL
() 
	`vPortExitCritical
()

	)

146 #define 
	#portTASK_FUNCTION_PROTO
( 
vFunction
, 
pvParameters
 ) void 
	`vFunction
( void *pvParameters )

	)

147 #define 
	#portTASK_FUNCTION
( 
vFunction
, 
pvParameters
 ) void 
	`vFunction
( void *pvParameters )

	)

149 #define 
	#portNOP
()

	)

151 #ifdef 
__cplusplus


	@FreeRTOS/portable/MemMang/heap_1.c

62 #include 
	~<stdlib.h
>

67 #define 
	#MPU_WRAPPERS_INCLUDED_FROM_API_FILE


	)

69 #include 
	~"FreeRTOS.h
"

70 #include 
	~"task.h
"

72 #undef 
MPU_WRAPPERS_INCLUDED_FROM_API_FILE


76 static union 
	uxRTOS_HEAP


78 #if 
portBYTE_ALIGNMENT
 == 8

79 volatile 
portDOUBLE
 
	mdDummy
;

81 volatile unsigned long 
	mulDummy
;

83 unsigned char 
	mucHeap
[ 
configTOTAL_HEAP_SIZE
 ];

84 } 
	gxHeap
;

86 static 
size_t
 
	gxNextFreeByte
 = ( size_t ) 0;

89 void *
	$pvPortMalloc
( 
size_t
 
xWantedSize
 )

91 void *
pvReturn
 = 
NULL
;

94 #if 
portBYTE_ALIGNMENT
 != 1

95 if( 
xWantedSize
 & 
portBYTE_ALIGNMENT_MASK
 )

98 
xWantedSize
 += ( 
portBYTE_ALIGNMENT
 - ( xWantedSize & 
portBYTE_ALIGNMENT_MASK
 ) );

102 
	`vTaskSuspendAll
();

105 if( ( ( 
xNextFreeByte
 + 
xWantedSize
 ) < 
configTOTAL_HEAP_SIZE
 ) &&

106 ( ( 
xNextFreeByte
 + 
xWantedSize
 ) > xNextFreeByte ) )

110 
pvReturn
 = &( 
xHeap
.
ucHeap
[ 
xNextFreeByte
 ] );

111 
xNextFreeByte
 += 
xWantedSize
;

114 
	`xTaskResumeAll
();

116 #if( 
configUSE_MALLOC_FAILED_HOOK
 == 1 )

118 if( 
pvReturn
 == 
NULL
 )

120 extern void 
	`vApplicationMallocFailedHook
( void );

121 
	`vApplicationMallocFailedHook
();

126 return 
pvReturn
;

127 
	}
}

130 void 
	$vPortFree
( void *
pv
 )

135 ( void ) 
pv
;

136 
	}
}

139 void 
	$vPortInitialiseBlocks
( void )

142 
xNextFreeByte
 = ( 
size_t
 ) 0;

143 
	}
}

146 
size_t
 
	$xPortGetFreeHeapSize
( void )

148 return ( 
configTOTAL_HEAP_SIZE
 - 
xNextFreeByte
 );

149 
	}
}

	@FreeRTOS/queue.c

54 #include 
	~<stdlib.h
>

55 #include 
	~<string.h
>

60 #define 
	#MPU_WRAPPERS_INCLUDED_FROM_API_FILE


	)

62 #include 
	~"FreeRTOS.h
"

63 #include 
	~"task.h
"

65 #if ( 
configUSE_CO_ROUTINES
 == 1 )

66 #include 
	~"croutine.h
"

69 #undef 
MPU_WRAPPERS_INCLUDED_FROM_API_FILE


76 #define 
	#queueUNLOCKED
 ( ( signed 
portBASE_TYPE
 ) -1 )

	)

77 #define 
	#queueLOCKED_UNMODIFIED
 ( ( signed 
portBASE_TYPE
 ) 0 )

	)

79 #define 
	#queueERRONEOUS_UNBLOCK
 ( -1 )

	)

82 #define 
	#queueSEND_TO_BACK
 ( 0 )

	)

83 #define 
	#queueSEND_TO_FRONT
 ( 1 )

	)

86 #define 
	#pxMutexHolder
 
pcTail


	)

87 #define 
	#uxQueueType
 
pcHead


	)

88 #define 
	#uxRecursiveCallCount
 
pcReadFrom


	)

89 #define 
	#queueQUEUE_IS_MUTEX
 
NULL


	)

93 #define 
	#queueSEMAPHORE_QUEUE_ITEM_LENGTH
 ( ( unsigned 
portBASE_TYPE
 ) 0 )

	)

94 #define 
	#queueDONT_BLOCK
 ( ( 
portTickType
 ) 0U )

	)

95 #define 
	#queueMUTEX_GIVE_BLOCK_TIME
 ( ( 
portTickType
 ) 0U )

	)

98 #define 
	#queueQUEUE_TYPE_BASE
 ( 0U )

	)

99 #define 
	#queueQUEUE_TYPE_MUTEX
 ( 1U )

	)

100 #define 
	#queueQUEUE_TYPE_COUNTING_SEMAPHORE
 ( 2U )

	)

101 #define 
	#queueQUEUE_TYPE_BINARY_SEMAPHORE
 ( 3U )

	)

102 #define 
	#queueQUEUE_TYPE_RECURSIVE_MUTEX
 ( 4U )

	)

108 typedef struct 
	sQueueDefinition


110 signed char *
	mpcHead
;

111 signed char *
	mpcTail
;

113 signed char *
	mpcWriteTo
;

114 signed char *
	mpcReadFrom
;

116 
xList
 
	mxTasksWaitingToSend
;

117 
xList
 
	mxTasksWaitingToReceive
;

119 volatile unsigned 
portBASE_TYPE
 
	muxMessagesWaiting
;

120 unsigned 
portBASE_TYPE
 
	muxLength
;

121 unsigned 
portBASE_TYPE
 
	muxItemSize
;

123 signed 
portBASE_TYPE
 
	mxRxLock
;

124 signed 
portBASE_TYPE
 
	mxTxLock
;

126 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

127 unsigned char 
	mucQueueNumber
;

128 unsigned char 
	mucQueueType
;

131 } 
	txQUEUE
;

139 typedef 
xQUEUE
 * 
	txQueueHandle
;

146 
xQueueHandle
 
	$xQueueGenericCreate
( unsigned 
portBASE_TYPE
 
uxQueueLength
, unsigned portBASE_TYPE 
uxItemSize
, unsigned char 
ucQueueType
 ) 
PRIVILEGED_FUNCTION
;

147 signed 
portBASE_TYPE
 
	$xQueueGenericSend
( 
xQueueHandle
 
xQueue
, const void * const 
pvItemToQueue
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xCopyPosition
 ) 
PRIVILEGED_FUNCTION
;

148 unsigned 
portBASE_TYPE
 
	$uxQueueMessagesWaiting
( const 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

149 void 
	$vQueueDelete
( 
xQueueHandle
 
xQueue
 ) 
PRIVILEGED_FUNCTION
;

150 signed 
portBASE_TYPE
 
	$xQueueGenericSendFromISR
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, signed 
portBASE_TYPE
 *
pxHigherPriorityTaskWoken
, portBASE_TYPE 
xCopyPosition
 ) 
PRIVILEGED_FUNCTION
;

151 signed 
portBASE_TYPE
 
	$xQueueGenericReceive
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xJustPeeking
 ) 
PRIVILEGED_FUNCTION
;

152 signed 
portBASE_TYPE
 
	$xQueueReceiveFromISR
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, signed 
portBASE_TYPE
 *
pxTaskWoken
 ) 
PRIVILEGED_FUNCTION
;

153 
xQueueHandle
 
	$xQueueCreateMutex
( unsigned char 
ucQueueType
 ) 
PRIVILEGED_FUNCTION
;

154 
xQueueHandle
 
	$xQueueCreateCountingSemaphore
( unsigned 
portBASE_TYPE
 
uxCountValue
, unsigned portBASE_TYPE 
uxInitialCount
 ) 
PRIVILEGED_FUNCTION
;

155 
portBASE_TYPE
 
	$xQueueTakeMutexRecursive
( 
xQueueHandle
 
xMutex
, 
portTickType
 
xBlockTime
 ) 
PRIVILEGED_FUNCTION
;

156 
portBASE_TYPE
 
	$xQueueGiveMutexRecursive
( 
xQueueHandle
 
xMutex
 ) 
PRIVILEGED_FUNCTION
;

157 signed 
portBASE_TYPE
 
	$xQueueAltGenericSend
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xCopyPosition
 ) 
PRIVILEGED_FUNCTION
;

158 signed 
portBASE_TYPE
 
	$xQueueAltGenericReceive
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xJustPeeking
 ) 
PRIVILEGED_FUNCTION
;

159 signed 
portBASE_TYPE
 
	$xQueueIsQueueEmptyFromISR
( const 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

160 signed 
portBASE_TYPE
 
	$xQueueIsQueueFullFromISR
( const 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

161 unsigned 
portBASE_TYPE
 
	$uxQueueMessagesWaitingFromISR
( const 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

162 void 
	$vQueueWaitForMessageRestricted
( 
xQueueHandle
 
pxQueue
, 
portTickType
 
xTicksToWait
 ) 
PRIVILEGED_FUNCTION
;

163 unsigned char 
	$ucQueueGetQueueNumber
( 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

164 void 
	$vQueueSetQueueNumber
( 
xQueueHandle
 
pxQueue
, unsigned char 
ucQueueNumber
 ) 
PRIVILEGED_FUNCTION
;

165 unsigned char 
	$ucQueueGetQueueType
( 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

171 #if 
configUSE_CO_ROUTINES
 == 1

172 signed 
portBASE_TYPE
 
	$xQueueCRSendFromISR
( 
xQueueHandle
 
pxQueue
, const void *
pvItemToQueue
, signed 
portBASE_TYPE
 
xCoRoutinePreviouslyWoken
 ) 
PRIVILEGED_FUNCTION
;

173 signed 
portBASE_TYPE
 
	$xQueueCRReceiveFromISR
( 
xQueueHandle
 
pxQueue
, void *
pvBuffer
, signed 
portBASE_TYPE
 *
pxTaskWoken
 ) 
PRIVILEGED_FUNCTION
;

174 signed 
portBASE_TYPE
 
	$xQueueCRSend
( 
xQueueHandle
 
pxQueue
, const void *
pvItemToQueue
, 
portTickType
 
xTicksToWait
 ) 
PRIVILEGED_FUNCTION
;

175 signed 
portBASE_TYPE
 
	$xQueueCRReceive
( 
xQueueHandle
 
pxQueue
, void *
pvBuffer
, 
portTickType
 
xTicksToWait
 ) 
PRIVILEGED_FUNCTION
;

182 #if 
configQUEUE_REGISTRY_SIZE
 > 0

187 typedef struct 
	sQUEUE_REGISTRY_ITEM


189 signed char *
pcQueueName
;

190 
xQueueHandle
 
xHandle
;

191 } 
	txQueueRegistryItem
;

196 
xQueueRegistryItem
 
xQueueRegistry
[ 
configQUEUE_REGISTRY_SIZE
 ];

200 static void 
	$vQueueUnregisterQueue
( 
xQueueHandle
 
xQueue
 ) 
PRIVILEGED_FUNCTION
;

201 void 
	$vQueueAddToRegistry
( 
xQueueHandle
 
xQueue
, signed char *
pcQueueName
 ) 
PRIVILEGED_FUNCTION
;

212 static void 
	$prvUnlockQueue
( 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

219 static signed 
portBASE_TYPE
 
	$prvIsQueueEmpty
( const 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

226 static signed 
portBASE_TYPE
 
	$prvIsQueueFull
( const 
xQueueHandle
 
pxQueue
 ) 
PRIVILEGED_FUNCTION
;

232 static void 
	$prvCopyDataToQueue
( 
xQUEUE
 *
pxQueue
, const void *
pvItemToQueue
, 
portBASE_TYPE
 
xPosition
 ) 
PRIVILEGED_FUNCTION
;

237 static void 
	$prvCopyDataFromQueue
( 
xQUEUE
 * const 
pxQueue
, const void *
pvBuffer
 ) 
PRIVILEGED_FUNCTION
;

244 #define 
	#prvLockQueue
( 
pxQueue
 ) \

	)

245 
	`taskENTER_CRITICAL
(); \

247 if( ( 
pxQueue
 )->
xRxLock
 == 
queueUNLOCKED
 ) \

249 ( 
pxQueue
 )->
xRxLock
 = 
queueLOCKED_UNMODIFIED
; \

251 if( ( 
pxQueue
 )->
xTxLock
 == 
queueUNLOCKED
 ) \

253 ( 
pxQueue
 )->
xTxLock
 = 
queueLOCKED_UNMODIFIED
; \

255 
	}
} \

256 
	$taskEXIT_CRITICAL
()

264 
xQueueHandle
 
	$xQueueGenericCreate
( unsigned 
portBASE_TYPE
 
uxQueueLength
, unsigned portBASE_TYPE 
uxItemSize
, unsigned char 
ucQueueType
 )

266 
xQUEUE
 *
pxNewQueue
;

267 
size_t
 
xQueueSizeInBytes
;

268 
xQueueHandle
 
xReturn
 = 
NULL
;

272 ( void ) 
ucQueueType
;

275 if( 
uxQueueLength
 > ( unsigned 
portBASE_TYPE
 ) 0 )

277 
pxNewQueue
 = ( 
xQUEUE
 * ) 
	`pvPortMalloc
( sizeof( xQUEUE ) );

278 if( 
pxNewQueue
 != 
NULL
 )

282 
xQueueSizeInBytes
 = ( 
size_t
 ) ( 
uxQueueLength
 * 
uxItemSize
 ) + ( size_t ) 1;

284 
pxNewQueue
->
pcHead
 = ( signed char * ) 
	`pvPortMalloc
( 
xQueueSizeInBytes
 );

285 if( 
pxNewQueue
->
pcHead
 != 
NULL
 )

289 
pxNewQueue
->
pcTail
 = pxNewQueue->
pcHead
 + ( 
uxQueueLength
 * 
uxItemSize
 );

290 
pxNewQueue
->
uxMessagesWaiting
 = ( unsigned 
portBASE_TYPE
 ) 0U;

291 
pxNewQueue
->
pcWriteTo
 = pxNewQueue->
pcHead
;

292 
pxNewQueue
->
pcReadFrom
 = pxNewQueue->
pcHead
 + ( ( 
uxQueueLength
 - ( unsigned 
portBASE_TYPE
 ) 1U ) * 
uxItemSize
 );

293 
pxNewQueue
->
uxLength
 = 
uxQueueLength
;

294 
pxNewQueue
->
uxItemSize
 = uxItemSize;

295 
pxNewQueue
->
xRxLock
 = 
queueUNLOCKED
;

296 
pxNewQueue
->
xTxLock
 = 
queueUNLOCKED
;

297 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

299 
pxNewQueue
->
ucQueueType
 = ucQueueType;

304 
	`vListInitialise
( &( 
pxNewQueue
->
xTasksWaitingToSend
 ) );

305 
	`vListInitialise
( &( 
pxNewQueue
->
xTasksWaitingToReceive
 ) );

307 
	`traceQUEUE_CREATE
( 
pxNewQueue
 );

308 
xReturn
 = 
pxNewQueue
;

312 
	`traceQUEUE_CREATE_FAILED
( 
ucQueueType
 );

313 
	`vPortFree
( 
pxNewQueue
 );

318 
	`configASSERT
( 
xReturn
 );

320 return 
xReturn
;

321 
	}
}

324 #if ( 
configUSE_MUTEXES
 == 1 )

326 
xQueueHandle
 
	$xQueueCreateMutex
( unsigned char 
ucQueueType
 )

328 
xQUEUE
 *
pxNewQueue
;

332 ( void ) 
ucQueueType
;

335 
pxNewQueue
 = ( 
xQUEUE
 * ) 
	`pvPortMalloc
( sizeof( xQUEUE ) );

336 if( 
pxNewQueue
 != 
NULL
 )

339 
pxNewQueue
->
pxMutexHolder
 = 
NULL
;

340 
pxNewQueue
->
uxQueueType
 = 
queueQUEUE_IS_MUTEX
;

344 
pxNewQueue
->
pcWriteTo
 = 
NULL
;

345 
pxNewQueue
->
pcReadFrom
 = 
NULL
;

350 
pxNewQueue
->
uxMessagesWaiting
 = ( unsigned 
portBASE_TYPE
 ) 0U;

351 
pxNewQueue
->
uxLength
 = ( unsigned 
portBASE_TYPE
 ) 1U;

352 
pxNewQueue
->
uxItemSize
 = ( unsigned 
portBASE_TYPE
 ) 0U;

353 
pxNewQueue
->
xRxLock
 = 
queueUNLOCKED
;

354 
pxNewQueue
->
xTxLock
 = 
queueUNLOCKED
;

356 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

358 
pxNewQueue
->
ucQueueType
 = ucQueueType;

363 
	`vListInitialise
( &( 
pxNewQueue
->
xTasksWaitingToSend
 ) );

364 
	`vListInitialise
( &( 
pxNewQueue
->
xTasksWaitingToReceive
 ) );

366 
	`traceCREATE_MUTEX
( 
pxNewQueue
 );

369 
	`xQueueGenericSend
( 
pxNewQueue
, 
NULL
, ( 
portTickType
 ) 0U, 
queueSEND_TO_BACK
 );

373 
	`traceCREATE_MUTEX_FAILED
();

376 
	`configASSERT
( 
pxNewQueue
 );

377 return 
pxNewQueue
;

378 
	}
}

383 #if 
configUSE_RECURSIVE_MUTEXES
 == 1

385 
portBASE_TYPE
 
	$xQueueGiveMutexRecursive
( 
xQueueHandle
 
pxMutex
 )

387 
portBASE_TYPE
 
xReturn
;

389 
	`configASSERT
( 
pxMutex
 );

397 if( 
pxMutex
->
pxMutexHolder
 == 
	`xTaskGetCurrentTaskHandle
() )

399 
	`traceGIVE_MUTEX_RECURSIVE
( 
pxMutex
 );

406 ( 
pxMutex
->
uxRecursiveCallCount
 )--;

409 if( 
pxMutex
->
uxRecursiveCallCount
 == 0 )

413 
	`xQueueGenericSend
( 
pxMutex
, 
NULL
, 
queueMUTEX_GIVE_BLOCK_TIME
, 
queueSEND_TO_BACK
 );

416 
xReturn
 = 
pdPASS
;

421 
xReturn
 = 
pdFAIL
;

423 
	`traceGIVE_MUTEX_RECURSIVE_FAILED
( 
pxMutex
 );

426 return 
xReturn
;

427 
	}
}

432 #if 
configUSE_RECURSIVE_MUTEXES
 == 1

434 
portBASE_TYPE
 
	$xQueueTakeMutexRecursive
( 
xQueueHandle
 
pxMutex
, 
portTickType
 
xBlockTime
 )

436 
portBASE_TYPE
 
xReturn
;

438 
	`configASSERT
( 
pxMutex
 );

443 
	`traceTAKE_MUTEX_RECURSIVE
( 
pxMutex
 );

445 if( 
pxMutex
->
pxMutexHolder
 == 
	`xTaskGetCurrentTaskHandle
() )

447 ( 
pxMutex
->
uxRecursiveCallCount
 )++;

448 
xReturn
 = 
pdPASS
;

452 
xReturn
 = 
	`xQueueGenericReceive
( 
pxMutex
, 
NULL
, 
xBlockTime
, 
pdFALSE
 );

456 if( 
xReturn
 == 
pdPASS
 )

458 ( 
pxMutex
->
uxRecursiveCallCount
 )++;

462 
	`traceTAKE_MUTEX_RECURSIVE_FAILED
( 
pxMutex
 );

466 return 
xReturn
;

467 
	}
}

472 #if 
configUSE_COUNTING_SEMAPHORES
 == 1

474 
xQueueHandle
 
	$xQueueCreateCountingSemaphore
( unsigned 
portBASE_TYPE
 
uxCountValue
, unsigned portBASE_TYPE 
uxInitialCount
 )

476 
xQueueHandle
 
pxHandle
;

478 
pxHandle
 = 
	`xQueueGenericCreate
( ( unsigned 
portBASE_TYPE
 ) 
uxCountValue
, 
queueSEMAPHORE_QUEUE_ITEM_LENGTH
, 
queueQUEUE_TYPE_COUNTING_SEMAPHORE
 );

480 if( 
pxHandle
 != 
NULL
 )

482 
pxHandle
->
uxMessagesWaiting
 = 
uxInitialCount
;

484 
	`traceCREATE_COUNTING_SEMAPHORE
();

488 
	`traceCREATE_COUNTING_SEMAPHORE_FAILED
();

491 
	`configASSERT
( 
pxHandle
 );

492 return 
pxHandle
;

493 
	}
}

498 signed 
portBASE_TYPE
 
	$xQueueGenericSend
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xCopyPosition
 )

500 signed 
portBASE_TYPE
 
xEntryTimeSet
 = 
pdFALSE
;

501 
xTimeOutType
 
xTimeOut
;

503 
	`configASSERT
( 
pxQueue
 );

504 
	`configASSERT
( !( ( 
pvItemToQueue
 == 
NULL
 ) && ( 
pxQueue
->
uxItemSize
 != ( unsigned 
portBASE_TYPE
 ) 0U ) ) );

511 
	`taskENTER_CRITICAL
();

515 if( 
pxQueue
->
uxMessagesWaiting
 < pxQueue->
uxLength
 )

517 
	`traceQUEUE_SEND
( 
pxQueue
 );

518 
	`prvCopyDataToQueue
( 
pxQueue
, 
pvItemToQueue
, 
xCopyPosition
 );

522 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

524 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdTRUE
 )

530 
	`portYIELD_WITHIN_API
();

534 
	`taskEXIT_CRITICAL
();

538 return 
pdPASS
;

542 if( 
xTicksToWait
 == ( 
portTickType
 ) 0 )

546 
	`taskEXIT_CRITICAL
();

550 
	`traceQUEUE_SEND_FAILED
( 
pxQueue
 );

551 return 
errQUEUE_FULL
;

553 else if( 
xEntryTimeSet
 == 
pdFALSE
 )

557 
	`vTaskSetTimeOutState
( &
xTimeOut
 );

558 
xEntryTimeSet
 = 
pdTRUE
;

562 
	`taskEXIT_CRITICAL
();

567 
	`vTaskSuspendAll
();

568 
	`prvLockQueue
( 
pxQueue
 );

571 if( 
	`xTaskCheckForTimeOut
( &
xTimeOut
, &
xTicksToWait
 ) == 
pdFALSE
 )

573 if( 
	`prvIsQueueFull
( 
pxQueue
 ) != 
pdFALSE
 )

575 
	`traceBLOCKING_ON_QUEUE_SEND
( 
pxQueue
 );

576 
	`vTaskPlaceOnEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ), 
xTicksToWait
 );

583 
	`prvUnlockQueue
( 
pxQueue
 );

590 if( 
	`xTaskResumeAll
() == 
pdFALSE
 )

592 
	`portYIELD_WITHIN_API
();

598 
	`prvUnlockQueue
( 
pxQueue
 );

599 ( void ) 
	`xTaskResumeAll
();

605 
	`prvUnlockQueue
( 
pxQueue
 );

606 ( void ) 
	`xTaskResumeAll
();

610 
	`traceQUEUE_SEND_FAILED
( 
pxQueue
 );

611 return 
errQUEUE_FULL
;

614 
	}
}

617 #if 
configUSE_ALTERNATIVE_API
 == 1

619 signed 
portBASE_TYPE
 
	$xQueueAltGenericSend
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xCopyPosition
 )

621 signed 
portBASE_TYPE
 
xEntryTimeSet
 = 
pdFALSE
;

622 
xTimeOutType
 
xTimeOut
;

624 
	`configASSERT
( 
pxQueue
 );

625 
	`configASSERT
( !( ( 
pvItemToQueue
 == 
NULL
 ) && ( 
pxQueue
->
uxItemSize
 != ( unsigned 
portBASE_TYPE
 ) 0U ) ) );

629 
	`taskENTER_CRITICAL
();

633 if( 
pxQueue
->
uxMessagesWaiting
 < pxQueue->
uxLength
 )

635 
	`traceQUEUE_SEND
( 
pxQueue
 );

636 
	`prvCopyDataToQueue
( 
pxQueue
, 
pvItemToQueue
, 
xCopyPosition
 );

640 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

642 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdTRUE
 )

646 
	`portYIELD_WITHIN_API
();

650 
	`taskEXIT_CRITICAL
();

651 return 
pdPASS
;

655 if( 
xTicksToWait
 == ( 
portTickType
 ) 0 )

657 
	`taskEXIT_CRITICAL
();

658 return 
errQUEUE_FULL
;

660 else if( 
xEntryTimeSet
 == 
pdFALSE
 )

662 
	`vTaskSetTimeOutState
( &
xTimeOut
 );

663 
xEntryTimeSet
 = 
pdTRUE
;

667 
	`taskEXIT_CRITICAL
();

669 
	`taskENTER_CRITICAL
();

671 if( 
	`xTaskCheckForTimeOut
( &
xTimeOut
, &
xTicksToWait
 ) == 
pdFALSE
 )

673 if( 
	`prvIsQueueFull
( 
pxQueue
 ) != 
pdFALSE
 )

675 
	`traceBLOCKING_ON_QUEUE_SEND
( 
pxQueue
 );

676 
	`vTaskPlaceOnEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ), 
xTicksToWait
 );

677 
	`portYIELD_WITHIN_API
();

682 
	`taskEXIT_CRITICAL
();

683 
	`traceQUEUE_SEND_FAILED
( 
pxQueue
 );

684 return 
errQUEUE_FULL
;

687 
	`taskEXIT_CRITICAL
();

689 
	}
}

694 #if 
configUSE_ALTERNATIVE_API
 == 1

696 signed 
portBASE_TYPE
 
	$xQueueAltGenericReceive
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xJustPeeking
 )

698 signed 
portBASE_TYPE
 
xEntryTimeSet
 = 
pdFALSE
;

699 
xTimeOutType
 
xTimeOut
;

700 signed char *
pcOriginalReadPosition
;

702 
	`configASSERT
( 
pxQueue
 );

703 
	`configASSERT
( !( ( 
pvBuffer
 == 
NULL
 ) && ( 
pxQueue
->
uxItemSize
 != ( unsigned 
portBASE_TYPE
 ) 0U ) ) );

707 
	`taskENTER_CRITICAL
();

709 if( 
pxQueue
->
uxMessagesWaiting
 > ( unsigned 
portBASE_TYPE
 ) 0 )

712 
pcOriginalReadPosition
 = 
pxQueue
->
pcReadFrom
;

714 
	`prvCopyDataFromQueue
( 
pxQueue
, 
pvBuffer
 );

716 if( 
xJustPeeking
 == 
pdFALSE
 )

718 
	`traceQUEUE_RECEIVE
( 
pxQueue
 );

721 --( 
pxQueue
->
uxMessagesWaiting
 );

723 #if ( 
configUSE_MUTEXES
 == 1 )

725 if( 
pxQueue
->
uxQueueType
 == 
queueQUEUE_IS_MUTEX
 )

729 
pxQueue
->
pxMutexHolder
 = 
	`xTaskGetCurrentTaskHandle
();

734 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdFALSE
 )

736 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdTRUE
 )

738 
	`portYIELD_WITHIN_API
();

744 
	`traceQUEUE_PEEK
( 
pxQueue
 );

748 
pxQueue
->
pcReadFrom
 = 
pcOriginalReadPosition
;

752 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

756 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) != 
pdFALSE
 )

759 
	`portYIELD_WITHIN_API
();

765 
	`taskEXIT_CRITICAL
();

766 return 
pdPASS
;

770 if( 
xTicksToWait
 == ( 
portTickType
 ) 0 )

772 
	`taskEXIT_CRITICAL
();

773 
	`traceQUEUE_RECEIVE_FAILED
( 
pxQueue
 );

774 return 
errQUEUE_EMPTY
;

776 else if( 
xEntryTimeSet
 == 
pdFALSE
 )

778 
	`vTaskSetTimeOutState
( &
xTimeOut
 );

779 
xEntryTimeSet
 = 
pdTRUE
;

783 
	`taskEXIT_CRITICAL
();

785 
	`taskENTER_CRITICAL
();

787 if( 
	`xTaskCheckForTimeOut
( &
xTimeOut
, &
xTicksToWait
 ) == 
pdFALSE
 )

789 if( 
	`prvIsQueueEmpty
( 
pxQueue
 ) != 
pdFALSE
 )

791 
	`traceBLOCKING_ON_QUEUE_RECEIVE
( 
pxQueue
 );

793 #if ( 
configUSE_MUTEXES
 == 1 )

795 if( 
pxQueue
->
uxQueueType
 == 
queueQUEUE_IS_MUTEX
 )

797 
	`portENTER_CRITICAL
();

798 
	`vTaskPriorityInherit
( ( void * ) 
pxQueue
->
pxMutexHolder
 );

799 
	`portEXIT_CRITICAL
();

804 
	`vTaskPlaceOnEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ), 
xTicksToWait
 );

805 
	`portYIELD_WITHIN_API
();

810 
	`taskEXIT_CRITICAL
();

811 
	`traceQUEUE_RECEIVE_FAILED
( 
pxQueue
 );

812 return 
errQUEUE_EMPTY
;

815 
	`taskEXIT_CRITICAL
();

817 
	}
}

823 signed 
portBASE_TYPE
 
	$xQueueGenericSendFromISR
( 
xQueueHandle
 
pxQueue
, const void * const 
pvItemToQueue
, signed 
portBASE_TYPE
 *
pxHigherPriorityTaskWoken
, portBASE_TYPE 
xCopyPosition
 )

825 signed 
portBASE_TYPE
 
xReturn
;

826 unsigned 
portBASE_TYPE
 
uxSavedInterruptStatus
;

828 
	`configASSERT
( 
pxQueue
 );

829 
	`configASSERT
( 
pxHigherPriorityTaskWoken
 );

830 
	`configASSERT
( !( ( 
pvItemToQueue
 == 
NULL
 ) && ( 
pxQueue
->
uxItemSize
 != ( unsigned 
portBASE_TYPE
 ) 0U ) ) );

837 
uxSavedInterruptStatus
 = 
	`portSET_INTERRUPT_MASK_FROM_ISR
();

839 if( 
pxQueue
->
uxMessagesWaiting
 < pxQueue->
uxLength
 )

841 
	`traceQUEUE_SEND_FROM_ISR
( 
pxQueue
 );

843 
	`prvCopyDataToQueue
( 
pxQueue
, 
pvItemToQueue
, 
xCopyPosition
 );

847 if( 
pxQueue
->
xTxLock
 == 
queueUNLOCKED
 )

849 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

851 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) != 
pdFALSE
 )

855 *
pxHigherPriorityTaskWoken
 = 
pdTRUE
;

863 ++( 
pxQueue
->
xTxLock
 );

866 
xReturn
 = 
pdPASS
;

870 
	`traceQUEUE_SEND_FROM_ISR_FAILED
( 
pxQueue
 );

871 
xReturn
 = 
errQUEUE_FULL
;

874 
	`portCLEAR_INTERRUPT_MASK_FROM_ISR
( 
uxSavedInterruptStatus
 );

876 return 
xReturn
;

877 
	}
}

880 signed 
portBASE_TYPE
 
	$xQueueGenericReceive
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, 
portTickType
 
xTicksToWait
, 
portBASE_TYPE
 
xJustPeeking
 )

882 signed 
portBASE_TYPE
 
xEntryTimeSet
 = 
pdFALSE
;

883 
xTimeOutType
 
xTimeOut
;

884 signed char *
pcOriginalReadPosition
;

886 
	`configASSERT
( 
pxQueue
 );

887 
	`configASSERT
( !( ( 
pvBuffer
 == 
NULL
 ) && ( 
pxQueue
->
uxItemSize
 != ( unsigned 
portBASE_TYPE
 ) 0U ) ) );

895 
	`taskENTER_CRITICAL
();

899 if( 
pxQueue
->
uxMessagesWaiting
 > ( unsigned 
portBASE_TYPE
 ) 0 )

902 
pcOriginalReadPosition
 = 
pxQueue
->
pcReadFrom
;

904 
	`prvCopyDataFromQueue
( 
pxQueue
, 
pvBuffer
 );

906 if( 
xJustPeeking
 == 
pdFALSE
 )

908 
	`traceQUEUE_RECEIVE
( 
pxQueue
 );

911 --( 
pxQueue
->
uxMessagesWaiting
 );

913 #if ( 
configUSE_MUTEXES
 == 1 )

915 if( 
pxQueue
->
uxQueueType
 == 
queueQUEUE_IS_MUTEX
 )

919 
pxQueue
->
pxMutexHolder
 = 
	`xTaskGetCurrentTaskHandle
();

924 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdFALSE
 )

926 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdTRUE
 )

928 
	`portYIELD_WITHIN_API
();

934 
	`traceQUEUE_PEEK
( 
pxQueue
 );

938 
pxQueue
->
pcReadFrom
 = 
pcOriginalReadPosition
;

942 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

946 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) != 
pdFALSE
 )

949 
	`portYIELD_WITHIN_API
();

955 
	`taskEXIT_CRITICAL
();

956 return 
pdPASS
;

960 if( 
xTicksToWait
 == ( 
portTickType
 ) 0 )

964 
	`taskEXIT_CRITICAL
();

965 
	`traceQUEUE_RECEIVE_FAILED
( 
pxQueue
 );

966 return 
errQUEUE_EMPTY
;

968 else if( 
xEntryTimeSet
 == 
pdFALSE
 )

972 
	`vTaskSetTimeOutState
( &
xTimeOut
 );

973 
xEntryTimeSet
 = 
pdTRUE
;

977 
	`taskEXIT_CRITICAL
();

982 
	`vTaskSuspendAll
();

983 
	`prvLockQueue
( 
pxQueue
 );

986 if( 
	`xTaskCheckForTimeOut
( &
xTimeOut
, &
xTicksToWait
 ) == 
pdFALSE
 )

988 if( 
	`prvIsQueueEmpty
( 
pxQueue
 ) != 
pdFALSE
 )

990 
	`traceBLOCKING_ON_QUEUE_RECEIVE
( 
pxQueue
 );

992 #if ( 
configUSE_MUTEXES
 == 1 )

994 if( 
pxQueue
->
uxQueueType
 == 
queueQUEUE_IS_MUTEX
 )

996 
	`portENTER_CRITICAL
();

998 
	`vTaskPriorityInherit
( ( void * ) 
pxQueue
->
pxMutexHolder
 );

1000 
	`portEXIT_CRITICAL
();

1005 
	`vTaskPlaceOnEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ), 
xTicksToWait
 );

1006 
	`prvUnlockQueue
( 
pxQueue
 );

1007 if( 
	`xTaskResumeAll
() == 
pdFALSE
 )

1009 
	`portYIELD_WITHIN_API
();

1015 
	`prvUnlockQueue
( 
pxQueue
 );

1016 ( void ) 
	`xTaskResumeAll
();

1021 
	`prvUnlockQueue
( 
pxQueue
 );

1022 ( void ) 
	`xTaskResumeAll
();

1023 
	`traceQUEUE_RECEIVE_FAILED
( 
pxQueue
 );

1024 return 
errQUEUE_EMPTY
;

1027 
	}
}

1030 signed 
portBASE_TYPE
 
	$xQueueReceiveFromISR
( 
xQueueHandle
 
pxQueue
, void * const 
pvBuffer
, signed 
portBASE_TYPE
 *
pxTaskWoken
 )

1032 signed 
portBASE_TYPE
 
xReturn
;

1033 unsigned 
portBASE_TYPE
 
uxSavedInterruptStatus
;

1035 
	`configASSERT
( 
pxQueue
 );

1036 
	`configASSERT
( 
pxTaskWoken
 );

1037 
	`configASSERT
( !( ( 
pvBuffer
 == 
NULL
 ) && ( 
pxQueue
->
uxItemSize
 != ( unsigned 
portBASE_TYPE
 ) 0U ) ) );

1039 
uxSavedInterruptStatus
 = 
	`portSET_INTERRUPT_MASK_FROM_ISR
();

1042 if( 
pxQueue
->
uxMessagesWaiting
 > ( unsigned 
portBASE_TYPE
 ) 0 )

1044 
	`traceQUEUE_RECEIVE_FROM_ISR
( 
pxQueue
 );

1046 
	`prvCopyDataFromQueue
( 
pxQueue
, 
pvBuffer
 );

1047 --( 
pxQueue
->
uxMessagesWaiting
 );

1052 if( 
pxQueue
->
xRxLock
 == 
queueUNLOCKED
 )

1054 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdFALSE
 )

1056 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) != 
pdFALSE
 )

1060 *
pxTaskWoken
 = 
pdTRUE
;

1068 ++( 
pxQueue
->
xRxLock
 );

1071 
xReturn
 = 
pdPASS
;

1075 
xReturn
 = 
pdFAIL
;

1076 
	`traceQUEUE_RECEIVE_FROM_ISR_FAILED
( 
pxQueue
 );

1079 
	`portCLEAR_INTERRUPT_MASK_FROM_ISR
( 
uxSavedInterruptStatus
 );

1081 return 
xReturn
;

1082 
	}
}

1085 unsigned 
portBASE_TYPE
 
	$uxQueueMessagesWaiting
( const 
xQueueHandle
 
pxQueue
 )

1087 unsigned 
portBASE_TYPE
 
uxReturn
;

1089 
	`configASSERT
( 
pxQueue
 );

1091 
	`taskENTER_CRITICAL
();

1092 
uxReturn
 = 
pxQueue
->
uxMessagesWaiting
;

1093 
	`taskEXIT_CRITICAL
();

1095 return 
uxReturn
;

1096 
	}
}

1099 unsigned 
portBASE_TYPE
 
	$uxQueueMessagesWaitingFromISR
( const 
xQueueHandle
 
pxQueue
 )

1101 unsigned 
portBASE_TYPE
 
uxReturn
;

1103 
	`configASSERT
( 
pxQueue
 );

1105 
uxReturn
 = 
pxQueue
->
uxMessagesWaiting
;

1107 return 
uxReturn
;

1108 
	}
}

1111 void 
	$vQueueDelete
( 
xQueueHandle
 
pxQueue
 )

1113 
	`configASSERT
( 
pxQueue
 );

1115 
	`traceQUEUE_DELETE
( 
pxQueue
 );

1116 
	`vQueueUnregisterQueue
( 
pxQueue
 );

1117 
	`vPortFree
( 
pxQueue
->
pcHead
 );

1118 
	`vPortFree
( 
pxQueue
 );

1119 
	}
}

1122 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

1124 unsigned char 
	$ucQueueGetQueueNumber
( 
xQueueHandle
 
pxQueue
 )

1126 return 
pxQueue
->
ucQueueNumber
;

1127 
	}
}

1132 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

1134 void 
	$vQueueSetQueueNumber
( 
xQueueHandle
 
pxQueue
, unsigned char 
ucQueueNumber
 )

1136 
pxQueue
->
ucQueueNumber
 = ucQueueNumber;

1137 
	}
}

1142 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

1144 unsigned char 
	$ucQueueGetQueueType
( 
xQueueHandle
 
pxQueue
 )

1146 return 
pxQueue
->
ucQueueType
;

1147 
	}
}

1152 static void 
	$prvCopyDataToQueue
( 
xQUEUE
 *
pxQueue
, const void *
pvItemToQueue
, 
portBASE_TYPE
 
xPosition
 )

1154 if( 
pxQueue
->
uxItemSize
 == ( unsigned 
portBASE_TYPE
 ) 0 )

1156 #if ( 
configUSE_MUTEXES
 == 1 )

1158 if( 
pxQueue
->
uxQueueType
 == 
queueQUEUE_IS_MUTEX
 )

1161 
	`vTaskPriorityDisinherit
( ( void * ) 
pxQueue
->
pxMutexHolder
 );

1162 
pxQueue
->
pxMutexHolder
 = 
NULL
;

1167 else if( 
xPosition
 == 
queueSEND_TO_BACK
 )

1169 
	`memcpy
( ( void * ) 
pxQueue
->
pcWriteTo
, 
pvItemToQueue
, ( unsigned ) pxQueue->
uxItemSize
 );

1170 
pxQueue
->
pcWriteTo
 += pxQueue->
uxItemSize
;

1171 if( 
pxQueue
->
pcWriteTo
 >= pxQueue->
pcTail
 )

1173 
pxQueue
->
pcWriteTo
 = pxQueue->
pcHead
;

1178 
	`memcpy
( ( void * ) 
pxQueue
->
pcReadFrom
, 
pvItemToQueue
, ( unsigned ) pxQueue->
uxItemSize
 );

1179 
pxQueue
->
pcReadFrom
 -= pxQueue->
uxItemSize
;

1180 if( 
pxQueue
->
pcReadFrom
 < pxQueue->
pcHead
 )

1182 
pxQueue
->
pcReadFrom
 = ( pxQueue->
pcTail
 - pxQueue->
uxItemSize
 );

1186 ++( 
pxQueue
->
uxMessagesWaiting
 );

1187 
	}
}

1190 static void 
	$prvCopyDataFromQueue
( 
xQUEUE
 * const 
pxQueue
, const void *
pvBuffer
 )

1192 if( 
pxQueue
->
uxQueueType
 != 
queueQUEUE_IS_MUTEX
 )

1194 
pxQueue
->
pcReadFrom
 += pxQueue->
uxItemSize
;

1195 if( 
pxQueue
->
pcReadFrom
 >= pxQueue->
pcTail
 )

1197 
pxQueue
->
pcReadFrom
 = pxQueue->
pcHead
;

1199 
	`memcpy
( ( void * ) 
pvBuffer
, ( void * ) 
pxQueue
->
pcReadFrom
, ( unsigned ) pxQueue->
uxItemSize
 );

1201 
	}
}

1204 static void 
	$prvUnlockQueue
( 
xQueueHandle
 
pxQueue
 )

1212 
	`taskENTER_CRITICAL
();

1215 while( 
pxQueue
->
xTxLock
 > 
queueLOCKED_UNMODIFIED
 )

1219 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

1223 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) != 
pdFALSE
 )

1227 
	`vTaskMissedYield
();

1230 --( 
pxQueue
->
xTxLock
 );

1238 
pxQueue
->
xTxLock
 = 
queueUNLOCKED
;

1240 
	`taskEXIT_CRITICAL
();

1243 
	`taskENTER_CRITICAL
();

1245 while( 
pxQueue
->
xRxLock
 > 
queueLOCKED_UNMODIFIED
 )

1247 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdFALSE
 )

1249 if( 
	`xTaskRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) != 
pdFALSE
 )

1251 
	`vTaskMissedYield
();

1254 --( 
pxQueue
->
xRxLock
 );

1262 
pxQueue
->
xRxLock
 = 
queueUNLOCKED
;

1264 
	`taskEXIT_CRITICAL
();

1265 
	}
}

1268 static signed 
portBASE_TYPE
 
	$prvIsQueueEmpty
( const 
xQueueHandle
 
pxQueue
 )

1270 signed 
portBASE_TYPE
 
xReturn
;

1272 
	`taskENTER_CRITICAL
();

1273 
xReturn
 = ( 
pxQueue
->
uxMessagesWaiting
 == ( unsigned 
portBASE_TYPE
 ) 0 );

1274 
	`taskEXIT_CRITICAL
();

1276 return 
xReturn
;

1277 
	}
}

1280 signed 
portBASE_TYPE
 
	$xQueueIsQueueEmptyFromISR
( const 
xQueueHandle
 
pxQueue
 )

1282 signed 
portBASE_TYPE
 
xReturn
;

1284 
	`configASSERT
( 
pxQueue
 );

1285 
xReturn
 = ( 
pxQueue
->
uxMessagesWaiting
 == ( unsigned 
portBASE_TYPE
 ) 0 );

1287 return 
xReturn
;

1288 
	}
}

1291 static signed 
portBASE_TYPE
 
	$prvIsQueueFull
( const 
xQueueHandle
 
pxQueue
 )

1293 signed 
portBASE_TYPE
 
xReturn
;

1295 
	`taskENTER_CRITICAL
();

1296 
xReturn
 = ( 
pxQueue
->
uxMessagesWaiting
 == pxQueue->
uxLength
 );

1297 
	`taskEXIT_CRITICAL
();

1299 return 
xReturn
;

1300 
	}
}

1303 signed 
portBASE_TYPE
 
	$xQueueIsQueueFullFromISR
( const 
xQueueHandle
 
pxQueue
 )

1305 signed 
portBASE_TYPE
 
xReturn
;

1307 
	`configASSERT
( 
pxQueue
 );

1308 
xReturn
 = ( 
pxQueue
->
uxMessagesWaiting
 == pxQueue->
uxLength
 );

1310 return 
xReturn
;

1311 
	}
}

1314 #if 
configUSE_CO_ROUTINES
 == 1

1315 signed 
portBASE_TYPE
 
	$xQueueCRSend
( 
xQueueHandle
 
pxQueue
, const void *
pvItemToQueue
, 
portTickType
 
xTicksToWait
 )

1317 signed 
portBASE_TYPE
 
xReturn
;

1322 
	`portDISABLE_INTERRUPTS
();

1324 if( 
	`prvIsQueueFull
( 
pxQueue
 ) != 
pdFALSE
 )

1328 if( 
xTicksToWait
 > ( 
portTickType
 ) 0 )

1332 
	`vCoRoutineAddToDelayedList
( 
xTicksToWait
, &( 
pxQueue
->
xTasksWaitingToSend
 ) );

1333 
	`portENABLE_INTERRUPTS
();

1334 return 
errQUEUE_BLOCKED
;

1338 
	`portENABLE_INTERRUPTS
();

1339 return 
errQUEUE_FULL
;

1343 
	`portENABLE_INTERRUPTS
();

1345 
	`portNOP
();

1347 
	`portDISABLE_INTERRUPTS
();

1349 if( 
pxQueue
->
uxMessagesWaiting
 < pxQueue->
uxLength
 )

1352 
	`prvCopyDataToQueue
( 
pxQueue
, 
pvItemToQueue
, 
queueSEND_TO_BACK
 );

1353 
xReturn
 = 
pdPASS
;

1356 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

1362 if( 
	`xCoRoutineRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) != 
pdFALSE
 )

1366 
xReturn
 = 
errQUEUE_YIELD
;

1372 
xReturn
 = 
errQUEUE_FULL
;

1375 
	`portENABLE_INTERRUPTS
();

1377 return 
xReturn
;

1378 
	}
}

1382 #if 
configUSE_CO_ROUTINES
 == 1

1383 signed 
portBASE_TYPE
 
	$xQueueCRReceive
( 
xQueueHandle
 
pxQueue
, void *
pvBuffer
, 
portTickType
 
xTicksToWait
 )

1385 signed 
portBASE_TYPE
 
xReturn
;

1390 
	`portDISABLE_INTERRUPTS
();

1392 if( 
pxQueue
->
uxMessagesWaiting
 == ( unsigned 
portBASE_TYPE
 ) 0 )

1396 if( 
xTicksToWait
 > ( 
portTickType
 ) 0 )

1400 
	`vCoRoutineAddToDelayedList
( 
xTicksToWait
, &( 
pxQueue
->
xTasksWaitingToReceive
 ) );

1401 
	`portENABLE_INTERRUPTS
();

1402 return 
errQUEUE_BLOCKED
;

1406 
	`portENABLE_INTERRUPTS
();

1407 return 
errQUEUE_FULL
;

1411 
	`portENABLE_INTERRUPTS
();

1413 
	`portNOP
();

1415 
	`portDISABLE_INTERRUPTS
();

1417 if( 
pxQueue
->
uxMessagesWaiting
 > ( unsigned 
portBASE_TYPE
 ) 0 )

1420 
pxQueue
->
pcReadFrom
 += pxQueue->
uxItemSize
;

1421 if( 
pxQueue
->
pcReadFrom
 >= pxQueue->
pcTail
 )

1423 
pxQueue
->
pcReadFrom
 = pxQueue->
pcHead
;

1425 --( 
pxQueue
->
uxMessagesWaiting
 );

1426 
	`memcpy
( ( void * ) 
pvBuffer
, ( void * ) 
pxQueue
->
pcReadFrom
, ( unsigned ) pxQueue->
uxItemSize
 );

1428 
xReturn
 = 
pdPASS
;

1431 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdFALSE
 )

1437 if( 
	`xCoRoutineRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) != 
pdFALSE
 )

1439 
xReturn
 = 
errQUEUE_YIELD
;

1445 
xReturn
 = 
pdFAIL
;

1448 
	`portENABLE_INTERRUPTS
();

1450 return 
xReturn
;

1451 
	}
}

1457 #if 
configUSE_CO_ROUTINES
 == 1

1458 signed 
portBASE_TYPE
 
	$xQueueCRSendFromISR
( 
xQueueHandle
 
pxQueue
, const void *
pvItemToQueue
, signed 
portBASE_TYPE
 
xCoRoutinePreviouslyWoken
 )

1462 if( 
pxQueue
->
uxMessagesWaiting
 < pxQueue->
uxLength
 )

1464 
	`prvCopyDataToQueue
( 
pxQueue
, 
pvItemToQueue
, 
queueSEND_TO_BACK
 );

1468 if( 
xCoRoutinePreviouslyWoken
 == 
pdFALSE
 )

1470 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) == 
pdFALSE
 )

1472 if( 
	`xCoRoutineRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToReceive
 ) ) != 
pdFALSE
 )

1474 return 
pdTRUE
;

1480 return 
xCoRoutinePreviouslyWoken
;

1481 
	}
}

1485 #if 
configUSE_CO_ROUTINES
 == 1

1486 signed 
portBASE_TYPE
 
	$xQueueCRReceiveFromISR
( 
xQueueHandle
 
pxQueue
, void *
pvBuffer
, signed 
portBASE_TYPE
 *
pxCoRoutineWoken
 )

1488 signed 
portBASE_TYPE
 
xReturn
;

1492 if( 
pxQueue
->
uxMessagesWaiting
 > ( unsigned 
portBASE_TYPE
 ) 0 )

1495 
pxQueue
->
pcReadFrom
 += pxQueue->
uxItemSize
;

1496 if( 
pxQueue
->
pcReadFrom
 >= pxQueue->
pcTail
 )

1498 
pxQueue
->
pcReadFrom
 = pxQueue->
pcHead
;

1500 --( 
pxQueue
->
uxMessagesWaiting
 );

1501 
	`memcpy
( ( void * ) 
pvBuffer
, ( void * ) 
pxQueue
->
pcReadFrom
, ( unsigned ) pxQueue->
uxItemSize
 );

1503 if( ( *
pxCoRoutineWoken
 ) == 
pdFALSE
 )

1505 if( 
	`listLIST_IS_EMPTY
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) == 
pdFALSE
 )

1507 if( 
	`xCoRoutineRemoveFromEventList
( &( 
pxQueue
->
xTasksWaitingToSend
 ) ) != 
pdFALSE
 )

1509 *
pxCoRoutineWoken
 = 
pdTRUE
;

1514 
xReturn
 = 
pdPASS
;

1518 
xReturn
 = 
pdFAIL
;

1521 return 
xReturn
;

1522 
	}
}

1526 #if 
configQUEUE_REGISTRY_SIZE
 > 0

1528 void 
	$vQueueAddToRegistry
( 
xQueueHandle
 
xQueue
, signed char *
pcQueueName
 )

1530 unsigned 
portBASE_TYPE
 
ux
;

1534 for( 
ux
 = ( unsigned 
portBASE_TYPE
 ) 0U; ux < ( unsigned portBASE_TYPE ) 
configQUEUE_REGISTRY_SIZE
; ux++ )

1536 if( 
xQueueRegistry
[ 
ux
 ].
pcQueueName
 == 
NULL
 )

1539 
xQueueRegistry
[ 
ux
 ].
pcQueueName
 = pcQueueName;

1540 
xQueueRegistry
[ 
ux
 ].
xHandle
 = 
xQueue
;

1544 
	}
}

1549 #if 
configQUEUE_REGISTRY_SIZE
 > 0

1551 static void 
	$vQueueUnregisterQueue
( 
xQueueHandle
 
xQueue
 )

1553 unsigned 
portBASE_TYPE
 
ux
;

1557 for( 
ux
 = ( unsigned 
portBASE_TYPE
 ) 0U; ux < ( unsigned portBASE_TYPE ) 
configQUEUE_REGISTRY_SIZE
; ux++ )

1559 if( 
xQueueRegistry
[ 
ux
 ].
xHandle
 == 
xQueue
 )

1562 
xQueueRegistry
[ 
ux
 ].
pcQueueName
 = 
NULL
;

1567 
	}
}

1572 #if 
configUSE_TIMERS
 == 1

1574 void 
	$vQueueWaitForMessageRestricted
( 
xQueueHandle
 
pxQueue
, 
portTickType
 
xTicksToWait
 )

1590 
	`prvLockQueue
( 
pxQueue
 );

1591 if( 
pxQueue
->
uxMessagesWaiting
 == ( unsigned 
portBASE_TYPE
 ) 0U )

1594 
	`vTaskPlaceOnEventListRestricted
( &( 
pxQueue
->
xTasksWaitingToReceive
 ), 
xTicksToWait
 );

1596 
	`prvUnlockQueue
( 
pxQueue
 );

1597 
	}
}

	@FreeRTOS/tasks.c

55 #include 
	~<stdio.h
>

56 #include 
	~<stdlib.h
>

57 #include 
	~<string.h
>

62 #define 
	#MPU_WRAPPERS_INCLUDED_FROM_API_FILE


	)

64 #include 
	~"FreeRTOS.h
"

65 #include 
	~"task.h
"

66 #include 
	~"timers.h
"

67 #include 
	~"StackMacros.h
"

69 #undef 
MPU_WRAPPERS_INCLUDED_FROM_API_FILE


74 #define 
	#tskIDLE_STACK_SIZE
 
configMINIMAL_STACK_SIZE


	)

80 typedef struct 
	stskTaskControlBlock


82 volatile 
portSTACK_TYPE
 *
	mpxTopOfStack
;

84 #if ( 
portUSING_MPU_WRAPPERS
 == 1 )

85 
xMPU_SETTINGS
 
	mxMPUSettings
;

88 
xListItem
 
	mxGenericListItem
;

89 
xListItem
 
	mxEventListItem
;

90 unsigned 
portBASE_TYPE
 
	muxPriority
;

91 
portSTACK_TYPE
 *
	mpxStack
;

92 signed char 
	mpcTaskName
[ 
configMAX_TASK_NAME_LEN
 ];

94 #if ( 
portSTACK_GROWTH
 > 0 )

95 
portSTACK_TYPE
 *
	mpxEndOfStack
;

98 #if ( 
portCRITICAL_NESTING_IN_TCB
 == 1 )

99 unsigned 
portBASE_TYPE
 
	muxCriticalNesting
;

102 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

103 unsigned 
portBASE_TYPE
 
	muxTCBNumber
;

104 unsigned 
portBASE_TYPE
 
	muxTaskNumber
;

107 #if ( 
configUSE_MUTEXES
 == 1 )

108 unsigned 
portBASE_TYPE
 
	muxBasePriority
;

111 #if ( 
configUSE_APPLICATION_TASK_TAG
 == 1 )

112 
pdTASK_HOOK_CODE
 
	mpxTaskTag
;

115 #if ( 
configGENERATE_RUN_TIME_STATS
 == 1 )

116 unsigned long 
	mulRunTimeCounter
;

119 } 
	ttskTCB
;

126 #ifdef 
portREMOVE_STATIC_QUALIFIER


127 #define static

	)

131 
PRIVILEGED_DATA
 
tskTCB
 * volatile 
	gpxCurrentTCB
 = 
NULL
;

135 
PRIVILEGED_DATA
 static 
xList
 
	gpxReadyTasksLists
[ 
configMAX_PRIORITIES
 ];

136 
PRIVILEGED_DATA
 static 
xList
 
	gxDelayedTaskList1
;

137 
PRIVILEGED_DATA
 static 
xList
 
	gxDelayedTaskList2
;

138 
PRIVILEGED_DATA
 static 
xList
 * volatile 
	gpxDelayedTaskList
 ;

139 
PRIVILEGED_DATA
 static 
xList
 * volatile 
	gpxOverflowDelayedTaskList
;

140 
PRIVILEGED_DATA
 static 
xList
 
	gxPendingReadyList
;

142 #if ( 
INCLUDE_vTaskDelete
 == 1 )

144 
PRIVILEGED_DATA
 static 
xList
 
	gxTasksWaitingTermination
;

145 
PRIVILEGED_DATA
 static volatile unsigned 
portBASE_TYPE
 
	guxTasksDeleted
 = ( unsigned portBASE_TYPE ) 0U;

149 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

151 
PRIVILEGED_DATA
 static 
xList
 
	gxSuspendedTaskList
;

155 #if ( 
INCLUDE_xTaskGetIdleTaskHandle
 == 1 )

157 
PRIVILEGED_DATA
 static 
xTaskHandle
 
	gxIdleTaskHandle
 = 
NULL
;

162 
PRIVILEGED_DATA
 static volatile unsigned 
portBASE_TYPE
 
	guxCurrentNumberOfTasks
 = ( unsigned portBASE_TYPE ) 0U;

163 
PRIVILEGED_DATA
 static volatile 
portTickType
 
	gxTickCount
 = ( portTickType ) 0U;

164 
PRIVILEGED_DATA
 static unsigned 
portBASE_TYPE
 
	guxTopUsedPriority
 = 
tskIDLE_PRIORITY
;

165 
PRIVILEGED_DATA
 static volatile unsigned 
portBASE_TYPE
 
	guxTopReadyPriority
 = 
tskIDLE_PRIORITY
;

166 
PRIVILEGED_DATA
 static volatile signed 
portBASE_TYPE
 
	gxSchedulerRunning
 = 
pdFALSE
;

167 
PRIVILEGED_DATA
 static volatile unsigned 
portBASE_TYPE
 
	guxSchedulerSuspended
 = ( unsigned portBASE_TYPE ) 
pdFALSE
;

168 
PRIVILEGED_DATA
 static volatile unsigned 
portBASE_TYPE
 
	guxMissedTicks
 = ( unsigned portBASE_TYPE ) 0U;

169 
PRIVILEGED_DATA
 static volatile 
portBASE_TYPE
 
	gxMissedYield
 = ( portBASE_TYPE ) 
pdFALSE
;

170 
PRIVILEGED_DATA
 static volatile 
portBASE_TYPE
 
	gxNumOfOverflows
 = ( portBASE_TYPE ) 0;

171 
PRIVILEGED_DATA
 static unsigned 
portBASE_TYPE
 
	guxTCBNumber
 = ( unsigned portBASE_TYPE ) 0U;

172 
PRIVILEGED_DATA
 static 
portTickType
 
	gxNextTaskUnblockTime
 = ( portTickType ) 
portMAX_DELAY
;

174 #if ( 
configGENERATE_RUN_TIME_STATS
 == 1 )

176 
PRIVILEGED_DATA
 static char 
	gpcStatsString
[ 50 ] ;

177 
PRIVILEGED_DATA
 static unsigned long 
	gulTaskSwitchedInTime
 = 0UL;

178 static void 
	$prvGenerateRunTimeStatsForTasksInList
( const signed char *
pcWriteBuffer
, 
xList
 *
pxList
, unsigned long 
ulTotalRunTime
 ) 
PRIVILEGED_FUNCTION
;

188 #define 
	#tskSTACK_FILL_BYTE
 ( 0xa5U )

	)

193 #define 
	#tskBLOCKED_CHAR
 ( ( signed char ) 'B' )

	)

194 #define 
	#tskREADY_CHAR
 ( ( signed char ) 'R' )

	)

195 #define 
	#tskDELETED_CHAR
 ( ( signed char ) 'D' )

	)

196 #define 
	#tskSUSPENDED_CHAR
 ( ( signed char ) 'S' )

	)

207 #define 
	#prvAddTaskToReadyQueue
( 
pxTCB
 ) \

	)

208 if( ( 
pxTCB
 )->
uxPriority
 > 
uxTopReadyPriority
 ) \

210 
uxTopReadyPriority
 = ( 
pxTCB
 )->
uxPriority
; \

211 
	}
} \

212 
vListInsertEnd
( ( 
xList
 * ) &( 
pxReadyTasksLists
[ ( 
pxTCB
 )->
uxPriority
 ] ), &( ( pxTCB )->
xGenericListItem
 ) )

223 #define 
	#prvCheckDelayedTasks
() \

	)

225 
portTickType
 
	gxItemValue
; \

229 if( 
	gxTickCount
 >= 
xNextTaskUnblockTime
 ) \

233 if( 
listLIST_IS_EMPTY
( 
pxDelayedTaskList
 ) != 
pdFALSE
 ) \

239 
xNextTaskUnblockTime
 = 
portMAX_DELAY
; \

248 
	gpxTCB
 = ( 
tskTCB
 * ) 
listGET_OWNER_OF_HEAD_ENTRY
( 
pxDelayedTaskList
 ); \

249 
	gxItemValue
 = 
listGET_LIST_ITEM_VALUE
( &( 
pxTCB
->
xGenericListItem
 ) ); \

251 if( 
	gxTickCount
 < 
	gxItemValue
 ) \

257 
	gxNextTaskUnblockTime
 = 
xItemValue
; \

262 
vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) ); \

265 if( 
	gpxTCB
->
	gxEventListItem
.
	gpvContainer
 != 
NULL
 ) \

267 
vListRemove
( &( 
pxTCB
->
xEventListItem
 ) ); \

269 
prvAddTaskToReadyQueue
( 
pxTCB
 ); \

282 #define 
	#prvGetTCBFromHandle
( 
pxHandle
 ) ( ( ( pxHandle ) == 
NULL
 ) ? ( 
tskTCB
 * ) 
pxCurrentTCB
 : ( tskTCB * ) ( pxHandle ) )

	)

285 extern void 
vApplicationStackOverflowHook
( 
xTaskHandle
 *
pxTask
, signed char *
pcTaskName
 );

286 extern void 
vApplicationTickHook
( void );

294 static void 
	$prvInitialiseTCBVariables
( 
tskTCB
 *
pxTCB
, const signed char * const 
pcName
, unsigned 
portBASE_TYPE
 
uxPriority
, const 
xMemoryRegion
 * const 
xRegions
, unsigned short 
usStackDepth
 ) 
PRIVILEGED_FUNCTION
;

300 static void 
	$prvInitialiseTaskLists
( void ) 
PRIVILEGED_FUNCTION
;

313 static 
	`portTASK_FUNCTION_PROTO
( 
prvIdleTask
, 
pvParameters
 );

322 #if ( 
INCLUDE_vTaskDelete
 == 1 )

324 static void 
	$prvDeleteTCB
( 
tskTCB
 *
pxTCB
 ) 
PRIVILEGED_FUNCTION
;

333 static void 
	$prvCheckTasksWaitingTermination
( void ) 
PRIVILEGED_FUNCTION
;

339 static void 
	$prvAddCurrentTaskToDelayedList
( 
portTickType
 
xTimeToWake
 ) 
PRIVILEGED_FUNCTION
;

345 static 
tskTCB
 *
	$prvAllocateTCBAndStack
( unsigned short 
usStackDepth
, 
portSTACK_TYPE
 *
puxStackBuffer
 ) 
PRIVILEGED_FUNCTION
;

356 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

358 static void 
	$prvListTaskWithinSingleList
( const signed char *
pcWriteBuffer
, 
xList
 *
pxList
, signed char 
cStatus
 ) 
PRIVILEGED_FUNCTION
;

367 #if ( ( 
configUSE_TRACE_FACILITY
 == 1 ) || ( 
INCLUDE_uxTaskGetStackHighWaterMark
 == 1 ) )

369 static unsigned short 
	$usTaskCheckFreeStackSpace
( const unsigned char * 
pucStackByte
 ) 
PRIVILEGED_FUNCTION
;

382 signed 
portBASE_TYPE
 
	$xTaskGenericCreate
( 
pdTASK_CODE
 
pxTaskCode
, const signed char * const 
pcName
, unsigned short 
usStackDepth
, void *
pvParameters
, unsigned 
portBASE_TYPE
 
uxPriority
, 
xTaskHandle
 *
pxCreatedTask
, 
portSTACK_TYPE
 *
puxStackBuffer
, const 
xMemoryRegion
 * const 
xRegions
 )

384 signed 
portBASE_TYPE
 
xReturn
;

385 
tskTCB
 * 
pxNewTCB
;

387 
	`configASSERT
( 
pxTaskCode
 );

388 
	`configASSERT
( ( 
uxPriority
 < 
configMAX_PRIORITIES
 ) );

392 
pxNewTCB
 = 
	`prvAllocateTCBAndStack
( 
usStackDepth
, 
puxStackBuffer
 );

394 if( 
pxNewTCB
 != 
NULL
 )

396 
portSTACK_TYPE
 *
pxTopOfStack
;

398 #if( 
portUSING_MPU_WRAPPERS
 == 1 )

400 
portBASE_TYPE
 
xRunPrivileged
;

401 if( ( 
uxPriority
 & 
portPRIVILEGE_BIT
 ) != 0U )

403 
xRunPrivileged
 = 
pdTRUE
;

407 
xRunPrivileged
 = 
pdFALSE
;

409 
uxPriority
 &= ~
portPRIVILEGE_BIT
;

416 #if( 
portSTACK_GROWTH
 < 0 )

418 
pxTopOfStack
 = 
pxNewTCB
->
pxStack
 + ( 
usStackDepth
 - ( unsigned short ) 1 );

419 
pxTopOfStack
 = ( 
portSTACK_TYPE
 * ) ( ( ( 
portPOINTER_SIZE_TYPE
 ) pxTopOfStack ) & ( ( portPOINTER_SIZE_TYPE ) ~
portBYTE_ALIGNMENT_MASK
 ) );

422 
	`configASSERT
( ( ( ( unsigned long ) 
pxTopOfStack
 & ( unsigned long ) 
portBYTE_ALIGNMENT_MASK
 ) == 0UL ) );

426 
pxTopOfStack
 = 
pxNewTCB
->
pxStack
;

429 
	`configASSERT
( ( ( ( unsigned long ) 
pxNewTCB
->
pxStack
 & ( unsigned long ) 
portBYTE_ALIGNMENT_MASK
 ) == 0UL ) );

434 
pxNewTCB
->
pxEndOfStack
 = pxNewTCB->
pxStack
 + ( 
usStackDepth
 - 1 );

439 
	`prvInitialiseTCBVariables
( 
pxNewTCB
, 
pcName
, 
uxPriority
, 
xRegions
, 
usStackDepth
 );

445 #if( 
portUSING_MPU_WRAPPERS
 == 1 )

447 
pxNewTCB
->
pxTopOfStack
 = 
	`pxPortInitialiseStack
( pxTopOfStack, 
pxTaskCode
, 
pvParameters
, 
xRunPrivileged
 );

451 
pxNewTCB
->
pxTopOfStack
 = 
	`pxPortInitialiseStack
( pxTopOfStack, 
pxTaskCode
, 
pvParameters
 );

456 
	`portALIGNMENT_ASSERT_pxCurrentTCB
( ( ( ( unsigned long ) 
pxNewTCB
->
pxTopOfStack
 & ( unsigned long ) 
portBYTE_ALIGNMENT_MASK
 ) == 0UL ) );

458 if( ( void * ) 
pxCreatedTask
 != 
NULL
 )

463 *
pxCreatedTask
 = ( 
xTaskHandle
 ) 
pxNewTCB
;

468 
	`taskENTER_CRITICAL
();

470 
uxCurrentNumberOfTasks
++;

471 if( 
pxCurrentTCB
 == 
NULL
 )

475 
pxCurrentTCB
 = 
pxNewTCB
;

477 if( 
uxCurrentNumberOfTasks
 == ( unsigned 
portBASE_TYPE
 ) 1 )

482 
	`prvInitialiseTaskLists
();

490 if( 
xSchedulerRunning
 == 
pdFALSE
 )

492 if( 
pxCurrentTCB
->
uxPriority
 <= uxPriority )

494 
pxCurrentTCB
 = 
pxNewTCB
;

501 if( 
pxNewTCB
->
uxPriority
 > 
uxTopUsedPriority
 )

503 
uxTopUsedPriority
 = 
pxNewTCB
->
uxPriority
;

506 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

509 
pxNewTCB
->
uxTCBNumber
 = uxTCBNumber;

512 
uxTCBNumber
++;

514 
	`prvAddTaskToReadyQueue
( 
pxNewTCB
 );

516 
xReturn
 = 
pdPASS
;

517 
	`traceTASK_CREATE
( 
pxNewTCB
 );

519 
	`taskEXIT_CRITICAL
();

523 
xReturn
 = 
errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY
;

524 
	`traceTASK_CREATE_FAILED
();

527 if( 
xReturn
 == 
pdPASS
 )

529 if( 
xSchedulerRunning
 != 
pdFALSE
 )

533 if( 
pxCurrentTCB
->
uxPriority
 < uxPriority )

535 
	`portYIELD_WITHIN_API
();

540 return 
xReturn
;

541 
	}
}

544 #if ( 
INCLUDE_vTaskDelete
 == 1 )

546 void 
	$vTaskDelete
( 
xTaskHandle
 
pxTaskToDelete
 )

548 
tskTCB
 *
pxTCB
;

550 
	`taskENTER_CRITICAL
();

554 if( 
pxTaskToDelete
 == 
pxCurrentTCB
 )

556 
pxTaskToDelete
 = 
NULL
;

560 
pxTCB
 = 
	`prvGetTCBFromHandle
( 
pxTaskToDelete
 );

566 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

569 if( 
pxTCB
->
xEventListItem
.
pvContainer
 != 
NULL
 )

571 
	`vListRemove
( &( 
pxTCB
->
xEventListItem
 ) );

574 
	`vListInsertEnd
( ( 
xList
 * ) &
xTasksWaitingTermination
, &( 
pxTCB
->
xGenericListItem
 ) );

579 ++
uxTasksDeleted
;

583 
uxTCBNumber
++;

585 
	`traceTASK_DELETE
( 
pxTCB
 );

587 
	`taskEXIT_CRITICAL
();

590 if( 
xSchedulerRunning
 != 
pdFALSE
 )

592 if( ( void * ) 
pxTaskToDelete
 == 
NULL
 )

594 
	`portYIELD_WITHIN_API
();

597 
	}
}

610 #if ( 
INCLUDE_vTaskDelayUntil
 == 1 )

612 void 
	$vTaskDelayUntil
( 
portTickType
 * const 
pxPreviousWakeTime
, portTickType 
xTimeIncrement
 )

614 
portTickType
 
xTimeToWake
;

615 
portBASE_TYPE
 
xAlreadyYielded
, 
xShouldDelay
 = 
pdFALSE
;

617 
	`configASSERT
( 
pxPreviousWakeTime
 );

618 
	`configASSERT
( ( 
xTimeIncrement
 > 0U ) );

620 
	`vTaskSuspendAll
();

623 
xTimeToWake
 = *
pxPreviousWakeTime
 + 
xTimeIncrement
;

625 if( 
xTickCount
 < *
pxPreviousWakeTime
 )

632 if( ( 
xTimeToWake
 < *
pxPreviousWakeTime
 ) && ( xTimeToWake > 
xTickCount
 ) )

634 
xShouldDelay
 = 
pdTRUE
;

642 if( ( 
xTimeToWake
 < *
pxPreviousWakeTime
 ) || ( xTimeToWake > 
xTickCount
 ) )

644 
xShouldDelay
 = 
pdTRUE
;

649 *
pxPreviousWakeTime
 = 
xTimeToWake
;

651 if( 
xShouldDelay
 != 
pdFALSE
 )

653 
	`traceTASK_DELAY_UNTIL
();

658 
	`vListRemove
( ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xGenericListItem
 ) );

659 
	`prvAddCurrentTaskToDelayedList
( 
xTimeToWake
 );

662 
xAlreadyYielded
 = 
	`xTaskResumeAll
();

666 if( 
xAlreadyYielded
 == 
pdFALSE
 )

668 
	`portYIELD_WITHIN_API
();

670 
	}
}

675 #if ( 
INCLUDE_vTaskDelay
 == 1 )

677 void 
	$vTaskDelay
( 
portTickType
 
xTicksToDelay
 )

679 
portTickType
 
xTimeToWake
;

680 signed 
portBASE_TYPE
 
xAlreadyYielded
 = 
pdFALSE
;

683 if( 
xTicksToDelay
 > ( 
portTickType
 ) 0U )

685 
	`vTaskSuspendAll
();

687 
	`traceTASK_DELAY
();

699 
xTimeToWake
 = 
xTickCount
 + 
xTicksToDelay
;

704 
	`vListRemove
( ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xGenericListItem
 ) );

705 
	`prvAddCurrentTaskToDelayedList
( 
xTimeToWake
 );

707 
xAlreadyYielded
 = 
	`xTaskResumeAll
();

712 if( 
xAlreadyYielded
 == 
pdFALSE
 )

714 
	`portYIELD_WITHIN_API
();

716 
	}
}

721 #if ( 
INCLUDE_uxTaskPriorityGet
 == 1 )

723 unsigned 
portBASE_TYPE
 
	$uxTaskPriorityGet
( 
xTaskHandle
 
pxTask
 )

725 
tskTCB
 *
pxTCB
;

726 unsigned 
portBASE_TYPE
 
uxReturn
;

728 
	`taskENTER_CRITICAL
();

732 
pxTCB
 = 
	`prvGetTCBFromHandle
( 
pxTask
 );

733 
uxReturn
 = 
pxTCB
->
uxPriority
;

735 
	`taskEXIT_CRITICAL
();

737 return 
uxReturn
;

738 
	}
}

743 #if ( 
INCLUDE_vTaskPrioritySet
 == 1 )

745 void 
	$vTaskPrioritySet
( 
xTaskHandle
 
pxTask
, unsigned 
portBASE_TYPE
 
uxNewPriority
 )

747 
tskTCB
 *
pxTCB
;

748 unsigned 
portBASE_TYPE
 
uxCurrentPriority
;

749 
portBASE_TYPE
 
xYieldRequired
 = 
pdFALSE
;

751 
	`configASSERT
( ( 
uxNewPriority
 < 
configMAX_PRIORITIES
 ) );

754 if( 
uxNewPriority
 >= 
configMAX_PRIORITIES
 )

756 
uxNewPriority
 = 
configMAX_PRIORITIES
 - ( unsigned 
portBASE_TYPE
 ) 1U;

759 
	`taskENTER_CRITICAL
();

761 if( 
pxTask
 == 
pxCurrentTCB
 )

763 
pxTask
 = 
NULL
;

768 
pxTCB
 = 
	`prvGetTCBFromHandle
( 
pxTask
 );

770 
	`traceTASK_PRIORITY_SET
( 
pxTCB
, 
uxNewPriority
 );

772 #if ( 
configUSE_MUTEXES
 == 1 )

774 
uxCurrentPriority
 = 
pxTCB
->
uxBasePriority
;

778 
uxCurrentPriority
 = 
pxTCB
->
uxPriority
;

782 if( 
uxCurrentPriority
 != 
uxNewPriority
 )

786 if( 
uxNewPriority
 > 
uxCurrentPriority
 )

788 if( 
pxTask
 != 
NULL
 )

794 
xYieldRequired
 = 
pdTRUE
;

797 else if( 
pxTask
 == 
NULL
 )

801 
xYieldRequired
 = 
pdTRUE
;

806 #if ( 
configUSE_MUTEXES
 == 1 )

810 if( 
pxTCB
->
uxBasePriority
 == pxTCB->
uxPriority
 )

812 
pxTCB
->
uxPriority
 = 
uxNewPriority
;

816 
pxTCB
->
uxBasePriority
 = 
uxNewPriority
;

820 
pxTCB
->
uxPriority
 = 
uxNewPriority
;

824 
	`listSET_LIST_ITEM_VALUE
( &( 
pxTCB
->
xEventListItem
 ), ( 
configMAX_PRIORITIES
 - ( 
portTickType
 ) 
uxNewPriority
 ) );

830 if( 
	`listIS_CONTAINED_WITHIN
( &( 
pxReadyTasksLists
[ 
uxCurrentPriority
 ] ), &( 
pxTCB
->
xGenericListItem
 ) ) )

835 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

836 
	`prvAddTaskToReadyQueue
( 
pxTCB
 );

839 if( 
xYieldRequired
 == 
pdTRUE
 )

841 
	`portYIELD_WITHIN_API
();

845 
	`taskEXIT_CRITICAL
();

846 
	}
}

851 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

853 void 
	$vTaskSuspend
( 
xTaskHandle
 
pxTaskToSuspend
 )

855 
tskTCB
 *
pxTCB
;

857 
	`taskENTER_CRITICAL
();

861 if( 
pxTaskToSuspend
 == 
pxCurrentTCB
 )

863 
pxTaskToSuspend
 = 
NULL
;

867 
pxTCB
 = 
	`prvGetTCBFromHandle
( 
pxTaskToSuspend
 );

869 
	`traceTASK_SUSPEND
( 
pxTCB
 );

872 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

875 if( 
pxTCB
->
xEventListItem
.
pvContainer
 != 
NULL
 )

877 
	`vListRemove
( &( 
pxTCB
->
xEventListItem
 ) );

880 
	`vListInsertEnd
( ( 
xList
 * ) &
xSuspendedTaskList
, &( 
pxTCB
->
xGenericListItem
 ) );

882 
	`taskEXIT_CRITICAL
();

884 if( ( void * ) 
pxTaskToSuspend
 == 
NULL
 )

886 if( 
xSchedulerRunning
 != 
pdFALSE
 )

889 
	`portYIELD_WITHIN_API
();

896 if( 
	`listCURRENT_LIST_LENGTH
( &
xSuspendedTaskList
 ) == 
uxCurrentNumberOfTasks
 )

902 
pxCurrentTCB
 = 
NULL
;

906 
	`vTaskSwitchContext
();

910 
	}
}

915 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

917 signed 
portBASE_TYPE
 
	$xTaskIsTaskSuspended
( 
xTaskHandle
 
xTask
 )

919 
portBASE_TYPE
 
xReturn
 = 
pdFALSE
;

920 const 
tskTCB
 * const 
pxTCB
 = ( tskTCB * ) 
xTask
;

923 
	`configASSERT
( 
xTask
 );

927 if( 
	`listIS_CONTAINED_WITHIN
( &
xSuspendedTaskList
, &( 
pxTCB
->
xGenericListItem
 ) ) != 
pdFALSE
 )

930 if( 
	`listIS_CONTAINED_WITHIN
( &
xPendingReadyList
, &( 
pxTCB
->
xEventListItem
 ) ) != 
pdTRUE
 )

936 if( 
	`listIS_CONTAINED_WITHIN
( 
NULL
, &( 
pxTCB
->
xEventListItem
 ) ) == 
pdTRUE
 )

938 
xReturn
 = 
pdTRUE
;

943 return 
xReturn
;

944 
	}
}

949 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

951 void 
	$vTaskResume
( 
xTaskHandle
 
pxTaskToResume
 )

953 
tskTCB
 *
pxTCB
;

956 
	`configASSERT
( 
pxTaskToResume
 );

960 
pxTCB
 = ( 
tskTCB
 * ) 
pxTaskToResume
;

964 if( ( 
pxTCB
 != 
NULL
 ) && ( pxTCB != 
pxCurrentTCB
 ) )

966 
	`taskENTER_CRITICAL
();

968 if( 
	`xTaskIsTaskSuspended
( 
pxTCB
 ) == 
pdTRUE
 )

970 
	`traceTASK_RESUME
( 
pxTCB
 );

974 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

975 
	`prvAddTaskToReadyQueue
( 
pxTCB
 );

978 if( 
pxTCB
->
uxPriority
 >= 
pxCurrentTCB
->uxPriority )

982 
	`portYIELD_WITHIN_API
();

986 
	`taskEXIT_CRITICAL
();

988 
	}
}

994 #if ( ( 
INCLUDE_xTaskResumeFromISR
 == 1 ) && ( 
INCLUDE_vTaskSuspend
 == 1 ) )

996 
portBASE_TYPE
 
	$xTaskResumeFromISR
( 
xTaskHandle
 
pxTaskToResume
 )

998 
portBASE_TYPE
 
xYieldRequired
 = 
pdFALSE
;

999 
tskTCB
 *
pxTCB
;

1000 unsigned 
portBASE_TYPE
 
uxSavedInterruptStatus
;

1002 
	`configASSERT
( 
pxTaskToResume
 );

1004 
pxTCB
 = ( 
tskTCB
 * ) 
pxTaskToResume
;

1006 
uxSavedInterruptStatus
 = 
	`portSET_INTERRUPT_MASK_FROM_ISR
();

1008 if( 
	`xTaskIsTaskSuspended
( 
pxTCB
 ) == 
pdTRUE
 )

1010 
	`traceTASK_RESUME_FROM_ISR
( 
pxTCB
 );

1012 if( 
uxSchedulerSuspended
 == ( unsigned 
portBASE_TYPE
 ) 
pdFALSE
 )

1014 
xYieldRequired
 = ( 
pxTCB
->
uxPriority
 >= 
pxCurrentTCB
->uxPriority );

1015 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

1016 
	`prvAddTaskToReadyQueue
( 
pxTCB
 );

1023 
	`vListInsertEnd
( ( 
xList
 * ) &( 
xPendingReadyList
 ), &( 
pxTCB
->
xEventListItem
 ) );

1027 
	`portCLEAR_INTERRUPT_MASK_FROM_ISR
( 
uxSavedInterruptStatus
 );

1029 return 
xYieldRequired
;

1030 
	}
}

1042 void 
	$vTaskStartScheduler
( void )

1044 
portBASE_TYPE
 
xReturn
;

1047 #if ( 
INCLUDE_xTaskGetIdleTaskHandle
 == 1 )

1051 
xReturn
 = 
	`xTaskCreate
( 
prvIdleTask
, ( signed char * ) "IDLE", 
tskIDLE_STACK_SIZE
, ( void * ) 
NULL
, ( 
tskIDLE_PRIORITY
 | 
portPRIVILEGE_BIT
 ), &
xIdleTaskHandle
 );

1056 
xReturn
 = 
	`xTaskCreate
( 
prvIdleTask
, ( signed char * ) "IDLE", 
tskIDLE_STACK_SIZE
, ( void * ) 
NULL
, ( 
tskIDLE_PRIORITY
 | 
portPRIVILEGE_BIT
 ), NULL );

1060 #if ( 
configUSE_TIMERS
 == 1 )

1062 if( 
xReturn
 == 
pdPASS
 )

1064 
xReturn
 = 
	`xTimerCreateTimerTask
();

1069 if( 
xReturn
 == 
pdPASS
 )

1079 
	`portDISABLE_INTERRUPTS
();

1081 
xSchedulerRunning
 = 
pdTRUE
;

1082 
xTickCount
 = ( 
portTickType
 ) 0U;

1087 
	`portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
();

1091 if( 
	`xPortStartScheduler
() != 
pdFALSE
 )

1103 
	`configASSERT
( 
xReturn
 );

1104 
	}
}

1107 void 
	$vTaskEndScheduler
( void )

1112 
	`portDISABLE_INTERRUPTS
();

1113 
xSchedulerRunning
 = 
pdFALSE
;

1114 
	`vPortEndScheduler
();

1115 
	}
}

1118 void 
	$vTaskSuspendAll
( void )

1122 ++
uxSchedulerSuspended
;

1123 
	}
}

1126 signed 
portBASE_TYPE
 
	$xTaskResumeAll
( void )

1128 register 
tskTCB
 *
pxTCB
;

1129 signed 
portBASE_TYPE
 
xAlreadyYielded
 = 
pdFALSE
;

1133 
	`configASSERT
( 
uxSchedulerSuspended
 );

1140 
	`taskENTER_CRITICAL
();

1142 --
uxSchedulerSuspended
;

1144 if( 
uxSchedulerSuspended
 == ( unsigned 
portBASE_TYPE
 ) 
pdFALSE
 )

1146 if( 
uxCurrentNumberOfTasks
 > ( unsigned 
portBASE_TYPE
 ) 0U )

1148 
portBASE_TYPE
 
xYieldRequired
 = 
pdFALSE
;

1152 while( 
	`listLIST_IS_EMPTY
( ( 
xList
 * ) &
xPendingReadyList
 ) == 
pdFALSE
 )

1154 
pxTCB
 = ( 
tskTCB
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( ( ( 
xList
 * ) &
xPendingReadyList
 ) );

1155 
	`vListRemove
( &( 
pxTCB
->
xEventListItem
 ) );

1156 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

1157 
	`prvAddTaskToReadyQueue
( 
pxTCB
 );

1161 if( 
pxTCB
->
uxPriority
 >= 
pxCurrentTCB
->uxPriority )

1163 
xYieldRequired
 = 
pdTRUE
;

1170 if( 
uxMissedTicks
 > ( unsigned 
portBASE_TYPE
 ) 0U )

1172 while( 
uxMissedTicks
 > ( unsigned 
portBASE_TYPE
 ) 0U )

1174 
	`vTaskIncrementTick
();

1175 --
uxMissedTicks
;

1181 #if 
configUSE_PREEMPTION
 == 1

1183 
xYieldRequired
 = 
pdTRUE
;

1188 if( ( 
xYieldRequired
 == 
pdTRUE
 ) || ( 
xMissedYield
 == pdTRUE ) )

1190 
xAlreadyYielded
 = 
pdTRUE
;

1191 
xMissedYield
 = 
pdFALSE
;

1192 
	`portYIELD_WITHIN_API
();

1197 
	`taskEXIT_CRITICAL
();

1199 return 
xAlreadyYielded
;

1200 
	}
}

1213 
portTickType
 
	$xTaskGetTickCount
( void )

1215 
portTickType
 
xTicks
;

1218 
	`taskENTER_CRITICAL
();

1220 
xTicks
 = 
xTickCount
;

1222 
	`taskEXIT_CRITICAL
();

1224 return 
xTicks
;

1225 
	}
}

1228 
portTickType
 
	$xTaskGetTickCountFromISR
( void )

1230 
portTickType
 
xReturn
;

1231 unsigned 
portBASE_TYPE
 
uxSavedInterruptStatus
;

1233 
uxSavedInterruptStatus
 = 
	`portSET_INTERRUPT_MASK_FROM_ISR
();

1234 
xReturn
 = 
xTickCount
;

1235 
	`portCLEAR_INTERRUPT_MASK_FROM_ISR
( 
uxSavedInterruptStatus
 );

1237 return 
xReturn
;

1238 
	}
}

1241 unsigned 
portBASE_TYPE
 
	$uxTaskGetNumberOfTasks
( void )

1245 return 
uxCurrentNumberOfTasks
;

1246 
	}
}

1249 #if ( 
INCLUDE_pcTaskGetTaskName
 == 1 )

1251 signed char *
	$pcTaskGetTaskName
( 
xTaskHandle
 
xTaskToQuery
 )

1253 
tskTCB
 *
pxTCB
;

1256 
pxTCB
 = 
	`prvGetTCBFromHandle
( 
xTaskToQuery
 );

1257 
	`configASSERT
( 
pxTCB
 );

1258 return &( 
pxTCB
->
pcTaskName
[ 0 ] );

1259 
	}
}

1264 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

1266 void 
	$vTaskList
( signed char *
pcWriteBuffer
 )

1268 unsigned 
portBASE_TYPE
 
uxQueue
;

1273 
	`vTaskSuspendAll
();

1278 *
pcWriteBuffer
 = ( signed char ) 0x00;

1279 
	`strcat
( ( char * ) 
pcWriteBuffer
, ( const char * ) "\r\n" );

1281 
uxQueue
 = 
uxTopUsedPriority
 + ( unsigned 
portBASE_TYPE
 ) 1U;

1285 
uxQueue
--;

1287 if( 
	`listLIST_IS_EMPTY
( &( 
pxReadyTasksLists
[ 
uxQueue
 ] ) ) == 
pdFALSE
 )

1289 
	`prvListTaskWithinSingleList
( 
pcWriteBuffer
, ( 
xList
 * ) &( 
pxReadyTasksLists
[ 
uxQueue
 ] ), 
tskREADY_CHAR
 );

1291 }while( 
uxQueue
 > ( unsigned short ) 
tskIDLE_PRIORITY
 );

1293 if( 
	`listLIST_IS_EMPTY
( 
pxDelayedTaskList
 ) == 
pdFALSE
 )

1295 
	`prvListTaskWithinSingleList
( 
pcWriteBuffer
, ( 
xList
 * ) 
pxDelayedTaskList
, 
tskBLOCKED_CHAR
 );

1298 if( 
	`listLIST_IS_EMPTY
( 
pxOverflowDelayedTaskList
 ) == 
pdFALSE
 )

1300 
	`prvListTaskWithinSingleList
( 
pcWriteBuffer
, ( 
xList
 * ) 
pxOverflowDelayedTaskList
, 
tskBLOCKED_CHAR
 );

1303 #if( 
INCLUDE_vTaskDelete
 == 1 )

1305 if( 
	`listLIST_IS_EMPTY
( &
xTasksWaitingTermination
 ) == 
pdFALSE
 )

1307 
	`prvListTaskWithinSingleList
( 
pcWriteBuffer
, &
xTasksWaitingTermination
, 
tskDELETED_CHAR
 );

1312 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

1314 if( 
	`listLIST_IS_EMPTY
( &
xSuspendedTaskList
 ) == 
pdFALSE
 )

1316 
	`prvListTaskWithinSingleList
( 
pcWriteBuffer
, &
xSuspendedTaskList
, 
tskSUSPENDED_CHAR
 );

1318 
	}
}

1321 
xTaskResumeAll
();

1327 #if ( 
configGENERATE_RUN_TIME_STATS
 == 1 )

1329 void 
	$vTaskGetRunTimeStats
( signed char *
pcWriteBuffer
 )

1331 unsigned 
portBASE_TYPE
 
uxQueue
;

1332 unsigned long 
ulTotalRunTime
;

1337 
	`vTaskSuspendAll
();

1339 #ifdef 
portALT_GET_RUN_TIME_COUNTER_VALUE


1340 
	`portALT_GET_RUN_TIME_COUNTER_VALUE
( 
ulTotalRunTime
 );

1342 
ulTotalRunTime
 = 
	`portGET_RUN_TIME_COUNTER_VALUE
();

1347 
ulTotalRunTime
 /= 100UL;

1353 *
pcWriteBuffer
 = ( signed char ) 0x00;

1354 
	`strcat
( ( char * ) 
pcWriteBuffer
, ( const char * ) "\r\n" );

1356 
uxQueue
 = 
uxTopUsedPriority
 + ( unsigned 
portBASE_TYPE
 ) 1U;

1360 
uxQueue
--;

1362 if( 
	`listLIST_IS_EMPTY
( &( 
pxReadyTasksLists
[ 
uxQueue
 ] ) ) == 
pdFALSE
 )

1364 
	`prvGenerateRunTimeStatsForTasksInList
( 
pcWriteBuffer
, ( 
xList
 * ) &( 
pxReadyTasksLists
[ 
uxQueue
 ] ), 
ulTotalRunTime
 );

1366 }while( 
uxQueue
 > ( unsigned short ) 
tskIDLE_PRIORITY
 );

1368 if( 
	`listLIST_IS_EMPTY
( 
pxDelayedTaskList
 ) == 
pdFALSE
 )

1370 
	`prvGenerateRunTimeStatsForTasksInList
( 
pcWriteBuffer
, ( 
xList
 * ) 
pxDelayedTaskList
, 
ulTotalRunTime
 );

1373 if( 
	`listLIST_IS_EMPTY
( 
pxOverflowDelayedTaskList
 ) == 
pdFALSE
 )

1375 
	`prvGenerateRunTimeStatsForTasksInList
( 
pcWriteBuffer
, ( 
xList
 * ) 
pxOverflowDelayedTaskList
, 
ulTotalRunTime
 );

1378 #if ( 
INCLUDE_vTaskDelete
 == 1 )

1380 if( 
	`listLIST_IS_EMPTY
( &
xTasksWaitingTermination
 ) == 
pdFALSE
 )

1382 
	`prvGenerateRunTimeStatsForTasksInList
( 
pcWriteBuffer
, &
xTasksWaitingTermination
, 
ulTotalRunTime
 );

1387 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

1389 if( 
	`listLIST_IS_EMPTY
( &
xSuspendedTaskList
 ) == 
pdFALSE
 )

1391 
	`prvGenerateRunTimeStatsForTasksInList
( 
pcWriteBuffer
, &
xSuspendedTaskList
, 
ulTotalRunTime
 );

1396 
	`xTaskResumeAll
();

1397 
	}
}

1402 #if ( 
INCLUDE_xTaskGetIdleTaskHandle
 == 1 )

1404 
xTaskHandle
 
	$xTaskGetIdleTaskHandle
( void )

1408 
	`configASSERT
( ( 
xIdleTaskHandle
 != 
NULL
 ) );

1409 return 
xIdleTaskHandle
;

1410 
	}
}

1419 void 
	$vTaskIncrementTick
( void )

1421 
tskTCB
 * 
pxTCB
;

1426 if( 
uxSchedulerSuspended
 == ( unsigned 
portBASE_TYPE
 ) 
pdFALSE
 )

1428 ++
xTickCount
;

1429 if( 
xTickCount
 == ( 
portTickType
 ) 0U )

1431 
xList
 *
pxTemp
;

1436 
	`configASSERT
( ( 
	`listLIST_IS_EMPTY
( 
pxDelayedTaskList
 ) ) );

1438 
pxTemp
 = 
pxDelayedTaskList
;

1439 
pxDelayedTaskList
 = 
pxOverflowDelayedTaskList
;

1440 
pxOverflowDelayedTaskList
 = 
pxTemp
;

1441 
xNumOfOverflows
++;

1443 if( 
	`listLIST_IS_EMPTY
( 
pxDelayedTaskList
 ) != 
pdFALSE
 )

1450 
xNextTaskUnblockTime
 = 
portMAX_DELAY
;

1458 
pxTCB
 = ( 
tskTCB
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( 
pxDelayedTaskList
 );

1459 
xNextTaskUnblockTime
 = 
	`listGET_LIST_ITEM_VALUE
( &( 
pxTCB
->
xGenericListItem
 ) );

1464 
	`prvCheckDelayedTasks
();

1468 ++
uxMissedTicks
;

1472 #if ( 
configUSE_TICK_HOOK
 == 1 )

1474 
	`vApplicationTickHook
();

1479 #if ( 
configUSE_TICK_HOOK
 == 1 )

1483 if( 
uxMissedTicks
 == ( unsigned 
portBASE_TYPE
 ) 0U )

1485 
	`vApplicationTickHook
();

1490 
	`traceTASK_INCREMENT_TICK
( 
xTickCount
 );

1491 
	}
}

1494 #if ( 
configUSE_APPLICATION_TASK_TAG
 == 1 )

1496 void 
	$vTaskSetApplicationTaskTag
( 
xTaskHandle
 
xTask
, 
pdTASK_HOOK_CODE
 
pxHookFunction
 )

1498 
tskTCB
 *
xTCB
;

1501 if( 
xTask
 == 
NULL
 )

1503 
xTCB
 = ( 
tskTCB
 * ) 
pxCurrentTCB
;

1507 
xTCB
 = ( 
tskTCB
 * ) 
xTask
;

1512 
	`taskENTER_CRITICAL
();

1513 
xTCB
->
pxTaskTag
 = 
pxHookFunction
;

1514 
	`taskEXIT_CRITICAL
();

1515 
	}
}

1520 #if ( 
configUSE_APPLICATION_TASK_TAG
 == 1 )

1522 
pdTASK_HOOK_CODE
 
	$xTaskGetApplicationTaskTag
( 
xTaskHandle
 
xTask
 )

1524 
tskTCB
 *
xTCB
;

1525 
pdTASK_HOOK_CODE
 
xReturn
;

1528 if( 
xTask
 == 
NULL
 )

1530 
xTCB
 = ( 
tskTCB
 * ) 
pxCurrentTCB
;

1534 
xTCB
 = ( 
tskTCB
 * ) 
xTask
;

1539 
	`taskENTER_CRITICAL
();

1540 
xReturn
 = 
xTCB
->
pxTaskTag
;

1541 
	`taskEXIT_CRITICAL
();

1543 return 
xReturn
;

1544 
	}
}

1549 #if ( 
configUSE_APPLICATION_TASK_TAG
 == 1 )

1551 
portBASE_TYPE
 
	$xTaskCallApplicationTaskHook
( 
xTaskHandle
 
xTask
, void *
pvParameter
 )

1553 
tskTCB
 *
xTCB
;

1554 
portBASE_TYPE
 
xReturn
;

1557 if( 
xTask
 == 
NULL
 )

1559 
xTCB
 = ( 
tskTCB
 * ) 
pxCurrentTCB
;

1563 
xTCB
 = ( 
tskTCB
 * ) 
xTask
;

1566 if( 
xTCB
->
pxTaskTag
 != 
NULL
 )

1568 
xReturn
 = 
xTCB
->
	`pxTaskTag
( 
pvParameter
 );

1572 
xReturn
 = 
pdFAIL
;

1575 return 
xReturn
;

1576 
	}
}

1581 void 
	$vTaskSwitchContext
( void )

1583 if( 
uxSchedulerSuspended
 != ( unsigned 
portBASE_TYPE
 ) 
pdFALSE
 )

1587 
xMissedYield
 = 
pdTRUE
;

1591 
	`traceTASK_SWITCHED_OUT
();

1593 #if ( 
configGENERATE_RUN_TIME_STATS
 == 1 )

1595 unsigned long 
ulTempCounter
;

1597 #ifdef 
portALT_GET_RUN_TIME_COUNTER_VALUE


1598 
	`portALT_GET_RUN_TIME_COUNTER_VALUE
( 
ulTempCounter
 );

1600 
ulTempCounter
 = 
	`portGET_RUN_TIME_COUNTER_VALUE
();

1608 
pxCurrentTCB
->
ulRunTimeCounter
 += ( 
ulTempCounter
 - 
ulTaskSwitchedInTime
 );

1609 
ulTaskSwitchedInTime
 = 
ulTempCounter
;

1613 
	`taskFIRST_CHECK_FOR_STACK_OVERFLOW
();

1614 
	`taskSECOND_CHECK_FOR_STACK_OVERFLOW
();

1617 while( 
	`listLIST_IS_EMPTY
( &( 
pxReadyTasksLists
[ 
uxTopReadyPriority
 ] ) ) )

1619 
	`configASSERT
( 
uxTopReadyPriority
 );

1620 --
uxTopReadyPriority
;

1625 
	`listGET_OWNER_OF_NEXT_ENTRY
( 
pxCurrentTCB
, &( 
pxReadyTasksLists
[ 
uxTopReadyPriority
 ] ) );

1627 
	`traceTASK_SWITCHED_IN
();

1629 
	}
}

1632 void 
	$vTaskPlaceOnEventList
( const 
xList
 * const 
pxEventList
, 
portTickType
 
xTicksToWait
 )

1634 
portTickType
 
xTimeToWake
;

1636 
	`configASSERT
( 
pxEventList
 );

1644 
	`vListInsert
( ( 
xList
 * ) 
pxEventList
, ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xEventListItem
 ) );

1649 
	`vListRemove
( ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xGenericListItem
 ) );

1652 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

1654 if( 
xTicksToWait
 == 
portMAX_DELAY
 )

1659 
	`vListInsertEnd
( ( 
xList
 * ) &
xSuspendedTaskList
, ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xGenericListItem
 ) );

1665 
xTimeToWake
 = 
xTickCount
 + 
xTicksToWait
;

1666 
	`prvAddCurrentTaskToDelayedList
( 
xTimeToWake
 );

1673 
xTimeToWake
 = 
xTickCount
 + 
xTicksToWait
;

1674 
	`prvAddCurrentTaskToDelayedList
( 
xTimeToWake
 );

1677 
	}
}

1680 #if 
configUSE_TIMERS
 == 1

1682 void 
	$vTaskPlaceOnEventListRestricted
( const 
xList
 * const 
pxEventList
, 
portTickType
 
xTicksToWait
 )

1684 
portTickType
 
xTimeToWake
;

1686 
	`configASSERT
( 
pxEventList
 );

1698 
	`vListInsertEnd
( ( 
xList
 * ) 
pxEventList
, ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xEventListItem
 ) );

1703 
	`vListRemove
( ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xGenericListItem
 ) );

1707 
xTimeToWake
 = 
xTickCount
 + 
xTicksToWait
;

1708 
	`prvAddCurrentTaskToDelayedList
( 
xTimeToWake
 );

1709 
	}
}

1714 signed 
portBASE_TYPE
 
	$xTaskRemoveFromEventList
( const 
xList
 * const 
pxEventList
 )

1716 
tskTCB
 *
pxUnblockedTCB
;

1717 
portBASE_TYPE
 
xReturn
;

1732 
pxUnblockedTCB
 = ( 
tskTCB
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( 
pxEventList
 );

1733 
	`configASSERT
( 
pxUnblockedTCB
 );

1734 
	`vListRemove
( &( 
pxUnblockedTCB
->
xEventListItem
 ) );

1736 if( 
uxSchedulerSuspended
 == ( unsigned 
portBASE_TYPE
 ) 
pdFALSE
 )

1738 
	`vListRemove
( &( 
pxUnblockedTCB
->
xGenericListItem
 ) );

1739 
	`prvAddTaskToReadyQueue
( 
pxUnblockedTCB
 );

1745 
	`vListInsertEnd
( ( 
xList
 * ) &( 
xPendingReadyList
 ), &( 
pxUnblockedTCB
->
xEventListItem
 ) );

1748 if( 
pxUnblockedTCB
->
uxPriority
 >= 
pxCurrentTCB
->uxPriority )

1754 
xReturn
 = 
pdTRUE
;

1758 
xReturn
 = 
pdFALSE
;

1761 return 
xReturn
;

1762 
	}
}

1765 void 
	$vTaskSetTimeOutState
( 
xTimeOutType
 * const 
pxTimeOut
 )

1767 
	`configASSERT
( 
pxTimeOut
 );

1768 
pxTimeOut
->
xOverflowCount
 = 
xNumOfOverflows
;

1769 
pxTimeOut
->
xTimeOnEntering
 = 
xTickCount
;

1770 
	}
}

1773 
portBASE_TYPE
 
	$xTaskCheckForTimeOut
( 
xTimeOutType
 * const 
pxTimeOut
, 
portTickType
 * const 
pxTicksToWait
 )

1775 
portBASE_TYPE
 
xReturn
;

1777 
	`configASSERT
( 
pxTimeOut
 );

1778 
	`configASSERT
( 
pxTicksToWait
 );

1780 
	`taskENTER_CRITICAL
();

1782 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

1786 if( *
pxTicksToWait
 == 
portMAX_DELAY
 )

1788 
xReturn
 = 
pdFALSE
;

1793 if( ( 
xNumOfOverflows
 != 
pxTimeOut
->
xOverflowCount
 ) && ( ( 
portTickType
 ) 
xTickCount
 >= ( portTickType ) pxTimeOut->
xTimeOnEntering
 ) )

1799 
xReturn
 = 
pdTRUE
;

1801 else if( ( ( 
portTickType
 ) ( ( portTickType ) 
xTickCount
 - ( portTickType ) 
pxTimeOut
->
xTimeOnEntering
 ) ) < ( portTickType ) *
pxTicksToWait
 )

1804 *
pxTicksToWait
 -= ( ( 
portTickType
 ) 
xTickCount
 - ( portTickType ) 
pxTimeOut
->
xTimeOnEntering
 );

1805 
	`vTaskSetTimeOutState
( 
pxTimeOut
 );

1806 
xReturn
 = 
pdFALSE
;

1810 
xReturn
 = 
pdTRUE
;

1813 
	`taskEXIT_CRITICAL
();

1815 return 
xReturn
;

1816 
	}
}

1819 void 
	$vTaskMissedYield
( void )

1821 
xMissedYield
 = 
pdTRUE
;

1822 
	}
}

1825 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

1826 unsigned 
portBASE_TYPE
 
	$uxTaskGetTaskNumber
( 
xTaskHandle
 
xTask
 )

1828 unsigned 
portBASE_TYPE
 
uxReturn
;

1829 
tskTCB
 *
pxTCB
;

1831 if( 
xTask
 != 
NULL
 )

1833 
pxTCB
 = ( 
tskTCB
 * ) 
xTask
;

1834 
uxReturn
 = 
pxTCB
->
uxTaskNumber
;

1838 
uxReturn
 = 0U;

1841 return 
uxReturn
;

1842 
	}
}

1846 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

1847 void 
	$vTaskSetTaskNumber
( 
xTaskHandle
 
xTask
, unsigned 
portBASE_TYPE
 
uxHandle
 )

1849 
tskTCB
 *
pxTCB
;

1851 if( 
xTask
 != 
NULL
 )

1853 
pxTCB
 = ( 
tskTCB
 * ) 
xTask
;

1854 
pxTCB
->
uxTaskNumber
 = 
uxHandle
;

1856 
	}
}

1871 static 
	$portTASK_FUNCTION
( 
prvIdleTask
, 
pvParameters
 )

1874 ( void ) 
pvParameters
;

1879 
	`prvCheckTasksWaitingTermination
();

1881 #if ( 
configUSE_PREEMPTION
 == 0 )

1887 
	`taskYIELD
();

1891 #if ( ( 
configUSE_PREEMPTION
 == 1 ) && ( 
configIDLE_SHOULD_YIELD
 == 1 ) )

1902 if( 
	`listCURRENT_LIST_LENGTH
( &( 
pxReadyTasksLists
[ 
tskIDLE_PRIORITY
 ] ) ) > ( unsigned 
portBASE_TYPE
 ) 1 )

1904 
	`taskYIELD
();

1909 #if ( 
configUSE_IDLE_HOOK
 == 1 )

1911 extern void 
	`vApplicationIdleHook
( void );

1918 
	`vApplicationIdleHook
();

1922 
	}
}

1936 static void 
	$prvInitialiseTCBVariables
( 
tskTCB
 *
pxTCB
, const signed char * const 
pcName
, unsigned 
portBASE_TYPE
 
uxPriority
, const 
xMemoryRegion
 * const 
xRegions
, unsigned short 
usStackDepth
 )

1939 #if 
configMAX_TASK_NAME_LEN
 > 1

1942 
	`strncpy
( ( char * ) 
pxTCB
->
pcTaskName
, ( const char * ) 
pcName
, ( unsigned short ) 
configMAX_TASK_NAME_LEN
 );

1945 
pxTCB
->
pcTaskName
[ ( unsigned short ) 
configMAX_TASK_NAME_LEN
 - ( unsigned short ) 1 ] = ( signed char ) '\0';

1949 if( 
uxPriority
 >= 
configMAX_PRIORITIES
 )

1951 
uxPriority
 = 
configMAX_PRIORITIES
 - ( unsigned 
portBASE_TYPE
 ) 1U;

1954 
pxTCB
->
uxPriority
 = uxPriority;

1955 #if ( 
configUSE_MUTEXES
 == 1 )

1957 
pxTCB
->
uxBasePriority
 = 
uxPriority
;

1961 
	`vListInitialiseItem
( &( 
pxTCB
->
xGenericListItem
 ) );

1962 
	`vListInitialiseItem
( &( 
pxTCB
->
xEventListItem
 ) );

1966 
	`listSET_LIST_ITEM_OWNER
( &( 
pxTCB
->
xGenericListItem
 ), pxTCB );

1969 
	`listSET_LIST_ITEM_VALUE
( &( 
pxTCB
->
xEventListItem
 ), 
configMAX_PRIORITIES
 - ( 
portTickType
 ) 
uxPriority
 );

1970 
	`listSET_LIST_ITEM_OWNER
( &( 
pxTCB
->
xEventListItem
 ), pxTCB );

1972 #if ( 
portCRITICAL_NESTING_IN_TCB
 == 1 )

1974 
pxTCB
->
uxCriticalNesting
 = ( unsigned 
portBASE_TYPE
 ) 0U;

1978 #if ( 
configUSE_APPLICATION_TASK_TAG
 == 1 )

1980 
pxTCB
->
pxTaskTag
 = 
NULL
;

1984 #if ( 
configGENERATE_RUN_TIME_STATS
 == 1 )

1986 
pxTCB
->
ulRunTimeCounter
 = 0UL;

1990 #if ( 
portUSING_MPU_WRAPPERS
 == 1 )

1992 
	`vPortStoreTaskMPUSettings
( &( 
pxTCB
->
xMPUSettings
 ), 
xRegions
, pxTCB->
pxStack
, 
usStackDepth
 );

1996 ( void ) 
xRegions
;

1997 ( void ) 
usStackDepth
;

2000 
	}
}

2003 #if ( 
portUSING_MPU_WRAPPERS
 == 1 )

2005 void 
	$vTaskAllocateMPURegions
( 
xTaskHandle
 
xTaskToModify
, const 
xMemoryRegion
 * const 
xRegions
 )

2007 
tskTCB
 *
pxTCB
;

2009 if( 
xTaskToModify
 == 
pxCurrentTCB
 )

2011 
xTaskToModify
 = 
NULL
;

2015 
pxTCB
 = 
	`prvGetTCBFromHandle
( 
xTaskToModify
 );

2017 
	`vPortStoreTaskMPUSettings
( &( 
pxTCB
->
xMPUSettings
 ), 
xRegions
, 
NULL
, 0 );

2018 
	}
}

2022 static void 
	$prvInitialiseTaskLists
( void )

2024 unsigned 
portBASE_TYPE
 
uxPriority
;

2026 for( 
uxPriority
 = ( unsigned 
portBASE_TYPE
 ) 0U; uxPriority < 
configMAX_PRIORITIES
; uxPriority++ )

2028 
	`vListInitialise
( ( 
xList
 * ) &( 
pxReadyTasksLists
[ 
uxPriority
 ] ) );

2031 
	`vListInitialise
( ( 
xList
 * ) &
xDelayedTaskList1
 );

2032 
	`vListInitialise
( ( 
xList
 * ) &
xDelayedTaskList2
 );

2033 
	`vListInitialise
( ( 
xList
 * ) &
xPendingReadyList
 );

2035 #if ( 
INCLUDE_vTaskDelete
 == 1 )

2037 
	`vListInitialise
( ( 
xList
 * ) &
xTasksWaitingTermination
 );

2041 #if ( 
INCLUDE_vTaskSuspend
 == 1 )

2043 
	`vListInitialise
( ( 
xList
 * ) &
xSuspendedTaskList
 );

2049 
pxDelayedTaskList
 = &
xDelayedTaskList1
;

2050 
pxOverflowDelayedTaskList
 = &
xDelayedTaskList2
;

2051 
	}
}

2054 static void 
	$prvCheckTasksWaitingTermination
( void )

2056 #if ( 
INCLUDE_vTaskDelete
 == 1 )

2058 
portBASE_TYPE
 
xListIsEmpty
;

2062 if( 
uxTasksDeleted
 > ( unsigned 
portBASE_TYPE
 ) 0U )

2064 
	`vTaskSuspendAll
();

2065 
xListIsEmpty
 = 
	`listLIST_IS_EMPTY
( &
xTasksWaitingTermination
 );

2066 
	`xTaskResumeAll
();

2068 if( 
xListIsEmpty
 == 
pdFALSE
 )

2070 
tskTCB
 *
pxTCB
;

2072 
	`taskENTER_CRITICAL
();

2074 
pxTCB
 = ( 
tskTCB
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( ( ( 
xList
 * ) &
xTasksWaitingTermination
 ) );

2075 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

2076 --
uxCurrentNumberOfTasks
;

2077 --
uxTasksDeleted
;

2079 
	`taskEXIT_CRITICAL
();

2081 
	`prvDeleteTCB
( 
pxTCB
 );

2086 
	}
}

2089 static void 
	$prvAddCurrentTaskToDelayedList
( 
portTickType
 
xTimeToWake
 )

2092 
	`listSET_LIST_ITEM_VALUE
( &( 
pxCurrentTCB
->
xGenericListItem
 ), 
xTimeToWake
 );

2094 if( 
xTimeToWake
 < 
xTickCount
 )

2097 
	`vListInsert
( ( 
xList
 * ) 
pxOverflowDelayedTaskList
, ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xGenericListItem
 ) );

2102 
	`vListInsert
( ( 
xList
 * ) 
pxDelayedTaskList
, ( 
xListItem
 * ) &( 
pxCurrentTCB
->
xGenericListItem
 ) );

2107 if( 
xTimeToWake
 < 
xNextTaskUnblockTime
 )

2109 
xNextTaskUnblockTime
 = 
xTimeToWake
;

2112 
	}
}

2115 static 
tskTCB
 *
	$prvAllocateTCBAndStack
( unsigned short 
usStackDepth
, 
portSTACK_TYPE
 *
puxStackBuffer
 )

2117 
tskTCB
 *
pxNewTCB
;

2121 
pxNewTCB
 = ( 
tskTCB
 * ) 
	`pvPortMalloc
( sizeof( tskTCB ) );

2123 if( 
pxNewTCB
 != 
NULL
 )

2128 
pxNewTCB
->
pxStack
 = ( 
portSTACK_TYPE
 * ) 
	`pvPortMallocAligned
( ( ( ( 
size_t
 )
usStackDepth
 ) * sizeof( portSTACK_TYPE ) ), 
puxStackBuffer
 );

2130 if( 
pxNewTCB
->
pxStack
 == 
NULL
 )

2133 
	`vPortFree
( 
pxNewTCB
 );

2134 
pxNewTCB
 = 
NULL
;

2139 
	`memset
( 
pxNewTCB
->
pxStack
, ( int ) 
tskSTACK_FILL_BYTE
, ( 
size_t
 ) 
usStackDepth
 * sizeof( 
portSTACK_TYPE
 ) );

2143 return 
pxNewTCB
;

2144 
	}
}

2147 #if ( 
configUSE_TRACE_FACILITY
 == 1 )

2149 static void 
	$prvListTaskWithinSingleList
( const signed char *
pcWriteBuffer
, 
xList
 *
pxList
, signed char 
cStatus
 )

2151 volatile 
tskTCB
 *
pxNextTCB
, *
pxFirstTCB
;

2152 unsigned short 
usStackRemaining
;

2153 
PRIVILEGED_DATA
 static char 
pcStatusString
[ 50 ];

2156 
	`listGET_OWNER_OF_NEXT_ENTRY
( 
pxFirstTCB
, 
pxList
 );

2159 
	`listGET_OWNER_OF_NEXT_ENTRY
( 
pxNextTCB
, 
pxList
 );

2160 #if ( 
portSTACK_GROWTH
 > 0 )

2162 
usStackRemaining
 = 
	`usTaskCheckFreeStackSpace
( ( unsigned char * ) 
pxNextTCB
->
pxEndOfStack
 );

2166 
usStackRemaining
 = 
	`usTaskCheckFreeStackSpace
( ( unsigned char * ) 
pxNextTCB
->
pxStack
 );

2170 
	`sprintf
( 
pcStatusString
, ( char * ) "%s\t\t%c\t%u\t%u\t%u\r\n", 
pxNextTCB
->
pcTaskName
, 
cStatus
, ( unsigned int ) pxNextTCB->
uxPriority
, 
usStackRemaining
, ( unsigned int ) pxNextTCB->
uxTCBNumber
 );

2171 
	`strcat
( ( char * ) 
pcWriteBuffer
, ( char * ) 
pcStatusString
 );

2173 } while( 
pxNextTCB
 != 
pxFirstTCB
 );

2174 
	}
}

2179 #if ( 
configGENERATE_RUN_TIME_STATS
 == 1 )

2181 static void 
	$prvGenerateRunTimeStatsForTasksInList
( const signed char *
pcWriteBuffer
, 
xList
 *
pxList
, unsigned long 
ulTotalRunTime
 )

2183 volatile 
tskTCB
 *
pxNextTCB
, *
pxFirstTCB
;

2184 unsigned long 
ulStatsAsPercentage
;

2187 
	`listGET_OWNER_OF_NEXT_ENTRY
( 
pxFirstTCB
, 
pxList
 );

2191 
	`listGET_OWNER_OF_NEXT_ENTRY
( 
pxNextTCB
, 
pxList
 );

2194 if( 
ulTotalRunTime
 > 0UL )

2197 if( 
pxNextTCB
->
ulRunTimeCounter
 == 0UL )

2200 
	`sprintf
( 
pcStatsString
, ( char * ) "%s\t\t0\t\t0%%\r\n", 
pxNextTCB
->
pcTaskName
 );

2207 
ulStatsAsPercentage
 = 
pxNextTCB
->
ulRunTimeCounter
 / 
ulTotalRunTime
;

2209 if( 
ulStatsAsPercentage
 > 0UL )

2211 #ifdef 
portLU_PRINTF_SPECIFIER_REQUIRED


2213 
	`sprintf
( 
pcStatsString
, ( char * ) "%s\t\t%lu\t\t%lu%%\r\n", 
pxNextTCB
->
pcTaskName
, pxNextTCB->
ulRunTimeCounter
, 
ulStatsAsPercentage
 );

2219 
	`sprintf
( 
pcStatsString
, ( char * ) "%s\t\t%u\t\t%u%%\r\n", 
pxNextTCB
->
pcTaskName
, ( unsigned int ) pxNextTCB->
ulRunTimeCounter
, ( unsigned int ) 
ulStatsAsPercentage
 );

2227 #ifdef 
portLU_PRINTF_SPECIFIER_REQUIRED


2229 
	`sprintf
( 
pcStatsString
, ( char * ) "%s\t\t%lu\t\t<1%%\r\n", 
pxNextTCB
->
pcTaskName
, pxNextTCB->
ulRunTimeCounter
 );

2235 
	`sprintf
( 
pcStatsString
, ( char * ) "%s\t\t%u\t\t<1%%\r\n", 
pxNextTCB
->
pcTaskName
, ( unsigned int ) pxNextTCB->
ulRunTimeCounter
 );

2241 
	`strcat
( ( char * ) 
pcWriteBuffer
, ( char * ) 
pcStatsString
 );

2244 } while( 
pxNextTCB
 != 
pxFirstTCB
 );

2245 
	}
}

2250 #if ( ( 
configUSE_TRACE_FACILITY
 == 1 ) || ( 
INCLUDE_uxTaskGetStackHighWaterMark
 == 1 ) )

2252 static unsigned short 
	$usTaskCheckFreeStackSpace
( const unsigned char * 
pucStackByte
 )

2254 register unsigned short 
usCount
 = 0U;

2256 while( *
pucStackByte
 == 
tskSTACK_FILL_BYTE
 )

2258 
pucStackByte
 -= 
portSTACK_GROWTH
;

2259 
usCount
++;

2262 
usCount
 /= sizeof( 
portSTACK_TYPE
 );

2264 return 
usCount
;

2265 
	}
}

2270 #if ( 
INCLUDE_uxTaskGetStackHighWaterMark
 == 1 )

2272 unsigned 
portBASE_TYPE
 
	$uxTaskGetStackHighWaterMark
( 
xTaskHandle
 
xTask
 )

2274 
tskTCB
 *
pxTCB
;

2275 unsigned char *
pcEndOfStack
;

2276 unsigned 
portBASE_TYPE
 
uxReturn
;

2278 
pxTCB
 = 
	`prvGetTCBFromHandle
( 
xTask
 );

2280 #if 
portSTACK_GROWTH
 < 0

2282 
pcEndOfStack
 = ( unsigned char * ) 
pxTCB
->
pxStack
;

2286 
pcEndOfStack
 = ( unsigned char * ) 
pxTCB
->
pxEndOfStack
;

2290 
uxReturn
 = ( unsigned 
portBASE_TYPE
 ) 
	`usTaskCheckFreeStackSpace
( 
pcEndOfStack
 );

2292 return 
uxReturn
;

2293 
	}
}

2298 #if ( 
INCLUDE_vTaskDelete
 == 1 )

2300 static void 
	$prvDeleteTCB
( 
tskTCB
 *
pxTCB
 )

2304 
	`portCLEAN_UP_TCB
( 
pxTCB
 );

2308 
	`vPortFreeAligned
( 
pxTCB
->
pxStack
 );

2309 
	`vPortFree
( 
pxTCB
 );

2310 
	}
}

2317 #if ( ( 
INCLUDE_xTaskGetCurrentTaskHandle
 == 1 ) || ( 
configUSE_MUTEXES
 == 1 ) )

2319 
xTaskHandle
 
	$xTaskGetCurrentTaskHandle
( void )

2321 
xTaskHandle
 
xReturn
;

2326 
xReturn
 = 
pxCurrentTCB
;

2328 return 
xReturn
;

2329 
	}
}

2335 #if ( ( 
INCLUDE_xTaskGetSchedulerState
 == 1 ) || ( 
configUSE_TIMERS
 == 1 ) )

2337 
portBASE_TYPE
 
	$xTaskGetSchedulerState
( void )

2339 
portBASE_TYPE
 
xReturn
;

2341 if( 
xSchedulerRunning
 == 
pdFALSE
 )

2343 
xReturn
 = 
taskSCHEDULER_NOT_STARTED
;

2347 if( 
uxSchedulerSuspended
 == ( unsigned 
portBASE_TYPE
 ) 
pdFALSE
 )

2349 
xReturn
 = 
taskSCHEDULER_RUNNING
;

2353 
xReturn
 = 
taskSCHEDULER_SUSPENDED
;

2357 return 
xReturn
;

2358 
	}
}

2363 #if ( 
configUSE_MUTEXES
 == 1 )

2365 void 
	$vTaskPriorityInherit
( 
xTaskHandle
 * const 
pxMutexHolder
 )

2367 
tskTCB
 * const 
pxTCB
 = ( tskTCB * ) 
pxMutexHolder
;

2369 
	`configASSERT
( 
pxMutexHolder
 );

2371 if( 
pxTCB
->
uxPriority
 < 
pxCurrentTCB
->uxPriority )

2374 
	`listSET_LIST_ITEM_VALUE
( &( 
pxTCB
->
xEventListItem
 ), 
configMAX_PRIORITIES
 - ( 
portTickType
 ) 
pxCurrentTCB
->
uxPriority
 );

2378 if( 
	`listIS_CONTAINED_WITHIN
( &( 
pxReadyTasksLists
[ 
pxTCB
->
uxPriority
 ] ), &( pxTCB->
xGenericListItem
 ) ) != 
pdFALSE
 )

2380 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

2383 
pxTCB
->
uxPriority
 = 
pxCurrentTCB
->uxPriority;

2384 
	`prvAddTaskToReadyQueue
( 
pxTCB
 );

2389 
pxTCB
->
uxPriority
 = 
pxCurrentTCB
->uxPriority;

2392 
	`traceTASK_PRIORITY_INHERIT
( 
pxTCB
, 
pxCurrentTCB
->
uxPriority
 );

2394 
	}
}

2399 #if ( 
configUSE_MUTEXES
 == 1 )

2401 void 
	$vTaskPriorityDisinherit
( 
xTaskHandle
 * const 
pxMutexHolder
 )

2403 
tskTCB
 * const 
pxTCB
 = ( tskTCB * ) 
pxMutexHolder
;

2405 if( 
pxMutexHolder
 != 
NULL
 )

2407 if( 
pxTCB
->
uxPriority
 != pxTCB->
uxBasePriority
 )

2411 
	`vListRemove
( &( 
pxTCB
->
xGenericListItem
 ) );

2415 
	`traceTASK_PRIORITY_DISINHERIT
( 
pxTCB
, pxTCB->
uxBasePriority
 );

2416 
pxTCB
->
uxPriority
 = pxTCB->
uxBasePriority
;

2417 
	`listSET_LIST_ITEM_VALUE
( &( 
pxTCB
->
xEventListItem
 ), 
configMAX_PRIORITIES
 - ( 
portTickType
 ) pxTCB->
uxPriority
 );

2418 
	`prvAddTaskToReadyQueue
( 
pxTCB
 );

2421 
	}
}

2426 #if ( 
portCRITICAL_NESTING_IN_TCB
 == 1 )

2428 void 
	$vTaskEnterCritical
( void )

2430 
	`portDISABLE_INTERRUPTS
();

2432 if( 
xSchedulerRunning
 != 
pdFALSE
 )

2434 ( 
pxCurrentTCB
->
uxCriticalNesting
 )++;

2436 
	}
}

2441 #if ( 
portCRITICAL_NESTING_IN_TCB
 == 1 )

2443 void 
	$vTaskExitCritical
( void )

2445 if( 
xSchedulerRunning
 != 
pdFALSE
 )

2447 if( 
pxCurrentTCB
->
uxCriticalNesting
 > 0U )

2449 ( 
pxCurrentTCB
->
uxCriticalNesting
 )--;

2451 if( 
pxCurrentTCB
->
uxCriticalNesting
 == 0U )

2453 
	`portENABLE_INTERRUPTS
();

2457 
	}
}

	@FreeRTOS/timers.c

57 #define 
	#MPU_WRAPPERS_INCLUDED_FROM_API_FILE


	)

59 #include 
	~"FreeRTOS.h
"

60 #include 
	~"task.h
"

61 #include 
	~"queue.h
"

62 #include 
	~"timers.h
"

64 #undef 
MPU_WRAPPERS_INCLUDED_FROM_API_FILE


70 #if ( 
configUSE_TIMERS
 == 1 )

73 #define 
	#tmrNO_DELAY
 ( 
portTickType
 ) 0U

	)

76 typedef struct 
	stmrTimerControl


78 const signed char *
	mpcTimerName
;

79 
xListItem
 
	mxTimerListItem
;

80 
portTickType
 
	mxTimerPeriodInTicks
;

81 unsigned 
portBASE_TYPE
 
	muxAutoReload
;

82 void *
	mpvTimerID
;

83 
tmrTIMER_CALLBACK
 
	mpxCallbackFunction
;

84 } 
	txTIMER
;

88 typedef struct 
	stmrTimerQueueMessage


90 
portBASE_TYPE
 
	mxMessageID
;

91 
portTickType
 
	mxMessageValue
;

92 
xTIMER
 * 
	mpxTimer
;

93 } 
	txTIMER_MESSAGE
;

99 
PRIVILEGED_DATA
 static 
xList
 
	gxActiveTimerList1
;

100 
PRIVILEGED_DATA
 static 
xList
 
	gxActiveTimerList2
;

101 
PRIVILEGED_DATA
 static 
xList
 *
	gpxCurrentTimerList
;

102 
PRIVILEGED_DATA
 static 
xList
 *
	gpxOverflowTimerList
;

105 
PRIVILEGED_DATA
 static 
xQueueHandle
 
	gxTimerQueue
 = 
NULL
;

107 #if ( 
INCLUDE_xTimerGetTimerDaemonTaskHandle
 == 1 )

109 
PRIVILEGED_DATA
 static 
xTaskHandle
 
	gxTimerTaskHandle
 = 
NULL
;

119 static void 
	$prvCheckForValidListAndQueue
( void ) 
PRIVILEGED_FUNCTION
;

126 static void 
	$prvTimerTask
( void *
pvParameters
 ) 
PRIVILEGED_FUNCTION
;

132 static void 
	$prvProcessReceivedCommands
( void ) 
PRIVILEGED_FUNCTION
;

138 static 
portBASE_TYPE
 
	$prvInsertTimerInActiveList
( 
xTIMER
 *
pxTimer
, 
portTickType
 
xNextExpiryTime
, portTickType 
xTimeNow
, portTickType 
xCommandTime
 ) 
PRIVILEGED_FUNCTION
;

144 static void 
	$prvProcessExpiredTimer
( 
portTickType
 
xNextExpireTime
, portTickType 
xTimeNow
 ) 
PRIVILEGED_FUNCTION
;

150 static void 
	$prvSwitchTimerLists
( 
portTickType
 
xLastTime
 ) 
PRIVILEGED_FUNCTION
;

156 static 
portTickType
 
	$prvSampleTimeNow
( 
portBASE_TYPE
 *
pxTimerListsWereSwitched
 ) 
PRIVILEGED_FUNCTION
;

164 static 
portTickType
 
	$prvGetNextExpireTime
( 
portBASE_TYPE
 *
pxListWasEmpty
 ) 
PRIVILEGED_FUNCTION
;

170 static void 
	$prvProcessTimerOrBlockTask
( 
portTickType
 
xNextExpireTime
, 
portBASE_TYPE
 
xListWasEmpty
 ) 
PRIVILEGED_FUNCTION
;

174 
portBASE_TYPE
 
	$xTimerCreateTimerTask
( void )

176 
portBASE_TYPE
 
xReturn
 = 
pdFAIL
;

182 
	`prvCheckForValidListAndQueue
();

184 if( 
xTimerQueue
 != 
NULL
 )

186 #if ( 
INCLUDE_xTimerGetTimerDaemonTaskHandle
 == 1 )

190 
xReturn
 = 
	`xTaskCreate
( 
prvTimerTask
, ( const signed char * ) "Tmr Svc", ( unsigned short ) 
configTIMER_TASK_STACK_DEPTH
, 
NULL
, ( unsigned 
portBASE_TYPE
 ) 
configTIMER_TASK_PRIORITY
, &
xTimerTaskHandle
 );

195 
xReturn
 = 
	`xTaskCreate
( 
prvTimerTask
, ( const signed char * ) "Tmr Svc", ( unsigned short ) 
configTIMER_TASK_STACK_DEPTH
, 
NULL
, ( unsigned 
portBASE_TYPE
 ) 
configTIMER_TASK_PRIORITY
, NULL);

200 
	`configASSERT
( 
xReturn
 );

201 return 
xReturn
;

202 
	}
}

205 
xTimerHandle
 
	$xTimerCreate
( const signed char *
pcTimerName
, 
portTickType
 
xTimerPeriodInTicks
, unsigned 
portBASE_TYPE
 
uxAutoReload
, void *
pvTimerID
, 
tmrTIMER_CALLBACK
 
pxCallbackFunction
 )

207 
xTIMER
 *
pxNewTimer
;

210 if( 
xTimerPeriodInTicks
 == ( 
portTickType
 ) 0U )

212 
pxNewTimer
 = 
NULL
;

213 
	`configASSERT
( ( 
xTimerPeriodInTicks
 > 0 ) );

217 
pxNewTimer
 = ( 
xTIMER
 * ) 
	`pvPortMalloc
( sizeof( xTIMER ) );

218 if( 
pxNewTimer
 != 
NULL
 )

222 
	`prvCheckForValidListAndQueue
();

225 
pxNewTimer
->
pcTimerName
 = pcTimerName;

226 
pxNewTimer
->
xTimerPeriodInTicks
 = xTimerPeriodInTicks;

227 
pxNewTimer
->
uxAutoReload
 = uxAutoReload;

228 
pxNewTimer
->
pvTimerID
 = pvTimerID;

229 
pxNewTimer
->
pxCallbackFunction
 = pxCallbackFunction;

230 
	`vListInitialiseItem
( &( 
pxNewTimer
->
xTimerListItem
 ) );

232 
	`traceTIMER_CREATE
( 
pxNewTimer
 );

236 
	`traceTIMER_CREATE_FAILED
();

240 return ( 
xTimerHandle
 ) 
pxNewTimer
;

241 
	}
}

244 
portBASE_TYPE
 
	$xTimerGenericCommand
( 
xTimerHandle
 
xTimer
, 
portBASE_TYPE
 
xCommandID
, 
portTickType
 
xOptionalValue
, signed portBASE_TYPE *
pxHigherPriorityTaskWoken
, portTickType 
xBlockTime
 )

246 
portBASE_TYPE
 
xReturn
 = 
pdFAIL
;

247 
xTIMER_MESSAGE
 
xMessage
;

251 if( 
xTimerQueue
 != 
NULL
 )

254 
xMessage
.
xMessageID
 = 
xCommandID
;

255 
xMessage
.
xMessageValue
 = 
xOptionalValue
;

256 
xMessage
.
pxTimer
 = ( 
xTIMER
 * ) 
xTimer
;

258 if( 
pxHigherPriorityTaskWoken
 == 
NULL
 )

260 if( 
	`xTaskGetSchedulerState
() == 
taskSCHEDULER_RUNNING
 )

262 
xReturn
 = 
	`xQueueSendToBack
( 
xTimerQueue
, &
xMessage
, 
xBlockTime
 );

266 
xReturn
 = 
	`xQueueSendToBack
( 
xTimerQueue
, &
xMessage
, 
tmrNO_DELAY
 );

271 
xReturn
 = 
	`xQueueSendToBackFromISR
( 
xTimerQueue
, &
xMessage
, 
pxHigherPriorityTaskWoken
 );

274 
	`traceTIMER_COMMAND_SEND
( 
xTimer
, 
xCommandID
, 
xOptionalValue
, 
xReturn
 );

277 return 
xReturn
;

278 
	}
}

281 #if ( 
INCLUDE_xTimerGetTimerDaemonTaskHandle
 == 1 )

283 
xTaskHandle
 
	$xTimerGetTimerDaemonTaskHandle
( void )

287 
	`configASSERT
( ( 
xTimerTaskHandle
 != 
NULL
 ) );

288 return 
xTimerTaskHandle
;

289 
	}
}

294 static void 
	$prvProcessExpiredTimer
( 
portTickType
 
xNextExpireTime
, portTickType 
xTimeNow
 )

296 
xTIMER
 *
pxTimer
;

297 
portBASE_TYPE
 
xResult
;

301 
pxTimer
 = ( 
xTIMER
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( 
pxCurrentTimerList
 );

302 
	`vListRemove
( &( 
pxTimer
->
xTimerListItem
 ) );

303 
	`traceTIMER_EXPIRED
( 
pxTimer
 );

307 if( 
pxTimer
->
uxAutoReload
 == ( unsigned 
portBASE_TYPE
 ) 
pdTRUE
 )

315 if( 
	`prvInsertTimerInActiveList
( 
pxTimer
, ( 
xNextExpireTime
 + pxTimer->
xTimerPeriodInTicks
 ), 
xTimeNow
, xNextExpireTime ) == 
pdTRUE
 )

319 
xResult
 = 
	`xTimerGenericCommand
( 
pxTimer
, 
tmrCOMMAND_START
, 
xNextExpireTime
, 
NULL
, 
tmrNO_DELAY
 );

320 
	`configASSERT
( 
xResult
 );

321 ( void ) 
xResult
;

326 
pxTimer
->
	`pxCallbackFunction
( ( 
xTimerHandle
 ) pxTimer );

327 
	}
}

330 static void 
	$prvTimerTask
( void *
pvParameters
 )

332 
portTickType
 
xNextExpireTime
;

333 
portBASE_TYPE
 
xListWasEmpty
;

336 ( void ) 
pvParameters
;

342 
xNextExpireTime
 = 
	`prvGetNextExpireTime
( &
xListWasEmpty
 );

346 
	`prvProcessTimerOrBlockTask
( 
xNextExpireTime
, 
xListWasEmpty
 );

349 
	`prvProcessReceivedCommands
();

351 
	}
}

354 static void 
	$prvProcessTimerOrBlockTask
( 
portTickType
 
xNextExpireTime
, 
portBASE_TYPE
 
xListWasEmpty
 )

356 
portTickType
 
xTimeNow
;

357 
portBASE_TYPE
 
xTimerListsWereSwitched
;

359 
	`vTaskSuspendAll
();

366 
xTimeNow
 = 
	`prvSampleTimeNow
( &
xTimerListsWereSwitched
 );

367 if( 
xTimerListsWereSwitched
 == 
pdFALSE
 )

370 if( ( 
xListWasEmpty
 == 
pdFALSE
 ) && ( 
xNextExpireTime
 <= 
xTimeNow
 ) )

372 
	`xTaskResumeAll
();

373 
	`prvProcessExpiredTimer
( 
xNextExpireTime
, 
xTimeNow
 );

383 
	`vQueueWaitForMessageRestricted
( 
xTimerQueue
, ( 
xNextExpireTime
 - 
xTimeNow
 ) );

385 if( 
	`xTaskResumeAll
() == 
pdFALSE
 )

391 
	`portYIELD_WITHIN_API
();

397 
	`xTaskResumeAll
();

400 
	}
}

403 static 
portTickType
 
	$prvGetNextExpireTime
( 
portBASE_TYPE
 *
pxListWasEmpty
 )

405 
portTickType
 
xNextExpireTime
;

414 *
pxListWasEmpty
 = 
	`listLIST_IS_EMPTY
( 
pxCurrentTimerList
 );

415 if( *
pxListWasEmpty
 == 
pdFALSE
 )

417 
xNextExpireTime
 = 
	`listGET_ITEM_VALUE_OF_HEAD_ENTRY
( 
pxCurrentTimerList
 );

422 
xNextExpireTime
 = ( 
portTickType
 ) 0U;

425 return 
xNextExpireTime
;

426 
	}
}

429 static 
portTickType
 
	$prvSampleTimeNow
( 
portBASE_TYPE
 *
pxTimerListsWereSwitched
 )

431 
portTickType
 
xTimeNow
;

432 static 
portTickType
 
xLastTime
 = ( portTickType ) 0U;

434 
xTimeNow
 = 
	`xTaskGetTickCount
();

436 if( 
xTimeNow
 < 
xLastTime
 )

438 
	`prvSwitchTimerLists
( 
xLastTime
 );

439 *
pxTimerListsWereSwitched
 = 
pdTRUE
;

443 *
pxTimerListsWereSwitched
 = 
pdFALSE
;

446 
xLastTime
 = 
xTimeNow
;

448 return 
xTimeNow
;

449 
	}
}

452 static 
portBASE_TYPE
 
	$prvInsertTimerInActiveList
( 
xTIMER
 *
pxTimer
, 
portTickType
 
xNextExpiryTime
, portTickType 
xTimeNow
, portTickType 
xCommandTime
 )

454 
portBASE_TYPE
 
xProcessTimerNow
 = 
pdFALSE
;

456 
	`listSET_LIST_ITEM_VALUE
( &( 
pxTimer
->
xTimerListItem
 ), 
xNextExpiryTime
 );

457 
	`listSET_LIST_ITEM_OWNER
( &( 
pxTimer
->
xTimerListItem
 ), pxTimer );

459 if( 
xNextExpiryTime
 <= 
xTimeNow
 )

463 if( ( ( 
portTickType
 ) ( 
xTimeNow
 - 
xCommandTime
 ) ) >= 
pxTimer
->
xTimerPeriodInTicks
 )

467 
xProcessTimerNow
 = 
pdTRUE
;

471 
	`vListInsert
( 
pxOverflowTimerList
, &( 
pxTimer
->
xTimerListItem
 ) );

476 if( ( 
xTimeNow
 < 
xCommandTime
 ) && ( 
xNextExpiryTime
 >= xCommandTime ) )

481 
xProcessTimerNow
 = 
pdTRUE
;

485 
	`vListInsert
( 
pxCurrentTimerList
, &( 
pxTimer
->
xTimerListItem
 ) );

489 return 
xProcessTimerNow
;

490 
	}
}

493 static void 
	$prvProcessReceivedCommands
( void )

495 
xTIMER_MESSAGE
 
xMessage
;

496 
xTIMER
 *
pxTimer
;

497 
portBASE_TYPE
 
xTimerListsWereSwitched
, 
xResult
;

498 
portTickType
 
xTimeNow
;

502 
xTimeNow
 = 
	`prvSampleTimeNow
( &
xTimerListsWereSwitched
 );

504 while( 
	`xQueueReceive
( 
xTimerQueue
, &
xMessage
, 
tmrNO_DELAY
 ) != 
pdFAIL
 )

506 
pxTimer
 = 
xMessage
.pxTimer;

511 if( 
pxTimer
 != 
NULL
 )

513 if( 
	`listIS_CONTAINED_WITHIN
( 
NULL
, &( 
pxTimer
->
xTimerListItem
 ) ) == 
pdFALSE
 )

516 
	`vListRemove
( &( 
pxTimer
->
xTimerListItem
 ) );

520 
	`traceTIMER_COMMAND_RECEIVED
( 
pxTimer
, 
xMessage
.
xMessageID
, xMessage.
xMessageValue
 );

522 switch( 
xMessage
.
xMessageID
 )

524 case 
tmrCOMMAND_START
 :

526 if( 
	`prvInsertTimerInActiveList
( 
pxTimer
, 
xMessage
.
xMessageValue
 + pxTimer->
xTimerPeriodInTicks
, 
xTimeNow
, xMessage.xMessageValue ) == 
pdTRUE
 )

530 
pxTimer
->
	`pxCallbackFunction
( ( 
xTimerHandle
 ) pxTimer );

532 if( 
pxTimer
->
uxAutoReload
 == ( unsigned 
portBASE_TYPE
 ) 
pdTRUE
 )

534 
xResult
 = 
	`xTimerGenericCommand
( 
pxTimer
, 
tmrCOMMAND_START
, 
xMessage
.
xMessageValue
 + pxTimer->
xTimerPeriodInTicks
, 
NULL
, 
tmrNO_DELAY
 );

535 
	`configASSERT
( 
xResult
 );

536 ( void ) 
xResult
;

541 case 
tmrCOMMAND_STOP
 :

546 case 
tmrCOMMAND_CHANGE_PERIOD
 :

547 
pxTimer
->
xTimerPeriodInTicks
 = 
xMessage
.
xMessageValue
;

548 
	`configASSERT
( ( 
pxTimer
->
xTimerPeriodInTicks
 > 0 ) );

549 
	`prvInsertTimerInActiveList
( 
pxTimer
, ( 
xTimeNow
 + pxTimer->
xTimerPeriodInTicks
 ), xTimeNow, xTimeNow );

552 case 
tmrCOMMAND_DELETE
 :

555 
	`vPortFree
( 
pxTimer
 );

563 
	}
}

566 static void 
	$prvSwitchTimerLists
( 
portTickType
 
xLastTime
 )

568 
portTickType
 
xNextExpireTime
, 
xReloadTime
;

569 
xList
 *
pxTemp
;

570 
xTIMER
 *
pxTimer
;

571 
portBASE_TYPE
 
xResult
;

574 ( void ) 
xLastTime
;

580 while( 
	`listLIST_IS_EMPTY
( 
pxCurrentTimerList
 ) == 
pdFALSE
 )

582 
xNextExpireTime
 = 
	`listGET_ITEM_VALUE_OF_HEAD_ENTRY
( 
pxCurrentTimerList
 );

585 
pxTimer
 = ( 
xTIMER
 * ) 
	`listGET_OWNER_OF_HEAD_ENTRY
( 
pxCurrentTimerList
 );

586 
	`vListRemove
( &( 
pxTimer
->
xTimerListItem
 ) );

591 
pxTimer
->
	`pxCallbackFunction
( ( 
xTimerHandle
 ) pxTimer );

593 if( 
pxTimer
->
uxAutoReload
 == ( unsigned 
portBASE_TYPE
 ) 
pdTRUE
 )

601 
xReloadTime
 = ( 
xNextExpireTime
 + 
pxTimer
->
xTimerPeriodInTicks
 );

602 if( 
xReloadTime
 > 
xNextExpireTime
 )

604 
	`listSET_LIST_ITEM_VALUE
( &( 
pxTimer
->
xTimerListItem
 ), 
xReloadTime
 );

605 
	`listSET_LIST_ITEM_OWNER
( &( 
pxTimer
->
xTimerListItem
 ), pxTimer );

606 
	`vListInsert
( 
pxCurrentTimerList
, &( 
pxTimer
->
xTimerListItem
 ) );

610 
xResult
 = 
	`xTimerGenericCommand
( 
pxTimer
, 
tmrCOMMAND_START
, 
xNextExpireTime
, 
NULL
, 
tmrNO_DELAY
 );

611 
	`configASSERT
( 
xResult
 );

612 ( void ) 
xResult
;

617 
pxTemp
 = 
pxCurrentTimerList
;

618 
pxCurrentTimerList
 = 
pxOverflowTimerList
;

619 
pxOverflowTimerList
 = 
pxTemp
;

620 
	}
}

623 static void 
	$prvCheckForValidListAndQueue
( void )

628 
	`taskENTER_CRITICAL
();

630 if( 
xTimerQueue
 == 
NULL
 )

632 
	`vListInitialise
( &
xActiveTimerList1
 );

633 
	`vListInitialise
( &
xActiveTimerList2
 );

634 
pxCurrentTimerList
 = &
xActiveTimerList1
;

635 
pxOverflowTimerList
 = &
xActiveTimerList2
;

636 
xTimerQueue
 = 
	`xQueueCreate
( ( unsigned 
portBASE_TYPE
 ) 
configTIMER_QUEUE_LENGTH
, sizeof( 
xTIMER_MESSAGE
 ) );

639 
	`taskEXIT_CRITICAL
();

640 
	}
}

643 
portBASE_TYPE
 
	$xTimerIsTimerActive
( 
xTimerHandle
 
xTimer
 )

645 
portBASE_TYPE
 
xTimerIsInActiveList
;

646 
xTIMER
 *
pxTimer
 = ( xTIMER * ) 
xTimer
;

649 
	`taskENTER_CRITICAL
();

654 
xTimerIsInActiveList
 = !( 
	`listIS_CONTAINED_WITHIN
( 
NULL
, &( 
pxTimer
->
xTimerListItem
 ) ) );

656 
	`taskEXIT_CRITICAL
();

658 return 
xTimerIsInActiveList
;

659 
	}
}

662 void *
	$pvTimerGetTimerID
( 
xTimerHandle
 
xTimer
 )

664 
xTIMER
 *
pxTimer
 = ( xTIMER * ) 
xTimer
;

666 return 
pxTimer
->
pvTimerID
;

667 
	}
}

	@Libraries/CMSIS/Include/core_cm4.h

23 #if 
defined
 ( 
__ICCARM__
 )

24 #pragma 
system_include


27 #ifdef 
__cplusplus


31 #ifndef 
__CORE_CM4_H_GENERIC


32 #define 
	#__CORE_CM4_H_GENERIC


	)

76 #define 
	#__CM4_CMSIS_VERSION_MAIN
 (0x02)

	)

77 #define 
	#__CM4_CMSIS_VERSION_SUB
 (0x10)

	)

78 #define 
	#__CM4_CMSIS_VERSION
 ((
__CM4_CMSIS_VERSION_MAIN
 << 16) | 
__CM4_CMSIS_VERSION_SUB
)

	)

80 #define 
	#__CORTEX_M
 (0x04)

	)

83 #if 
defined
 ( 
__CC_ARM
 )

84 #define 
	#__ASM
 
__asm


	)

85 #define 
	#__INLINE
 
__inline


	)

87 #elif 
defined
 ( 
__ICCARM__
 )

88 #define 
	#__ASM
 
__asm


	)

89 #define 
	#__INLINE
 
inline


	)

91 #elif 
defined
 ( 
__GNUC__
 )

92 #define 
	#__ASM
 
__asm


	)

93 #define 
	#__INLINE
 
inline


	)

95 #elif 
defined
 ( 
__TASKING__
 )

96 #define 
	#__ASM
 
__asm


	)

97 #define 
	#__INLINE
 
inline


	)

102 #if 
defined
 ( 
__CC_ARM
 )

103 #if 
defined
 
__TARGET_FPU_VFP


104 #if (
__FPU_PRESENT
 == 1)

105 #define 
	#__FPU_USED
 1

	)

108 #define 
	#__FPU_USED
 0

	)

111 #define 
	#__FPU_USED
 0

	)

114 #elif 
defined
 ( 
__ICCARM__
 )

115 #if 
defined
 
__ARMVFP__


116 #if (
__FPU_PRESENT
 == 1)

117 #define 
	#__FPU_USED
 1

	)

120 #define 
	#__FPU_USED
 0

	)

123 #define 
	#__FPU_USED
 0

	)

126 #elif 
defined
 ( 
__GNUC__
 )

127 #if 
defined
 (
__VFP_FP__
) && !defined(
__SOFTFP__
)

128 #if (
__FPU_PRESENT
 == 1)

129 #define 
	#__FPU_USED
 1

	)

132 #define 
	#__FPU_USED
 0

	)

135 #define 
	#__FPU_USED
 0

	)

138 #elif 
defined
 ( 
__TASKING__
 )

140 #define 
	#__FPU_USED
 0

	)

143 #include 
	~<stdint.h
>

144 #include 
	~<core_cmInstr.h
>

145 #include 
	~<core_cmFunc.h
>

146 #include 
	~<core_cm4_simd.h
>

150 #ifndef 
__CMSIS_GENERIC


152 #ifndef 
__CORE_CM4_H_DEPENDANT


153 #define 
	#__CORE_CM4_H_DEPENDANT


	)

156 #if 
defined
 
__CHECK_DEVICE_DEFINES


157 #ifndef 
__CM4_REV


158 #define 
	#__CM4_REV
 0x0000

	)

162 #ifndef 
__FPU_PRESENT


163 #define 
	#__FPU_PRESENT
 0

	)

167 #ifndef 
__MPU_PRESENT


168 #define 
	#__MPU_PRESENT
 0

	)

172 #ifndef 
__NVIC_PRIO_BITS


173 #define 
	#__NVIC_PRIO_BITS
 4

	)

177 #ifndef 
__Vendor_SysTickConfig


178 #define 
	#__Vendor_SysTickConfig
 0

	)

184 #ifdef 
__cplusplus


185 #define 
	#__I
 volatile

	)

187 #define 
	#__I
 volatile const

	)

189 #define 
	#__O
 volatile

	)

190 #define 
	#__IO
 volatile

	)

222 #if (
__CORTEX_M
 != 0x04)

223 
uint32_t
 
_reserved0
:27;

225 
uint32_t
 
_reserved0
:16;

226 
uint32_t
 
GE
:4;

227 
uint32_t
 
_reserved1
:7;

229 
uint32_t
 
Q
:1;

230 
uint32_t
 
V
:1;

231 
uint32_t
 
C
:1;

232 
uint32_t
 
Z
:1;

233 
uint32_t
 
N
:1;

234 } 
b
;

235 
uint32_t
 
w
;

236 } 
	tAPSR_Type
;

245 
uint32_t
 
ISR
:9;

246 
uint32_t
 
_reserved0
:23;

247 } 
b
;

248 
uint32_t
 
w
;

249 } 
	tIPSR_Type
;

258 
uint32_t
 
ISR
:9;

259 #if (
__CORTEX_M
 != 0x04)

260 
uint32_t
 
_reserved0
:15;

262 
uint32_t
 
_reserved0
:7;

263 
uint32_t
 
GE
:4;

264 
uint32_t
 
_reserved1
:4;

266 
uint32_t
 
T
:1;

267 
uint32_t
 
IT
:2;

268 
uint32_t
 
Q
:1;

269 
uint32_t
 
V
:1;

270 
uint32_t
 
C
:1;

271 
uint32_t
 
Z
:1;

272 
uint32_t
 
N
:1;

273 } 
b
;

274 
uint32_t
 
w
;

275 } 
	txPSR_Type
;

284 
uint32_t
 
nPRIV
:1;

285 
uint32_t
 
SPSEL
:1;

286 
uint32_t
 
FPCA
:1;

287 
uint32_t
 
_reserved0
:29;

288 } 
b
;

289 
uint32_t
 
w
;

290 } 
	tCONTROL_Type
;

305 
__IO
 
uint32_t
 
ISER
[8];

306 
uint32_t
 
RESERVED0
[24];

307 
__IO
 
uint32_t
 
ICER
[8];

308 
uint32_t
 
RSERVED1
[24];

309 
__IO
 
uint32_t
 
ISPR
[8];

310 
uint32_t
 
RESERVED2
[24];

311 
__IO
 
uint32_t
 
ICPR
[8];

312 
uint32_t
 
RESERVED3
[24];

313 
__IO
 
uint32_t
 
IABR
[8];

314 
uint32_t
 
RESERVED4
[56];

315 
__IO
 
uint8_t
 
IP
[240];

316 
uint32_t
 
RESERVED5
[644];

317 
__O
 
uint32_t
 
STIR
;

318 } 
	tNVIC_Type
;

321 #define 
	#NVIC_STIR_INTID_Pos
 0

	)

322 #define 
	#NVIC_STIR_INTID_Msk
 (0x1FFUL << 
NVIC_STIR_INTID_Pos
)

	)

337 
__I
 
uint32_t
 
CPUID
;

338 
__IO
 
uint32_t
 
ICSR
;

339 
__IO
 
uint32_t
 
VTOR
;

340 
__IO
 
uint32_t
 
AIRCR
;

341 
__IO
 
uint32_t
 
SCR
;

342 
__IO
 
uint32_t
 
CCR
;

343 
__IO
 
uint8_t
 
SHP
[12];

344 
__IO
 
uint32_t
 
SHCSR
;

345 
__IO
 
uint32_t
 
CFSR
;

346 
__IO
 
uint32_t
 
HFSR
;

347 
__IO
 
uint32_t
 
DFSR
;

348 
__IO
 
uint32_t
 
MMFAR
;

349 
__IO
 
uint32_t
 
BFAR
;

350 
__IO
 
uint32_t
 
AFSR
;

351 
__I
 
uint32_t
 
PFR
[2];

352 
__I
 
uint32_t
 
DFR
;

353 
__I
 
uint32_t
 
ADR
;

354 
__I
 
uint32_t
 
MMFR
[4];

355 
__I
 
uint32_t
 
ISAR
[5];

356 
uint32_t
 
RESERVED0
[5];

357 
__IO
 
uint32_t
 
CPACR
;

358 } 
	tSCB_Type
;

361 #define 
	#SCB_CPUID_IMPLEMENTER_Pos
 24

	)

362 #define 
	#SCB_CPUID_IMPLEMENTER_Msk
 (0xFFUL << 
SCB_CPUID_IMPLEMENTER_Pos
)

	)

364 #define 
	#SCB_CPUID_VARIANT_Pos
 20

	)

365 #define 
	#SCB_CPUID_VARIANT_Msk
 (0xFUL << 
SCB_CPUID_VARIANT_Pos
)

	)

367 #define 
	#SCB_CPUID_ARCHITECTURE_Pos
 16

	)

368 #define 
	#SCB_CPUID_ARCHITECTURE_Msk
 (0xFUL << 
SCB_CPUID_ARCHITECTURE_Pos
)

	)

370 #define 
	#SCB_CPUID_PARTNO_Pos
 4

	)

371 #define 
	#SCB_CPUID_PARTNO_Msk
 (0xFFFUL << 
SCB_CPUID_PARTNO_Pos
)

	)

373 #define 
	#SCB_CPUID_REVISION_Pos
 0

	)

374 #define 
	#SCB_CPUID_REVISION_Msk
 (0xFUL << 
SCB_CPUID_REVISION_Pos
)

	)

377 #define 
	#SCB_ICSR_NMIPENDSET_Pos
 31

	)

378 #define 
	#SCB_ICSR_NMIPENDSET_Msk
 (1UL << 
SCB_ICSR_NMIPENDSET_Pos
)

	)

380 #define 
	#SCB_ICSR_PENDSVSET_Pos
 28

	)

381 #define 
	#SCB_ICSR_PENDSVSET_Msk
 (1UL << 
SCB_ICSR_PENDSVSET_Pos
)

	)

383 #define 
	#SCB_ICSR_PENDSVCLR_Pos
 27

	)

384 #define 
	#SCB_ICSR_PENDSVCLR_Msk
 (1UL << 
SCB_ICSR_PENDSVCLR_Pos
)

	)

386 #define 
	#SCB_ICSR_PENDSTSET_Pos
 26

	)

387 #define 
	#SCB_ICSR_PENDSTSET_Msk
 (1UL << 
SCB_ICSR_PENDSTSET_Pos
)

	)

389 #define 
	#SCB_ICSR_PENDSTCLR_Pos
 25

	)

390 #define 
	#SCB_ICSR_PENDSTCLR_Msk
 (1UL << 
SCB_ICSR_PENDSTCLR_Pos
)

	)

392 #define 
	#SCB_ICSR_ISRPREEMPT_Pos
 23

	)

393 #define 
	#SCB_ICSR_ISRPREEMPT_Msk
 (1UL << 
SCB_ICSR_ISRPREEMPT_Pos
)

	)

395 #define 
	#SCB_ICSR_ISRPENDING_Pos
 22

	)

396 #define 
	#SCB_ICSR_ISRPENDING_Msk
 (1UL << 
SCB_ICSR_ISRPENDING_Pos
)

	)

398 #define 
	#SCB_ICSR_VECTPENDING_Pos
 12

	)

399 #define 
	#SCB_ICSR_VECTPENDING_Msk
 (0x1FFUL << 
SCB_ICSR_VECTPENDING_Pos
)

	)

401 #define 
	#SCB_ICSR_RETTOBASE_Pos
 11

	)

402 #define 
	#SCB_ICSR_RETTOBASE_Msk
 (1UL << 
SCB_ICSR_RETTOBASE_Pos
)

	)

404 #define 
	#SCB_ICSR_VECTACTIVE_Pos
 0

	)

405 #define 
	#SCB_ICSR_VECTACTIVE_Msk
 (0x1FFUL << 
SCB_ICSR_VECTACTIVE_Pos
)

	)

408 #define 
	#SCB_VTOR_TBLOFF_Pos
 7

	)

409 #define 
	#SCB_VTOR_TBLOFF_Msk
 (0x1FFFFFFUL << 
SCB_VTOR_TBLOFF_Pos
)

	)

412 #define 
	#SCB_AIRCR_VECTKEY_Pos
 16

	)

413 #define 
	#SCB_AIRCR_VECTKEY_Msk
 (0xFFFFUL << 
SCB_AIRCR_VECTKEY_Pos
)

	)

415 #define 
	#SCB_AIRCR_VECTKEYSTAT_Pos
 16

	)

416 #define 
	#SCB_AIRCR_VECTKEYSTAT_Msk
 (0xFFFFUL << 
SCB_AIRCR_VECTKEYSTAT_Pos
)

	)

418 #define 
	#SCB_AIRCR_ENDIANESS_Pos
 15

	)

419 #define 
	#SCB_AIRCR_ENDIANESS_Msk
 (1UL << 
SCB_AIRCR_ENDIANESS_Pos
)

	)

421 #define 
	#SCB_AIRCR_PRIGROUP_Pos
 8

	)

422 #define 
	#SCB_AIRCR_PRIGROUP_Msk
 (7UL << 
SCB_AIRCR_PRIGROUP_Pos
)

	)

424 #define 
	#SCB_AIRCR_SYSRESETREQ_Pos
 2

	)

425 #define 
	#SCB_AIRCR_SYSRESETREQ_Msk
 (1UL << 
SCB_AIRCR_SYSRESETREQ_Pos
)

	)

427 #define 
	#SCB_AIRCR_VECTCLRACTIVE_Pos
 1

	)

428 #define 
	#SCB_AIRCR_VECTCLRACTIVE_Msk
 (1UL << 
SCB_AIRCR_VECTCLRACTIVE_Pos
)

	)

430 #define 
	#SCB_AIRCR_VECTRESET_Pos
 0

	)

431 #define 
	#SCB_AIRCR_VECTRESET_Msk
 (1UL << 
SCB_AIRCR_VECTRESET_Pos
)

	)

434 #define 
	#SCB_SCR_SEVONPEND_Pos
 4

	)

435 #define 
	#SCB_SCR_SEVONPEND_Msk
 (1UL << 
SCB_SCR_SEVONPEND_Pos
)

	)

437 #define 
	#SCB_SCR_SLEEPDEEP_Pos
 2

	)

438 #define 
	#SCB_SCR_SLEEPDEEP_Msk
 (1UL << 
SCB_SCR_SLEEPDEEP_Pos
)

	)

440 #define 
	#SCB_SCR_SLEEPONEXIT_Pos
 1

	)

441 #define 
	#SCB_SCR_SLEEPONEXIT_Msk
 (1UL << 
SCB_SCR_SLEEPONEXIT_Pos
)

	)

444 #define 
	#SCB_CCR_STKALIGN_Pos
 9

	)

445 #define 
	#SCB_CCR_STKALIGN_Msk
 (1UL << 
SCB_CCR_STKALIGN_Pos
)

	)

447 #define 
	#SCB_CCR_BFHFNMIGN_Pos
 8

	)

448 #define 
	#SCB_CCR_BFHFNMIGN_Msk
 (1UL << 
SCB_CCR_BFHFNMIGN_Pos
)

	)

450 #define 
	#SCB_CCR_DIV_0_TRP_Pos
 4

	)

451 #define 
	#SCB_CCR_DIV_0_TRP_Msk
 (1UL << 
SCB_CCR_DIV_0_TRP_Pos
)

	)

453 #define 
	#SCB_CCR_UNALIGN_TRP_Pos
 3

	)

454 #define 
	#SCB_CCR_UNALIGN_TRP_Msk
 (1UL << 
SCB_CCR_UNALIGN_TRP_Pos
)

	)

456 #define 
	#SCB_CCR_USERSETMPEND_Pos
 1

	)

457 #define 
	#SCB_CCR_USERSETMPEND_Msk
 (1UL << 
SCB_CCR_USERSETMPEND_Pos
)

	)

459 #define 
	#SCB_CCR_NONBASETHRDENA_Pos
 0

	)

460 #define 
	#SCB_CCR_NONBASETHRDENA_Msk
 (1UL << 
SCB_CCR_NONBASETHRDENA_Pos
)

	)

463 #define 
	#SCB_SHCSR_USGFAULTENA_Pos
 18

	)

464 #define 
	#SCB_SHCSR_USGFAULTENA_Msk
 (1UL << 
SCB_SHCSR_USGFAULTENA_Pos
)

	)

466 #define 
	#SCB_SHCSR_BUSFAULTENA_Pos
 17

	)

467 #define 
	#SCB_SHCSR_BUSFAULTENA_Msk
 (1UL << 
SCB_SHCSR_BUSFAULTENA_Pos
)

	)

469 #define 
	#SCB_SHCSR_MEMFAULTENA_Pos
 16

	)

470 #define 
	#SCB_SHCSR_MEMFAULTENA_Msk
 (1UL << 
SCB_SHCSR_MEMFAULTENA_Pos
)

	)

472 #define 
	#SCB_SHCSR_SVCALLPENDED_Pos
 15

	)

473 #define 
	#SCB_SHCSR_SVCALLPENDED_Msk
 (1UL << 
SCB_SHCSR_SVCALLPENDED_Pos
)

	)

475 #define 
	#SCB_SHCSR_BUSFAULTPENDED_Pos
 14

	)

476 #define 
	#SCB_SHCSR_BUSFAULTPENDED_Msk
 (1UL << 
SCB_SHCSR_BUSFAULTPENDED_Pos
)

	)

478 #define 
	#SCB_SHCSR_MEMFAULTPENDED_Pos
 13

	)

479 #define 
	#SCB_SHCSR_MEMFAULTPENDED_Msk
 (1UL << 
SCB_SHCSR_MEMFAULTPENDED_Pos
)

	)

481 #define 
	#SCB_SHCSR_USGFAULTPENDED_Pos
 12

	)

482 #define 
	#SCB_SHCSR_USGFAULTPENDED_Msk
 (1UL << 
SCB_SHCSR_USGFAULTPENDED_Pos
)

	)

484 #define 
	#SCB_SHCSR_SYSTICKACT_Pos
 11

	)

485 #define 
	#SCB_SHCSR_SYSTICKACT_Msk
 (1UL << 
SCB_SHCSR_SYSTICKACT_Pos
)

	)

487 #define 
	#SCB_SHCSR_PENDSVACT_Pos
 10

	)

488 #define 
	#SCB_SHCSR_PENDSVACT_Msk
 (1UL << 
SCB_SHCSR_PENDSVACT_Pos
)

	)

490 #define 
	#SCB_SHCSR_MONITORACT_Pos
 8

	)

491 #define 
	#SCB_SHCSR_MONITORACT_Msk
 (1UL << 
SCB_SHCSR_MONITORACT_Pos
)

	)

493 #define 
	#SCB_SHCSR_SVCALLACT_Pos
 7

	)

494 #define 
	#SCB_SHCSR_SVCALLACT_Msk
 (1UL << 
SCB_SHCSR_SVCALLACT_Pos
)

	)

496 #define 
	#SCB_SHCSR_USGFAULTACT_Pos
 3

	)

497 #define 
	#SCB_SHCSR_USGFAULTACT_Msk
 (1UL << 
SCB_SHCSR_USGFAULTACT_Pos
)

	)

499 #define 
	#SCB_SHCSR_BUSFAULTACT_Pos
 1

	)

500 #define 
	#SCB_SHCSR_BUSFAULTACT_Msk
 (1UL << 
SCB_SHCSR_BUSFAULTACT_Pos
)

	)

502 #define 
	#SCB_SHCSR_MEMFAULTACT_Pos
 0

	)

503 #define 
	#SCB_SHCSR_MEMFAULTACT_Msk
 (1UL << 
SCB_SHCSR_MEMFAULTACT_Pos
)

	)

506 #define 
	#SCB_CFSR_USGFAULTSR_Pos
 16

	)

507 #define 
	#SCB_CFSR_USGFAULTSR_Msk
 (0xFFFFUL << 
SCB_CFSR_USGFAULTSR_Pos
)

	)

509 #define 
	#SCB_CFSR_BUSFAULTSR_Pos
 8

	)

510 #define 
	#SCB_CFSR_BUSFAULTSR_Msk
 (0xFFUL << 
SCB_CFSR_BUSFAULTSR_Pos
)

	)

512 #define 
	#SCB_CFSR_MEMFAULTSR_Pos
 0

	)

513 #define 
	#SCB_CFSR_MEMFAULTSR_Msk
 (0xFFUL << 
SCB_CFSR_MEMFAULTSR_Pos
)

	)

516 #define 
	#SCB_HFSR_DEBUGEVT_Pos
 31

	)

517 #define 
	#SCB_HFSR_DEBUGEVT_Msk
 (1UL << 
SCB_HFSR_DEBUGEVT_Pos
)

	)

519 #define 
	#SCB_HFSR_FORCED_Pos
 30

	)

520 #define 
	#SCB_HFSR_FORCED_Msk
 (1UL << 
SCB_HFSR_FORCED_Pos
)

	)

522 #define 
	#SCB_HFSR_VECTTBL_Pos
 1

	)

523 #define 
	#SCB_HFSR_VECTTBL_Msk
 (1UL << 
SCB_HFSR_VECTTBL_Pos
)

	)

526 #define 
	#SCB_DFSR_EXTERNAL_Pos
 4

	)

527 #define 
	#SCB_DFSR_EXTERNAL_Msk
 (1UL << 
SCB_DFSR_EXTERNAL_Pos
)

	)

529 #define 
	#SCB_DFSR_VCATCH_Pos
 3

	)

530 #define 
	#SCB_DFSR_VCATCH_Msk
 (1UL << 
SCB_DFSR_VCATCH_Pos
)

	)

532 #define 
	#SCB_DFSR_DWTTRAP_Pos
 2

	)

533 #define 
	#SCB_DFSR_DWTTRAP_Msk
 (1UL << 
SCB_DFSR_DWTTRAP_Pos
)

	)

535 #define 
	#SCB_DFSR_BKPT_Pos
 1

	)

536 #define 
	#SCB_DFSR_BKPT_Msk
 (1UL << 
SCB_DFSR_BKPT_Pos
)

	)

538 #define 
	#SCB_DFSR_HALTED_Pos
 0

	)

539 #define 
	#SCB_DFSR_HALTED_Msk
 (1UL << 
SCB_DFSR_HALTED_Pos
)

	)

554 
uint32_t
 
RESERVED0
[1];

555 
__I
 
uint32_t
 
ICTR
;

556 
__IO
 
uint32_t
 
ACTLR
;

557 } 
	tSCnSCB_Type
;

560 #define 
	#SCnSCB_ICTR_INTLINESNUM_Pos
 0

	)

561 #define 
	#SCnSCB_ICTR_INTLINESNUM_Msk
 (0xFUL << 
SCnSCB_ICTR_INTLINESNUM_Pos
)

	)

564 #define 
	#SCnSCB_ACTLR_DISOOFP_Pos
 9

	)

565 #define 
	#SCnSCB_ACTLR_DISOOFP_Msk
 (1UL << 
SCnSCB_ACTLR_DISOOFP_Pos
)

	)

567 #define 
	#SCnSCB_ACTLR_DISFPCA_Pos
 8

	)

568 #define 
	#SCnSCB_ACTLR_DISFPCA_Msk
 (1UL << 
SCnSCB_ACTLR_DISFPCA_Pos
)

	)

570 #define 
	#SCnSCB_ACTLR_DISFOLD_Pos
 2

	)

571 #define 
	#SCnSCB_ACTLR_DISFOLD_Msk
 (1UL << 
SCnSCB_ACTLR_DISFOLD_Pos
)

	)

573 #define 
	#SCnSCB_ACTLR_DISDEFWBUF_Pos
 1

	)

574 #define 
	#SCnSCB_ACTLR_DISDEFWBUF_Msk
 (1UL << 
SCnSCB_ACTLR_DISDEFWBUF_Pos
)

	)

576 #define 
	#SCnSCB_ACTLR_DISMCYCINT_Pos
 0

	)

577 #define 
	#SCnSCB_ACTLR_DISMCYCINT_Msk
 (1UL << 
SCnSCB_ACTLR_DISMCYCINT_Pos
)

	)

592 
__IO
 
uint32_t
 
CTRL
;

593 
__IO
 
uint32_t
 
LOAD
;

594 
__IO
 
uint32_t
 
VAL
;

595 
__I
 
uint32_t
 
CALIB
;

596 } 
	tSysTick_Type
;

599 #define 
	#SysTick_CTRL_COUNTFLAG_Pos
 16

	)

600 #define 
	#SysTick_CTRL_COUNTFLAG_Msk
 (1UL << 
SysTick_CTRL_COUNTFLAG_Pos
)

	)

602 #define 
	#SysTick_CTRL_CLKSOURCE_Pos
 2

	)

603 #define 
	#SysTick_CTRL_CLKSOURCE_Msk
 (1UL << 
SysTick_CTRL_CLKSOURCE_Pos
)

	)

605 #define 
	#SysTick_CTRL_TICKINT_Pos
 1

	)

606 #define 
	#SysTick_CTRL_TICKINT_Msk
 (1UL << 
SysTick_CTRL_TICKINT_Pos
)

	)

608 #define 
	#SysTick_CTRL_ENABLE_Pos
 0

	)

609 #define 
	#SysTick_CTRL_ENABLE_Msk
 (1UL << 
SysTick_CTRL_ENABLE_Pos
)

	)

612 #define 
	#SysTick_LOAD_RELOAD_Pos
 0

	)

613 #define 
	#SysTick_LOAD_RELOAD_Msk
 (0xFFFFFFUL << 
SysTick_LOAD_RELOAD_Pos
)

	)

616 #define 
	#SysTick_VAL_CURRENT_Pos
 0

	)

617 #define 
	#SysTick_VAL_CURRENT_Msk
 (0xFFFFFFUL << 
SysTick_VAL_CURRENT_Pos
)

	)

620 #define 
	#SysTick_CALIB_NOREF_Pos
 31

	)

621 #define 
	#SysTick_CALIB_NOREF_Msk
 (1UL << 
SysTick_CALIB_NOREF_Pos
)

	)

623 #define 
	#SysTick_CALIB_SKEW_Pos
 30

	)

624 #define 
	#SysTick_CALIB_SKEW_Msk
 (1UL << 
SysTick_CALIB_SKEW_Pos
)

	)

626 #define 
	#SysTick_CALIB_TENMS_Pos
 0

	)

627 #define 
	#SysTick_CALIB_TENMS_Msk
 (0xFFFFFFUL << 
SysTick_VAL_CURRENT_Pos
)

	)

642 
__O
 union

644 
__O
 
uint8_t
 
u8
;

645 
__O
 
uint16_t
 
u16
;

646 
__O
 
uint32_t
 
u32
;

647 } 
PORT
 [32];

648 
uint32_t
 
RESERVED0
[864];

649 
__IO
 
uint32_t
 
TER
;

650 
uint32_t
 
RESERVED1
[15];

651 
__IO
 
uint32_t
 
TPR
;

652 
uint32_t
 
RESERVED2
[15];

653 
__IO
 
uint32_t
 
TCR
;

654 } 
	tITM_Type
;

657 #define 
	#ITM_TPR_PRIVMASK_Pos
 0

	)

658 #define 
	#ITM_TPR_PRIVMASK_Msk
 (0xFUL << 
ITM_TPR_PRIVMASK_Pos
)

	)

661 #define 
	#ITM_TCR_BUSY_Pos
 23

	)

662 #define 
	#ITM_TCR_BUSY_Msk
 (1UL << 
ITM_TCR_BUSY_Pos
)

	)

664 #define 
	#ITM_TCR_TraceBusID_Pos
 16

	)

665 #define 
	#ITM_TCR_TraceBusID_Msk
 (0x7FUL << 
ITM_TCR_TraceBusID_Pos
)

	)

667 #define 
	#ITM_TCR_GTSFREQ_Pos
 10

	)

668 #define 
	#ITM_TCR_GTSFREQ_Msk
 (3UL << 
ITM_TCR_GTSFREQ_Pos
)

	)

670 #define 
	#ITM_TCR_TSPrescale_Pos
 8

	)

671 #define 
	#ITM_TCR_TSPrescale_Msk
 (3UL << 
ITM_TCR_TSPrescale_Pos
)

	)

673 #define 
	#ITM_TCR_SWOENA_Pos
 4

	)

674 #define 
	#ITM_TCR_SWOENA_Msk
 (1UL << 
ITM_TCR_SWOENA_Pos
)

	)

676 #define 
	#ITM_TCR_TXENA_Pos
 3

	)

677 #define 
	#ITM_TCR_TXENA_Msk
 (1UL << 
ITM_TCR_TXENA_Pos
)

	)

679 #define 
	#ITM_TCR_SYNCENA_Pos
 2

	)

680 #define 
	#ITM_TCR_SYNCENA_Msk
 (1UL << 
ITM_TCR_SYNCENA_Pos
)

	)

682 #define 
	#ITM_TCR_TSENA_Pos
 1

	)

683 #define 
	#ITM_TCR_TSENA_Msk
 (1UL << 
ITM_TCR_TSENA_Pos
)

	)

685 #define 
	#ITM_TCR_ITMENA_Pos
 0

	)

686 #define 
	#ITM_TCR_ITMENA_Msk
 (1UL << 
ITM_TCR_ITMENA_Pos
)

	)

691 #if (
__MPU_PRESENT
 == 1)

702 
__I
 
uint32_t
 
TYPE
;

703 
__IO
 
uint32_t
 
CTRL
;

704 
__IO
 
uint32_t
 
RNR
;

705 
__IO
 
uint32_t
 
RBAR
;

706 
__IO
 
uint32_t
 
RASR
;

707 
__IO
 
uint32_t
 
RBAR_A1
;

708 
__IO
 
uint32_t
 
RASR_A1
;

709 
__IO
 
uint32_t
 
RBAR_A2
;

710 
__IO
 
uint32_t
 
RASR_A2
;

711 
__IO
 
uint32_t
 
RBAR_A3
;

712 
__IO
 
uint32_t
 
RASR_A3
;

713 } 
	tMPU_Type
;

716 #define 
	#MPU_TYPE_IREGION_Pos
 16

	)

717 #define 
	#MPU_TYPE_IREGION_Msk
 (0xFFUL << 
MPU_TYPE_IREGION_Pos
)

	)

719 #define 
	#MPU_TYPE_DREGION_Pos
 8

	)

720 #define 
	#MPU_TYPE_DREGION_Msk
 (0xFFUL << 
MPU_TYPE_DREGION_Pos
)

	)

722 #define 
	#MPU_TYPE_SEPARATE_Pos
 0

	)

723 #define 
	#MPU_TYPE_SEPARATE_Msk
 (1UL << 
MPU_TYPE_SEPARATE_Pos
)

	)

726 #define 
	#MPU_CTRL_PRIVDEFENA_Pos
 2

	)

727 #define 
	#MPU_CTRL_PRIVDEFENA_Msk
 (1UL << 
MPU_CTRL_PRIVDEFENA_Pos
)

	)

729 #define 
	#MPU_CTRL_HFNMIENA_Pos
 1

	)

730 #define 
	#MPU_CTRL_HFNMIENA_Msk
 (1UL << 
MPU_CTRL_HFNMIENA_Pos
)

	)

732 #define 
	#MPU_CTRL_ENABLE_Pos
 0

	)

733 #define 
	#MPU_CTRL_ENABLE_Msk
 (1UL << 
MPU_CTRL_ENABLE_Pos
)

	)

736 #define 
	#MPU_RNR_REGION_Pos
 0

	)

737 #define 
	#MPU_RNR_REGION_Msk
 (0xFFUL << 
MPU_RNR_REGION_Pos
)

	)

740 #define 
	#MPU_RBAR_ADDR_Pos
 5

	)

741 #define 
	#MPU_RBAR_ADDR_Msk
 (0x7FFFFFFUL << 
MPU_RBAR_ADDR_Pos
)

	)

743 #define 
	#MPU_RBAR_VALID_Pos
 4

	)

744 #define 
	#MPU_RBAR_VALID_Msk
 (1UL << 
MPU_RBAR_VALID_Pos
)

	)

746 #define 
	#MPU_RBAR_REGION_Pos
 0

	)

747 #define 
	#MPU_RBAR_REGION_Msk
 (0xFUL << 
MPU_RBAR_REGION_Pos
)

	)

750 #define 
	#MPU_RASR_ATTRS_Pos
 16

	)

751 #define 
	#MPU_RASR_ATTRS_Msk
 (0xFFFFUL << 
MPU_RASR_ATTRS_Pos
)

	)

753 #define 
	#MPU_RASR_SRD_Pos
 8

	)

754 #define 
	#MPU_RASR_SRD_Msk
 (0xFFUL << 
MPU_RASR_SRD_Pos
)

	)

756 #define 
	#MPU_RASR_SIZE_Pos
 1

	)

757 #define 
	#MPU_RASR_SIZE_Msk
 (0x1FUL << 
MPU_RASR_SIZE_Pos
)

	)

759 #define 
	#MPU_RASR_ENABLE_Pos
 0

	)

760 #define 
	#MPU_RASR_ENABLE_Msk
 (1UL << 
MPU_RASR_ENABLE_Pos
)

	)

766 #if (
__FPU_PRESENT
 == 1)

777 
uint32_t
 
RESERVED0
[1];

778 
__IO
 
uint32_t
 
FPCCR
;

779 
__IO
 
uint32_t
 
FPCAR
;

780 
__IO
 
uint32_t
 
FPDSCR
;

781 
__I
 
uint32_t
 
MVFR0
;

782 
__I
 
uint32_t
 
MVFR1
;

783 } 
	tFPU_Type
;

786 #define 
	#FPU_FPCCR_ASPEN_Pos
 31

	)

787 #define 
	#FPU_FPCCR_ASPEN_Msk
 (1UL << 
FPU_FPCCR_ASPEN_Pos
)

	)

789 #define 
	#FPU_FPCCR_LSPEN_Pos
 30

	)

790 #define 
	#FPU_FPCCR_LSPEN_Msk
 (1UL << 
FPU_FPCCR_LSPEN_Pos
)

	)

792 #define 
	#FPU_FPCCR_MONRDY_Pos
 8

	)

793 #define 
	#FPU_FPCCR_MONRDY_Msk
 (1UL << 
FPU_FPCCR_MONRDY_Pos
)

	)

795 #define 
	#FPU_FPCCR_BFRDY_Pos
 6

	)

796 #define 
	#FPU_FPCCR_BFRDY_Msk
 (1UL << 
FPU_FPCCR_BFRDY_Pos
)

	)

798 #define 
	#FPU_FPCCR_MMRDY_Pos
 5

	)

799 #define 
	#FPU_FPCCR_MMRDY_Msk
 (1UL << 
FPU_FPCCR_MMRDY_Pos
)

	)

801 #define 
	#FPU_FPCCR_HFRDY_Pos
 4

	)

802 #define 
	#FPU_FPCCR_HFRDY_Msk
 (1UL << 
FPU_FPCCR_HFRDY_Pos
)

	)

804 #define 
	#FPU_FPCCR_THREAD_Pos
 3

	)

805 #define 
	#FPU_FPCCR_THREAD_Msk
 (1UL << 
FPU_FPCCR_THREAD_Pos
)

	)

807 #define 
	#FPU_FPCCR_USER_Pos
 1

	)

808 #define 
	#FPU_FPCCR_USER_Msk
 (1UL << 
FPU_FPCCR_USER_Pos
)

	)

810 #define 
	#FPU_FPCCR_LSPACT_Pos
 0

	)

811 #define 
	#FPU_FPCCR_LSPACT_Msk
 (1UL << 
FPU_FPCCR_LSPACT_Pos
)

	)

814 #define 
	#FPU_FPCAR_ADDRESS_Pos
 3

	)

815 #define 
	#FPU_FPCAR_ADDRESS_Msk
 (0x1FFFFFFFUL << 
FPU_FPCAR_ADDRESS_Pos
)

	)

818 #define 
	#FPU_FPDSCR_AHP_Pos
 26

	)

819 #define 
	#FPU_FPDSCR_AHP_Msk
 (1UL << 
FPU_FPDSCR_AHP_Pos
)

	)

821 #define 
	#FPU_FPDSCR_DN_Pos
 25

	)

822 #define 
	#FPU_FPDSCR_DN_Msk
 (1UL << 
FPU_FPDSCR_DN_Pos
)

	)

824 #define 
	#FPU_FPDSCR_FZ_Pos
 24

	)

825 #define 
	#FPU_FPDSCR_FZ_Msk
 (1UL << 
FPU_FPDSCR_FZ_Pos
)

	)

827 #define 
	#FPU_FPDSCR_RMode_Pos
 22

	)

828 #define 
	#FPU_FPDSCR_RMode_Msk
 (3UL << 
FPU_FPDSCR_RMode_Pos
)

	)

831 #define 
	#FPU_MVFR0_FP_rounding_modes_Pos
 28

	)

832 #define 
	#FPU_MVFR0_FP_rounding_modes_Msk
 (0xFUL << 
FPU_MVFR0_FP_rounding_modes_Pos
)

	)

834 #define 
	#FPU_MVFR0_Short_vectors_Pos
 24

	)

835 #define 
	#FPU_MVFR0_Short_vectors_Msk
 (0xFUL << 
FPU_MVFR0_Short_vectors_Pos
)

	)

837 #define 
	#FPU_MVFR0_Square_root_Pos
 20

	)

838 #define 
	#FPU_MVFR0_Square_root_Msk
 (0xFUL << 
FPU_MVFR0_Square_root_Pos
)

	)

840 #define 
	#FPU_MVFR0_Divide_Pos
 16

	)

841 #define 
	#FPU_MVFR0_Divide_Msk
 (0xFUL << 
FPU_MVFR0_Divide_Pos
)

	)

843 #define 
	#FPU_MVFR0_FP_excep_trapping_Pos
 12

	)

844 #define 
	#FPU_MVFR0_FP_excep_trapping_Msk
 (0xFUL << 
FPU_MVFR0_FP_excep_trapping_Pos
)

	)

846 #define 
	#FPU_MVFR0_Double_precision_Pos
 8

	)

847 #define 
	#FPU_MVFR0_Double_precision_Msk
 (0xFUL << 
FPU_MVFR0_Double_precision_Pos
)

	)

849 #define 
	#FPU_MVFR0_Single_precision_Pos
 4

	)

850 #define 
	#FPU_MVFR0_Single_precision_Msk
 (0xFUL << 
FPU_MVFR0_Single_precision_Pos
)

	)

852 #define 
	#FPU_MVFR0_A_SIMD_registers_Pos
 0

	)

853 #define 
	#FPU_MVFR0_A_SIMD_registers_Msk
 (0xFUL << 
FPU_MVFR0_A_SIMD_registers_Pos
)

	)

856 #define 
	#FPU_MVFR1_FP_fused_MAC_Pos
 28

	)

857 #define 
	#FPU_MVFR1_FP_fused_MAC_Msk
 (0xFUL << 
FPU_MVFR1_FP_fused_MAC_Pos
)

	)

859 #define 
	#FPU_MVFR1_FP_HPFP_Pos
 24

	)

860 #define 
	#FPU_MVFR1_FP_HPFP_Msk
 (0xFUL << 
FPU_MVFR1_FP_HPFP_Pos
)

	)

862 #define 
	#FPU_MVFR1_D_NaN_mode_Pos
 4

	)

863 #define 
	#FPU_MVFR1_D_NaN_mode_Msk
 (0xFUL << 
FPU_MVFR1_D_NaN_mode_Pos
)

	)

865 #define 
	#FPU_MVFR1_FtZ_mode_Pos
 0

	)

866 #define 
	#FPU_MVFR1_FtZ_mode_Msk
 (0xFUL << 
FPU_MVFR1_FtZ_mode_Pos
)

	)

882 
__IO
 
uint32_t
 
DHCSR
;

883 
__O
 
uint32_t
 
DCRSR
;

884 
__IO
 
uint32_t
 
DCRDR
;

885 
__IO
 
uint32_t
 
DEMCR
;

886 } 
	tCoreDebug_Type
;

889 #define 
	#CoreDebug_DHCSR_DBGKEY_Pos
 16

	)

890 #define 
	#CoreDebug_DHCSR_DBGKEY_Msk
 (0xFFFFUL << 
CoreDebug_DHCSR_DBGKEY_Pos
)

	)

892 #define 
	#CoreDebug_DHCSR_S_RESET_ST_Pos
 25

	)

893 #define 
	#CoreDebug_DHCSR_S_RESET_ST_Msk
 (1UL << 
CoreDebug_DHCSR_S_RESET_ST_Pos
)

	)

895 #define 
	#CoreDebug_DHCSR_S_RETIRE_ST_Pos
 24

	)

896 #define 
	#CoreDebug_DHCSR_S_RETIRE_ST_Msk
 (1UL << 
CoreDebug_DHCSR_S_RETIRE_ST_Pos
)

	)

898 #define 
	#CoreDebug_DHCSR_S_LOCKUP_Pos
 19

	)

899 #define 
	#CoreDebug_DHCSR_S_LOCKUP_Msk
 (1UL << 
CoreDebug_DHCSR_S_LOCKUP_Pos
)

	)

901 #define 
	#CoreDebug_DHCSR_S_SLEEP_Pos
 18

	)

902 #define 
	#CoreDebug_DHCSR_S_SLEEP_Msk
 (1UL << 
CoreDebug_DHCSR_S_SLEEP_Pos
)

	)

904 #define 
	#CoreDebug_DHCSR_S_HALT_Pos
 17

	)

905 #define 
	#CoreDebug_DHCSR_S_HALT_Msk
 (1UL << 
CoreDebug_DHCSR_S_HALT_Pos
)

	)

907 #define 
	#CoreDebug_DHCSR_S_REGRDY_Pos
 16

	)

908 #define 
	#CoreDebug_DHCSR_S_REGRDY_Msk
 (1UL << 
CoreDebug_DHCSR_S_REGRDY_Pos
)

	)

910 #define 
	#CoreDebug_DHCSR_C_SNAPSTALL_Pos
 5

	)

911 #define 
	#CoreDebug_DHCSR_C_SNAPSTALL_Msk
 (1UL << 
CoreDebug_DHCSR_C_SNAPSTALL_Pos
)

	)

913 #define 
	#CoreDebug_DHCSR_C_MASKINTS_Pos
 3

	)

914 #define 
	#CoreDebug_DHCSR_C_MASKINTS_Msk
 (1UL << 
CoreDebug_DHCSR_C_MASKINTS_Pos
)

	)

916 #define 
	#CoreDebug_DHCSR_C_STEP_Pos
 2

	)

917 #define 
	#CoreDebug_DHCSR_C_STEP_Msk
 (1UL << 
CoreDebug_DHCSR_C_STEP_Pos
)

	)

919 #define 
	#CoreDebug_DHCSR_C_HALT_Pos
 1

	)

920 #define 
	#CoreDebug_DHCSR_C_HALT_Msk
 (1UL << 
CoreDebug_DHCSR_C_HALT_Pos
)

	)

922 #define 
	#CoreDebug_DHCSR_C_DEBUGEN_Pos
 0

	)

923 #define 
	#CoreDebug_DHCSR_C_DEBUGEN_Msk
 (1UL << 
CoreDebug_DHCSR_C_DEBUGEN_Pos
)

	)

926 #define 
	#CoreDebug_DCRSR_REGWnR_Pos
 16

	)

927 #define 
	#CoreDebug_DCRSR_REGWnR_Msk
 (1UL << 
CoreDebug_DCRSR_REGWnR_Pos
)

	)

929 #define 
	#CoreDebug_DCRSR_REGSEL_Pos
 0

	)

930 #define 
	#CoreDebug_DCRSR_REGSEL_Msk
 (0x1FUL << 
CoreDebug_DCRSR_REGSEL_Pos
)

	)

933 #define 
	#CoreDebug_DEMCR_TRCENA_Pos
 24

	)

934 #define 
	#CoreDebug_DEMCR_TRCENA_Msk
 (1UL << 
CoreDebug_DEMCR_TRCENA_Pos
)

	)

936 #define 
	#CoreDebug_DEMCR_MON_REQ_Pos
 19

	)

937 #define 
	#CoreDebug_DEMCR_MON_REQ_Msk
 (1UL << 
CoreDebug_DEMCR_MON_REQ_Pos
)

	)

939 #define 
	#CoreDebug_DEMCR_MON_STEP_Pos
 18

	)

940 #define 
	#CoreDebug_DEMCR_MON_STEP_Msk
 (1UL << 
CoreDebug_DEMCR_MON_STEP_Pos
)

	)

942 #define 
	#CoreDebug_DEMCR_MON_PEND_Pos
 17

	)

943 #define 
	#CoreDebug_DEMCR_MON_PEND_Msk
 (1UL << 
CoreDebug_DEMCR_MON_PEND_Pos
)

	)

945 #define 
	#CoreDebug_DEMCR_MON_EN_Pos
 16

	)

946 #define 
	#CoreDebug_DEMCR_MON_EN_Msk
 (1UL << 
CoreDebug_DEMCR_MON_EN_Pos
)

	)

948 #define 
	#CoreDebug_DEMCR_VC_HARDERR_Pos
 10

	)

949 #define 
	#CoreDebug_DEMCR_VC_HARDERR_Msk
 (1UL << 
CoreDebug_DEMCR_VC_HARDERR_Pos
)

	)

951 #define 
	#CoreDebug_DEMCR_VC_INTERR_Pos
 9

	)

952 #define 
	#CoreDebug_DEMCR_VC_INTERR_Msk
 (1UL << 
CoreDebug_DEMCR_VC_INTERR_Pos
)

	)

954 #define 
	#CoreDebug_DEMCR_VC_BUSERR_Pos
 8

	)

955 #define 
	#CoreDebug_DEMCR_VC_BUSERR_Msk
 (1UL << 
CoreDebug_DEMCR_VC_BUSERR_Pos
)

	)

957 #define 
	#CoreDebug_DEMCR_VC_STATERR_Pos
 7

	)

958 #define 
	#CoreDebug_DEMCR_VC_STATERR_Msk
 (1UL << 
CoreDebug_DEMCR_VC_STATERR_Pos
)

	)

960 #define 
	#CoreDebug_DEMCR_VC_CHKERR_Pos
 6

	)

961 #define 
	#CoreDebug_DEMCR_VC_CHKERR_Msk
 (1UL << 
CoreDebug_DEMCR_VC_CHKERR_Pos
)

	)

963 #define 
	#CoreDebug_DEMCR_VC_NOCPERR_Pos
 5

	)

964 #define 
	#CoreDebug_DEMCR_VC_NOCPERR_Msk
 (1UL << 
CoreDebug_DEMCR_VC_NOCPERR_Pos
)

	)

966 #define 
	#CoreDebug_DEMCR_VC_MMERR_Pos
 4

	)

967 #define 
	#CoreDebug_DEMCR_VC_MMERR_Msk
 (1UL << 
CoreDebug_DEMCR_VC_MMERR_Pos
)

	)

969 #define 
	#CoreDebug_DEMCR_VC_CORERESET_Pos
 0

	)

970 #define 
	#CoreDebug_DEMCR_VC_CORERESET_Msk
 (1UL << 
CoreDebug_DEMCR_VC_CORERESET_Pos
)

	)

980 #define 
	#SCS_BASE
 (0xE000E000UL)

	)

981 #define 
	#ITM_BASE
 (0xE0000000UL)

	)

982 #define 
	#CoreDebug_BASE
 (0xE000EDF0UL)

	)

983 #define 
	#SysTick_BASE
 (
SCS_BASE
 + 0x0010UL)

	)

984 #define 
	#NVIC_BASE
 (
SCS_BASE
 + 0x0100UL)

	)

985 #define 
	#SCB_BASE
 (
SCS_BASE
 + 0x0D00UL)

	)

987 #define 
	#SCnSCB
 ((
SCnSCB_Type
 *) 
SCS_BASE
 )

	)

988 #define 
	#SCB
 ((
SCB_Type
 *) 
SCB_BASE
 )

	)

989 #define 
	#SysTick
 ((
SysTick_Type
 *) 
SysTick_BASE
 )

	)

990 #define 
	#NVIC
 ((
NVIC_Type
 *) 
NVIC_BASE
 )

	)

991 #define 
	#ITM
 ((
ITM_Type
 *) 
ITM_BASE
 )

	)

992 #define 
	#CoreDebug
 ((
CoreDebug_Type
 *) 
CoreDebug_BASE
)

	)

994 #if (
__MPU_PRESENT
 == 1)

995 #define 
	#MPU_BASE
 (
SCS_BASE
 + 0x0D90UL)

	)

996 #define 
	#MPU
 ((
MPU_Type
 *) 
MPU_BASE
 )

	)

999 #if (
__FPU_PRESENT
 == 1)

1000 #define 
	#FPU_BASE
 (
SCS_BASE
 + 0x0F30UL)

	)

1001 #define 
	#FPU
 ((
FPU_Type
 *) 
FPU_BASE
 )

	)

1037 static 
__INLINE
 void 
NVIC_SetPriorityGrouping
(
uint32_t
 
PriorityGroup
)

1039 
uint32_t
 
reg_value
;

1040 
uint32_t
 
PriorityGroupTmp
 = (
PriorityGroup
 & (uint32_t)0x07);

1042 
reg_value
 = 
SCB
->
AIRCR
;

1043 
reg_value
 &= ~(
SCB_AIRCR_VECTKEY_Msk
 | 
SCB_AIRCR_PRIGROUP_Msk
);

1044 
reg_value
 = (reg_value |

1045 ((
uint32_t
)0x5FA << 
SCB_AIRCR_VECTKEY_Pos
) |

1046 (
PriorityGroupTmp
 << 8));

1047 
SCB
->
AIRCR
 = 
reg_value
;

1058 static 
__INLINE
 
uint32_t
 
NVIC_GetPriorityGrouping
(void)

1060 return ((
SCB
->
AIRCR
 & 
SCB_AIRCR_PRIGROUP_Msk
) >> 
SCB_AIRCR_PRIGROUP_Pos
);

1071 static 
__INLINE
 void 
NVIC_EnableIRQ
(
IRQn_Type
 
IRQn
)

1074 
NVIC
->
ISER
[(
uint32_t
)((
int32_t
)
IRQn
) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F));

1085 static 
__INLINE
 void 
NVIC_DisableIRQ
(
IRQn_Type
 
IRQn
)

1087 
NVIC
->
ICER
[((
uint32_t
)(
IRQn
) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));

1100 static 
__INLINE
 
uint32_t
 
NVIC_GetPendingIRQ
(
IRQn_Type
 
IRQn
)

1102 return((
uint32_t
) ((
NVIC
->
ISPR
[(uint32_t)(
IRQn
) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));

1113 static 
__INLINE
 void 
NVIC_SetPendingIRQ
(
IRQn_Type
 
IRQn
)

1115 
NVIC
->
ISPR
[((
uint32_t
)(
IRQn
) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));

1126 static 
__INLINE
 void 
NVIC_ClearPendingIRQ
(
IRQn_Type
 
IRQn
)

1128 
NVIC
->
ICPR
[((
uint32_t
)(
IRQn
) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));

1139 static 
__INLINE
 
uint32_t
 
NVIC_GetActive
(
IRQn_Type
 
IRQn
)

1141 return((
uint32_t
)((
NVIC
->
IABR
[(uint32_t)(
IRQn
) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));

1156 static 
__INLINE
 void 
NVIC_SetPriority
(
IRQn_Type
 
IRQn
, 
uint32_t
 
priority
)

1158 if(
IRQn
 < 0) {

1159 
SCB
->
SHP
[((
uint32_t
)(
IRQn
) & 0xF)-4] = ((
priority
 << (8 - 
__NVIC_PRIO_BITS
)) & 0xff); }

1161 
NVIC
->
IP
[(
uint32_t
)(
IRQn
)] = ((
priority
 << (8 - 
__NVIC_PRIO_BITS
)) & 0xff); }

1177 static 
__INLINE
 
uint32_t
 
NVIC_GetPriority
(
IRQn_Type
 
IRQn
)

1180 if(
IRQn
 < 0) {

1181 return((
uint32_t
)(
SCB
->
SHP
[((uint32_t)(
IRQn
) & 0xF)-4] >> (8 - 
__NVIC_PRIO_BITS
))); }

1183 return((
uint32_t
)(
NVIC
->
IP
[(uint32_t)(
IRQn
)] >> (8 - 
__NVIC_PRIO_BITS
))); }

1201 static 
__INLINE
 
uint32_t
 
NVIC_EncodePriority
 (uint32_t 
PriorityGroup
, uint32_t 
PreemptPriority
, uint32_t 
SubPriority
)

1203 
uint32_t
 
PriorityGroupTmp
 = (
PriorityGroup
 & 0x07);

1204 
uint32_t
 
PreemptPriorityBits
;

1205 
uint32_t
 
SubPriorityBits
;

1207 
PreemptPriorityBits
 = ((7 - 
PriorityGroupTmp
) > 
__NVIC_PRIO_BITS
) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;

1208 
SubPriorityBits
 = ((
PriorityGroupTmp
 + 
__NVIC_PRIO_BITS
) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

1211 ((
PreemptPriority
 & ((1 << (
PreemptPriorityBits
)) - 1)) << 
SubPriorityBits
) |

1212 ((
SubPriority
 & ((1 << (
SubPriorityBits
 )) - 1)))

1231 static 
__INLINE
 void 
NVIC_DecodePriority
 (
uint32_t
 
Priority
, uint32_t 
PriorityGroup
, uint32_t* 
pPreemptPriority
, uint32_t* 
pSubPriority
)

1233 
uint32_t
 
PriorityGroupTmp
 = (
PriorityGroup
 & 0x07);

1234 
uint32_t
 
PreemptPriorityBits
;

1235 
uint32_t
 
SubPriorityBits
;

1237 
PreemptPriorityBits
 = ((7 - 
PriorityGroupTmp
) > 
__NVIC_PRIO_BITS
) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;

1238 
SubPriorityBits
 = ((
PriorityGroupTmp
 + 
__NVIC_PRIO_BITS
) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;

1240 *
pPreemptPriority
 = (
Priority
 >> 
SubPriorityBits
) & ((1 << (
PreemptPriorityBits
)) - 1);

1241 *
pSubPriority
 = (
Priority
 ) & ((1 << (
SubPriorityBits
 )) - 1);

1249 static 
__INLINE
 void 
NVIC_SystemReset
(void)

1251 
__DSB
();

1253 
SCB
->
AIRCR
 = ((0x5FA << 
SCB_AIRCR_VECTKEY_Pos
) |

1254 (
SCB
->
AIRCR
 & 
SCB_AIRCR_PRIGROUP_Msk
) |

1255 
SCB_AIRCR_SYSRESETREQ_Msk
);

1256 
__DSB
();

1270 #if (
__Vendor_SysTickConfig
 == 0)

1281 static 
__INLINE
 
uint32_t
 
SysTick_Config
(uint32_t 
ticks
)

1283 if (
ticks
 > 
SysTick_LOAD_RELOAD_Msk
) return (1);

1285 
SysTick
->
LOAD
 = (
ticks
 & 
SysTick_LOAD_RELOAD_Msk
) - 1;

1286 
NVIC_SetPriority
 (
SysTick_IRQn
, (1<<
__NVIC_PRIO_BITS
) - 1);

1287 
SysTick
->
VAL
 = 0;

1288 
SysTick
->
CTRL
 = 
SysTick_CTRL_CLKSOURCE_Msk
 |

1289 
SysTick_CTRL_TICKINT_Msk
 |

1290 
SysTick_CTRL_ENABLE_Msk
;

1306 extern volatile 
int32_t
 
ITM_RxBuffer
;

1307 #define 
	#ITM_RXBUFFER_EMPTY
 0x5AA55AA5

	)

1319 static 
__INLINE
 
uint32_t
 
ITM_SendChar
 (uint32_t 
ch
)

1321 if ((
	gCoreDebug
->
	gDEMCR
 & 
	gCoreDebug_DEMCR_TRCENA_Msk
) &&

1322 (
	gITM
->
	gTCR
 & 
	gITM_TCR_ITMENA_Msk
) &&

1323 (
	gITM
->
	gTER
 & (1UL << 0) ) )

1325 while (
	gITM
->
	gPORT
[0].
	gu32
 == 0);

1326 
	gITM
->
	gPORT
[0].
	gu8
 = (
uint8_t
) 
ch
;

1328 return (
	gch
);

1341 static 
__INLINE
 
int32_t
 
ITM_ReceiveChar
 (void) {

1342 
int32_t
 
	gch
 = -1;

1344 if (
	gITM_RxBuffer
 != 
ITM_RXBUFFER_EMPTY
) {

1345 
ch
 = 
ITM_RxBuffer
;

1346 
	gITM_RxBuffer
 = 
ITM_RXBUFFER_EMPTY
;

1349 return (
	gch
);

1361 static 
__INLINE
 
int32_t
 
ITM_CheckChar
 (void) {

1363 if (
	gITM_RxBuffer
 == 
ITM_RXBUFFER_EMPTY
) {

1376 #ifdef 
__cplusplus


	@Libraries/CMSIS/Include/core_cm4_simd.h

24 #ifdef 
__cplusplus


28 #ifndef 
__CORE_CM4_SIMD_H


29 #define 
	#__CORE_CM4_SIMD_H


	)

43 #if 
defined
 ( 
__CC_ARM
 )

47 #define 
	#__SADD8
 
__sadd8


	)

48 #define 
	#__QADD8
 
__qadd8


	)

49 #define 
	#__SHADD8
 
__shadd8


	)

50 #define 
	#__UADD8
 
__uadd8


	)

51 #define 
	#__UQADD8
 
__uqadd8


	)

52 #define 
	#__UHADD8
 
__uhadd8


	)

53 #define 
	#__SSUB8
 
__ssub8


	)

54 #define 
	#__QSUB8
 
__qsub8


	)

55 #define 
	#__SHSUB8
 
__shsub8


	)

56 #define 
	#__USUB8
 
__usub8


	)

57 #define 
	#__UQSUB8
 
__uqsub8


	)

58 #define 
	#__UHSUB8
 
__uhsub8


	)

59 #define 
	#__SADD16
 
__sadd16


	)

60 #define 
	#__QADD16
 
__qadd16


	)

61 #define 
	#__SHADD16
 
__shadd16


	)

62 #define 
	#__UADD16
 
__uadd16


	)

63 #define 
	#__UQADD16
 
__uqadd16


	)

64 #define 
	#__UHADD16
 
__uhadd16


	)

65 #define 
	#__SSUB16
 
__ssub16


	)

66 #define 
	#__QSUB16
 
__qsub16


	)

67 #define 
	#__SHSUB16
 
__shsub16


	)

68 #define 
	#__USUB16
 
__usub16


	)

69 #define 
	#__UQSUB16
 
__uqsub16


	)

70 #define 
	#__UHSUB16
 
__uhsub16


	)

71 #define 
	#__SASX
 
__sasx


	)

72 #define 
	#__QASX
 
__qasx


	)

73 #define 
	#__SHASX
 
__shasx


	)

74 #define 
	#__UASX
 
__uasx


	)

75 #define 
	#__UQASX
 
__uqasx


	)

76 #define 
	#__UHASX
 
__uhasx


	)

77 #define 
	#__SSAX
 
__ssax


	)

78 #define 
	#__QSAX
 
__qsax


	)

79 #define 
	#__SHSAX
 
__shsax


	)

80 #define 
	#__USAX
 
__usax


	)

81 #define 
	#__UQSAX
 
__uqsax


	)

82 #define 
	#__UHSAX
 
__uhsax


	)

83 #define 
	#__USAD8
 
__usad8


	)

84 #define 
	#__USADA8
 
__usada8


	)

85 #define 
	#__SSAT16
 
__ssat16


	)

86 #define 
	#__USAT16
 
__usat16


	)

87 #define 
	#__UXTB16
 
__uxtb16


	)

88 #define 
	#__UXTAB16
 
__uxtab16


	)

89 #define 
	#__SXTB16
 
__sxtb16


	)

90 #define 
	#__SXTAB16
 
__sxtab16


	)

91 #define 
	#__SMUAD
 
__smuad


	)

92 #define 
	#__SMUADX
 
__smuadx


	)

93 #define 
	#__SMLAD
 
__smlad


	)

94 #define 
	#__SMLADX
 
__smladx


	)

95 #define 
	#__SMLALD
 
__smlald


	)

96 #define 
	#__SMLALDX
 
__smlaldx


	)

97 #define 
	#__SMUSD
 
__smusd


	)

98 #define 
	#__SMUSDX
 
__smusdx


	)

99 #define 
	#__SMLSD
 
__smlsd


	)

100 #define 
	#__SMLSDX
 
__smlsdx


	)

101 #define 
	#__SMLSLD
 
__smlsld


	)

102 #define 
	#__SMLSLDX
 
__smlsldx


	)

103 #define 
	#__SEL
 
__sel


	)

104 #define 
	#__QADD
 
__qadd


	)

105 #define 
	#__QSUB
 
__qsub


	)

107 #define 
	#__PKHBT
(
ARG1
,
ARG2
,
ARG3
) ( ((((
uint32_t
)(ARG1)) ) & 0x0000FFFFUL) | \

	)

108 ((((
uint32_t
)(
ARG2
)) << (
ARG3
)) & 0xFFFF0000UL) )

110 #define 
	#__PKHTB
(
ARG1
,
ARG2
,
ARG3
) ( ((((
uint32_t
)(ARG1)) ) & 0xFFFF0000UL) | \

	)

111 ((((
uint32_t
)(
ARG2
)) >> (
ARG3
)) & 0x0000FFFFUL) )

118 #elif 
defined
 ( 
__ICCARM__
 )

121 #include 
	~<cmsis_iar.h
>

190 #elif 
defined
 ( 
__GNUC__
 )

194 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SADD8
(
uint32_t
 
op1
, uint32_t 
op2
)

196 
uint32_t
 
result
;

198 
__ASM
 volatile ("sadd8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

199 return(
result
);

200 
	}
}

202 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QADD8
(
uint32_t
 
op1
, uint32_t 
op2
)

204 
uint32_t
 
result
;

206 
__ASM
 volatile ("qadd8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

207 return(
result
);

208 
	}
}

210 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SHADD8
(
uint32_t
 
op1
, uint32_t 
op2
)

212 
uint32_t
 
result
;

214 
__ASM
 volatile ("shadd8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

215 return(
result
);

216 
	}
}

218 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UADD8
(
uint32_t
 
op1
, uint32_t 
op2
)

220 
uint32_t
 
result
;

222 
__ASM
 volatile ("uadd8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

223 return(
result
);

224 
	}
}

226 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UQADD8
(
uint32_t
 
op1
, uint32_t 
op2
)

228 
uint32_t
 
result
;

230 
__ASM
 volatile ("uqadd8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

231 return(
result
);

232 
	}
}

234 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UHADD8
(
uint32_t
 
op1
, uint32_t 
op2
)

236 
uint32_t
 
result
;

238 
__ASM
 volatile ("uhadd8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

239 return(
result
);

240 
	}
}

243 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SSUB8
(
uint32_t
 
op1
, uint32_t 
op2
)

245 
uint32_t
 
result
;

247 
__ASM
 volatile ("ssub8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

248 return(
result
);

249 
	}
}

251 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QSUB8
(
uint32_t
 
op1
, uint32_t 
op2
)

253 
uint32_t
 
result
;

255 
__ASM
 volatile ("qsub8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

256 return(
result
);

257 
	}
}

259 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SHSUB8
(
uint32_t
 
op1
, uint32_t 
op2
)

261 
uint32_t
 
result
;

263 
__ASM
 volatile ("shsub8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

264 return(
result
);

265 
	}
}

267 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__USUB8
(
uint32_t
 
op1
, uint32_t 
op2
)

269 
uint32_t
 
result
;

271 
__ASM
 volatile ("usub8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

272 return(
result
);

273 
	}
}

275 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UQSUB8
(
uint32_t
 
op1
, uint32_t 
op2
)

277 
uint32_t
 
result
;

279 
__ASM
 volatile ("uqsub8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

280 return(
result
);

281 
	}
}

283 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UHSUB8
(
uint32_t
 
op1
, uint32_t 
op2
)

285 
uint32_t
 
result
;

287 
__ASM
 volatile ("uhsub8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

288 return(
result
);

289 
	}
}

292 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SADD16
(
uint32_t
 
op1
, uint32_t 
op2
)

294 
uint32_t
 
result
;

296 
__ASM
 volatile ("sadd16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

297 return(
result
);

298 
	}
}

300 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QADD16
(
uint32_t
 
op1
, uint32_t 
op2
)

302 
uint32_t
 
result
;

304 
__ASM
 volatile ("qadd16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

305 return(
result
);

306 
	}
}

308 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SHADD16
(
uint32_t
 
op1
, uint32_t 
op2
)

310 
uint32_t
 
result
;

312 
__ASM
 volatile ("shadd16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

313 return(
result
);

314 
	}
}

316 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UADD16
(
uint32_t
 
op1
, uint32_t 
op2
)

318 
uint32_t
 
result
;

320 
__ASM
 volatile ("uadd16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

321 return(
result
);

322 
	}
}

324 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UQADD16
(
uint32_t
 
op1
, uint32_t 
op2
)

326 
uint32_t
 
result
;

328 
__ASM
 volatile ("uqadd16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

329 return(
result
);

330 
	}
}

332 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UHADD16
(
uint32_t
 
op1
, uint32_t 
op2
)

334 
uint32_t
 
result
;

336 
__ASM
 volatile ("uhadd16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

337 return(
result
);

338 
	}
}

340 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SSUB16
(
uint32_t
 
op1
, uint32_t 
op2
)

342 
uint32_t
 
result
;

344 
__ASM
 volatile ("ssub16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

345 return(
result
);

346 
	}
}

348 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QSUB16
(
uint32_t
 
op1
, uint32_t 
op2
)

350 
uint32_t
 
result
;

352 
__ASM
 volatile ("qsub16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

353 return(
result
);

354 
	}
}

356 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SHSUB16
(
uint32_t
 
op1
, uint32_t 
op2
)

358 
uint32_t
 
result
;

360 
__ASM
 volatile ("shsub16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

361 return(
result
);

362 
	}
}

364 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__USUB16
(
uint32_t
 
op1
, uint32_t 
op2
)

366 
uint32_t
 
result
;

368 
__ASM
 volatile ("usub16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

369 return(
result
);

370 
	}
}

372 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UQSUB16
(
uint32_t
 
op1
, uint32_t 
op2
)

374 
uint32_t
 
result
;

376 
__ASM
 volatile ("uqsub16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

377 return(
result
);

378 
	}
}

380 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UHSUB16
(
uint32_t
 
op1
, uint32_t 
op2
)

382 
uint32_t
 
result
;

384 
__ASM
 volatile ("uhsub16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

385 return(
result
);

386 
	}
}

388 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SASX
(
uint32_t
 
op1
, uint32_t 
op2
)

390 
uint32_t
 
result
;

392 
__ASM
 volatile ("sasx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

393 return(
result
);

394 
	}
}

396 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QASX
(
uint32_t
 
op1
, uint32_t 
op2
)

398 
uint32_t
 
result
;

400 
__ASM
 volatile ("qasx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

401 return(
result
);

402 
	}
}

404 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SHASX
(
uint32_t
 
op1
, uint32_t 
op2
)

406 
uint32_t
 
result
;

408 
__ASM
 volatile ("shasx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

409 return(
result
);

410 
	}
}

412 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UASX
(
uint32_t
 
op1
, uint32_t 
op2
)

414 
uint32_t
 
result
;

416 
__ASM
 volatile ("uasx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

417 return(
result
);

418 
	}
}

420 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UQASX
(
uint32_t
 
op1
, uint32_t 
op2
)

422 
uint32_t
 
result
;

424 
__ASM
 volatile ("uqasx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

425 return(
result
);

426 
	}
}

428 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UHASX
(
uint32_t
 
op1
, uint32_t 
op2
)

430 
uint32_t
 
result
;

432 
__ASM
 volatile ("uhasx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

433 return(
result
);

434 
	}
}

436 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SSAX
(
uint32_t
 
op1
, uint32_t 
op2
)

438 
uint32_t
 
result
;

440 
__ASM
 volatile ("ssax %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

441 return(
result
);

442 
	}
}

444 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QSAX
(
uint32_t
 
op1
, uint32_t 
op2
)

446 
uint32_t
 
result
;

448 
__ASM
 volatile ("qsax %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

449 return(
result
);

450 
	}
}

452 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SHSAX
(
uint32_t
 
op1
, uint32_t 
op2
)

454 
uint32_t
 
result
;

456 
__ASM
 volatile ("shsax %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

457 return(
result
);

458 
	}
}

460 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__USAX
(
uint32_t
 
op1
, uint32_t 
op2
)

462 
uint32_t
 
result
;

464 
__ASM
 volatile ("usax %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

465 return(
result
);

466 
	}
}

468 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UQSAX
(
uint32_t
 
op1
, uint32_t 
op2
)

470 
uint32_t
 
result
;

472 
__ASM
 volatile ("uqsax %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

473 return(
result
);

474 
	}
}

476 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UHSAX
(
uint32_t
 
op1
, uint32_t 
op2
)

478 
uint32_t
 
result
;

480 
__ASM
 volatile ("uhsax %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

481 return(
result
);

482 
	}
}

484 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__USAD8
(
uint32_t
 
op1
, uint32_t 
op2
)

486 
uint32_t
 
result
;

488 
__ASM
 volatile ("usad8 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

489 return(
result
);

490 
	}
}

492 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__USADA8
(
uint32_t
 
op1
, uint32_t 
op2
, uint32_t 
op3
)

494 
uint32_t
 
result
;

496 
__ASM
 volatile ("usada8 %0, %1, %2, %3" : "=r" (
result
) : "r" (
op1
), "r" (
op2
), "r" (
op3
) );

497 return(
result
);

498 
	}
}

500 #define 
	#__SSAT16
(
ARG1
,
ARG2
) \

	)

502 
uint32_t
 
__RES
, 
__ARG1
 = (
ARG1
); \

503 
__ASM
 ("ssat16 %0, %1, %2" : "=r" (
__RES
) : "I" (
ARG2
), "r" (
__ARG1
) ); \

504 
__RES
; \

507 #define 
	#__USAT16
(
ARG1
,
ARG2
) \

	)

509 
uint32_t
 
__RES
, 
__ARG1
 = (
ARG1
); \

510 
__ASM
 ("usat16 %0, %1, %2" : "=r" (
__RES
) : "I" (
ARG2
), "r" (
__ARG1
) ); \

511 
__RES
; \

514 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UXTB16
(
uint32_t
 
op1
)

516 
uint32_t
 
result
;

518 
__ASM
 volatile ("uxtb16 %0, %1" : "=r" (
result
) : "r" (
op1
));

519 return(
result
);

520 
	}
}

522 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__UXTAB16
(
uint32_t
 
op1
, uint32_t 
op2
)

524 
uint32_t
 
result
;

526 
__ASM
 volatile ("uxtab16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

527 return(
result
);

528 
	}
}

530 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SXTB16
(
uint32_t
 
op1
)

532 
uint32_t
 
result
;

534 
__ASM
 volatile ("sxtb16 %0, %1" : "=r" (
result
) : "r" (
op1
));

535 return(
result
);

536 
	}
}

538 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SXTAB16
(
uint32_t
 
op1
, uint32_t 
op2
)

540 
uint32_t
 
result
;

542 
__ASM
 volatile ("sxtab16 %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

543 return(
result
);

544 
	}
}

546 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMUAD
 (
uint32_t
 
op1
, uint32_t 
op2
)

548 
uint32_t
 
result
;

550 
__ASM
 volatile ("smuad %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

551 return(
result
);

552 
	}
}

554 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMUADX
 (
uint32_t
 
op1
, uint32_t 
op2
)

556 
uint32_t
 
result
;

558 
__ASM
 volatile ("smuadx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

559 return(
result
);

560 
	}
}

562 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMLAD
 (
uint32_t
 
op1
, uint32_t 
op2
, uint32_t 
op3
)

564 
uint32_t
 
result
;

566 
__ASM
 volatile ("smlad %0, %1, %2, %3" : "=r" (
result
) : "r" (
op1
), "r" (
op2
), "r" (
op3
) );

567 return(
result
);

568 
	}
}

570 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMLADX
 (
uint32_t
 
op1
, uint32_t 
op2
, uint32_t 
op3
)

572 
uint32_t
 
result
;

574 
__ASM
 volatile ("smladx %0, %1, %2, %3" : "=r" (
result
) : "r" (
op1
), "r" (
op2
), "r" (
op3
) );

575 return(
result
);

576 
	}
}

578 #define 
	#__SMLALD
(
ARG1
,
ARG2
,
ARG3
) \

	)

580 
uint32_t
 
__ARG1
 = (
ARG1
), 
__ARG2
 = (
ARG2
), 
__ARG3_H
 = (uint32_t)((
uint64_t
)(
ARG3
) >> 32), 
__ARG3_L
 = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \

581 
__ASM
 volatile ("smlald %0, %1, %2, %3" : "=r" (
__ARG3_L
), "=r" (
__ARG3_H
) : "r" (
__ARG1
), "r" (
__ARG2
), "0" (__ARG3_L), "1" (__ARG3_H) ); \

582 (
uint64_t
)(((uint64_t)
__ARG3_H
 << 32) | 
__ARG3_L
); \

585 #define 
	#__SMLALDX
(
ARG1
,
ARG2
,
ARG3
) \

	)

587 
uint32_t
 
__ARG1
 = (
ARG1
), 
__ARG2
 = (
ARG2
), 
__ARG3_H
 = (uint32_t)((
uint64_t
)(
ARG3
) >> 32), 
__ARG3_L
 = (uint32_t)((uint64_t)(ARG3) & 0xFFFFFFFFUL); \

588 
__ASM
 volatile ("smlaldx %0, %1, %2, %3" : "=r" (
__ARG3_L
), "=r" (
__ARG3_H
) : "r" (
__ARG1
), "r" (
__ARG2
), "0" (__ARG3_L), "1" (__ARG3_H) ); \

589 (
uint64_t
)(((uint64_t)
__ARG3_H
 << 32) | 
__ARG3_L
); \

592 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMUSD
 (
uint32_t
 
op1
, uint32_t 
op2
)

594 
uint32_t
 
result
;

596 
__ASM
 volatile ("smusd %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

597 return(
result
);

598 
	}
}

600 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMUSDX
 (
uint32_t
 
op1
, uint32_t 
op2
)

602 
uint32_t
 
result
;

604 
__ASM
 volatile ("smusdx %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

605 return(
result
);

606 
	}
}

608 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMLSD
 (
uint32_t
 
op1
, uint32_t 
op2
, uint32_t 
op3
)

610 
uint32_t
 
result
;

612 
__ASM
 volatile ("smlsd %0, %1, %2, %3" : "=r" (
result
) : "r" (
op1
), "r" (
op2
), "r" (
op3
) );

613 return(
result
);

614 
	}
}

616 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SMLSDX
 (
uint32_t
 
op1
, uint32_t 
op2
, uint32_t 
op3
)

618 
uint32_t
 
result
;

620 
__ASM
 volatile ("smlsdx %0, %1, %2, %3" : "=r" (
result
) : "r" (
op1
), "r" (
op2
), "r" (
op3
) );

621 return(
result
);

622 
	}
}

624 #define 
	#__SMLSLD
(
ARG1
,
ARG2
,
ARG3
) \

	)

626 
uint32_t
 
__ARG1
 = (
ARG1
), 
__ARG2
 = (
ARG2
), 
__ARG3_H
 = (uint32_t)((
ARG3
) >> 32), 
__ARG3_L
 = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \

627 
__ASM
 volatile ("smlsld %0, %1, %2, %3" : "=r" (
__ARG3_L
), "=r" (
__ARG3_H
) : "r" (
__ARG1
), "r" (
__ARG2
), "0" (__ARG3_L), "1" (__ARG3_H) ); \

628 (
uint64_t
)(((uint64_t)
__ARG3_H
 << 32) | 
__ARG3_L
); \

631 #define 
	#__SMLSLDX
(
ARG1
,
ARG2
,
ARG3
) \

	)

633 
uint32_t
 
__ARG1
 = (
ARG1
), 
__ARG2
 = (
ARG2
), 
__ARG3_H
 = (uint32_t)((
ARG3
) >> 32), 
__ARG3_L
 = (uint32_t)((ARG3) & 0xFFFFFFFFUL); \

634 
__ASM
 volatile ("smlsldx %0, %1, %2, %3" : "=r" (
__ARG3_L
), "=r" (
__ARG3_H
) : "r" (
__ARG1
), "r" (
__ARG2
), "0" (__ARG3_L), "1" (__ARG3_H) ); \

635 (
uint64_t
)(((uint64_t)
__ARG3_H
 << 32) | 
__ARG3_L
); \

638 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__SEL
 (
uint32_t
 
op1
, uint32_t 
op2
)

640 
uint32_t
 
result
;

642 
__ASM
 volatile ("sel %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

643 return(
result
);

644 
	}
}

646 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QADD
(
uint32_t
 
op1
, uint32_t 
op2
)

648 
uint32_t
 
result
;

650 
__ASM
 volatile ("qadd %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

651 return(
result
);

652 
	}
}

654 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__QSUB
(
uint32_t
 
op1
, uint32_t 
op2
)

656 
uint32_t
 
result
;

658 
__ASM
 volatile ("qsub %0, %1, %2" : "=r" (
result
) : "r" (
op1
), "r" (
op2
) );

659 return(
result
);

660 
	}
}

662 #define 
	#__PKHBT
(
ARG1
,
ARG2
,
ARG3
) \

	)

664 
uint32_t
 
__RES
, 
__ARG1
 = (
ARG1
), 
__ARG2
 = (
ARG2
); \

665 
__ASM
 ("pkhbt %0, %1, %2, lsl %3" : "=r" (
__RES
) : "r" (
__ARG1
), "r" (
__ARG2
), "I" (
ARG3
) ); \

666 
__RES
; \

669 #define 
	#__PKHTB
(
ARG1
,
ARG2
,
ARG3
) \

	)

671 
uint32_t
 
__RES
, 
__ARG1
 = (
ARG1
), 
__ARG2
 = (
ARG2
); \

672 if (
ARG3
 == 0) \

673 
__ASM
 ("pkhtb %0, %1, %2" : "=r" (
__RES
) : "r" (
__ARG1
), "r" (
__ARG2
) ); \

675 
__ASM
 ("pkhtb %0, %1, %2, asr %3" : "=r" (
__RES
) : "r" (
__ARG1
), "r" (
__ARG2
), "I" (
ARG3
) ); \

676 
__RES
; \

683 #elif 
defined
 ( 
__TASKING__
 )

699 #ifdef 
__cplusplus


	@Libraries/CMSIS/Include/core_cmFunc.h

24 #ifndef 
__CORE_CMFUNC_H


25 #define 
	#__CORE_CMFUNC_H


	)

34 #if 
defined
 ( 
__CC_ARM
 )

37 #if (
__ARMCC_VERSION
 < 400677)

50 static 
__INLINE
 
uint32_t
 
	$__get_CONTROL
(void)

52 register 
uint32_t
 
__regControl
 
	`__ASM
("control");

53 return(
__regControl
);

54 
	}
}

63 static 
__INLINE
 void 
	$__set_CONTROL
(
uint32_t
 
control
)

65 register 
uint32_t
 
__regControl
 
	`__ASM
("control");

66 
__regControl
 = 
control
;

67 
	}
}

76 static 
__INLINE
 
uint32_t
 
	$__get_IPSR
(void)

78 register 
uint32_t
 
__regIPSR
 
	`__ASM
("ipsr");

79 return(
__regIPSR
);

80 
	}
}

89 static 
__INLINE
 
uint32_t
 
	$__get_APSR
(void)

91 register 
uint32_t
 
__regAPSR
 
	`__ASM
("apsr");

92 return(
__regAPSR
);

93 
	}
}

102 static 
__INLINE
 
uint32_t
 
	$__get_xPSR
(void)

104 register 
uint32_t
 
__regXPSR
 
	`__ASM
("xpsr");

105 return(
__regXPSR
);

106 
	}
}

115 static 
__INLINE
 
uint32_t
 
	$__get_PSP
(void)

117 register 
uint32_t
 
__regProcessStackPointer
 
	`__ASM
("psp");

118 return(
__regProcessStackPointer
);

119 
	}
}

128 static 
__INLINE
 void 
	$__set_PSP
(
uint32_t
 
topOfProcStack
)

130 register 
uint32_t
 
__regProcessStackPointer
 
	`__ASM
("psp");

131 
__regProcessStackPointer
 = 
topOfProcStack
;

132 
	}
}

141 static 
__INLINE
 
uint32_t
 
	$__get_MSP
(void)

143 register 
uint32_t
 
__regMainStackPointer
 
	`__ASM
("msp");

144 return(
__regMainStackPointer
);

145 
	}
}

154 static 
__INLINE
 void 
	$__set_MSP
(
uint32_t
 
topOfMainStack
)

156 register 
uint32_t
 
__regMainStackPointer
 
	`__ASM
("msp");

157 
__regMainStackPointer
 = 
topOfMainStack
;

158 
	}
}

167 static 
__INLINE
 
uint32_t
 
	$__get_PRIMASK
(void)

169 register 
uint32_t
 
__regPriMask
 
	`__ASM
("primask");

170 return(
__regPriMask
);

171 
	}
}

180 static 
__INLINE
 void 
	$__set_PRIMASK
(
uint32_t
 
priMask
)

182 register 
uint32_t
 
__regPriMask
 
	`__ASM
("primask");

183 
__regPriMask
 = (
priMask
);

184 
	}
}

187 #if (
__CORTEX_M
 >= 0x03)

194 #define 
	#__enable_fault_irq
 
__enable_fiq


	)

202 #define 
	#__disable_fault_irq
 
__disable_fiq


	)

211 static 
__INLINE
 
uint32_t
 
	$__get_BASEPRI
(void)

213 register 
uint32_t
 
__regBasePri
 
	`__ASM
("basepri");

214 return(
__regBasePri
);

215 
	}
}

224 static 
__INLINE
 void 
	$__set_BASEPRI
(
uint32_t
 
basePri
)

226 register 
uint32_t
 
__regBasePri
 
	`__ASM
("basepri");

227 
__regBasePri
 = (
basePri
 & 0xff);

228 
	}
}

237 static 
__INLINE
 
uint32_t
 
	$__get_FAULTMASK
(void)

239 register 
uint32_t
 
__regFaultMask
 
	`__ASM
("faultmask");

240 return(
__regFaultMask
);

241 
	}
}

250 static 
__INLINE
 void 
	$__set_FAULTMASK
(
uint32_t
 
faultMask
)

252 register 
uint32_t
 
__regFaultMask
 
	`__ASM
("faultmask");

253 
__regFaultMask
 = (
faultMask
 & (
uint32_t
)1);

254 
	}
}

259 #if (
__CORTEX_M
 == 0x04)

267 static 
__INLINE
 
uint32_t
 
	$__get_FPSCR
(void)

269 #if (
__FPU_PRESENT
 == 1) && (
__FPU_USED
 == 1)

270 register 
uint32_t
 
__regfpscr
 
	`__ASM
("fpscr");

271 return(
__regfpscr
);

275 
	}
}

284 static 
__INLINE
 void 
	$__set_FPSCR
(
uint32_t
 
fpscr
)

286 #if (
__FPU_PRESENT
 == 1) && (
__FPU_USED
 == 1)

287 register 
uint32_t
 
__regfpscr
 
	`__ASM
("fpscr");

288 
__regfpscr
 = (
fpscr
);

290 
	}
}

295 #elif 
defined
 ( 
__ICCARM__
 )

298 #include 
	~<cmsis_iar.h
>

300 #elif 
defined
 ( 
__GNUC__
 )

308 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__enable_irq
(void)

310 
__ASM
 volatile ("cpsie i");

311 
	}
}

319 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__disable_irq
(void)

321 
__ASM
 volatile ("cpsid i");

322 
	}
}

331 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_CONTROL
(void)

333 
uint32_t
 
result
;

335 
__ASM
 volatile ("MRS %0, control" : "=r" (
result
) );

336 return(
result
);

337 
	}
}

346 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__set_CONTROL
(
uint32_t
 
control
)

348 
__ASM
 volatile ("MSR control, %0" : : "r" (
control
) );

349 
	}
}

358 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_IPSR
(void)

360 
uint32_t
 
result
;

362 
__ASM
 volatile ("MRS %0, ipsr" : "=r" (
result
) );

363 return(
result
);

364 
	}
}

373 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_APSR
(void)

375 
uint32_t
 
result
;

377 
__ASM
 volatile ("MRS %0, apsr" : "=r" (
result
) );

378 return(
result
);

379 
	}
}

388 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_xPSR
(void)

390 
uint32_t
 
result
;

392 
__ASM
 volatile ("MRS %0, xpsr" : "=r" (
result
) );

393 return(
result
);

394 
	}
}

403 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_PSP
(void)

405 register 
uint32_t
 
result
;

407 
__ASM
 volatile ("MRS %0, psp\n" : "=r" (
result
) );

408 return(
result
);

409 
	}
}

418 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__set_PSP
(
uint32_t
 
topOfProcStack
)

420 
__ASM
 volatile ("MSR psp, %0\n" : : "r" (
topOfProcStack
) );

421 
	}
}

430 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_MSP
(void)

432 register 
uint32_t
 
result
;

434 
__ASM
 volatile ("MRS %0, msp\n" : "=r" (
result
) );

435 return(
result
);

436 
	}
}

445 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__set_MSP
(
uint32_t
 
topOfMainStack
)

447 
__ASM
 volatile ("MSR msp, %0\n" : : "r" (
topOfMainStack
) );

448 
	}
}

457 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_PRIMASK
(void)

459 
uint32_t
 
result
;

461 
__ASM
 volatile ("MRS %0, primask" : "=r" (
result
) );

462 return(
result
);

463 
	}
}

472 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__set_PRIMASK
(
uint32_t
 
priMask
)

474 
__ASM
 volatile ("MSR primask, %0" : : "r" (
priMask
) );

475 
	}
}

478 #if (
__CORTEX_M
 >= 0x03)

485 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__enable_fault_irq
(void)

487 
__ASM
 volatile ("cpsie f");

488 
	}
}

496 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__disable_fault_irq
(void)

498 
__ASM
 volatile ("cpsid f");

499 
	}
}

508 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_BASEPRI
(void)

510 
uint32_t
 
result
;

512 
__ASM
 volatile ("MRS %0, basepri_max" : "=r" (
result
) );

513 return(
result
);

514 
	}
}

523 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__set_BASEPRI
(
uint32_t
 
value
)

525 
__ASM
 volatile ("MSR basepri, %0" : : "r" (
value
) );

526 
	}
}

535 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_FAULTMASK
(void)

537 
uint32_t
 
result
;

539 
__ASM
 volatile ("MRS %0, faultmask" : "=r" (
result
) );

540 return(
result
);

541 
	}
}

550 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__set_FAULTMASK
(
uint32_t
 
faultMask
)

552 
__ASM
 volatile ("MSR faultmask, %0" : : "r" (
faultMask
) );

553 
	}
}

558 #if (
__CORTEX_M
 == 0x04)

566 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__get_FPSCR
(void)

568 #if (
__FPU_PRESENT
 == 1) && (
__FPU_USED
 == 1)

569 
uint32_t
 
result
;

571 
__ASM
 volatile ("VMRS %0, fpscr" : "=r" (
result
) );

572 return(
result
);

576 
	}
}

585 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__set_FPSCR
(
uint32_t
 
fpscr
)

587 #if (
__FPU_PRESENT
 == 1) && (
__FPU_USED
 == 1)

588 
__ASM
 volatile ("VMSR fpscr, %0" : : "r" (
fpscr
) );

590 
	}
}

595 #elif 
defined
 ( 
__TASKING__
 )

	@Libraries/CMSIS/Include/core_cmInstr.h

24 #ifndef 
__CORE_CMINSTR_H


25 #define 
	#__CORE_CMINSTR_H


	)

34 #if 
defined
 ( 
__CC_ARM
 )

37 #if (
__ARMCC_VERSION
 < 400677)

46 #define 
	#__NOP
 
__nop


	)

54 #define 
	#__WFI
 
__wfi


	)

62 #define 
	#__WFE
 
__wfe


	)

69 #define 
	#__SEV
 
__sev


	)

78 #define 
	#__ISB
() 
	`__isb
(0xF)

	)

86 #define 
	#__DSB
() 
	`__dsb
(0xF)

	)

94 #define 
	#__DMB
() 
	`__dmb
(0xF)

	)

104 #define 
	#__REV
 
__rev


	)

114 static 
__INLINE
 
__ASM
 
uint32_t
 
	$__REV16
(
uint32_t
 
value
)

116 
rev16
 
r0
, r0

117 
bx
 
lr


118 
	}
}

128 static 
__INLINE
 
__ASM
 
int32_t
 
	$__REVSH
(
int32_t
 
value
)

130 
revsh
 
r0
, r0

131 
bx
 
lr


132 
	}
}

135 #if (
__CORTEX_M
 >= 0x03)

144 #define 
	#__RBIT
 
__rbit


	)

154 #define 
	#__LDREXB
(
ptr
) ((
uint8_t
 ) 
	`__ldrex
(ptr))

	)

164 #define 
	#__LDREXH
(
ptr
) ((
uint16_t
) 
	`__ldrex
(ptr))

	)

174 #define 
	#__LDREXW
(
ptr
) ((
uint32_t
 ) 
	`__ldrex
(ptr))

	)

186 #define 
	#__STREXB
(
value
, 
ptr
) 
	`__strex
(value, ptr)

	)

198 #define 
	#__STREXH
(
value
, 
ptr
) 
	`__strex
(value, ptr)

	)

210 #define 
	#__STREXW
(
value
, 
ptr
) 
	`__strex
(value, ptr)

	)

218 #define 
	#__CLREX
 
__clrex


	)

229 #define 
	#__SSAT
 
__ssat


	)

240 #define 
	#__USAT
 
__usat


	)

250 #define 
	#__CLZ
 
__clz


	)

256 #elif 
defined
 ( 
__ICCARM__
 )

259 #include 
	~<cmsis_iar.h
>

262 #elif 
defined
 ( 
__GNUC__
 )

269 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__NOP
(void)

271 
__ASM
 volatile ("nop");

272 
	}
}

280 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__WFI
(void)

282 
__ASM
 volatile ("wfi");

283 
	}
}

291 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__WFE
(void)

293 
__ASM
 volatile ("wfe");

294 
	}
}

301 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__SEV
(void)

303 
__ASM
 volatile ("sev");

304 
	}
}

313 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__ISB
(void)

315 
__ASM
 volatile ("isb");

316 
	}
}

324 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__DSB
(void)

326 
__ASM
 volatile ("dsb");

327 
	}
}

335 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__DMB
(void)

337 
__ASM
 volatile ("dmb");

338 
	}
}

348 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__REV
(
uint32_t
 
value
)

350 
uint32_t
 
result
;

352 
__ASM
 volatile ("rev %0, %1" : "=r" (
result
) : "r" (
value
) );

353 return(
result
);

354 
	}
}

364 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__REV16
(
uint32_t
 
value
)

366 
uint32_t
 
result
;

368 
__ASM
 volatile ("rev16 %0, %1" : "=r" (
result
) : "r" (
value
) );

369 return(
result
);

370 
	}
}

380 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
int32_t
 
	$__REVSH
(
int32_t
 
value
)

382 
uint32_t
 
result
;

384 
__ASM
 volatile ("revsh %0, %1" : "=r" (
result
) : "r" (
value
) );

385 return(
result
);

386 
	}
}

389 #if (
__CORTEX_M
 >= 0x03)

398 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__RBIT
(
uint32_t
 
value
)

400 
uint32_t
 
result
;

402 
__ASM
 volatile ("rbit %0, %1" : "=r" (
result
) : "r" (
value
) );

403 return(
result
);

404 
	}
}

414 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint8_t
 
	$__LDREXB
(volatile 
uint8_t
 *
addr
)

416 
uint8_t
 
result
;

418 
__ASM
 volatile ("ldrexb %0, [%1]" : "=r" (
result
) : "r" (
addr
) );

419 return(
result
);

420 
	}
}

430 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint16_t
 
	$__LDREXH
(volatile 
uint16_t
 *
addr
)

432 
uint16_t
 
result
;

434 
__ASM
 volatile ("ldrexh %0, [%1]" : "=r" (
result
) : "r" (
addr
) );

435 return(
result
);

436 
	}
}

446 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__LDREXW
(volatile 
uint32_t
 *
addr
)

448 
uint32_t
 
result
;

450 
__ASM
 volatile ("ldrex %0, [%1]" : "=r" (
result
) : "r" (
addr
) );

451 return(
result
);

452 
	}
}

464 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__STREXB
(
uint8_t
 
value
, volatile uint8_t *
addr
)

466 
uint32_t
 
result
;

468 
__ASM
 volatile ("strexb %0, %2, [%1]" : "=r" (
result
) : "r" (
addr
), "r" (
value
) );

469 return(
result
);

470 
	}
}

482 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__STREXH
(
uint16_t
 
value
, volatile uint16_t *
addr
)

484 
uint32_t
 
result
;

486 
__ASM
 volatile ("strexh %0, %2, [%1]" : "=r" (
result
) : "r" (
addr
), "r" (
value
) );

487 return(
result
);

488 
	}
}

500 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint32_t
 
	$__STREXW
(
uint32_t
 
value
, volatile uint32_t *
addr
)

502 
uint32_t
 
result
;

504 
__ASM
 volatile ("strex %0, %2, [%1]" : "=r" (
result
) : "r" (
addr
), "r" (
value
) );

505 return(
result
);

506 
	}
}

514 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 void 
	$__CLREX
(void)

516 
__ASM
 volatile ("clrex");

517 
	}
}

528 #define 
	#__SSAT
(
ARG1
,
ARG2
) \

	)

530 
uint32_t
 
	g__RES
, 
	g__ARG1
 = (
ARG1
); \

531 
__ASM
 ("ssat %0, %1, %2" : "=r" (
__RES
) : "I" (
ARG2
), "r" (
__ARG1
) ); \

532 
	g__RES
; \

544 #define 
	#__USAT
(
ARG1
,
ARG2
) \

	)

546 
uint32_t
 
	g__RES
, 
	g__ARG1
 = (
ARG1
); \

547 
__ASM
 ("usat %0, %1, %2" : "=r" (
__RES
) : "I" (
ARG2
), "r" (
__ARG1
) ); \

548 
	g__RES
; \

559 
__attribute__
( ( 
always_inline
 ) ) static 
__INLINE
 
uint8_t
 
	$__CLZ
(
uint32_t
 
value
)

561 
uint8_t
 
result
;

563 
__ASM
 volatile ("clz %0, %1" : "=r" (
result
) : "r" (
value
) );

564 return(
result
);

565 
	}
}

572 #elif 
defined
 ( 
__TASKING__
 )

	@Libraries/Device/STM32F4xx/Include/stm32f4xx.h

47 #ifndef 
__STM32F4xx_H


48 #define 
	#__STM32F4xx_H


	)

50 #ifdef 
__cplusplus


62 #if !
defined
 (
STM32F4XX
)

63 #define 
	#STM32F4XX


	)

70 #if !
defined
 (
STM32F4XX
)

74 #if !
defined
 (
USE_STDPERIPH_DRIVER
)

91 #if !
defined
 (
HSE_VALUE
)

92 #define 
	#HSE_VALUE
 ((
uint32_t
) 12000000)

	)

99 #if !
defined
 (
HSE_STARTUP_TIMEOUT
)

100 #define 
	#HSE_STARTUP_TIMEOUT
 ((
uint16_t
)0x0500)

	)

103 #if !
defined
 (
HSI_VALUE
)

104 #define 
	#HSI_VALUE
 ((
uint32_t
)16000000)

	)

110 #define 
	#__STM32F4XX_STDPERIPH_VERSION_MAIN
 (0x01)

	)

111 #define 
	#__STM32F4XX_STDPERIPH_VERSION_SUB1
 (0x00)

	)

112 #define 
	#__STM32F4XX_STDPERIPH_VERSION_SUB2
 (0x00)

	)

113 #define 
	#__STM32F4XX_STDPERIPH_VERSION_RC
 (0x01)

	)

114 #define 
	#__STM32F4XX_STDPERIPH_VERSION
 ((
__STM32F4XX_STDPERIPH_VERSION_MAIN
 << 24)\

	)

115 |(
__STM32F4XX_STDPERIPH_VERSION_SUB1
 << 16)\

116 |(
__STM32F4XX_STDPERIPH_VERSION_SUB2
 << 8)\

117 |(
__STM32F4XX_STDPERIPH_VERSION_RC
))

130 #define 
	#__MPU_PRESENT
 1

	)

131 #define 
	#__NVIC_PRIO_BITS
 4

	)

132 #define 
	#__Vendor_SysTickConfig
 0

	)

133 #define 
	#__FPU_PRESENT
 1

	)

139 typedef enum 
	eIRQn


142 
NonMaskableInt_IRQn
 = -14,

143 
MemoryManagement_IRQn
 = -12,

144 
BusFault_IRQn
 = -11,

145 
UsageFault_IRQn
 = -10,

146 
SVCall_IRQn
 = -5,

147 
DebugMonitor_IRQn
 = -4,

148 
PendSV_IRQn
 = -2,

149 
SysTick_IRQn
 = -1,

151 
WWDG_IRQn
 = 0,

152 
PVD_IRQn
 = 1,

153 
TAMP_STAMP_IRQn
 = 2,

154 
RTC_WKUP_IRQn
 = 3,

155 
FLASH_IRQn
 = 4,

156 
RCC_IRQn
 = 5,

157 
EXTI0_IRQn
 = 6,

158 
EXTI1_IRQn
 = 7,

159 
EXTI2_IRQn
 = 8,

160 
EXTI3_IRQn
 = 9,

161 
EXTI4_IRQn
 = 10,

162 
DMA1_Stream0_IRQn
 = 11,

163 
DMA1_Stream1_IRQn
 = 12,

164 
DMA1_Stream2_IRQn
 = 13,

165 
DMA1_Stream3_IRQn
 = 14,

166 
DMA1_Stream4_IRQn
 = 15,

167 
DMA1_Stream5_IRQn
 = 16,

168 
DMA1_Stream6_IRQn
 = 17,

169 
ADC_IRQn
 = 18,

170 
CAN1_TX_IRQn
 = 19,

171 
CAN1_RX0_IRQn
 = 20,

172 
CAN1_RX1_IRQn
 = 21,

173 
CAN1_SCE_IRQn
 = 22,

174 
EXTI9_5_IRQn
 = 23,

175 
TIM1_BRK_TIM9_IRQn
 = 24,

176 
TIM1_UP_TIM10_IRQn
 = 25,

177 
TIM1_TRG_COM_TIM11_IRQn
 = 26,

178 
TIM1_CC_IRQn
 = 27,

179 
TIM2_IRQn
 = 28,

180 
TIM3_IRQn
 = 29,

181 
TIM4_IRQn
 = 30,

182 
I2C1_EV_IRQn
 = 31,

183 
I2C1_ER_IRQn
 = 32,

184 
I2C2_EV_IRQn
 = 33,

185 
I2C2_ER_IRQn
 = 34,

186 
SPI1_IRQn
 = 35,

187 
SPI2_IRQn
 = 36,

188 
USART1_IRQn
 = 37,

189 
USART2_IRQn
 = 38,

190 
USART3_IRQn
 = 39,

191 
EXTI15_10_IRQn
 = 40,

192 
RTC_Alarm_IRQn
 = 41,

193 
OTG_FS_WKUP_IRQn
 = 42,

194 
TIM8_BRK_TIM12_IRQn
 = 43,

195 
TIM8_UP_TIM13_IRQn
 = 44,

196 
TIM8_TRG_COM_TIM14_IRQn
 = 45,

197 
TIM8_CC_IRQn
 = 46,

198 
DMA1_Stream7_IRQn
 = 47,

199 
FSMC_IRQn
 = 48,

200 
SDIO_IRQn
 = 49,

201 
TIM5_IRQn
 = 50,

202 
SPI3_IRQn
 = 51,

203 
UART4_IRQn
 = 52,

204 
UART5_IRQn
 = 53,

205 
TIM6_DAC_IRQn
 = 54,

206 
TIM7_IRQn
 = 55,

207 
DMA2_Stream0_IRQn
 = 56,

208 
DMA2_Stream1_IRQn
 = 57,

209 
DMA2_Stream2_IRQn
 = 58,

210 
DMA2_Stream3_IRQn
 = 59,

211 
DMA2_Stream4_IRQn
 = 60,

212 
ETH_IRQn
 = 61,

213 
ETH_WKUP_IRQn
 = 62,

214 
CAN2_TX_IRQn
 = 63,

215 
CAN2_RX0_IRQn
 = 64,

216 
CAN2_RX1_IRQn
 = 65,

217 
CAN2_SCE_IRQn
 = 66,

218 
OTG_FS_IRQn
 = 67,

219 
DMA2_Stream5_IRQn
 = 68,

220 
DMA2_Stream6_IRQn
 = 69,

221 
DMA2_Stream7_IRQn
 = 70,

222 
USART6_IRQn
 = 71,

223 
I2C3_EV_IRQn
 = 72,

224 
I2C3_ER_IRQn
 = 73,

225 
OTG_HS_EP1_OUT_IRQn
 = 74,

226 
OTG_HS_EP1_IN_IRQn
 = 75,

227 
OTG_HS_WKUP_IRQn
 = 76,

228 
OTG_HS_IRQn
 = 77,

229 
DCMI_IRQn
 = 78,

230 
CRYP_IRQn
 = 79,

231 
HASH_RNG_IRQn
 = 80,

232 
FPU_IRQn
 = 81

233 } 
	tIRQn_Type
;

239 #include 
	~"core_cm4.h
"

240 #include 
	~"system_stm32f4xx.h
"

241 #include 
	~<stdint.h
>

247 typedef 
int32_t
 
	ts32
;

248 typedef 
int16_t
 
	ts16
;

249 typedef 
int8_t
 
	ts8
;

251 typedef const 
	tint32_t
 
	tsc32
;

252 typedef const 
	tint16_t
 
	tsc16
;

253 typedef const 
	tint8_t
 
	tsc8
;

255 typedef 
__IO
 
	tint32_t
 
	tvs32
;

256 typedef 
__IO
 
	tint16_t
 
	tvs16
;

257 typedef 
__IO
 
	tint8_t
 
	tvs8
;

259 typedef 
__I
 
	tint32_t
 
	tvsc32
;

260 typedef 
__I
 
	tint16_t
 
	tvsc16
;

261 typedef 
__I
 
	tint8_t
 
	tvsc8
;

263 typedef 
uint32_t
 
	tu32
;

264 typedef 
uint16_t
 
	tu16
;

265 typedef 
uint8_t
 
	tu8
;

267 typedef const 
	tuint32_t
 
	tuc32
;

268 typedef const 
	tuint16_t
 
	tuc16
;

269 typedef const 
	tuint8_t
 
	tuc8
;

271 typedef 
__IO
 
	tuint32_t
 
	tvu32
;

272 typedef 
__IO
 
	tuint16_t
 
	tvu16
;

273 typedef 
__IO
 
	tuint8_t
 
	tvu8
;

275 typedef 
__I
 
	tuint32_t
 
	tvuc32
;

276 typedef 
__I
 
	tuint16_t
 
	tvuc16
;

277 typedef 
__I
 
	tuint8_t
 
	tvuc8
;

279 typedef enum {
RESET
 = 0, 
SET
 = !RESET} 
	tFlagStatus
, 
	tITStatus
;

281 typedef enum {
DISABLE
 = 0, 
ENABLE
 = !DISABLE} 
	tFunctionalState
;

282 #define 
	#IS_FUNCTIONAL_STATE
(
STATE
) (((STATE) == 
DISABLE
) || ((STATE) == 
ENABLE
))

	)

284 typedef enum {
ERROR
 = 0, 
SUCCESS
 = !ERROR} 
	tErrorStatus
;

300 
__IO
 
uint32_t
 
SR
;

301 
__IO
 
uint32_t
 
CR1
;

302 
__IO
 
uint32_t
 
CR2
;

303 
__IO
 
uint32_t
 
SMPR1
;

304 
__IO
 
uint32_t
 
SMPR2
;

305 
__IO
 
uint32_t
 
JOFR1
;

306 
__IO
 
uint32_t
 
JOFR2
;

307 
__IO
 
uint32_t
 
JOFR3
;

308 
__IO
 
uint32_t
 
JOFR4
;

309 
__IO
 
uint32_t
 
HTR
;

310 
__IO
 
uint32_t
 
LTR
;

311 
__IO
 
uint32_t
 
SQR1
;

312 
__IO
 
uint32_t
 
SQR2
;

313 
__IO
 
uint32_t
 
SQR3
;

314 
__IO
 
uint32_t
 
JSQR
;

315 
__IO
 
uint32_t
 
JDR1
;

316 
__IO
 
uint32_t
 
JDR2
;

317 
__IO
 
uint32_t
 
JDR3
;

318 
__IO
 
uint32_t
 
JDR4
;

319 
__IO
 
uint32_t
 
DR
;

320 } 
	tADC_TypeDef
;

324 
__IO
 
uint32_t
 
CSR
;

325 
__IO
 
uint32_t
 
CCR
;

326 
__IO
 
uint32_t
 
CDR
;

328 } 
	tADC_Common_TypeDef
;

337 
__IO
 
uint32_t
 
TIR
;

338 
__IO
 
uint32_t
 
TDTR
;

339 
__IO
 
uint32_t
 
TDLR
;

340 
__IO
 
uint32_t
 
TDHR
;

341 } 
	tCAN_TxMailBox_TypeDef
;

349 
__IO
 
uint32_t
 
RIR
;

350 
__IO
 
uint32_t
 
RDTR
;

351 
__IO
 
uint32_t
 
RDLR
;

352 
__IO
 
uint32_t
 
RDHR
;

353 } 
	tCAN_FIFOMailBox_TypeDef
;

361 
__IO
 
uint32_t
 
FR1
;

362 
__IO
 
uint32_t
 
FR2
;

363 } 
	tCAN_FilterRegister_TypeDef
;

371 
__IO
 
uint32_t
 
MCR
;

372 
__IO
 
uint32_t
 
MSR
;

373 
__IO
 
uint32_t
 
TSR
;

374 
__IO
 
uint32_t
 
RF0R
;

375 
__IO
 
uint32_t
 
RF1R
;

376 
__IO
 
uint32_t
 
IER
;

377 
__IO
 
uint32_t
 
ESR
;

378 
__IO
 
uint32_t
 
BTR
;

379 
uint32_t
 
RESERVED0
[88];

380 
CAN_TxMailBox_TypeDef
 
sTxMailBox
[3];

381 
CAN_FIFOMailBox_TypeDef
 
sFIFOMailBox
[2];

382 
uint32_t
 
RESERVED1
[12];

383 
__IO
 
uint32_t
 
FMR
;

384 
__IO
 
uint32_t
 
FM1R
;

385 
uint32_t
 
RESERVED2
;

386 
__IO
 
uint32_t
 
FS1R
;

387 
uint32_t
 
RESERVED3
;

388 
__IO
 
uint32_t
 
FFA1R
;

389 
uint32_t
 
RESERVED4
;

390 
__IO
 
uint32_t
 
FA1R
;

391 
uint32_t
 
RESERVED5
[8];

392 
CAN_FilterRegister_TypeDef
 
sFilterRegister
[28];

393 } 
	tCAN_TypeDef
;

401 
__IO
 
uint32_t
 
DR
;

402 
__IO
 
uint8_t
 
IDR
;

403 
uint8_t
 
RESERVED0
;

404 
uint16_t
 
RESERVED1
;

405 
__IO
 
uint32_t
 
CR
;

406 } 
	tCRC_TypeDef
;

414 
__IO
 
uint32_t
 
CR
;

415 
__IO
 
uint32_t
 
SWTRIGR
;

416 
__IO
 
uint32_t
 
DHR12R1
;

417 
__IO
 
uint32_t
 
DHR12L1
;

418 
__IO
 
uint32_t
 
DHR8R1
;

419 
__IO
 
uint32_t
 
DHR12R2
;

420 
__IO
 
uint32_t
 
DHR12L2
;

421 
__IO
 
uint32_t
 
DHR8R2
;

422 
__IO
 
uint32_t
 
DHR12RD
;

423 
__IO
 
uint32_t
 
DHR12LD
;

424 
__IO
 
uint32_t
 
DHR8RD
;

425 
__IO
 
uint32_t
 
DOR1
;

426 
__IO
 
uint32_t
 
DOR2
;

427 
__IO
 
uint32_t
 
SR
;

428 } 
	tDAC_TypeDef
;

436 
__IO
 
uint32_t
 
IDCODE
;

437 
__IO
 
uint32_t
 
CR
;

438 
__IO
 
uint32_t
 
APB1FZ
;

439 
__IO
 
uint32_t
 
APB2FZ
;

440 }
	tDBGMCU_TypeDef
;

448 
__IO
 
uint32_t
 
CR
;

449 
__IO
 
uint32_t
 
SR
;

450 
__IO
 
uint32_t
 
RISR
;

451 
__IO
 
uint32_t
 
IER
;

452 
__IO
 
uint32_t
 
MISR
;

453 
__IO
 
uint32_t
 
ICR
;

454 
__IO
 
uint32_t
 
ESCR
;

455 
__IO
 
uint32_t
 
ESUR
;

456 
__IO
 
uint32_t
 
CWSTRTR
;

457 
__IO
 
uint32_t
 
CWSIZER
;

458 
__IO
 
uint32_t
 
DR
;

459 } 
	tDCMI_TypeDef
;

467 
__IO
 
uint32_t
 
CR
;

468 
__IO
 
uint32_t
 
NDTR
;

469 
__IO
 
uint32_t
 
PAR
;

470 
__IO
 
uint32_t
 
M0AR
;

471 
__IO
 
uint32_t
 
M1AR
;

472 
__IO
 
uint32_t
 
FCR
;

473 } 
	tDMA_Stream_TypeDef
;

477 
__IO
 
uint32_t
 
LISR
;

478 
__IO
 
uint32_t
 
HISR
;

479 
__IO
 
uint32_t
 
LIFCR
;

480 
__IO
 
uint32_t
 
HIFCR
;

481 } 
	tDMA_TypeDef
;

489 
__IO
 
uint32_t
 
MACCR
;

490 
__IO
 
uint32_t
 
MACFFR
;

491 
__IO
 
uint32_t
 
MACHTHR
;

492 
__IO
 
uint32_t
 
MACHTLR
;

493 
__IO
 
uint32_t
 
MACMIIAR
;

494 
__IO
 
uint32_t
 
MACMIIDR
;

495 
__IO
 
uint32_t
 
MACFCR
;

496 
__IO
 
uint32_t
 
MACVLANTR
;

497 
uint32_t
 
RESERVED0
[2];

498 
__IO
 
uint32_t
 
MACRWUFFR
;

499 
__IO
 
uint32_t
 
MACPMTCSR
;

500 
uint32_t
 
RESERVED1
[2];

501 
__IO
 
uint32_t
 
MACSR
;

502 
__IO
 
uint32_t
 
MACIMR
;

503 
__IO
 
uint32_t
 
MACA0HR
;

504 
__IO
 
uint32_t
 
MACA0LR
;

505 
__IO
 
uint32_t
 
MACA1HR
;

506 
__IO
 
uint32_t
 
MACA1LR
;

507 
__IO
 
uint32_t
 
MACA2HR
;

508 
__IO
 
uint32_t
 
MACA2LR
;

509 
__IO
 
uint32_t
 
MACA3HR
;

510 
__IO
 
uint32_t
 
MACA3LR
;

511 
uint32_t
 
RESERVED2
[40];

512 
__IO
 
uint32_t
 
MMCCR
;

513 
__IO
 
uint32_t
 
MMCRIR
;

514 
__IO
 
uint32_t
 
MMCTIR
;

515 
__IO
 
uint32_t
 
MMCRIMR
;

516 
__IO
 
uint32_t
 
MMCTIMR
;

517 
uint32_t
 
RESERVED3
[14];

518 
__IO
 
uint32_t
 
MMCTGFSCCR
;

519 
__IO
 
uint32_t
 
MMCTGFMSCCR
;

520 
uint32_t
 
RESERVED4
[5];

521 
__IO
 
uint32_t
 
MMCTGFCR
;

522 
uint32_t
 
RESERVED5
[10];

523 
__IO
 
uint32_t
 
MMCRFCECR
;

524 
__IO
 
uint32_t
 
MMCRFAECR
;

525 
uint32_t
 
RESERVED6
[10];

526 
__IO
 
uint32_t
 
MMCRGUFCR
;

527 
uint32_t
 
RESERVED7
[334];

528 
__IO
 
uint32_t
 
PTPTSCR
;

529 
__IO
 
uint32_t
 
PTPSSIR
;

530 
__IO
 
uint32_t
 
PTPTSHR
;

531 
__IO
 
uint32_t
 
PTPTSLR
;

532 
__IO
 
uint32_t
 
PTPTSHUR
;

533 
__IO
 
uint32_t
 
PTPTSLUR
;

534 
__IO
 
uint32_t
 
PTPTSAR
;

535 
__IO
 
uint32_t
 
PTPTTHR
;

536 
__IO
 
uint32_t
 
PTPTTLR
;

537 
__IO
 
uint32_t
 
RESERVED8
;

538 
__IO
 
uint32_t
 
PTPTSSR
;

539 
uint32_t
 
RESERVED9
[565];

540 
__IO
 
uint32_t
 
DMABMR
;

541 
__IO
 
uint32_t
 
DMATPDR
;

542 
__IO
 
uint32_t
 
DMARPDR
;

543 
__IO
 
uint32_t
 
DMARDLAR
;

544 
__IO
 
uint32_t
 
DMATDLAR
;

545 
__IO
 
uint32_t
 
DMASR
;

546 
__IO
 
uint32_t
 
DMAOMR
;

547 
__IO
 
uint32_t
 
DMAIER
;

548 
__IO
 
uint32_t
 
DMAMFBOCR
;

549 
__IO
 
uint32_t
 
DMARSWTR
;

550 
uint32_t
 
RESERVED10
[8];

551 
__IO
 
uint32_t
 
DMACHTDR
;

552 
__IO
 
uint32_t
 
DMACHRDR
;

553 
__IO
 
uint32_t
 
DMACHTBAR
;

554 
__IO
 
uint32_t
 
DMACHRBAR
;

555 } 
	tETH_TypeDef
;

563 
__IO
 
uint32_t
 
IMR
;

564 
__IO
 
uint32_t
 
EMR
;

565 
__IO
 
uint32_t
 
RTSR
;

566 
__IO
 
uint32_t
 
FTSR
;

567 
__IO
 
uint32_t
 
SWIER
;

568 
__IO
 
uint32_t
 
PR
;

569 } 
	tEXTI_TypeDef
;

577 
__IO
 
uint32_t
 
ACR
;

578 
__IO
 
uint32_t
 
KEYR
;

579 
__IO
 
uint32_t
 
OPTKEYR
;

580 
__IO
 
uint32_t
 
SR
;

581 
__IO
 
uint32_t
 
CR
;

582 
__IO
 
uint32_t
 
OPTCR
;

583 } 
	tFLASH_TypeDef
;

591 
__IO
 
uint32_t
 
BTCR
[8];

592 } 
	tFSMC_Bank1_TypeDef
;

600 
__IO
 
uint32_t
 
BWTR
[7];

601 } 
	tFSMC_Bank1E_TypeDef
;

609 
__IO
 
uint32_t
 
PCR2
;

610 
__IO
 
uint32_t
 
SR2
;

611 
__IO
 
uint32_t
 
PMEM2
;

612 
__IO
 
uint32_t
 
PATT2
;

613 
uint32_t
 
RESERVED0
;

614 
__IO
 
uint32_t
 
ECCR2
;

615 } 
	tFSMC_Bank2_TypeDef
;

623 
__IO
 
uint32_t
 
PCR3
;

624 
__IO
 
uint32_t
 
SR3
;

625 
__IO
 
uint32_t
 
PMEM3
;

626 
__IO
 
uint32_t
 
PATT3
;

627 
uint32_t
 
RESERVED0
;

628 
__IO
 
uint32_t
 
ECCR3
;

629 } 
	tFSMC_Bank3_TypeDef
;

637 
__IO
 
uint32_t
 
PCR4
;

638 
__IO
 
uint32_t
 
SR4
;

639 
__IO
 
uint32_t
 
PMEM4
;

640 
__IO
 
uint32_t
 
PATT4
;

641 
__IO
 
uint32_t
 
PIO4
;

642 } 
	tFSMC_Bank4_TypeDef
;

650 
__IO
 
uint32_t
 
MODER
;

651 
__IO
 
uint32_t
 
OTYPER
;

652 
__IO
 
uint32_t
 
OSPEEDR
;

653 
__IO
 
uint32_t
 
PUPDR
;

654 
__IO
 
uint32_t
 
IDR
;

655 
__IO
 
uint32_t
 
ODR
;

656 
__IO
 
uint16_t
 
BSRRL
;

657 
__IO
 
uint16_t
 
BSRRH
;

658 
__IO
 
uint32_t
 
LCKR
;

659 
__IO
 
uint32_t
 
AFR
[2];

660 } 
	tGPIO_TypeDef
;

668 
__IO
 
uint32_t
 
MEMRMP
;

669 
__IO
 
uint32_t
 
PMC
;

670 
__IO
 
uint32_t
 
EXTICR
[4];

671 
uint32_t
 
RESERVED
[2];

672 
__IO
 
uint32_t
 
CMPCR
;

673 } 
	tSYSCFG_TypeDef
;

681 
__IO
 
uint16_t
 
CR1
;

682 
uint16_t
 
RESERVED0
;

683 
__IO
 
uint16_t
 
CR2
;

684 
uint16_t
 
RESERVED1
;

685 
__IO
 
uint16_t
 
OAR1
;

686 
uint16_t
 
RESERVED2
;

687 
__IO
 
uint16_t
 
OAR2
;

688 
uint16_t
 
RESERVED3
;

689 
__IO
 
uint16_t
 
DR
;

690 
uint16_t
 
RESERVED4
;

691 
__IO
 
uint16_t
 
SR1
;

692 
uint16_t
 
RESERVED5
;

693 
__IO
 
uint16_t
 
SR2
;

694 
uint16_t
 
RESERVED6
;

695 
__IO
 
uint16_t
 
CCR
;

696 
uint16_t
 
RESERVED7
;

697 
__IO
 
uint16_t
 
TRISE
;

698 
uint16_t
 
RESERVED8
;

699 } 
	tI2C_TypeDef
;

707 
__IO
 
uint32_t
 
KR
;

708 
__IO
 
uint32_t
 
PR
;

709 
__IO
 
uint32_t
 
RLR
;

710 
__IO
 
uint32_t
 
SR
;

711 } 
	tIWDG_TypeDef
;

719 
__IO
 
uint32_t
 
CR
;

720 
__IO
 
uint32_t
 
CSR
;

721 } 
	tPWR_TypeDef
;

729 
__IO
 
uint32_t
 
CR
;

730 
__IO
 
uint32_t
 
PLLCFGR
;

731 
__IO
 
uint32_t
 
CFGR
;

732 
__IO
 
uint32_t
 
CIR
;

733 
__IO
 
uint32_t
 
AHB1RSTR
;

734 
__IO
 
uint32_t
 
AHB2RSTR
;

735 
__IO
 
uint32_t
 
AHB3RSTR
;

736 
uint32_t
 
RESERVED0
;

737 
__IO
 
uint32_t
 
APB1RSTR
;

738 
__IO
 
uint32_t
 
APB2RSTR
;

739 
uint32_t
 
RESERVED1
[2];

740 
__IO
 
uint32_t
 
AHB1ENR
;

741 
__IO
 
uint32_t
 
AHB2ENR
;

742 
__IO
 
uint32_t
 
AHB3ENR
;

743 
uint32_t
 
RESERVED2
;

744 
__IO
 
uint32_t
 
APB1ENR
;

745 
__IO
 
uint32_t
 
APB2ENR
;

746 
uint32_t
 
RESERVED3
[2];

747 
__IO
 
uint32_t
 
AHB1LPENR
;

748 
__IO
 
uint32_t
 
AHB2LPENR
;

749 
__IO
 
uint32_t
 
AHB3LPENR
;

750 
uint32_t
 
RESERVED4
;

751 
__IO
 
uint32_t
 
APB1LPENR
;

752 
__IO
 
uint32_t
 
APB2LPENR
;

753 
uint32_t
 
RESERVED5
[2];

754 
__IO
 
uint32_t
 
BDCR
;

755 
__IO
 
uint32_t
 
CSR
;

756 
uint32_t
 
RESERVED6
[2];

757 
__IO
 
uint32_t
 
SSCGR
;

758 
__IO
 
uint32_t
 
PLLI2SCFGR
;

759 } 
	tRCC_TypeDef
;

767 
__IO
 
uint32_t
 
TR
;

768 
__IO
 
uint32_t
 
DR
;

769 
__IO
 
uint32_t
 
CR
;

770 
__IO
 
uint32_t
 
ISR
;

771 
__IO
 
uint32_t
 
PRER
;

772 
__IO
 
uint32_t
 
WUTR
;

773 
__IO
 
uint32_t
 
CALIBR
;

774 
__IO
 
uint32_t
 
ALRMAR
;

775 
__IO
 
uint32_t
 
ALRMBR
;

776 
__IO
 
uint32_t
 
WPR
;

777 
__IO
 
uint32_t
 
SSR
;

778 
__IO
 
uint32_t
 
SHIFTR
;

779 
__IO
 
uint32_t
 
TSTR
;

780 
__IO
 
uint32_t
 
TSDR
;

781 
__IO
 
uint32_t
 
TSSSR
;

782 
__IO
 
uint32_t
 
CALR
;

783 
__IO
 
uint32_t
 
TAFCR
;

784 
__IO
 
uint32_t
 
ALRMASSR
;

785 
__IO
 
uint32_t
 
ALRMBSSR
;

786 
uint32_t
 
RESERVED7
;

787 
__IO
 
uint32_t
 
BKP0R
;

788 
__IO
 
uint32_t
 
BKP1R
;

789 
__IO
 
uint32_t
 
BKP2R
;

790 
__IO
 
uint32_t
 
BKP3R
;

791 
__IO
 
uint32_t
 
BKP4R
;

792 
__IO
 
uint32_t
 
BKP5R
;

793 
__IO
 
uint32_t
 
BKP6R
;

794 
__IO
 
uint32_t
 
BKP7R
;

795 
__IO
 
uint32_t
 
BKP8R
;

796 
__IO
 
uint32_t
 
BKP9R
;

797 
__IO
 
uint32_t
 
BKP10R
;

798 
__IO
 
uint32_t
 
BKP11R
;

799 
__IO
 
uint32_t
 
BKP12R
;

800 
__IO
 
uint32_t
 
BKP13R
;

801 
__IO
 
uint32_t
 
BKP14R
;

802 
__IO
 
uint32_t
 
BKP15R
;

803 
__IO
 
uint32_t
 
BKP16R
;

804 
__IO
 
uint32_t
 
BKP17R
;

805 
__IO
 
uint32_t
 
BKP18R
;

806 
__IO
 
uint32_t
 
BKP19R
;

807 } 
	tRTC_TypeDef
;

815 
__IO
 
uint32_t
 
POWER
;

816 
__IO
 
uint32_t
 
CLKCR
;

817 
__IO
 
uint32_t
 
ARG
;

818 
__IO
 
uint32_t
 
CMD
;

819 
__I
 
uint32_t
 
RESPCMD
;

820 
__I
 
uint32_t
 
RESP1
;

821 
__I
 
uint32_t
 
RESP2
;

822 
__I
 
uint32_t
 
RESP3
;

823 
__I
 
uint32_t
 
RESP4
;

824 
__IO
 
uint32_t
 
DTIMER
;

825 
__IO
 
uint32_t
 
DLEN
;

826 
__IO
 
uint32_t
 
DCTRL
;

827 
__I
 
uint32_t
 
DCOUNT
;

828 
__I
 
uint32_t
 
STA
;

829 
__IO
 
uint32_t
 
ICR
;

830 
__IO
 
uint32_t
 
MASK
;

831 
uint32_t
 
RESERVED0
[2];

832 
__I
 
uint32_t
 
FIFOCNT
;

833 
uint32_t
 
RESERVED1
[13];

834 
__IO
 
uint32_t
 
FIFO
;

835 } 
	tSDIO_TypeDef
;

843 
__IO
 
uint16_t
 
CR1
;

844 
uint16_t
 
RESERVED0
;

845 
__IO
 
uint16_t
 
CR2
;

846 
uint16_t
 
RESERVED1
;

847 
__IO
 
uint16_t
 
SR
;

848 
uint16_t
 
RESERVED2
;

849 
__IO
 
uint16_t
 
DR
;

850 
uint16_t
 
RESERVED3
;

851 
__IO
 
uint16_t
 
CRCPR
;

852 
uint16_t
 
RESERVED4
;

853 
__IO
 
uint16_t
 
RXCRCR
;

854 
uint16_t
 
RESERVED5
;

855 
__IO
 
uint16_t
 
TXCRCR
;

856 
uint16_t
 
RESERVED6
;

857 
__IO
 
uint16_t
 
I2SCFGR
;

858 
uint16_t
 
RESERVED7
;

859 
__IO
 
uint16_t
 
I2SPR
;

860 
uint16_t
 
RESERVED8
;

861 } 
	tSPI_TypeDef
;

869 
__IO
 
uint16_t
 
CR1
;

870 
uint16_t
 
RESERVED0
;

871 
__IO
 
uint16_t
 
CR2
;

872 
uint16_t
 
RESERVED1
;

873 
__IO
 
uint16_t
 
SMCR
;

874 
uint16_t
 
RESERVED2
;

875 
__IO
 
uint16_t
 
DIER
;

876 
uint16_t
 
RESERVED3
;

877 
__IO
 
uint16_t
 
SR
;

878 
uint16_t
 
RESERVED4
;

879 
__IO
 
uint16_t
 
EGR
;

880 
uint16_t
 
RESERVED5
;

881 
__IO
 
uint16_t
 
CCMR1
;

882 
uint16_t
 
RESERVED6
;

883 
__IO
 
uint16_t
 
CCMR2
;

884 
uint16_t
 
RESERVED7
;

885 
__IO
 
uint16_t
 
CCER
;

886 
uint16_t
 
RESERVED8
;

887 
__IO
 
uint32_t
 
CNT
;

888 
__IO
 
uint16_t
 
PSC
;

889 
uint16_t
 
RESERVED9
;

890 
__IO
 
uint32_t
 
ARR
;

891 
__IO
 
uint16_t
 
RCR
;

892 
uint16_t
 
RESERVED10
;

893 
__IO
 
uint32_t
 
CCR1
;

894 
__IO
 
uint32_t
 
CCR2
;

895 
__IO
 
uint32_t
 
CCR3
;

896 
__IO
 
uint32_t
 
CCR4
;

897 
__IO
 
uint16_t
 
BDTR
;

898 
uint16_t
 
RESERVED11
;

899 
__IO
 
uint16_t
 
DCR
;

900 
uint16_t
 
RESERVED12
;

901 
__IO
 
uint16_t
 
DMAR
;

902 
uint16_t
 
RESERVED13
;

903 
__IO
 
uint16_t
 
OR
;

904 
uint16_t
 
RESERVED14
;

905 } 
	tTIM_TypeDef
;

913 
__IO
 
uint16_t
 
SR
;

914 
uint16_t
 
RESERVED0
;

915 
__IO
 
uint16_t
 
DR
;

916 
uint16_t
 
RESERVED1
;

917 
__IO
 
uint16_t
 
BRR
;

918 
uint16_t
 
RESERVED2
;

919 
__IO
 
uint16_t
 
CR1
;

920 
uint16_t
 
RESERVED3
;

921 
__IO
 
uint16_t
 
CR2
;

922 
uint16_t
 
RESERVED4
;

923 
__IO
 
uint16_t
 
CR3
;

924 
uint16_t
 
RESERVED5
;

925 
__IO
 
uint16_t
 
GTPR
;

926 
uint16_t
 
RESERVED6
;

927 } 
	tUSART_TypeDef
;

935 
__IO
 
uint32_t
 
CR
;

936 
__IO
 
uint32_t
 
CFR
;

937 
__IO
 
uint32_t
 
SR
;

938 } 
	tWWDG_TypeDef
;

946 
__IO
 
uint32_t
 
CR
;

947 
__IO
 
uint32_t
 
SR
;

948 
__IO
 
uint32_t
 
DR
;

949 
__IO
 
uint32_t
 
DOUT
;

950 
__IO
 
uint32_t
 
DMACR
;

951 
__IO
 
uint32_t
 
IMSCR
;

952 
__IO
 
uint32_t
 
RISR
;

953 
__IO
 
uint32_t
 
MISR
;

954 
__IO
 
uint32_t
 
K0LR
;

955 
__IO
 
uint32_t
 
K0RR
;

956 
__IO
 
uint32_t
 
K1LR
;

957 
__IO
 
uint32_t
 
K1RR
;

958 
__IO
 
uint32_t
 
K2LR
;

959 
__IO
 
uint32_t
 
K2RR
;

960 
__IO
 
uint32_t
 
K3LR
;

961 
__IO
 
uint32_t
 
K3RR
;

962 
__IO
 
uint32_t
 
IV0LR
;

963 
__IO
 
uint32_t
 
IV0RR
;

964 
__IO
 
uint32_t
 
IV1LR
;

965 
__IO
 
uint32_t
 
IV1RR
;

966 } 
	tCRYP_TypeDef
;

974 
__IO
 
uint32_t
 
CR
;

975 
__IO
 
uint32_t
 
DIN
;

976 
__IO
 
uint32_t
 
STR
;

977 
__IO
 
uint32_t
 
HR
[5];

978 
__IO
 
uint32_t
 
IMR
;

979 
__IO
 
uint32_t
 
SR
;

980 
uint32_t
 
RESERVED
[52];

981 
__IO
 
uint32_t
 
CSR
[51];

982 } 
	tHASH_TypeDef
;

990 
__IO
 
uint32_t
 
CR
;

991 
__IO
 
uint32_t
 
SR
;

992 
__IO
 
uint32_t
 
DR
;

993 } 
	tRNG_TypeDef
;

1003 #define 
	#FLASH_BASE
 ((
uint32_t
)0x08000000)

	)

1004 #define 
	#SRAM_BASE
 ((
uint32_t
)0x20000000)

	)

1005 #define 
	#PERIPH_BASE
 ((
uint32_t
)0x40000000)

	)

1007 #define 
	#SRAM_BB_BASE
 ((
uint32_t
)0x22000000)

	)

1008 #define 
	#PERIPH_BB_BASE
 ((
uint32_t
)0x42000000)

	)

1010 #define 
	#FSMC_R_BASE
 ((
uint32_t
)0xA0000000)

	)

1013 #define 
	#APB1PERIPH_BASE
 
PERIPH_BASE


	)

1014 #define 
	#APB2PERIPH_BASE
 (
PERIPH_BASE
 + 0x00010000)

	)

1015 #define 
	#AHB1PERIPH_BASE
 (
PERIPH_BASE
 + 0x00020000)

	)

1016 #define 
	#AHB2PERIPH_BASE
 (
PERIPH_BASE
 + 0x10000000)

	)

1019 #define 
	#TIM2_BASE
 (
APB1PERIPH_BASE
 + 0x0000)

	)

1020 #define 
	#TIM3_BASE
 (
APB1PERIPH_BASE
 + 0x0400)

	)

1021 #define 
	#TIM4_BASE
 (
APB1PERIPH_BASE
 + 0x0800)

	)

1022 #define 
	#TIM5_BASE
 (
APB1PERIPH_BASE
 + 0x0C00)

	)

1023 #define 
	#TIM6_BASE
 (
APB1PERIPH_BASE
 + 0x1000)

	)

1024 #define 
	#TIM7_BASE
 (
APB1PERIPH_BASE
 + 0x1400)

	)

1025 #define 
	#TIM12_BASE
 (
APB1PERIPH_BASE
 + 0x1800)

	)

1026 #define 
	#TIM13_BASE
 (
APB1PERIPH_BASE
 + 0x1C00)

	)

1027 #define 
	#TIM14_BASE
 (
APB1PERIPH_BASE
 + 0x2000)

	)

1028 #define 
	#RTC_BASE
 (
APB1PERIPH_BASE
 + 0x2800)

	)

1029 #define 
	#WWDG_BASE
 (
APB1PERIPH_BASE
 + 0x2C00)

	)

1030 #define 
	#IWDG_BASE
 (
APB1PERIPH_BASE
 + 0x3000)

	)

1031 #define 
	#I2S2ext_BASE
 (
APB1PERIPH_BASE
 + 0x3400)

	)

1032 #define 
	#SPI2_BASE
 (
APB1PERIPH_BASE
 + 0x3800)

	)

1033 #define 
	#SPI3_BASE
 (
APB1PERIPH_BASE
 + 0x3C00)

	)

1034 #define 
	#I2S3ext_BASE
 (
APB1PERIPH_BASE
 + 0x4000)

	)

1035 #define 
	#USART2_BASE
 (
APB1PERIPH_BASE
 + 0x4400)

	)

1036 #define 
	#USART3_BASE
 (
APB1PERIPH_BASE
 + 0x4800)

	)

1037 #define 
	#UART4_BASE
 (
APB1PERIPH_BASE
 + 0x4C00)

	)

1038 #define 
	#UART5_BASE
 (
APB1PERIPH_BASE
 + 0x5000)

	)

1039 #define 
	#I2C1_BASE
 (
APB1PERIPH_BASE
 + 0x5400)

	)

1040 #define 
	#I2C2_BASE
 (
APB1PERIPH_BASE
 + 0x5800)

	)

1041 #define 
	#I2C3_BASE
 (
APB1PERIPH_BASE
 + 0x5C00)

	)

1042 #define 
	#CAN1_BASE
 (
APB1PERIPH_BASE
 + 0x6400)

	)

1043 #define 
	#CAN2_BASE
 (
APB1PERIPH_BASE
 + 0x6800)

	)

1044 #define 
	#PWR_BASE
 (
APB1PERIPH_BASE
 + 0x7000)

	)

1045 #define 
	#DAC_BASE
 (
APB1PERIPH_BASE
 + 0x7400)

	)

1048 #define 
	#TIM1_BASE
 (
APB2PERIPH_BASE
 + 0x0000)

	)

1049 #define 
	#TIM8_BASE
 (
APB2PERIPH_BASE
 + 0x0400)

	)

1050 #define 
	#USART1_BASE
 (
APB2PERIPH_BASE
 + 0x1000)

	)

1051 #define 
	#USART6_BASE
 (
APB2PERIPH_BASE
 + 0x1400)

	)

1052 #define 
	#ADC1_BASE
 (
APB2PERIPH_BASE
 + 0x2000)

	)

1053 #define 
	#ADC2_BASE
 (
APB2PERIPH_BASE
 + 0x2100)

	)

1054 #define 
	#ADC3_BASE
 (
APB2PERIPH_BASE
 + 0x2200)

	)

1055 #define 
	#ADC_BASE
 (
APB2PERIPH_BASE
 + 0x2300)

	)

1056 #define 
	#SDIO_BASE
 (
APB2PERIPH_BASE
 + 0x2C00)

	)

1057 #define 
	#SPI1_BASE
 (
APB2PERIPH_BASE
 + 0x3000)

	)

1058 #define 
	#SYSCFG_BASE
 (
APB2PERIPH_BASE
 + 0x3800)

	)

1059 #define 
	#EXTI_BASE
 (
APB2PERIPH_BASE
 + 0x3C00)

	)

1060 #define 
	#TIM9_BASE
 (
APB2PERIPH_BASE
 + 0x4000)

	)

1061 #define 
	#TIM10_BASE
 (
APB2PERIPH_BASE
 + 0x4400)

	)

1062 #define 
	#TIM11_BASE
 (
APB2PERIPH_BASE
 + 0x4800)

	)

1065 #define 
	#GPIOA_BASE
 (
AHB1PERIPH_BASE
 + 0x0000)

	)

1066 #define 
	#GPIOB_BASE
 (
AHB1PERIPH_BASE
 + 0x0400)

	)

1067 #define 
	#GPIOC_BASE
 (
AHB1PERIPH_BASE
 + 0x0800)

	)

1068 #define 
	#GPIOD_BASE
 (
AHB1PERIPH_BASE
 + 0x0C00)

	)

1069 #define 
	#GPIOE_BASE
 (
AHB1PERIPH_BASE
 + 0x1000)

	)

1070 #define 
	#GPIOF_BASE
 (
AHB1PERIPH_BASE
 + 0x1400)

	)

1071 #define 
	#GPIOG_BASE
 (
AHB1PERIPH_BASE
 + 0x1800)

	)

1072 #define 
	#GPIOH_BASE
 (
AHB1PERIPH_BASE
 + 0x1C00)

	)

1073 #define 
	#GPIOI_BASE
 (
AHB1PERIPH_BASE
 + 0x2000)

	)

1074 #define 
	#CRC_BASE
 (
AHB1PERIPH_BASE
 + 0x3000)

	)

1075 #define 
	#RCC_BASE
 (
AHB1PERIPH_BASE
 + 0x3800)

	)

1076 #define 
	#FLASH_R_BASE
 (
AHB1PERIPH_BASE
 + 0x3C00)

	)

1077 #define 
	#BKPSRAM_BASE
 (
AHB1PERIPH_BASE
 + 0x4000)

	)

1078 #define 
	#DMA1_BASE
 (
AHB1PERIPH_BASE
 + 0x6000)

	)

1079 #define 
	#DMA1_Stream0_BASE
 (
DMA1_BASE
 + 0x010)

	)

1080 #define 
	#DMA1_Stream1_BASE
 (
DMA1_BASE
 + 0x028)

	)

1081 #define 
	#DMA1_Stream2_BASE
 (
DMA1_BASE
 + 0x040)

	)

1082 #define 
	#DMA1_Stream3_BASE
 (
DMA1_BASE
 + 0x058)

	)

1083 #define 
	#DMA1_Stream4_BASE
 (
DMA1_BASE
 + 0x070)

	)

1084 #define 
	#DMA1_Stream5_BASE
 (
DMA1_BASE
 + 0x088)

	)

1085 #define 
	#DMA1_Stream6_BASE
 (
DMA1_BASE
 + 0x0A0)

	)

1086 #define 
	#DMA1_Stream7_BASE
 (
DMA1_BASE
 + 0x0B8)

	)

1087 #define 
	#DMA2_BASE
 (
AHB1PERIPH_BASE
 + 0x6400)

	)

1088 #define 
	#DMA2_Stream0_BASE
 (
DMA2_BASE
 + 0x010)

	)

1089 #define 
	#DMA2_Stream1_BASE
 (
DMA2_BASE
 + 0x028)

	)

1090 #define 
	#DMA2_Stream2_BASE
 (
DMA2_BASE
 + 0x040)

	)

1091 #define 
	#DMA2_Stream3_BASE
 (
DMA2_BASE
 + 0x058)

	)

1092 #define 
	#DMA2_Stream4_BASE
 (
DMA2_BASE
 + 0x070)

	)

1093 #define 
	#DMA2_Stream5_BASE
 (
DMA2_BASE
 + 0x088)

	)

1094 #define 
	#DMA2_Stream6_BASE
 (
DMA2_BASE
 + 0x0A0)

	)

1095 #define 
	#DMA2_Stream7_BASE
 (
DMA2_BASE
 + 0x0B8)

	)

1096 #define 
	#ETH_BASE
 (
AHB1PERIPH_BASE
 + 0x8000)

	)

1097 #define 
	#ETH_MAC_BASE
 (
ETH_BASE
)

	)

1098 #define 
	#ETH_MMC_BASE
 (
ETH_BASE
 + 0x0100)

	)

1099 #define 
	#ETH_PTP_BASE
 (
ETH_BASE
 + 0x0700)

	)

1100 #define 
	#ETH_DMA_BASE
 (
ETH_BASE
 + 0x1000)

	)

1103 #define 
	#DCMI_BASE
 (
AHB2PERIPH_BASE
 + 0x50000)

	)

1104 #define 
	#CRYP_BASE
 (
AHB2PERIPH_BASE
 + 0x60000)

	)

1105 #define 
	#HASH_BASE
 (
AHB2PERIPH_BASE
 + 0x60400)

	)

1106 #define 
	#RNG_BASE
 (
AHB2PERIPH_BASE
 + 0x60800)

	)

1109 #define 
	#FSMC_Bank1_R_BASE
 (
FSMC_R_BASE
 + 0x0000)

	)

1110 #define 
	#FSMC_Bank1E_R_BASE
 (
FSMC_R_BASE
 + 0x0104)

	)

1111 #define 
	#FSMC_Bank2_R_BASE
 (
FSMC_R_BASE
 + 0x0060)

	)

1112 #define 
	#FSMC_Bank3_R_BASE
 (
FSMC_R_BASE
 + 0x0080)

	)

1113 #define 
	#FSMC_Bank4_R_BASE
 (
FSMC_R_BASE
 + 0x00A0)

	)

1116 #define 
	#DBGMCU_BASE
 ((
uint32_t
 )0xE0042000)

	)

1125 #define 
	#TIM2
 ((
TIM_TypeDef
 *) 
TIM2_BASE
)

	)

1126 #define 
	#TIM3
 ((
TIM_TypeDef
 *) 
TIM3_BASE
)

	)

1127 #define 
	#TIM4
 ((
TIM_TypeDef
 *) 
TIM4_BASE
)

	)

1128 #define 
	#TIM5
 ((
TIM_TypeDef
 *) 
TIM5_BASE
)

	)

1129 #define 
	#TIM6
 ((
TIM_TypeDef
 *) 
TIM6_BASE
)

	)

1130 #define 
	#TIM7
 ((
TIM_TypeDef
 *) 
TIM7_BASE
)

	)

1131 #define 
	#TIM12
 ((
TIM_TypeDef
 *) 
TIM12_BASE
)

	)

1132 #define 
	#TIM13
 ((
TIM_TypeDef
 *) 
TIM13_BASE
)

	)

1133 #define 
	#TIM14
 ((
TIM_TypeDef
 *) 
TIM14_BASE
)

	)

1134 #define 
	#RTC
 ((
RTC_TypeDef
 *) 
RTC_BASE
)

	)

1135 #define 
	#WWDG
 ((
WWDG_TypeDef
 *) 
WWDG_BASE
)

	)

1136 #define 
	#IWDG
 ((
IWDG_TypeDef
 *) 
IWDG_BASE
)

	)

1137 #define 
	#I2S2ext
 ((
SPI_TypeDef
 *) 
I2S2ext_BASE
)

	)

1138 #define 
	#SPI2
 ((
SPI_TypeDef
 *) 
SPI2_BASE
)

	)

1139 #define 
	#SPI3
 ((
SPI_TypeDef
 *) 
SPI3_BASE
)

	)

1140 #define 
	#I2S3ext
 ((
SPI_TypeDef
 *) 
I2S3ext_BASE
)

	)

1141 #define 
	#USART2
 ((
USART_TypeDef
 *) 
USART2_BASE
)

	)

1142 #define 
	#USART3
 ((
USART_TypeDef
 *) 
USART3_BASE
)

	)

1143 #define 
	#UART4
 ((
USART_TypeDef
 *) 
UART4_BASE
)

	)

1144 #define 
	#UART5
 ((
USART_TypeDef
 *) 
UART5_BASE
)

	)

1145 #define 
	#I2C1
 ((
I2C_TypeDef
 *) 
I2C1_BASE
)

	)

1146 #define 
	#I2C2
 ((
I2C_TypeDef
 *) 
I2C2_BASE
)

	)

1147 #define 
	#I2C3
 ((
I2C_TypeDef
 *) 
I2C3_BASE
)

	)

1148 #define 
	#CAN1
 ((
CAN_TypeDef
 *) 
CAN1_BASE
)

	)

1149 #define 
	#CAN2
 ((
CAN_TypeDef
 *) 
CAN2_BASE
)

	)

1150 #define 
	#PWR
 ((
PWR_TypeDef
 *) 
PWR_BASE
)

	)

1151 #define 
	#DAC
 ((
DAC_TypeDef
 *) 
DAC_BASE
)

	)

1152 #define 
	#TIM1
 ((
TIM_TypeDef
 *) 
TIM1_BASE
)

	)

1153 #define 
	#TIM8
 ((
TIM_TypeDef
 *) 
TIM8_BASE
)

	)

1154 #define 
	#USART1
 ((
USART_TypeDef
 *) 
USART1_BASE
)

	)

1155 #define 
	#USART6
 ((
USART_TypeDef
 *) 
USART6_BASE
)

	)

1156 #define 
	#ADC
 ((
ADC_Common_TypeDef
 *) 
ADC_BASE
)

	)

1157 #define 
	#ADC1
 ((
ADC_TypeDef
 *) 
ADC1_BASE
)

	)

1158 #define 
	#ADC2
 ((
ADC_TypeDef
 *) 
ADC2_BASE
)

	)

1159 #define 
	#ADC3
 ((
ADC_TypeDef
 *) 
ADC3_BASE
)

	)

1160 #define 
	#SDIO
 ((
SDIO_TypeDef
 *) 
SDIO_BASE
)

	)

1161 #define 
	#SPI1
 ((
SPI_TypeDef
 *) 
SPI1_BASE
)

	)

1162 #define 
	#SYSCFG
 ((
SYSCFG_TypeDef
 *) 
SYSCFG_BASE
)

	)

1163 #define 
	#EXTI
 ((
EXTI_TypeDef
 *) 
EXTI_BASE
)

	)

1164 #define 
	#TIM9
 ((
TIM_TypeDef
 *) 
TIM9_BASE
)

	)

1165 #define 
	#TIM10
 ((
TIM_TypeDef
 *) 
TIM10_BASE
)

	)

1166 #define 
	#TIM11
 ((
TIM_TypeDef
 *) 
TIM11_BASE
)

	)

1167 #define 
	#GPIOA
 ((
GPIO_TypeDef
 *) 
GPIOA_BASE
)

	)

1168 #define 
	#GPIOB
 ((
GPIO_TypeDef
 *) 
GPIOB_BASE
)

	)

1169 #define 
	#GPIOC
 ((
GPIO_TypeDef
 *) 
GPIOC_BASE
)

	)

1170 #define 
	#GPIOD
 ((
GPIO_TypeDef
 *) 
GPIOD_BASE
)

	)

1171 #define 
	#GPIOE
 ((
GPIO_TypeDef
 *) 
GPIOE_BASE
)

	)

1172 #define 
	#GPIOF
 ((
GPIO_TypeDef
 *) 
GPIOF_BASE
)

	)

1173 #define 
	#GPIOG
 ((
GPIO_TypeDef
 *) 
GPIOG_BASE
)

	)

1174 #define 
	#GPIOH
 ((
GPIO_TypeDef
 *) 
GPIOH_BASE
)

	)

1175 #define 
	#GPIOI
 ((
GPIO_TypeDef
 *) 
GPIOI_BASE
)

	)

1176 #define 
	#CRC
 ((
CRC_TypeDef
 *) 
CRC_BASE
)

	)

1177 #define 
	#RCC
 ((
RCC_TypeDef
 *) 
RCC_BASE
)

	)

1178 #define 
	#FLASH
 ((
FLASH_TypeDef
 *) 
FLASH_R_BASE
)

	)

1179 #define 
	#DMA1
 ((
DMA_TypeDef
 *) 
DMA1_BASE
)

	)

1180 #define 
	#DMA1_Stream0
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream0_BASE
)

	)

1181 #define 
	#DMA1_Stream1
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream1_BASE
)

	)

1182 #define 
	#DMA1_Stream2
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream2_BASE
)

	)

1183 #define 
	#DMA1_Stream3
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream3_BASE
)

	)

1184 #define 
	#DMA1_Stream4
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream4_BASE
)

	)

1185 #define 
	#DMA1_Stream5
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream5_BASE
)

	)

1186 #define 
	#DMA1_Stream6
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream6_BASE
)

	)

1187 #define 
	#DMA1_Stream7
 ((
DMA_Stream_TypeDef
 *) 
DMA1_Stream7_BASE
)

	)

1188 #define 
	#DMA2
 ((
DMA_TypeDef
 *) 
DMA2_BASE
)

	)

1189 #define 
	#DMA2_Stream0
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream0_BASE
)

	)

1190 #define 
	#DMA2_Stream1
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream1_BASE
)

	)

1191 #define 
	#DMA2_Stream2
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream2_BASE
)

	)

1192 #define 
	#DMA2_Stream3
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream3_BASE
)

	)

1193 #define 
	#DMA2_Stream4
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream4_BASE
)

	)

1194 #define 
	#DMA2_Stream5
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream5_BASE
)

	)

1195 #define 
	#DMA2_Stream6
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream6_BASE
)

	)

1196 #define 
	#DMA2_Stream7
 ((
DMA_Stream_TypeDef
 *) 
DMA2_Stream7_BASE
)

	)

1197 #define 
	#ETH
 ((
ETH_TypeDef
 *) 
ETH_BASE
)

	)

1198 #define 
	#DCMI
 ((
DCMI_TypeDef
 *) 
DCMI_BASE
)

	)

1199 #define 
	#CRYP
 ((
CRYP_TypeDef
 *) 
CRYP_BASE
)

	)

1200 #define 
	#HASH
 ((
HASH_TypeDef
 *) 
HASH_BASE
)

	)

1201 #define 
	#RNG
 ((
RNG_TypeDef
 *) 
RNG_BASE
)

	)

1202 #define 
	#FSMC_Bank1
 ((
FSMC_Bank1_TypeDef
 *) 
FSMC_Bank1_R_BASE
)

	)

1203 #define 
	#FSMC_Bank1E
 ((
FSMC_Bank1E_TypeDef
 *) 
FSMC_Bank1E_R_BASE
)

	)

1204 #define 
	#FSMC_Bank2
 ((
FSMC_Bank2_TypeDef
 *) 
FSMC_Bank2_R_BASE
)

	)

1205 #define 
	#FSMC_Bank3
 ((
FSMC_Bank3_TypeDef
 *) 
FSMC_Bank3_R_BASE
)

	)

1206 #define 
	#FSMC_Bank4
 ((
FSMC_Bank4_TypeDef
 *) 
FSMC_Bank4_R_BASE
)

	)

1207 #define 
	#DBGMCU
 ((
DBGMCU_TypeDef
 *) 
DBGMCU_BASE
)

	)

1231 #define 
	#ADC_SR_AWD
 ((
uint8_t
)0x01)

	)

1232 #define 
	#ADC_SR_EOC
 ((
uint8_t
)0x02)

	)

1233 #define 
	#ADC_SR_JEOC
 ((
uint8_t
)0x04)

	)

1234 #define 
	#ADC_SR_JSTRT
 ((
uint8_t
)0x08)

	)

1235 #define 
	#ADC_SR_STRT
 ((
uint8_t
)0x10)

	)

1236 #define 
	#ADC_SR_OVR
 ((
uint8_t
)0x20)

	)

1239 #define 
	#ADC_CR1_AWDCH
 ((
uint32_t
)0x0000001F)

	)

1240 #define 
	#ADC_CR1_AWDCH_0
 ((
uint32_t
)0x00000001)

	)

1241 #define 
	#ADC_CR1_AWDCH_1
 ((
uint32_t
)0x00000002)

	)

1242 #define 
	#ADC_CR1_AWDCH_2
 ((
uint32_t
)0x00000004)

	)

1243 #define 
	#ADC_CR1_AWDCH_3
 ((
uint32_t
)0x00000008)

	)

1244 #define 
	#ADC_CR1_AWDCH_4
 ((
uint32_t
)0x00000010)

	)

1245 #define 
	#ADC_CR1_EOCIE
 ((
uint32_t
)0x00000020)

	)

1246 #define 
	#ADC_CR1_AWDIE
 ((
uint32_t
)0x00000040)

	)

1247 #define 
	#ADC_CR1_JEOCIE
 ((
uint32_t
)0x00000080)

	)

1248 #define 
	#ADC_CR1_SCAN
 ((
uint32_t
)0x00000100)

	)

1249 #define 
	#ADC_CR1_AWDSGL
 ((
uint32_t
)0x00000200)

	)

1250 #define 
	#ADC_CR1_JAUTO
 ((
uint32_t
)0x00000400)

	)

1251 #define 
	#ADC_CR1_DISCEN
 ((
uint32_t
)0x00000800)

	)

1252 #define 
	#ADC_CR1_JDISCEN
 ((
uint32_t
)0x00001000)

	)

1253 #define 
	#ADC_CR1_DISCNUM
 ((
uint32_t
)0x0000E000)

	)

1254 #define 
	#ADC_CR1_DISCNUM_0
 ((
uint32_t
)0x00002000)

	)

1255 #define 
	#ADC_CR1_DISCNUM_1
 ((
uint32_t
)0x00004000)

	)

1256 #define 
	#ADC_CR1_DISCNUM_2
 ((
uint32_t
)0x00008000)

	)

1257 #define 
	#ADC_CR1_JAWDEN
 ((
uint32_t
)0x00400000)

	)

1258 #define 
	#ADC_CR1_AWDEN
 ((
uint32_t
)0x00800000)

	)

1259 #define 
	#ADC_CR1_RES
 ((
uint32_t
)0x03000000)

	)

1260 #define 
	#ADC_CR1_RES_0
 ((
uint32_t
)0x01000000)

	)

1261 #define 
	#ADC_CR1_RES_1
 ((
uint32_t
)0x02000000)

	)

1262 #define 
	#ADC_CR1_OVRIE
 ((
uint32_t
)0x04000000)

	)

1265 #define 
	#ADC_CR2_ADON
 ((
uint32_t
)0x00000001)

	)

1266 #define 
	#ADC_CR2_CONT
 ((
uint32_t
)0x00000002)

	)

1267 #define 
	#ADC_CR2_DMA
 ((
uint32_t
)0x00000100)

	)

1268 #define 
	#ADC_CR2_DDS
 ((
uint32_t
)0x00000200)

	)

1269 #define 
	#ADC_CR2_EOCS
 ((
uint32_t
)0x00000400)

	)

1270 #define 
	#ADC_CR2_ALIGN
 ((
uint32_t
)0x00000800)

	)

1271 #define 
	#ADC_CR2_JEXTSEL
 ((
uint32_t
)0x000F0000)

	)

1272 #define 
	#ADC_CR2_JEXTSEL_0
 ((
uint32_t
)0x00010000)

	)

1273 #define 
	#ADC_CR2_JEXTSEL_1
 ((
uint32_t
)0x00020000)

	)

1274 #define 
	#ADC_CR2_JEXTSEL_2
 ((
uint32_t
)0x00040000)

	)

1275 #define 
	#ADC_CR2_JEXTSEL_3
 ((
uint32_t
)0x00080000)

	)

1276 #define 
	#ADC_CR2_JEXTEN
 ((
uint32_t
)0x00300000)

	)

1277 #define 
	#ADC_CR2_JEXTEN_0
 ((
uint32_t
)0x00100000)

	)

1278 #define 
	#ADC_CR2_JEXTEN_1
 ((
uint32_t
)0x00200000)

	)

1279 #define 
	#ADC_CR2_JSWSTART
 ((
uint32_t
)0x00400000)

	)

1280 #define 
	#ADC_CR2_EXTSEL
 ((
uint32_t
)0x0F000000)

	)

1281 #define 
	#ADC_CR2_EXTSEL_0
 ((
uint32_t
)0x01000000)

	)

1282 #define 
	#ADC_CR2_EXTSEL_1
 ((
uint32_t
)0x02000000)

	)

1283 #define 
	#ADC_CR2_EXTSEL_2
 ((
uint32_t
)0x04000000)

	)

1284 #define 
	#ADC_CR2_EXTSEL_3
 ((
uint32_t
)0x08000000)

	)

1285 #define 
	#ADC_CR2_EXTEN
 ((
uint32_t
)0x30000000)

	)

1286 #define 
	#ADC_CR2_EXTEN_0
 ((
uint32_t
)0x10000000)

	)

1287 #define 
	#ADC_CR2_EXTEN_1
 ((
uint32_t
)0x20000000)

	)

1288 #define 
	#ADC_CR2_SWSTART
 ((
uint32_t
)0x40000000)

	)

1291 #define 
	#ADC_SMPR1_SMP10
 ((
uint32_t
)0x00000007)

	)

1292 #define 
	#ADC_SMPR1_SMP10_0
 ((
uint32_t
)0x00000001)

	)

1293 #define 
	#ADC_SMPR1_SMP10_1
 ((
uint32_t
)0x00000002)

	)

1294 #define 
	#ADC_SMPR1_SMP10_2
 ((
uint32_t
)0x00000004)

	)

1295 #define 
	#ADC_SMPR1_SMP11
 ((
uint32_t
)0x00000038)

	)

1296 #define 
	#ADC_SMPR1_SMP11_0
 ((
uint32_t
)0x00000008)

	)

1297 #define 
	#ADC_SMPR1_SMP11_1
 ((
uint32_t
)0x00000010)

	)

1298 #define 
	#ADC_SMPR1_SMP11_2
 ((
uint32_t
)0x00000020)

	)

1299 #define 
	#ADC_SMPR1_SMP12
 ((
uint32_t
)0x000001C0)

	)

1300 #define 
	#ADC_SMPR1_SMP12_0
 ((
uint32_t
)0x00000040)

	)

1301 #define 
	#ADC_SMPR1_SMP12_1
 ((
uint32_t
)0x00000080)

	)

1302 #define 
	#ADC_SMPR1_SMP12_2
 ((
uint32_t
)0x00000100)

	)

1303 #define 
	#ADC_SMPR1_SMP13
 ((
uint32_t
)0x00000E00)

	)

1304 #define 
	#ADC_SMPR1_SMP13_0
 ((
uint32_t
)0x00000200)

	)

1305 #define 
	#ADC_SMPR1_SMP13_1
 ((
uint32_t
)0x00000400)

	)

1306 #define 
	#ADC_SMPR1_SMP13_2
 ((
uint32_t
)0x00000800)

	)

1307 #define 
	#ADC_SMPR1_SMP14
 ((
uint32_t
)0x00007000)

	)

1308 #define 
	#ADC_SMPR1_SMP14_0
 ((
uint32_t
)0x00001000)

	)

1309 #define 
	#ADC_SMPR1_SMP14_1
 ((
uint32_t
)0x00002000)

	)

1310 #define 
	#ADC_SMPR1_SMP14_2
 ((
uint32_t
)0x00004000)

	)

1311 #define 
	#ADC_SMPR1_SMP15
 ((
uint32_t
)0x00038000)

	)

1312 #define 
	#ADC_SMPR1_SMP15_0
 ((
uint32_t
)0x00008000)

	)

1313 #define 
	#ADC_SMPR1_SMP15_1
 ((
uint32_t
)0x00010000)

	)

1314 #define 
	#ADC_SMPR1_SMP15_2
 ((
uint32_t
)0x00020000)

	)

1315 #define 
	#ADC_SMPR1_SMP16
 ((
uint32_t
)0x001C0000)

	)

1316 #define 
	#ADC_SMPR1_SMP16_0
 ((
uint32_t
)0x00040000)

	)

1317 #define 
	#ADC_SMPR1_SMP16_1
 ((
uint32_t
)0x00080000)

	)

1318 #define 
	#ADC_SMPR1_SMP16_2
 ((
uint32_t
)0x00100000)

	)

1319 #define 
	#ADC_SMPR1_SMP17
 ((
uint32_t
)0x00E00000)

	)

1320 #define 
	#ADC_SMPR1_SMP17_0
 ((
uint32_t
)0x00200000)

	)

1321 #define 
	#ADC_SMPR1_SMP17_1
 ((
uint32_t
)0x00400000)

	)

1322 #define 
	#ADC_SMPR1_SMP17_2
 ((
uint32_t
)0x00800000)

	)

1323 #define 
	#ADC_SMPR1_SMP18
 ((
uint32_t
)0x07000000)

	)

1324 #define 
	#ADC_SMPR1_SMP18_0
 ((
uint32_t
)0x01000000)

	)

1325 #define 
	#ADC_SMPR1_SMP18_1
 ((
uint32_t
)0x02000000)

	)

1326 #define 
	#ADC_SMPR1_SMP18_2
 ((
uint32_t
)0x04000000)

	)

1329 #define 
	#ADC_SMPR2_SMP0
 ((
uint32_t
)0x00000007)

	)

1330 #define 
	#ADC_SMPR2_SMP0_0
 ((
uint32_t
)0x00000001)

	)

1331 #define 
	#ADC_SMPR2_SMP0_1
 ((
uint32_t
)0x00000002)

	)

1332 #define 
	#ADC_SMPR2_SMP0_2
 ((
uint32_t
)0x00000004)

	)

1333 #define 
	#ADC_SMPR2_SMP1
 ((
uint32_t
)0x00000038)

	)

1334 #define 
	#ADC_SMPR2_SMP1_0
 ((
uint32_t
)0x00000008)

	)

1335 #define 
	#ADC_SMPR2_SMP1_1
 ((
uint32_t
)0x00000010)

	)

1336 #define 
	#ADC_SMPR2_SMP1_2
 ((
uint32_t
)0x00000020)

	)

1337 #define 
	#ADC_SMPR2_SMP2
 ((
uint32_t
)0x000001C0)

	)

1338 #define 
	#ADC_SMPR2_SMP2_0
 ((
uint32_t
)0x00000040)

	)

1339 #define 
	#ADC_SMPR2_SMP2_1
 ((
uint32_t
)0x00000080)

	)

1340 #define 
	#ADC_SMPR2_SMP2_2
 ((
uint32_t
)0x00000100)

	)

1341 #define 
	#ADC_SMPR2_SMP3
 ((
uint32_t
)0x00000E00)

	)

1342 #define 
	#ADC_SMPR2_SMP3_0
 ((
uint32_t
)0x00000200)

	)

1343 #define 
	#ADC_SMPR2_SMP3_1
 ((
uint32_t
)0x00000400)

	)

1344 #define 
	#ADC_SMPR2_SMP3_2
 ((
uint32_t
)0x00000800)

	)

1345 #define 
	#ADC_SMPR2_SMP4
 ((
uint32_t
)0x00007000)

	)

1346 #define 
	#ADC_SMPR2_SMP4_0
 ((
uint32_t
)0x00001000)

	)

1347 #define 
	#ADC_SMPR2_SMP4_1
 ((
uint32_t
)0x00002000)

	)

1348 #define 
	#ADC_SMPR2_SMP4_2
 ((
uint32_t
)0x00004000)

	)

1349 #define 
	#ADC_SMPR2_SMP5
 ((
uint32_t
)0x00038000)

	)

1350 #define 
	#ADC_SMPR2_SMP5_0
 ((
uint32_t
)0x00008000)

	)

1351 #define 
	#ADC_SMPR2_SMP5_1
 ((
uint32_t
)0x00010000)

	)

1352 #define 
	#ADC_SMPR2_SMP5_2
 ((
uint32_t
)0x00020000)

	)

1353 #define 
	#ADC_SMPR2_SMP6
 ((
uint32_t
)0x001C0000)

	)

1354 #define 
	#ADC_SMPR2_SMP6_0
 ((
uint32_t
)0x00040000)

	)

1355 #define 
	#ADC_SMPR2_SMP6_1
 ((
uint32_t
)0x00080000)

	)

1356 #define 
	#ADC_SMPR2_SMP6_2
 ((
uint32_t
)0x00100000)

	)

1357 #define 
	#ADC_SMPR2_SMP7
 ((
uint32_t
)0x00E00000)

	)

1358 #define 
	#ADC_SMPR2_SMP7_0
 ((
uint32_t
)0x00200000)

	)

1359 #define 
	#ADC_SMPR2_SMP7_1
 ((
uint32_t
)0x00400000)

	)

1360 #define 
	#ADC_SMPR2_SMP7_2
 ((
uint32_t
)0x00800000)

	)

1361 #define 
	#ADC_SMPR2_SMP8
 ((
uint32_t
)0x07000000)

	)

1362 #define 
	#ADC_SMPR2_SMP8_0
 ((
uint32_t
)0x01000000)

	)

1363 #define 
	#ADC_SMPR2_SMP8_1
 ((
uint32_t
)0x02000000)

	)

1364 #define 
	#ADC_SMPR2_SMP8_2
 ((
uint32_t
)0x04000000)

	)

1365 #define 
	#ADC_SMPR2_SMP9
 ((
uint32_t
)0x38000000)

	)

1366 #define 
	#ADC_SMPR2_SMP9_0
 ((
uint32_t
)0x08000000)

	)

1367 #define 
	#ADC_SMPR2_SMP9_1
 ((
uint32_t
)0x10000000)

	)

1368 #define 
	#ADC_SMPR2_SMP9_2
 ((
uint32_t
)0x20000000)

	)

1371 #define 
	#ADC_JOFR1_JOFFSET1
 ((
uint16_t
)0x0FFF)

	)

1374 #define 
	#ADC_JOFR2_JOFFSET2
 ((
uint16_t
)0x0FFF)

	)

1377 #define 
	#ADC_JOFR3_JOFFSET3
 ((
uint16_t
)0x0FFF)

	)

1380 #define 
	#ADC_JOFR4_JOFFSET4
 ((
uint16_t
)0x0FFF)

	)

1383 #define 
	#ADC_HTR_HT
 ((
uint16_t
)0x0FFF)

	)

1386 #define 
	#ADC_LTR_LT
 ((
uint16_t
)0x0FFF)

	)

1389 #define 
	#ADC_SQR1_SQ13
 ((
uint32_t
)0x0000001F)

	)

1390 #define 
	#ADC_SQR1_SQ13_0
 ((
uint32_t
)0x00000001)

	)

1391 #define 
	#ADC_SQR1_SQ13_1
 ((
uint32_t
)0x00000002)

	)

1392 #define 
	#ADC_SQR1_SQ13_2
 ((
uint32_t
)0x00000004)

	)

1393 #define 
	#ADC_SQR1_SQ13_3
 ((
uint32_t
)0x00000008)

	)

1394 #define 
	#ADC_SQR1_SQ13_4
 ((
uint32_t
)0x00000010)

	)

1395 #define 
	#ADC_SQR1_SQ14
 ((
uint32_t
)0x000003E0)

	)

1396 #define 
	#ADC_SQR1_SQ14_0
 ((
uint32_t
)0x00000020)

	)

1397 #define 
	#ADC_SQR1_SQ14_1
 ((
uint32_t
)0x00000040)

	)

1398 #define 
	#ADC_SQR1_SQ14_2
 ((
uint32_t
)0x00000080)

	)

1399 #define 
	#ADC_SQR1_SQ14_3
 ((
uint32_t
)0x00000100)

	)

1400 #define 
	#ADC_SQR1_SQ14_4
 ((
uint32_t
)0x00000200)

	)

1401 #define 
	#ADC_SQR1_SQ15
 ((
uint32_t
)0x00007C00)

	)

1402 #define 
	#ADC_SQR1_SQ15_0
 ((
uint32_t
)0x00000400)

	)

1403 #define 
	#ADC_SQR1_SQ15_1
 ((
uint32_t
)0x00000800)

	)

1404 #define 
	#ADC_SQR1_SQ15_2
 ((
uint32_t
)0x00001000)

	)

1405 #define 
	#ADC_SQR1_SQ15_3
 ((
uint32_t
)0x00002000)

	)

1406 #define 
	#ADC_SQR1_SQ15_4
 ((
uint32_t
)0x00004000)

	)

1407 #define 
	#ADC_SQR1_SQ16
 ((
uint32_t
)0x000F8000)

	)

1408 #define 
	#ADC_SQR1_SQ16_0
 ((
uint32_t
)0x00008000)

	)

1409 #define 
	#ADC_SQR1_SQ16_1
 ((
uint32_t
)0x00010000)

	)

1410 #define 
	#ADC_SQR1_SQ16_2
 ((
uint32_t
)0x00020000)

	)

1411 #define 
	#ADC_SQR1_SQ16_3
 ((
uint32_t
)0x00040000)

	)

1412 #define 
	#ADC_SQR1_SQ16_4
 ((
uint32_t
)0x00080000)

	)

1413 #define 
	#ADC_SQR1_L
 ((
uint32_t
)0x00F00000)

	)

1414 #define 
	#ADC_SQR1_L_0
 ((
uint32_t
)0x00100000)

	)

1415 #define 
	#ADC_SQR1_L_1
 ((
uint32_t
)0x00200000)

	)

1416 #define 
	#ADC_SQR1_L_2
 ((
uint32_t
)0x00400000)

	)

1417 #define 
	#ADC_SQR1_L_3
 ((
uint32_t
)0x00800000)

	)

1420 #define 
	#ADC_SQR2_SQ7
 ((
uint32_t
)0x0000001F)

	)

1421 #define 
	#ADC_SQR2_SQ7_0
 ((
uint32_t
)0x00000001)

	)

1422 #define 
	#ADC_SQR2_SQ7_1
 ((
uint32_t
)0x00000002)

	)

1423 #define 
	#ADC_SQR2_SQ7_2
 ((
uint32_t
)0x00000004)

	)

1424 #define 
	#ADC_SQR2_SQ7_3
 ((
uint32_t
)0x00000008)

	)

1425 #define 
	#ADC_SQR2_SQ7_4
 ((
uint32_t
)0x00000010)

	)

1426 #define 
	#ADC_SQR2_SQ8
 ((
uint32_t
)0x000003E0)

	)

1427 #define 
	#ADC_SQR2_SQ8_0
 ((
uint32_t
)0x00000020)

	)

1428 #define 
	#ADC_SQR2_SQ8_1
 ((
uint32_t
)0x00000040)

	)

1429 #define 
	#ADC_SQR2_SQ8_2
 ((
uint32_t
)0x00000080)

	)

1430 #define 
	#ADC_SQR2_SQ8_3
 ((
uint32_t
)0x00000100)

	)

1431 #define 
	#ADC_SQR2_SQ8_4
 ((
uint32_t
)0x00000200)

	)

1432 #define 
	#ADC_SQR2_SQ9
 ((
uint32_t
)0x00007C00)

	)

1433 #define 
	#ADC_SQR2_SQ9_0
 ((
uint32_t
)0x00000400)

	)

1434 #define 
	#ADC_SQR2_SQ9_1
 ((
uint32_t
)0x00000800)

	)

1435 #define 
	#ADC_SQR2_SQ9_2
 ((
uint32_t
)0x00001000)

	)

1436 #define 
	#ADC_SQR2_SQ9_3
 ((
uint32_t
)0x00002000)

	)

1437 #define 
	#ADC_SQR2_SQ9_4
 ((
uint32_t
)0x00004000)

	)

1438 #define 
	#ADC_SQR2_SQ10
 ((
uint32_t
)0x000F8000)

	)

1439 #define 
	#ADC_SQR2_SQ10_0
 ((
uint32_t
)0x00008000)

	)

1440 #define 
	#ADC_SQR2_SQ10_1
 ((
uint32_t
)0x00010000)

	)

1441 #define 
	#ADC_SQR2_SQ10_2
 ((
uint32_t
)0x00020000)

	)

1442 #define 
	#ADC_SQR2_SQ10_3
 ((
uint32_t
)0x00040000)

	)

1443 #define 
	#ADC_SQR2_SQ10_4
 ((
uint32_t
)0x00080000)

	)

1444 #define 
	#ADC_SQR2_SQ11
 ((
uint32_t
)0x01F00000)

	)

1445 #define 
	#ADC_SQR2_SQ11_0
 ((
uint32_t
)0x00100000)

	)

1446 #define 
	#ADC_SQR2_SQ11_1
 ((
uint32_t
)0x00200000)

	)

1447 #define 
	#ADC_SQR2_SQ11_2
 ((
uint32_t
)0x00400000)

	)

1448 #define 
	#ADC_SQR2_SQ11_3
 ((
uint32_t
)0x00800000)

	)

1449 #define 
	#ADC_SQR2_SQ11_4
 ((
uint32_t
)0x01000000)

	)

1450 #define 
	#ADC_SQR2_SQ12
 ((
uint32_t
)0x3E000000)

	)

1451 #define 
	#ADC_SQR2_SQ12_0
 ((
uint32_t
)0x02000000)

	)

1452 #define 
	#ADC_SQR2_SQ12_1
 ((
uint32_t
)0x04000000)

	)

1453 #define 
	#ADC_SQR2_SQ12_2
 ((
uint32_t
)0x08000000)

	)

1454 #define 
	#ADC_SQR2_SQ12_3
 ((
uint32_t
)0x10000000)

	)

1455 #define 
	#ADC_SQR2_SQ12_4
 ((
uint32_t
)0x20000000)

	)

1458 #define 
	#ADC_SQR3_SQ1
 ((
uint32_t
)0x0000001F)

	)

1459 #define 
	#ADC_SQR3_SQ1_0
 ((
uint32_t
)0x00000001)

	)

1460 #define 
	#ADC_SQR3_SQ1_1
 ((
uint32_t
)0x00000002)

	)

1461 #define 
	#ADC_SQR3_SQ1_2
 ((
uint32_t
)0x00000004)

	)

1462 #define 
	#ADC_SQR3_SQ1_3
 ((
uint32_t
)0x00000008)

	)

1463 #define 
	#ADC_SQR3_SQ1_4
 ((
uint32_t
)0x00000010)

	)

1464 #define 
	#ADC_SQR3_SQ2
 ((
uint32_t
)0x000003E0)

	)

1465 #define 
	#ADC_SQR3_SQ2_0
 ((
uint32_t
)0x00000020)

	)

1466 #define 
	#ADC_SQR3_SQ2_1
 ((
uint32_t
)0x00000040)

	)

1467 #define 
	#ADC_SQR3_SQ2_2
 ((
uint32_t
)0x00000080)

	)

1468 #define 
	#ADC_SQR3_SQ2_3
 ((
uint32_t
)0x00000100)

	)

1469 #define 
	#ADC_SQR3_SQ2_4
 ((
uint32_t
)0x00000200)

	)

1470 #define 
	#ADC_SQR3_SQ3
 ((
uint32_t
)0x00007C00)

	)

1471 #define 
	#ADC_SQR3_SQ3_0
 ((
uint32_t
)0x00000400)

	)

1472 #define 
	#ADC_SQR3_SQ3_1
 ((
uint32_t
)0x00000800)

	)

1473 #define 
	#ADC_SQR3_SQ3_2
 ((
uint32_t
)0x00001000)

	)

1474 #define 
	#ADC_SQR3_SQ3_3
 ((
uint32_t
)0x00002000)

	)

1475 #define 
	#ADC_SQR3_SQ3_4
 ((
uint32_t
)0x00004000)

	)

1476 #define 
	#ADC_SQR3_SQ4
 ((
uint32_t
)0x000F8000)

	)

1477 #define 
	#ADC_SQR3_SQ4_0
 ((
uint32_t
)0x00008000)

	)

1478 #define 
	#ADC_SQR3_SQ4_1
 ((
uint32_t
)0x00010000)

	)

1479 #define 
	#ADC_SQR3_SQ4_2
 ((
uint32_t
)0x00020000)

	)

1480 #define 
	#ADC_SQR3_SQ4_3
 ((
uint32_t
)0x00040000)

	)

1481 #define 
	#ADC_SQR3_SQ4_4
 ((
uint32_t
)0x00080000)

	)

1482 #define 
	#ADC_SQR3_SQ5
 ((
uint32_t
)0x01F00000)

	)

1483 #define 
	#ADC_SQR3_SQ5_0
 ((
uint32_t
)0x00100000)

	)

1484 #define 
	#ADC_SQR3_SQ5_1
 ((
uint32_t
)0x00200000)

	)

1485 #define 
	#ADC_SQR3_SQ5_2
 ((
uint32_t
)0x00400000)

	)

1486 #define 
	#ADC_SQR3_SQ5_3
 ((
uint32_t
)0x00800000)

	)

1487 #define 
	#ADC_SQR3_SQ5_4
 ((
uint32_t
)0x01000000)

	)

1488 #define 
	#ADC_SQR3_SQ6
 ((
uint32_t
)0x3E000000)

	)

1489 #define 
	#ADC_SQR3_SQ6_0
 ((
uint32_t
)0x02000000)

	)

1490 #define 
	#ADC_SQR3_SQ6_1
 ((
uint32_t
)0x04000000)

	)

1491 #define 
	#ADC_SQR3_SQ6_2
 ((
uint32_t
)0x08000000)

	)

1492 #define 
	#ADC_SQR3_SQ6_3
 ((
uint32_t
)0x10000000)

	)

1493 #define 
	#ADC_SQR3_SQ6_4
 ((
uint32_t
)0x20000000)

	)

1496 #define 
	#ADC_JSQR_JSQ1
 ((
uint32_t
)0x0000001F)

	)

1497 #define 
	#ADC_JSQR_JSQ1_0
 ((
uint32_t
)0x00000001)

	)

1498 #define 
	#ADC_JSQR_JSQ1_1
 ((
uint32_t
)0x00000002)

	)

1499 #define 
	#ADC_JSQR_JSQ1_2
 ((
uint32_t
)0x00000004)

	)

1500 #define 
	#ADC_JSQR_JSQ1_3
 ((
uint32_t
)0x00000008)

	)

1501 #define 
	#ADC_JSQR_JSQ1_4
 ((
uint32_t
)0x00000010)

	)

1502 #define 
	#ADC_JSQR_JSQ2
 ((
uint32_t
)0x000003E0)

	)

1503 #define 
	#ADC_JSQR_JSQ2_0
 ((
uint32_t
)0x00000020)

	)

1504 #define 
	#ADC_JSQR_JSQ2_1
 ((
uint32_t
)0x00000040)

	)

1505 #define 
	#ADC_JSQR_JSQ2_2
 ((
uint32_t
)0x00000080)

	)

1506 #define 
	#ADC_JSQR_JSQ2_3
 ((
uint32_t
)0x00000100)

	)

1507 #define 
	#ADC_JSQR_JSQ2_4
 ((
uint32_t
)0x00000200)

	)

1508 #define 
	#ADC_JSQR_JSQ3
 ((
uint32_t
)0x00007C00)

	)

1509 #define 
	#ADC_JSQR_JSQ3_0
 ((
uint32_t
)0x00000400)

	)

1510 #define 
	#ADC_JSQR_JSQ3_1
 ((
uint32_t
)0x00000800)

	)

1511 #define 
	#ADC_JSQR_JSQ3_2
 ((
uint32_t
)0x00001000)

	)

1512 #define 
	#ADC_JSQR_JSQ3_3
 ((
uint32_t
)0x00002000)

	)

1513 #define 
	#ADC_JSQR_JSQ3_4
 ((
uint32_t
)0x00004000)

	)

1514 #define 
	#ADC_JSQR_JSQ4
 ((
uint32_t
)0x000F8000)

	)

1515 #define 
	#ADC_JSQR_JSQ4_0
 ((
uint32_t
)0x00008000)

	)

1516 #define 
	#ADC_JSQR_JSQ4_1
 ((
uint32_t
)0x00010000)

	)

1517 #define 
	#ADC_JSQR_JSQ4_2
 ((
uint32_t
)0x00020000)

	)

1518 #define 
	#ADC_JSQR_JSQ4_3
 ((
uint32_t
)0x00040000)

	)

1519 #define 
	#ADC_JSQR_JSQ4_4
 ((
uint32_t
)0x00080000)

	)

1520 #define 
	#ADC_JSQR_JL
 ((
uint32_t
)0x00300000)

	)

1521 #define 
	#ADC_JSQR_JL_0
 ((
uint32_t
)0x00100000)

	)

1522 #define 
	#ADC_JSQR_JL_1
 ((
uint32_t
)0x00200000)

	)

1525 #define 
	#ADC_JDR1_JDATA
 ((
uint16_t
)0xFFFF)

	)

1528 #define 
	#ADC_JDR2_JDATA
 ((
uint16_t
)0xFFFF)

	)

1531 #define 
	#ADC_JDR3_JDATA
 ((
uint16_t
)0xFFFF)

	)

1534 #define 
	#ADC_JDR4_JDATA
 ((
uint16_t
)0xFFFF)

	)

1537 #define 
	#ADC_DR_DATA
 ((
uint32_t
)0x0000FFFF)

	)

1538 #define 
	#ADC_DR_ADC2DATA
 ((
uint32_t
)0xFFFF0000)

	)

1541 #define 
	#ADC_CSR_AWD1
 ((
uint32_t
)0x00000001)

	)

1542 #define 
	#ADC_CSR_EOC1
 ((
uint32_t
)0x00000002)

	)

1543 #define 
	#ADC_CSR_JEOC1
 ((
uint32_t
)0x00000004)

	)

1544 #define 
	#ADC_CSR_JSTRT1
 ((
uint32_t
)0x00000008)

	)

1545 #define 
	#ADC_CSR_STRT1
 ((
uint32_t
)0x00000010)

	)

1546 #define 
	#ADC_CSR_DOVR1
 ((
uint32_t
)0x00000020)

	)

1547 #define 
	#ADC_CSR_AWD2
 ((
uint32_t
)0x00000100)

	)

1548 #define 
	#ADC_CSR_EOC2
 ((
uint32_t
)0x00000200)

	)

1549 #define 
	#ADC_CSR_JEOC2
 ((
uint32_t
)0x00000400)

	)

1550 #define 
	#ADC_CSR_JSTRT2
 ((
uint32_t
)0x00000800)

	)

1551 #define 
	#ADC_CSR_STRT2
 ((
uint32_t
)0x00001000)

	)

1552 #define 
	#ADC_CSR_DOVR2
 ((
uint32_t
)0x00002000)

	)

1553 #define 
	#ADC_CSR_AWD3
 ((
uint32_t
)0x00010000)

	)

1554 #define 
	#ADC_CSR_EOC3
 ((
uint32_t
)0x00020000)

	)

1555 #define 
	#ADC_CSR_JEOC3
 ((
uint32_t
)0x00040000)

	)

1556 #define 
	#ADC_CSR_JSTRT3
 ((
uint32_t
)0x00080000)

	)

1557 #define 
	#ADC_CSR_STRT3
 ((
uint32_t
)0x00100000)

	)

1558 #define 
	#ADC_CSR_DOVR3
 ((
uint32_t
)0x00200000)

	)

1561 #define 
	#ADC_CCR_MULTI
 ((
uint32_t
)0x0000001F)

	)

1562 #define 
	#ADC_CCR_MULTI_0
 ((
uint32_t
)0x00000001)

	)

1563 #define 
	#ADC_CCR_MULTI_1
 ((
uint32_t
)0x00000002)

	)

1564 #define 
	#ADC_CCR_MULTI_2
 ((
uint32_t
)0x00000004)

	)

1565 #define 
	#ADC_CCR_MULTI_3
 ((
uint32_t
)0x00000008)

	)

1566 #define 
	#ADC_CCR_MULTI_4
 ((
uint32_t
)0x00000010)

	)

1567 #define 
	#ADC_CCR_DELAY
 ((
uint32_t
)0x00000F00)

	)

1568 #define 
	#ADC_CCR_DELAY_0
 ((
uint32_t
)0x00000100)

	)

1569 #define 
	#ADC_CCR_DELAY_1
 ((
uint32_t
)0x00000200)

	)

1570 #define 
	#ADC_CCR_DELAY_2
 ((
uint32_t
)0x00000400)

	)

1571 #define 
	#ADC_CCR_DELAY_3
 ((
uint32_t
)0x00000800)

	)

1572 #define 
	#ADC_CCR_DDS
 ((
uint32_t
)0x00002000)

	)

1573 #define 
	#ADC_CCR_DMA
 ((
uint32_t
)0x0000C000)

	)

1574 #define 
	#ADC_CCR_DMA_0
 ((
uint32_t
)0x00004000)

	)

1575 #define 
	#ADC_CCR_DMA_1
 ((
uint32_t
)0x00008000)

	)

1576 #define 
	#ADC_CCR_ADCPRE
 ((
uint32_t
)0x00030000)

	)

1577 #define 
	#ADC_CCR_ADCPRE_0
 ((
uint32_t
)0x00010000)

	)

1578 #define 
	#ADC_CCR_ADCPRE_1
 ((
uint32_t
)0x00020000)

	)

1579 #define 
	#ADC_CCR_VBATE
 ((
uint32_t
)0x00400000)

	)

1580 #define 
	#ADC_CCR_TSVREFE
 ((
uint32_t
)0x00800000)

	)

1583 #define 
	#ADC_CDR_DATA1
 ((
uint32_t
)0x0000FFFF)

	)

1584 #define 
	#ADC_CDR_DATA2
 ((
uint32_t
)0xFFFF0000)

	)

1593 #define 
	#CAN_MCR_INRQ
 ((
uint16_t
)0x0001)

	)

1594 #define 
	#CAN_MCR_SLEEP
 ((
uint16_t
)0x0002)

	)

1595 #define 
	#CAN_MCR_TXFP
 ((
uint16_t
)0x0004)

	)

1596 #define 
	#CAN_MCR_RFLM
 ((
uint16_t
)0x0008)

	)

1597 #define 
	#CAN_MCR_NART
 ((
uint16_t
)0x0010)

	)

1598 #define 
	#CAN_MCR_AWUM
 ((
uint16_t
)0x0020)

	)

1599 #define 
	#CAN_MCR_ABOM
 ((
uint16_t
)0x0040)

	)

1600 #define 
	#CAN_MCR_TTCM
 ((
uint16_t
)0x0080)

	)

1601 #define 
	#CAN_MCR_RESET
 ((
uint16_t
)0x8000)

	)

1604 #define 
	#CAN_MSR_INAK
 ((
uint16_t
)0x0001)

	)

1605 #define 
	#CAN_MSR_SLAK
 ((
uint16_t
)0x0002)

	)

1606 #define 
	#CAN_MSR_ERRI
 ((
uint16_t
)0x0004)

	)

1607 #define 
	#CAN_MSR_WKUI
 ((
uint16_t
)0x0008)

	)

1608 #define 
	#CAN_MSR_SLAKI
 ((
uint16_t
)0x0010)

	)

1609 #define 
	#CAN_MSR_TXM
 ((
uint16_t
)0x0100)

	)

1610 #define 
	#CAN_MSR_RXM
 ((
uint16_t
)0x0200)

	)

1611 #define 
	#CAN_MSR_SAMP
 ((
uint16_t
)0x0400)

	)

1612 #define 
	#CAN_MSR_RX
 ((
uint16_t
)0x0800)

	)

1615 #define 
	#CAN_TSR_RQCP0
 ((
uint32_t
)0x00000001)

	)

1616 #define 
	#CAN_TSR_TXOK0
 ((
uint32_t
)0x00000002)

	)

1617 #define 
	#CAN_TSR_ALST0
 ((
uint32_t
)0x00000004)

	)

1618 #define 
	#CAN_TSR_TERR0
 ((
uint32_t
)0x00000008)

	)

1619 #define 
	#CAN_TSR_ABRQ0
 ((
uint32_t
)0x00000080)

	)

1620 #define 
	#CAN_TSR_RQCP1
 ((
uint32_t
)0x00000100)

	)

1621 #define 
	#CAN_TSR_TXOK1
 ((
uint32_t
)0x00000200)

	)

1622 #define 
	#CAN_TSR_ALST1
 ((
uint32_t
)0x00000400)

	)

1623 #define 
	#CAN_TSR_TERR1
 ((
uint32_t
)0x00000800)

	)

1624 #define 
	#CAN_TSR_ABRQ1
 ((
uint32_t
)0x00008000)

	)

1625 #define 
	#CAN_TSR_RQCP2
 ((
uint32_t
)0x00010000)

	)

1626 #define 
	#CAN_TSR_TXOK2
 ((
uint32_t
)0x00020000)

	)

1627 #define 
	#CAN_TSR_ALST2
 ((
uint32_t
)0x00040000)

	)

1628 #define 
	#CAN_TSR_TERR2
 ((
uint32_t
)0x00080000)

	)

1629 #define 
	#CAN_TSR_ABRQ2
 ((
uint32_t
)0x00800000)

	)

1630 #define 
	#CAN_TSR_CODE
 ((
uint32_t
)0x03000000)

	)

1632 #define 
	#CAN_TSR_TME
 ((
uint32_t
)0x1C000000)

	)

1633 #define 
	#CAN_TSR_TME0
 ((
uint32_t
)0x04000000)

	)

1634 #define 
	#CAN_TSR_TME1
 ((
uint32_t
)0x08000000)

	)

1635 #define 
	#CAN_TSR_TME2
 ((
uint32_t
)0x10000000)

	)

1637 #define 
	#CAN_TSR_LOW
 ((
uint32_t
)0xE0000000)

	)

1638 #define 
	#CAN_TSR_LOW0
 ((
uint32_t
)0x20000000)

	)

1639 #define 
	#CAN_TSR_LOW1
 ((
uint32_t
)0x40000000)

	)

1640 #define 
	#CAN_TSR_LOW2
 ((
uint32_t
)0x80000000)

	)

1643 #define 
	#CAN_RF0R_FMP0
 ((
uint8_t
)0x03)

	)

1644 #define 
	#CAN_RF0R_FULL0
 ((
uint8_t
)0x08)

	)

1645 #define 
	#CAN_RF0R_FOVR0
 ((
uint8_t
)0x10)

	)

1646 #define 
	#CAN_RF0R_RFOM0
 ((
uint8_t
)0x20)

	)

1649 #define 
	#CAN_RF1R_FMP1
 ((
uint8_t
)0x03)

	)

1650 #define 
	#CAN_RF1R_FULL1
 ((
uint8_t
)0x08)

	)

1651 #define 
	#CAN_RF1R_FOVR1
 ((
uint8_t
)0x10)

	)

1652 #define 
	#CAN_RF1R_RFOM1
 ((
uint8_t
)0x20)

	)

1655 #define 
	#CAN_IER_TMEIE
 ((
uint32_t
)0x00000001)

	)

1656 #define 
	#CAN_IER_FMPIE0
 ((
uint32_t
)0x00000002)

	)

1657 #define 
	#CAN_IER_FFIE0
 ((
uint32_t
)0x00000004)

	)

1658 #define 
	#CAN_IER_FOVIE0
 ((
uint32_t
)0x00000008)

	)

1659 #define 
	#CAN_IER_FMPIE1
 ((
uint32_t
)0x00000010)

	)

1660 #define 
	#CAN_IER_FFIE1
 ((
uint32_t
)0x00000020)

	)

1661 #define 
	#CAN_IER_FOVIE1
 ((
uint32_t
)0x00000040)

	)

1662 #define 
	#CAN_IER_EWGIE
 ((
uint32_t
)0x00000100)

	)

1663 #define 
	#CAN_IER_EPVIE
 ((
uint32_t
)0x00000200)

	)

1664 #define 
	#CAN_IER_BOFIE
 ((
uint32_t
)0x00000400)

	)

1665 #define 
	#CAN_IER_LECIE
 ((
uint32_t
)0x00000800)

	)

1666 #define 
	#CAN_IER_ERRIE
 ((
uint32_t
)0x00008000)

	)

1667 #define 
	#CAN_IER_WKUIE
 ((
uint32_t
)0x00010000)

	)

1668 #define 
	#CAN_IER_SLKIE
 ((
uint32_t
)0x00020000)

	)

1671 #define 
	#CAN_ESR_EWGF
 ((
uint32_t
)0x00000001)

	)

1672 #define 
	#CAN_ESR_EPVF
 ((
uint32_t
)0x00000002)

	)

1673 #define 
	#CAN_ESR_BOFF
 ((
uint32_t
)0x00000004)

	)

1675 #define 
	#CAN_ESR_LEC
 ((
uint32_t
)0x00000070)

	)

1676 #define 
	#CAN_ESR_LEC_0
 ((
uint32_t
)0x00000010)

	)

1677 #define 
	#CAN_ESR_LEC_1
 ((
uint32_t
)0x00000020)

	)

1678 #define 
	#CAN_ESR_LEC_2
 ((
uint32_t
)0x00000040)

	)

1680 #define 
	#CAN_ESR_TEC
 ((
uint32_t
)0x00FF0000)

	)

1681 #define 
	#CAN_ESR_REC
 ((
uint32_t
)0xFF000000)

	)

1684 #define 
	#CAN_BTR_BRP
 ((
uint32_t
)0x000003FF)

	)

1685 #define 
	#CAN_BTR_TS1
 ((
uint32_t
)0x000F0000)

	)

1686 #define 
	#CAN_BTR_TS2
 ((
uint32_t
)0x00700000)

	)

1687 #define 
	#CAN_BTR_SJW
 ((
uint32_t
)0x03000000)

	)

1688 #define 
	#CAN_BTR_LBKM
 ((
uint32_t
)0x40000000)

	)

1689 #define 
	#CAN_BTR_SILM
 ((
uint32_t
)0x80000000)

	)

1693 #define 
	#CAN_TI0R_TXRQ
 ((
uint32_t
)0x00000001)

	)

1694 #define 
	#CAN_TI0R_RTR
 ((
uint32_t
)0x00000002)

	)

1695 #define 
	#CAN_TI0R_IDE
 ((
uint32_t
)0x00000004)

	)

1696 #define 
	#CAN_TI0R_EXID
 ((
uint32_t
)0x001FFFF8)

	)

1697 #define 
	#CAN_TI0R_STID
 ((
uint32_t
)0xFFE00000)

	)

1700 #define 
	#CAN_TDT0R_DLC
 ((
uint32_t
)0x0000000F)

	)

1701 #define 
	#CAN_TDT0R_TGT
 ((
uint32_t
)0x00000100)

	)

1702 #define 
	#CAN_TDT0R_TIME
 ((
uint32_t
)0xFFFF0000)

	)

1705 #define 
	#CAN_TDL0R_DATA0
 ((
uint32_t
)0x000000FF)

	)

1706 #define 
	#CAN_TDL0R_DATA1
 ((
uint32_t
)0x0000FF00)

	)

1707 #define 
	#CAN_TDL0R_DATA2
 ((
uint32_t
)0x00FF0000)

	)

1708 #define 
	#CAN_TDL0R_DATA3
 ((
uint32_t
)0xFF000000)

	)

1711 #define 
	#CAN_TDH0R_DATA4
 ((
uint32_t
)0x000000FF)

	)

1712 #define 
	#CAN_TDH0R_DATA5
 ((
uint32_t
)0x0000FF00)

	)

1713 #define 
	#CAN_TDH0R_DATA6
 ((
uint32_t
)0x00FF0000)

	)

1714 #define 
	#CAN_TDH0R_DATA7
 ((
uint32_t
)0xFF000000)

	)

1717 #define 
	#CAN_TI1R_TXRQ
 ((
uint32_t
)0x00000001)

	)

1718 #define 
	#CAN_TI1R_RTR
 ((
uint32_t
)0x00000002)

	)

1719 #define 
	#CAN_TI1R_IDE
 ((
uint32_t
)0x00000004)

	)

1720 #define 
	#CAN_TI1R_EXID
 ((
uint32_t
)0x001FFFF8)

	)

1721 #define 
	#CAN_TI1R_STID
 ((
uint32_t
)0xFFE00000)

	)

1724 #define 
	#CAN_TDT1R_DLC
 ((
uint32_t
)0x0000000F)

	)

1725 #define 
	#CAN_TDT1R_TGT
 ((
uint32_t
)0x00000100)

	)

1726 #define 
	#CAN_TDT1R_TIME
 ((
uint32_t
)0xFFFF0000)

	)

1729 #define 
	#CAN_TDL1R_DATA0
 ((
uint32_t
)0x000000FF)

	)

1730 #define 
	#CAN_TDL1R_DATA1
 ((
uint32_t
)0x0000FF00)

	)

1731 #define 
	#CAN_TDL1R_DATA2
 ((
uint32_t
)0x00FF0000)

	)

1732 #define 
	#CAN_TDL1R_DATA3
 ((
uint32_t
)0xFF000000)

	)

1735 #define 
	#CAN_TDH1R_DATA4
 ((
uint32_t
)0x000000FF)

	)

1736 #define 
	#CAN_TDH1R_DATA5
 ((
uint32_t
)0x0000FF00)

	)

1737 #define 
	#CAN_TDH1R_DATA6
 ((
uint32_t
)0x00FF0000)

	)

1738 #define 
	#CAN_TDH1R_DATA7
 ((
uint32_t
)0xFF000000)

	)

1741 #define 
	#CAN_TI2R_TXRQ
 ((
uint32_t
)0x00000001)

	)

1742 #define 
	#CAN_TI2R_RTR
 ((
uint32_t
)0x00000002)

	)

1743 #define 
	#CAN_TI2R_IDE
 ((
uint32_t
)0x00000004)

	)

1744 #define 
	#CAN_TI2R_EXID
 ((
uint32_t
)0x001FFFF8)

	)

1745 #define 
	#CAN_TI2R_STID
 ((
uint32_t
)0xFFE00000)

	)

1748 #define 
	#CAN_TDT2R_DLC
 ((
uint32_t
)0x0000000F)

	)

1749 #define 
	#CAN_TDT2R_TGT
 ((
uint32_t
)0x00000100)

	)

1750 #define 
	#CAN_TDT2R_TIME
 ((
uint32_t
)0xFFFF0000)

	)

1753 #define 
	#CAN_TDL2R_DATA0
 ((
uint32_t
)0x000000FF)

	)

1754 #define 
	#CAN_TDL2R_DATA1
 ((
uint32_t
)0x0000FF00)

	)

1755 #define 
	#CAN_TDL2R_DATA2
 ((
uint32_t
)0x00FF0000)

	)

1756 #define 
	#CAN_TDL2R_DATA3
 ((
uint32_t
)0xFF000000)

	)

1759 #define 
	#CAN_TDH2R_DATA4
 ((
uint32_t
)0x000000FF)

	)

1760 #define 
	#CAN_TDH2R_DATA5
 ((
uint32_t
)0x0000FF00)

	)

1761 #define 
	#CAN_TDH2R_DATA6
 ((
uint32_t
)0x00FF0000)

	)

1762 #define 
	#CAN_TDH2R_DATA7
 ((
uint32_t
)0xFF000000)

	)

1765 #define 
	#CAN_RI0R_RTR
 ((
uint32_t
)0x00000002)

	)

1766 #define 
	#CAN_RI0R_IDE
 ((
uint32_t
)0x00000004)

	)

1767 #define 
	#CAN_RI0R_EXID
 ((
uint32_t
)0x001FFFF8)

	)

1768 #define 
	#CAN_RI0R_STID
 ((
uint32_t
)0xFFE00000)

	)

1771 #define 
	#CAN_RDT0R_DLC
 ((
uint32_t
)0x0000000F)

	)

1772 #define 
	#CAN_RDT0R_FMI
 ((
uint32_t
)0x0000FF00)

	)

1773 #define 
	#CAN_RDT0R_TIME
 ((
uint32_t
)0xFFFF0000)

	)

1776 #define 
	#CAN_RDL0R_DATA0
 ((
uint32_t
)0x000000FF)

	)

1777 #define 
	#CAN_RDL0R_DATA1
 ((
uint32_t
)0x0000FF00)

	)

1778 #define 
	#CAN_RDL0R_DATA2
 ((
uint32_t
)0x00FF0000)

	)

1779 #define 
	#CAN_RDL0R_DATA3
 ((
uint32_t
)0xFF000000)

	)

1782 #define 
	#CAN_RDH0R_DATA4
 ((
uint32_t
)0x000000FF)

	)

1783 #define 
	#CAN_RDH0R_DATA5
 ((
uint32_t
)0x0000FF00)

	)

1784 #define 
	#CAN_RDH0R_DATA6
 ((
uint32_t
)0x00FF0000)

	)

1785 #define 
	#CAN_RDH0R_DATA7
 ((
uint32_t
)0xFF000000)

	)

1788 #define 
	#CAN_RI1R_RTR
 ((
uint32_t
)0x00000002)

	)

1789 #define 
	#CAN_RI1R_IDE
 ((
uint32_t
)0x00000004)

	)

1790 #define 
	#CAN_RI1R_EXID
 ((
uint32_t
)0x001FFFF8)

	)

1791 #define 
	#CAN_RI1R_STID
 ((
uint32_t
)0xFFE00000)

	)

1794 #define 
	#CAN_RDT1R_DLC
 ((
uint32_t
)0x0000000F)

	)

1795 #define 
	#CAN_RDT1R_FMI
 ((
uint32_t
)0x0000FF00)

	)

1796 #define 
	#CAN_RDT1R_TIME
 ((
uint32_t
)0xFFFF0000)

	)

1799 #define 
	#CAN_RDL1R_DATA0
 ((
uint32_t
)0x000000FF)

	)

1800 #define 
	#CAN_RDL1R_DATA1
 ((
uint32_t
)0x0000FF00)

	)

1801 #define 
	#CAN_RDL1R_DATA2
 ((
uint32_t
)0x00FF0000)

	)

1802 #define 
	#CAN_RDL1R_DATA3
 ((
uint32_t
)0xFF000000)

	)

1805 #define 
	#CAN_RDH1R_DATA4
 ((
uint32_t
)0x000000FF)

	)

1806 #define 
	#CAN_RDH1R_DATA5
 ((
uint32_t
)0x0000FF00)

	)

1807 #define 
	#CAN_RDH1R_DATA6
 ((
uint32_t
)0x00FF0000)

	)

1808 #define 
	#CAN_RDH1R_DATA7
 ((
uint32_t
)0xFF000000)

	)

1812 #define 
	#CAN_FMR_FINIT
 ((
uint8_t
)0x01)

	)

1815 #define 
	#CAN_FM1R_FBM
 ((
uint16_t
)0x3FFF)

	)

1816 #define 
	#CAN_FM1R_FBM0
 ((
uint16_t
)0x0001)

	)

1817 #define 
	#CAN_FM1R_FBM1
 ((
uint16_t
)0x0002)

	)

1818 #define 
	#CAN_FM1R_FBM2
 ((
uint16_t
)0x0004)

	)

1819 #define 
	#CAN_FM1R_FBM3
 ((
uint16_t
)0x0008)

	)

1820 #define 
	#CAN_FM1R_FBM4
 ((
uint16_t
)0x0010)

	)

1821 #define 
	#CAN_FM1R_FBM5
 ((
uint16_t
)0x0020)

	)

1822 #define 
	#CAN_FM1R_FBM6
 ((
uint16_t
)0x0040)

	)

1823 #define 
	#CAN_FM1R_FBM7
 ((
uint16_t
)0x0080)

	)

1824 #define 
	#CAN_FM1R_FBM8
 ((
uint16_t
)0x0100)

	)

1825 #define 
	#CAN_FM1R_FBM9
 ((
uint16_t
)0x0200)

	)

1826 #define 
	#CAN_FM1R_FBM10
 ((
uint16_t
)0x0400)

	)

1827 #define 
	#CAN_FM1R_FBM11
 ((
uint16_t
)0x0800)

	)

1828 #define 
	#CAN_FM1R_FBM12
 ((
uint16_t
)0x1000)

	)

1829 #define 
	#CAN_FM1R_FBM13
 ((
uint16_t
)0x2000)

	)

1832 #define 
	#CAN_FS1R_FSC
 ((
uint16_t
)0x3FFF)

	)

1833 #define 
	#CAN_FS1R_FSC0
 ((
uint16_t
)0x0001)

	)

1834 #define 
	#CAN_FS1R_FSC1
 ((
uint16_t
)0x0002)

	)

1835 #define 
	#CAN_FS1R_FSC2
 ((
uint16_t
)0x0004)

	)

1836 #define 
	#CAN_FS1R_FSC3
 ((
uint16_t
)0x0008)

	)

1837 #define 
	#CAN_FS1R_FSC4
 ((
uint16_t
)0x0010)

	)

1838 #define 
	#CAN_FS1R_FSC5
 ((
uint16_t
)0x0020)

	)

1839 #define 
	#CAN_FS1R_FSC6
 ((
uint16_t
)0x0040)

	)

1840 #define 
	#CAN_FS1R_FSC7
 ((
uint16_t
)0x0080)

	)

1841 #define 
	#CAN_FS1R_FSC8
 ((
uint16_t
)0x0100)

	)

1842 #define 
	#CAN_FS1R_FSC9
 ((
uint16_t
)0x0200)

	)

1843 #define 
	#CAN_FS1R_FSC10
 ((
uint16_t
)0x0400)

	)

1844 #define 
	#CAN_FS1R_FSC11
 ((
uint16_t
)0x0800)

	)

1845 #define 
	#CAN_FS1R_FSC12
 ((
uint16_t
)0x1000)

	)

1846 #define 
	#CAN_FS1R_FSC13
 ((
uint16_t
)0x2000)

	)

1849 #define 
	#CAN_FFA1R_FFA
 ((
uint16_t
)0x3FFF)

	)

1850 #define 
	#CAN_FFA1R_FFA0
 ((
uint16_t
)0x0001)

	)

1851 #define 
	#CAN_FFA1R_FFA1
 ((
uint16_t
)0x0002)

	)

1852 #define 
	#CAN_FFA1R_FFA2
 ((
uint16_t
)0x0004)

	)

1853 #define 
	#CAN_FFA1R_FFA3
 ((
uint16_t
)0x0008)

	)

1854 #define 
	#CAN_FFA1R_FFA4
 ((
uint16_t
)0x0010)

	)

1855 #define 
	#CAN_FFA1R_FFA5
 ((
uint16_t
)0x0020)

	)

1856 #define 
	#CAN_FFA1R_FFA6
 ((
uint16_t
)0x0040)

	)

1857 #define 
	#CAN_FFA1R_FFA7
 ((
uint16_t
)0x0080)

	)

1858 #define 
	#CAN_FFA1R_FFA8
 ((
uint16_t
)0x0100)

	)

1859 #define 
	#CAN_FFA1R_FFA9
 ((
uint16_t
)0x0200)

	)

1860 #define 
	#CAN_FFA1R_FFA10
 ((
uint16_t
)0x0400)

	)

1861 #define 
	#CAN_FFA1R_FFA11
 ((
uint16_t
)0x0800)

	)

1862 #define 
	#CAN_FFA1R_FFA12
 ((
uint16_t
)0x1000)

	)

1863 #define 
	#CAN_FFA1R_FFA13
 ((
uint16_t
)0x2000)

	)

1866 #define 
	#CAN_FA1R_FACT
 ((
uint16_t
)0x3FFF)

	)

1867 #define 
	#CAN_FA1R_FACT0
 ((
uint16_t
)0x0001)

	)

1868 #define 
	#CAN_FA1R_FACT1
 ((
uint16_t
)0x0002)

	)

1869 #define 
	#CAN_FA1R_FACT2
 ((
uint16_t
)0x0004)

	)

1870 #define 
	#CAN_FA1R_FACT3
 ((
uint16_t
)0x0008)

	)

1871 #define 
	#CAN_FA1R_FACT4
 ((
uint16_t
)0x0010)

	)

1872 #define 
	#CAN_FA1R_FACT5
 ((
uint16_t
)0x0020)

	)

1873 #define 
	#CAN_FA1R_FACT6
 ((
uint16_t
)0x0040)

	)

1874 #define 
	#CAN_FA1R_FACT7
 ((
uint16_t
)0x0080)

	)

1875 #define 
	#CAN_FA1R_FACT8
 ((
uint16_t
)0x0100)

	)

1876 #define 
	#CAN_FA1R_FACT9
 ((
uint16_t
)0x0200)

	)

1877 #define 
	#CAN_FA1R_FACT10
 ((
uint16_t
)0x0400)

	)

1878 #define 
	#CAN_FA1R_FACT11
 ((
uint16_t
)0x0800)

	)

1879 #define 
	#CAN_FA1R_FACT12
 ((
uint16_t
)0x1000)

	)

1880 #define 
	#CAN_FA1R_FACT13
 ((
uint16_t
)0x2000)

	)

1883 #define 
	#CAN_F0R1_FB0
 ((
uint32_t
)0x00000001)

	)

1884 #define 
	#CAN_F0R1_FB1
 ((
uint32_t
)0x00000002)

	)

1885 #define 
	#CAN_F0R1_FB2
 ((
uint32_t
)0x00000004)

	)

1886 #define 
	#CAN_F0R1_FB3
 ((
uint32_t
)0x00000008)

	)

1887 #define 
	#CAN_F0R1_FB4
 ((
uint32_t
)0x00000010)

	)

1888 #define 
	#CAN_F0R1_FB5
 ((
uint32_t
)0x00000020)

	)

1889 #define 
	#CAN_F0R1_FB6
 ((
uint32_t
)0x00000040)

	)

1890 #define 
	#CAN_F0R1_FB7
 ((
uint32_t
)0x00000080)

	)

1891 #define 
	#CAN_F0R1_FB8
 ((
uint32_t
)0x00000100)

	)

1892 #define 
	#CAN_F0R1_FB9
 ((
uint32_t
)0x00000200)

	)

1893 #define 
	#CAN_F0R1_FB10
 ((
uint32_t
)0x00000400)

	)

1894 #define 
	#CAN_F0R1_FB11
 ((
uint32_t
)0x00000800)

	)

1895 #define 
	#CAN_F0R1_FB12
 ((
uint32_t
)0x00001000)

	)

1896 #define 
	#CAN_F0R1_FB13
 ((
uint32_t
)0x00002000)

	)

1897 #define 
	#CAN_F0R1_FB14
 ((
uint32_t
)0x00004000)

	)

1898 #define 
	#CAN_F0R1_FB15
 ((
uint32_t
)0x00008000)

	)

1899 #define 
	#CAN_F0R1_FB16
 ((
uint32_t
)0x00010000)

	)

1900 #define 
	#CAN_F0R1_FB17
 ((
uint32_t
)0x00020000)

	)

1901 #define 
	#CAN_F0R1_FB18
 ((
uint32_t
)0x00040000)

	)

1902 #define 
	#CAN_F0R1_FB19
 ((
uint32_t
)0x00080000)

	)

1903 #define 
	#CAN_F0R1_FB20
 ((
uint32_t
)0x00100000)

	)

1904 #define 
	#CAN_F0R1_FB21
 ((
uint32_t
)0x00200000)

	)

1905 #define 
	#CAN_F0R1_FB22
 ((
uint32_t
)0x00400000)

	)

1906 #define 
	#CAN_F0R1_FB23
 ((
uint32_t
)0x00800000)

	)

1907 #define 
	#CAN_F0R1_FB24
 ((
uint32_t
)0x01000000)

	)

1908 #define 
	#CAN_F0R1_FB25
 ((
uint32_t
)0x02000000)

	)

1909 #define 
	#CAN_F0R1_FB26
 ((
uint32_t
)0x04000000)

	)

1910 #define 
	#CAN_F0R1_FB27
 ((
uint32_t
)0x08000000)

	)

1911 #define 
	#CAN_F0R1_FB28
 ((
uint32_t
)0x10000000)

	)

1912 #define 
	#CAN_F0R1_FB29
 ((
uint32_t
)0x20000000)

	)

1913 #define 
	#CAN_F0R1_FB30
 ((
uint32_t
)0x40000000)

	)

1914 #define 
	#CAN_F0R1_FB31
 ((
uint32_t
)0x80000000)

	)

1917 #define 
	#CAN_F1R1_FB0
 ((
uint32_t
)0x00000001)

	)

1918 #define 
	#CAN_F1R1_FB1
 ((
uint32_t
)0x00000002)

	)

1919 #define 
	#CAN_F1R1_FB2
 ((
uint32_t
)0x00000004)

	)

1920 #define 
	#CAN_F1R1_FB3
 ((
uint32_t
)0x00000008)

	)

1921 #define 
	#CAN_F1R1_FB4
 ((
uint32_t
)0x00000010)

	)

1922 #define 
	#CAN_F1R1_FB5
 ((
uint32_t
)0x00000020)

	)

1923 #define 
	#CAN_F1R1_FB6
 ((
uint32_t
)0x00000040)

	)

1924 #define 
	#CAN_F1R1_FB7
 ((
uint32_t
)0x00000080)

	)

1925 #define 
	#CAN_F1R1_FB8
 ((
uint32_t
)0x00000100)

	)

1926 #define 
	#CAN_F1R1_FB9
 ((
uint32_t
)0x00000200)

	)

1927 #define 
	#CAN_F1R1_FB10
 ((
uint32_t
)0x00000400)

	)

1928 #define 
	#CAN_F1R1_FB11
 ((
uint32_t
)0x00000800)

	)

1929 #define 
	#CAN_F1R1_FB12
 ((
uint32_t
)0x00001000)

	)

1930 #define 
	#CAN_F1R1_FB13
 ((
uint32_t
)0x00002000)

	)

1931 #define 
	#CAN_F1R1_FB14
 ((
uint32_t
)0x00004000)

	)

1932 #define 
	#CAN_F1R1_FB15
 ((
uint32_t
)0x00008000)

	)

1933 #define 
	#CAN_F1R1_FB16
 ((
uint32_t
)0x00010000)

	)

1934 #define 
	#CAN_F1R1_FB17
 ((
uint32_t
)0x00020000)

	)

1935 #define 
	#CAN_F1R1_FB18
 ((
uint32_t
)0x00040000)

	)

1936 #define 
	#CAN_F1R1_FB19
 ((
uint32_t
)0x00080000)

	)

1937 #define 
	#CAN_F1R1_FB20
 ((
uint32_t
)0x00100000)

	)

1938 #define 
	#CAN_F1R1_FB21
 ((
uint32_t
)0x00200000)

	)

1939 #define 
	#CAN_F1R1_FB22
 ((
uint32_t
)0x00400000)

	)

1940 #define 
	#CAN_F1R1_FB23
 ((
uint32_t
)0x00800000)

	)

1941 #define 
	#CAN_F1R1_FB24
 ((
uint32_t
)0x01000000)

	)

1942 #define 
	#CAN_F1R1_FB25
 ((
uint32_t
)0x02000000)

	)

1943 #define 
	#CAN_F1R1_FB26
 ((
uint32_t
)0x04000000)

	)

1944 #define 
	#CAN_F1R1_FB27
 ((
uint32_t
)0x08000000)

	)

1945 #define 
	#CAN_F1R1_FB28
 ((
uint32_t
)0x10000000)

	)

1946 #define 
	#CAN_F1R1_FB29
 ((
uint32_t
)0x20000000)

	)

1947 #define 
	#CAN_F1R1_FB30
 ((
uint32_t
)0x40000000)

	)

1948 #define 
	#CAN_F1R1_FB31
 ((
uint32_t
)0x80000000)

	)

1951 #define 
	#CAN_F2R1_FB0
 ((
uint32_t
)0x00000001)

	)

1952 #define 
	#CAN_F2R1_FB1
 ((
uint32_t
)0x00000002)

	)

1953 #define 
	#CAN_F2R1_FB2
 ((
uint32_t
)0x00000004)

	)

1954 #define 
	#CAN_F2R1_FB3
 ((
uint32_t
)0x00000008)

	)

1955 #define 
	#CAN_F2R1_FB4
 ((
uint32_t
)0x00000010)

	)

1956 #define 
	#CAN_F2R1_FB5
 ((
uint32_t
)0x00000020)

	)

1957 #define 
	#CAN_F2R1_FB6
 ((
uint32_t
)0x00000040)

	)

1958 #define 
	#CAN_F2R1_FB7
 ((
uint32_t
)0x00000080)

	)

1959 #define 
	#CAN_F2R1_FB8
 ((
uint32_t
)0x00000100)

	)

1960 #define 
	#CAN_F2R1_FB9
 ((
uint32_t
)0x00000200)

	)

1961 #define 
	#CAN_F2R1_FB10
 ((
uint32_t
)0x00000400)

	)

1962 #define 
	#CAN_F2R1_FB11
 ((
uint32_t
)0x00000800)

	)

1963 #define 
	#CAN_F2R1_FB12
 ((
uint32_t
)0x00001000)

	)

1964 #define 
	#CAN_F2R1_FB13
 ((
uint32_t
)0x00002000)

	)

1965 #define 
	#CAN_F2R1_FB14
 ((
uint32_t
)0x00004000)

	)

1966 #define 
	#CAN_F2R1_FB15
 ((
uint32_t
)0x00008000)

	)

1967 #define 
	#CAN_F2R1_FB16
 ((
uint32_t
)0x00010000)

	)

1968 #define 
	#CAN_F2R1_FB17
 ((
uint32_t
)0x00020000)

	)

1969 #define 
	#CAN_F2R1_FB18
 ((
uint32_t
)0x00040000)

	)

1970 #define 
	#CAN_F2R1_FB19
 ((
uint32_t
)0x00080000)

	)

1971 #define 
	#CAN_F2R1_FB20
 ((
uint32_t
)0x00100000)

	)

1972 #define 
	#CAN_F2R1_FB21
 ((
uint32_t
)0x00200000)

	)

1973 #define 
	#CAN_F2R1_FB22
 ((
uint32_t
)0x00400000)

	)

1974 #define 
	#CAN_F2R1_FB23
 ((
uint32_t
)0x00800000)

	)

1975 #define 
	#CAN_F2R1_FB24
 ((
uint32_t
)0x01000000)

	)

1976 #define 
	#CAN_F2R1_FB25
 ((
uint32_t
)0x02000000)

	)

1977 #define 
	#CAN_F2R1_FB26
 ((
uint32_t
)0x04000000)

	)

1978 #define 
	#CAN_F2R1_FB27
 ((
uint32_t
)0x08000000)

	)

1979 #define 
	#CAN_F2R1_FB28
 ((
uint32_t
)0x10000000)

	)

1980 #define 
	#CAN_F2R1_FB29
 ((
uint32_t
)0x20000000)

	)

1981 #define 
	#CAN_F2R1_FB30
 ((
uint32_t
)0x40000000)

	)

1982 #define 
	#CAN_F2R1_FB31
 ((
uint32_t
)0x80000000)

	)

1985 #define 
	#CAN_F3R1_FB0
 ((
uint32_t
)0x00000001)

	)

1986 #define 
	#CAN_F3R1_FB1
 ((
uint32_t
)0x00000002)

	)

1987 #define 
	#CAN_F3R1_FB2
 ((
uint32_t
)0x00000004)

	)

1988 #define 
	#CAN_F3R1_FB3
 ((
uint32_t
)0x00000008)

	)

1989 #define 
	#CAN_F3R1_FB4
 ((
uint32_t
)0x00000010)

	)

1990 #define 
	#CAN_F3R1_FB5
 ((
uint32_t
)0x00000020)

	)

1991 #define 
	#CAN_F3R1_FB6
 ((
uint32_t
)0x00000040)

	)

1992 #define 
	#CAN_F3R1_FB7
 ((
uint32_t
)0x00000080)

	)

1993 #define 
	#CAN_F3R1_FB8
 ((
uint32_t
)0x00000100)

	)

1994 #define 
	#CAN_F3R1_FB9
 ((
uint32_t
)0x00000200)

	)

1995 #define 
	#CAN_F3R1_FB10
 ((
uint32_t
)0x00000400)

	)

1996 #define 
	#CAN_F3R1_FB11
 ((
uint32_t
)0x00000800)

	)

1997 #define 
	#CAN_F3R1_FB12
 ((
uint32_t
)0x00001000)

	)

1998 #define 
	#CAN_F3R1_FB13
 ((
uint32_t
)0x00002000)

	)

1999 #define 
	#CAN_F3R1_FB14
 ((
uint32_t
)0x00004000)

	)

2000 #define 
	#CAN_F3R1_FB15
 ((
uint32_t
)0x00008000)

	)

2001 #define 
	#CAN_F3R1_FB16
 ((
uint32_t
)0x00010000)

	)

2002 #define 
	#CAN_F3R1_FB17
 ((
uint32_t
)0x00020000)

	)

2003 #define 
	#CAN_F3R1_FB18
 ((
uint32_t
)0x00040000)

	)

2004 #define 
	#CAN_F3R1_FB19
 ((
uint32_t
)0x00080000)

	)

2005 #define 
	#CAN_F3R1_FB20
 ((
uint32_t
)0x00100000)

	)

2006 #define 
	#CAN_F3R1_FB21
 ((
uint32_t
)0x00200000)

	)

2007 #define 
	#CAN_F3R1_FB22
 ((
uint32_t
)0x00400000)

	)

2008 #define 
	#CAN_F3R1_FB23
 ((
uint32_t
)0x00800000)

	)

2009 #define 
	#CAN_F3R1_FB24
 ((
uint32_t
)0x01000000)

	)

2010 #define 
	#CAN_F3R1_FB25
 ((
uint32_t
)0x02000000)

	)

2011 #define 
	#CAN_F3R1_FB26
 ((
uint32_t
)0x04000000)

	)

2012 #define 
	#CAN_F3R1_FB27
 ((
uint32_t
)0x08000000)

	)

2013 #define 
	#CAN_F3R1_FB28
 ((
uint32_t
)0x10000000)

	)

2014 #define 
	#CAN_F3R1_FB29
 ((
uint32_t
)0x20000000)

	)

2015 #define 
	#CAN_F3R1_FB30
 ((
uint32_t
)0x40000000)

	)

2016 #define 
	#CAN_F3R1_FB31
 ((
uint32_t
)0x80000000)

	)

2019 #define 
	#CAN_F4R1_FB0
 ((
uint32_t
)0x00000001)

	)

2020 #define 
	#CAN_F4R1_FB1
 ((
uint32_t
)0x00000002)

	)

2021 #define 
	#CAN_F4R1_FB2
 ((
uint32_t
)0x00000004)

	)

2022 #define 
	#CAN_F4R1_FB3
 ((
uint32_t
)0x00000008)

	)

2023 #define 
	#CAN_F4R1_FB4
 ((
uint32_t
)0x00000010)

	)

2024 #define 
	#CAN_F4R1_FB5
 ((
uint32_t
)0x00000020)

	)

2025 #define 
	#CAN_F4R1_FB6
 ((
uint32_t
)0x00000040)

	)

2026 #define 
	#CAN_F4R1_FB7
 ((
uint32_t
)0x00000080)

	)

2027 #define 
	#CAN_F4R1_FB8
 ((
uint32_t
)0x00000100)

	)

2028 #define 
	#CAN_F4R1_FB9
 ((
uint32_t
)0x00000200)

	)

2029 #define 
	#CAN_F4R1_FB10
 ((
uint32_t
)0x00000400)

	)

2030 #define 
	#CAN_F4R1_FB11
 ((
uint32_t
)0x00000800)

	)

2031 #define 
	#CAN_F4R1_FB12
 ((
uint32_t
)0x00001000)

	)

2032 #define 
	#CAN_F4R1_FB13
 ((
uint32_t
)0x00002000)

	)

2033 #define 
	#CAN_F4R1_FB14
 ((
uint32_t
)0x00004000)

	)

2034 #define 
	#CAN_F4R1_FB15
 ((
uint32_t
)0x00008000)

	)

2035 #define 
	#CAN_F4R1_FB16
 ((
uint32_t
)0x00010000)

	)

2036 #define 
	#CAN_F4R1_FB17
 ((
uint32_t
)0x00020000)

	)

2037 #define 
	#CAN_F4R1_FB18
 ((
uint32_t
)0x00040000)

	)

2038 #define 
	#CAN_F4R1_FB19
 ((
uint32_t
)0x00080000)

	)

2039 #define 
	#CAN_F4R1_FB20
 ((
uint32_t
)0x00100000)

	)

2040 #define 
	#CAN_F4R1_FB21
 ((
uint32_t
)0x00200000)

	)

2041 #define 
	#CAN_F4R1_FB22
 ((
uint32_t
)0x00400000)

	)

2042 #define 
	#CAN_F4R1_FB23
 ((
uint32_t
)0x00800000)

	)

2043 #define 
	#CAN_F4R1_FB24
 ((
uint32_t
)0x01000000)

	)

2044 #define 
	#CAN_F4R1_FB25
 ((
uint32_t
)0x02000000)

	)

2045 #define 
	#CAN_F4R1_FB26
 ((
uint32_t
)0x04000000)

	)

2046 #define 
	#CAN_F4R1_FB27
 ((
uint32_t
)0x08000000)

	)

2047 #define 
	#CAN_F4R1_FB28
 ((
uint32_t
)0x10000000)

	)

2048 #define 
	#CAN_F4R1_FB29
 ((
uint32_t
)0x20000000)

	)

2049 #define 
	#CAN_F4R1_FB30
 ((
uint32_t
)0x40000000)

	)

2050 #define 
	#CAN_F4R1_FB31
 ((
uint32_t
)0x80000000)

	)

2053 #define 
	#CAN_F5R1_FB0
 ((
uint32_t
)0x00000001)

	)

2054 #define 
	#CAN_F5R1_FB1
 ((
uint32_t
)0x00000002)

	)

2055 #define 
	#CAN_F5R1_FB2
 ((
uint32_t
)0x00000004)

	)

2056 #define 
	#CAN_F5R1_FB3
 ((
uint32_t
)0x00000008)

	)

2057 #define 
	#CAN_F5R1_FB4
 ((
uint32_t
)0x00000010)

	)

2058 #define 
	#CAN_F5R1_FB5
 ((
uint32_t
)0x00000020)

	)

2059 #define 
	#CAN_F5R1_FB6
 ((
uint32_t
)0x00000040)

	)

2060 #define 
	#CAN_F5R1_FB7
 ((
uint32_t
)0x00000080)

	)

2061 #define 
	#CAN_F5R1_FB8
 ((
uint32_t
)0x00000100)

	)

2062 #define 
	#CAN_F5R1_FB9
 ((
uint32_t
)0x00000200)

	)

2063 #define 
	#CAN_F5R1_FB10
 ((
uint32_t
)0x00000400)

	)

2064 #define 
	#CAN_F5R1_FB11
 ((
uint32_t
)0x00000800)

	)

2065 #define 
	#CAN_F5R1_FB12
 ((
uint32_t
)0x00001000)

	)

2066 #define 
	#CAN_F5R1_FB13
 ((
uint32_t
)0x00002000)

	)

2067 #define 
	#CAN_F5R1_FB14
 ((
uint32_t
)0x00004000)

	)

2068 #define 
	#CAN_F5R1_FB15
 ((
uint32_t
)0x00008000)

	)

2069 #define 
	#CAN_F5R1_FB16
 ((
uint32_t
)0x00010000)

	)

2070 #define 
	#CAN_F5R1_FB17
 ((
uint32_t
)0x00020000)

	)

2071 #define 
	#CAN_F5R1_FB18
 ((
uint32_t
)0x00040000)

	)

2072 #define 
	#CAN_F5R1_FB19
 ((
uint32_t
)0x00080000)

	)

2073 #define 
	#CAN_F5R1_FB20
 ((
uint32_t
)0x00100000)

	)

2074 #define 
	#CAN_F5R1_FB21
 ((
uint32_t
)0x00200000)

	)

2075 #define 
	#CAN_F5R1_FB22
 ((
uint32_t
)0x00400000)

	)

2076 #define 
	#CAN_F5R1_FB23
 ((
uint32_t
)0x00800000)

	)

2077 #define 
	#CAN_F5R1_FB24
 ((
uint32_t
)0x01000000)

	)

2078 #define 
	#CAN_F5R1_FB25
 ((
uint32_t
)0x02000000)

	)

2079 #define 
	#CAN_F5R1_FB26
 ((
uint32_t
)0x04000000)

	)

2080 #define 
	#CAN_F5R1_FB27
 ((
uint32_t
)0x08000000)

	)

2081 #define 
	#CAN_F5R1_FB28
 ((
uint32_t
)0x10000000)

	)

2082 #define 
	#CAN_F5R1_FB29
 ((
uint32_t
)0x20000000)

	)

2083 #define 
	#CAN_F5R1_FB30
 ((
uint32_t
)0x40000000)

	)

2084 #define 
	#CAN_F5R1_FB31
 ((
uint32_t
)0x80000000)

	)

2087 #define 
	#CAN_F6R1_FB0
 ((
uint32_t
)0x00000001)

	)

2088 #define 
	#CAN_F6R1_FB1
 ((
uint32_t
)0x00000002)

	)

2089 #define 
	#CAN_F6R1_FB2
 ((
uint32_t
)0x00000004)

	)

2090 #define 
	#CAN_F6R1_FB3
 ((
uint32_t
)0x00000008)

	)

2091 #define 
	#CAN_F6R1_FB4
 ((
uint32_t
)0x00000010)

	)

2092 #define 
	#CAN_F6R1_FB5
 ((
uint32_t
)0x00000020)

	)

2093 #define 
	#CAN_F6R1_FB6
 ((
uint32_t
)0x00000040)

	)

2094 #define 
	#CAN_F6R1_FB7
 ((
uint32_t
)0x00000080)

	)

2095 #define 
	#CAN_F6R1_FB8
 ((
uint32_t
)0x00000100)

	)

2096 #define 
	#CAN_F6R1_FB9
 ((
uint32_t
)0x00000200)

	)

2097 #define 
	#CAN_F6R1_FB10
 ((
uint32_t
)0x00000400)

	)

2098 #define 
	#CAN_F6R1_FB11
 ((
uint32_t
)0x00000800)

	)

2099 #define 
	#CAN_F6R1_FB12
 ((
uint32_t
)0x00001000)

	)

2100 #define 
	#CAN_F6R1_FB13
 ((
uint32_t
)0x00002000)

	)

2101 #define 
	#CAN_F6R1_FB14
 ((
uint32_t
)0x00004000)

	)

2102 #define 
	#CAN_F6R1_FB15
 ((
uint32_t
)0x00008000)

	)

2103 #define 
	#CAN_F6R1_FB16
 ((
uint32_t
)0x00010000)

	)

2104 #define 
	#CAN_F6R1_FB17
 ((
uint32_t
)0x00020000)

	)

2105 #define 
	#CAN_F6R1_FB18
 ((
uint32_t
)0x00040000)

	)

2106 #define 
	#CAN_F6R1_FB19
 ((
uint32_t
)0x00080000)

	)

2107 #define 
	#CAN_F6R1_FB20
 ((
uint32_t
)0x00100000)

	)

2108 #define 
	#CAN_F6R1_FB21
 ((
uint32_t
)0x00200000)

	)

2109 #define 
	#CAN_F6R1_FB22
 ((
uint32_t
)0x00400000)

	)

2110 #define 
	#CAN_F6R1_FB23
 ((
uint32_t
)0x00800000)

	)

2111 #define 
	#CAN_F6R1_FB24
 ((
uint32_t
)0x01000000)

	)

2112 #define 
	#CAN_F6R1_FB25
 ((
uint32_t
)0x02000000)

	)

2113 #define 
	#CAN_F6R1_FB26
 ((
uint32_t
)0x04000000)

	)

2114 #define 
	#CAN_F6R1_FB27
 ((
uint32_t
)0x08000000)

	)

2115 #define 
	#CAN_F6R1_FB28
 ((
uint32_t
)0x10000000)

	)

2116 #define 
	#CAN_F6R1_FB29
 ((
uint32_t
)0x20000000)

	)

2117 #define 
	#CAN_F6R1_FB30
 ((
uint32_t
)0x40000000)

	)

2118 #define 
	#CAN_F6R1_FB31
 ((
uint32_t
)0x80000000)

	)

2121 #define 
	#CAN_F7R1_FB0
 ((
uint32_t
)0x00000001)

	)

2122 #define 
	#CAN_F7R1_FB1
 ((
uint32_t
)0x00000002)

	)

2123 #define 
	#CAN_F7R1_FB2
 ((
uint32_t
)0x00000004)

	)

2124 #define 
	#CAN_F7R1_FB3
 ((
uint32_t
)0x00000008)

	)

2125 #define 
	#CAN_F7R1_FB4
 ((
uint32_t
)0x00000010)

	)

2126 #define 
	#CAN_F7R1_FB5
 ((
uint32_t
)0x00000020)

	)

2127 #define 
	#CAN_F7R1_FB6
 ((
uint32_t
)0x00000040)

	)

2128 #define 
	#CAN_F7R1_FB7
 ((
uint32_t
)0x00000080)

	)

2129 #define 
	#CAN_F7R1_FB8
 ((
uint32_t
)0x00000100)

	)

2130 #define 
	#CAN_F7R1_FB9
 ((
uint32_t
)0x00000200)

	)

2131 #define 
	#CAN_F7R1_FB10
 ((
uint32_t
)0x00000400)

	)

2132 #define 
	#CAN_F7R1_FB11
 ((
uint32_t
)0x00000800)

	)

2133 #define 
	#CAN_F7R1_FB12
 ((
uint32_t
)0x00001000)

	)

2134 #define 
	#CAN_F7R1_FB13
 ((
uint32_t
)0x00002000)

	)

2135 #define 
	#CAN_F7R1_FB14
 ((
uint32_t
)0x00004000)

	)

2136 #define 
	#CAN_F7R1_FB15
 ((
uint32_t
)0x00008000)

	)

2137 #define 
	#CAN_F7R1_FB16
 ((
uint32_t
)0x00010000)

	)

2138 #define 
	#CAN_F7R1_FB17
 ((
uint32_t
)0x00020000)

	)

2139 #define 
	#CAN_F7R1_FB18
 ((
uint32_t
)0x00040000)

	)

2140 #define 
	#CAN_F7R1_FB19
 ((
uint32_t
)0x00080000)

	)

2141 #define 
	#CAN_F7R1_FB20
 ((
uint32_t
)0x00100000)

	)

2142 #define 
	#CAN_F7R1_FB21
 ((
uint32_t
)0x00200000)

	)

2143 #define 
	#CAN_F7R1_FB22
 ((
uint32_t
)0x00400000)

	)

2144 #define 
	#CAN_F7R1_FB23
 ((
uint32_t
)0x00800000)

	)

2145 #define 
	#CAN_F7R1_FB24
 ((
uint32_t
)0x01000000)

	)

2146 #define 
	#CAN_F7R1_FB25
 ((
uint32_t
)0x02000000)

	)

2147 #define 
	#CAN_F7R1_FB26
 ((
uint32_t
)0x04000000)

	)

2148 #define 
	#CAN_F7R1_FB27
 ((
uint32_t
)0x08000000)

	)

2149 #define 
	#CAN_F7R1_FB28
 ((
uint32_t
)0x10000000)

	)

2150 #define 
	#CAN_F7R1_FB29
 ((
uint32_t
)0x20000000)

	)

2151 #define 
	#CAN_F7R1_FB30
 ((
uint32_t
)0x40000000)

	)

2152 #define 
	#CAN_F7R1_FB31
 ((
uint32_t
)0x80000000)

	)

2155 #define 
	#CAN_F8R1_FB0
 ((
uint32_t
)0x00000001)

	)

2156 #define 
	#CAN_F8R1_FB1
 ((
uint32_t
)0x00000002)

	)

2157 #define 
	#CAN_F8R1_FB2
 ((
uint32_t
)0x00000004)

	)

2158 #define 
	#CAN_F8R1_FB3
 ((
uint32_t
)0x00000008)

	)

2159 #define 
	#CAN_F8R1_FB4
 ((
uint32_t
)0x00000010)

	)

2160 #define 
	#CAN_F8R1_FB5
 ((
uint32_t
)0x00000020)

	)

2161 #define 
	#CAN_F8R1_FB6
 ((
uint32_t
)0x00000040)

	)

2162 #define 
	#CAN_F8R1_FB7
 ((
uint32_t
)0x00000080)

	)

2163 #define 
	#CAN_F8R1_FB8
 ((
uint32_t
)0x00000100)

	)

2164 #define 
	#CAN_F8R1_FB9
 ((
uint32_t
)0x00000200)

	)

2165 #define 
	#CAN_F8R1_FB10
 ((
uint32_t
)0x00000400)

	)

2166 #define 
	#CAN_F8R1_FB11
 ((
uint32_t
)0x00000800)

	)

2167 #define 
	#CAN_F8R1_FB12
 ((
uint32_t
)0x00001000)

	)

2168 #define 
	#CAN_F8R1_FB13
 ((
uint32_t
)0x00002000)

	)

2169 #define 
	#CAN_F8R1_FB14
 ((
uint32_t
)0x00004000)

	)

2170 #define 
	#CAN_F8R1_FB15
 ((
uint32_t
)0x00008000)

	)

2171 #define 
	#CAN_F8R1_FB16
 ((
uint32_t
)0x00010000)

	)

2172 #define 
	#CAN_F8R1_FB17
 ((
uint32_t
)0x00020000)

	)

2173 #define 
	#CAN_F8R1_FB18
 ((
uint32_t
)0x00040000)

	)

2174 #define 
	#CAN_F8R1_FB19
 ((
uint32_t
)0x00080000)

	)

2175 #define 
	#CAN_F8R1_FB20
 ((
uint32_t
)0x00100000)

	)

2176 #define 
	#CAN_F8R1_FB21
 ((
uint32_t
)0x00200000)

	)

2177 #define 
	#CAN_F8R1_FB22
 ((
uint32_t
)0x00400000)

	)

2178 #define 
	#CAN_F8R1_FB23
 ((
uint32_t
)0x00800000)

	)

2179 #define 
	#CAN_F8R1_FB24
 ((
uint32_t
)0x01000000)

	)

2180 #define 
	#CAN_F8R1_FB25
 ((
uint32_t
)0x02000000)

	)

2181 #define 
	#CAN_F8R1_FB26
 ((
uint32_t
)0x04000000)

	)

2182 #define 
	#CAN_F8R1_FB27
 ((
uint32_t
)0x08000000)

	)

2183 #define 
	#CAN_F8R1_FB28
 ((
uint32_t
)0x10000000)

	)

2184 #define 
	#CAN_F8R1_FB29
 ((
uint32_t
)0x20000000)

	)

2185 #define 
	#CAN_F8R1_FB30
 ((
uint32_t
)0x40000000)

	)

2186 #define 
	#CAN_F8R1_FB31
 ((
uint32_t
)0x80000000)

	)

2189 #define 
	#CAN_F9R1_FB0
 ((
uint32_t
)0x00000001)

	)

2190 #define 
	#CAN_F9R1_FB1
 ((
uint32_t
)0x00000002)

	)

2191 #define 
	#CAN_F9R1_FB2
 ((
uint32_t
)0x00000004)

	)

2192 #define 
	#CAN_F9R1_FB3
 ((
uint32_t
)0x00000008)

	)

2193 #define 
	#CAN_F9R1_FB4
 ((
uint32_t
)0x00000010)

	)

2194 #define 
	#CAN_F9R1_FB5
 ((
uint32_t
)0x00000020)

	)

2195 #define 
	#CAN_F9R1_FB6
 ((
uint32_t
)0x00000040)

	)

2196 #define 
	#CAN_F9R1_FB7
 ((
uint32_t
)0x00000080)

	)

2197 #define 
	#CAN_F9R1_FB8
 ((
uint32_t
)0x00000100)

	)

2198 #define 
	#CAN_F9R1_FB9
 ((
uint32_t
)0x00000200)

	)

2199 #define 
	#CAN_F9R1_FB10
 ((
uint32_t
)0x00000400)

	)

2200 #define 
	#CAN_F9R1_FB11
 ((
uint32_t
)0x00000800)

	)

2201 #define 
	#CAN_F9R1_FB12
 ((
uint32_t
)0x00001000)

	)

2202 #define 
	#CAN_F9R1_FB13
 ((
uint32_t
)0x00002000)

	)

2203 #define 
	#CAN_F9R1_FB14
 ((
uint32_t
)0x00004000)

	)

2204 #define 
	#CAN_F9R1_FB15
 ((
uint32_t
)0x00008000)

	)

2205 #define 
	#CAN_F9R1_FB16
 ((
uint32_t
)0x00010000)

	)

2206 #define 
	#CAN_F9R1_FB17
 ((
uint32_t
)0x00020000)

	)

2207 #define 
	#CAN_F9R1_FB18
 ((
uint32_t
)0x00040000)

	)

2208 #define 
	#CAN_F9R1_FB19
 ((
uint32_t
)0x00080000)

	)

2209 #define 
	#CAN_F9R1_FB20
 ((
uint32_t
)0x00100000)

	)

2210 #define 
	#CAN_F9R1_FB21
 ((
uint32_t
)0x00200000)

	)

2211 #define 
	#CAN_F9R1_FB22
 ((
uint32_t
)0x00400000)

	)

2212 #define 
	#CAN_F9R1_FB23
 ((
uint32_t
)0x00800000)

	)

2213 #define 
	#CAN_F9R1_FB24
 ((
uint32_t
)0x01000000)

	)

2214 #define 
	#CAN_F9R1_FB25
 ((
uint32_t
)0x02000000)

	)

2215 #define 
	#CAN_F9R1_FB26
 ((
uint32_t
)0x04000000)

	)

2216 #define 
	#CAN_F9R1_FB27
 ((
uint32_t
)0x08000000)

	)

2217 #define 
	#CAN_F9R1_FB28
 ((
uint32_t
)0x10000000)

	)

2218 #define 
	#CAN_F9R1_FB29
 ((
uint32_t
)0x20000000)

	)

2219 #define 
	#CAN_F9R1_FB30
 ((
uint32_t
)0x40000000)

	)

2220 #define 
	#CAN_F9R1_FB31
 ((
uint32_t
)0x80000000)

	)

2223 #define 
	#CAN_F10R1_FB0
 ((
uint32_t
)0x00000001)

	)

2224 #define 
	#CAN_F10R1_FB1
 ((
uint32_t
)0x00000002)

	)

2225 #define 
	#CAN_F10R1_FB2
 ((
uint32_t
)0x00000004)

	)

2226 #define 
	#CAN_F10R1_FB3
 ((
uint32_t
)0x00000008)

	)

2227 #define 
	#CAN_F10R1_FB4
 ((
uint32_t
)0x00000010)

	)

2228 #define 
	#CAN_F10R1_FB5
 ((
uint32_t
)0x00000020)

	)

2229 #define 
	#CAN_F10R1_FB6
 ((
uint32_t
)0x00000040)

	)

2230 #define 
	#CAN_F10R1_FB7
 ((
uint32_t
)0x00000080)

	)

2231 #define 
	#CAN_F10R1_FB8
 ((
uint32_t
)0x00000100)

	)

2232 #define 
	#CAN_F10R1_FB9
 ((
uint32_t
)0x00000200)

	)

2233 #define 
	#CAN_F10R1_FB10
 ((
uint32_t
)0x00000400)

	)

2234 #define 
	#CAN_F10R1_FB11
 ((
uint32_t
)0x00000800)

	)

2235 #define 
	#CAN_F10R1_FB12
 ((
uint32_t
)0x00001000)

	)

2236 #define 
	#CAN_F10R1_FB13
 ((
uint32_t
)0x00002000)

	)

2237 #define 
	#CAN_F10R1_FB14
 ((
uint32_t
)0x00004000)

	)

2238 #define 
	#CAN_F10R1_FB15
 ((
uint32_t
)0x00008000)

	)

2239 #define 
	#CAN_F10R1_FB16
 ((
uint32_t
)0x00010000)

	)

2240 #define 
	#CAN_F10R1_FB17
 ((
uint32_t
)0x00020000)

	)

2241 #define 
	#CAN_F10R1_FB18
 ((
uint32_t
)0x00040000)

	)

2242 #define 
	#CAN_F10R1_FB19
 ((
uint32_t
)0x00080000)

	)

2243 #define 
	#CAN_F10R1_FB20
 ((
uint32_t
)0x00100000)

	)

2244 #define 
	#CAN_F10R1_FB21
 ((
uint32_t
)0x00200000)

	)

2245 #define 
	#CAN_F10R1_FB22
 ((
uint32_t
)0x00400000)

	)

2246 #define 
	#CAN_F10R1_FB23
 ((
uint32_t
)0x00800000)

	)

2247 #define 
	#CAN_F10R1_FB24
 ((
uint32_t
)0x01000000)

	)

2248 #define 
	#CAN_F10R1_FB25
 ((
uint32_t
)0x02000000)

	)

2249 #define 
	#CAN_F10R1_FB26
 ((
uint32_t
)0x04000000)

	)

2250 #define 
	#CAN_F10R1_FB27
 ((
uint32_t
)0x08000000)

	)

2251 #define 
	#CAN_F10R1_FB28
 ((
uint32_t
)0x10000000)

	)

2252 #define 
	#CAN_F10R1_FB29
 ((
uint32_t
)0x20000000)

	)

2253 #define 
	#CAN_F10R1_FB30
 ((
uint32_t
)0x40000000)

	)

2254 #define 
	#CAN_F10R1_FB31
 ((
uint32_t
)0x80000000)

	)

2257 #define 
	#CAN_F11R1_FB0
 ((
uint32_t
)0x00000001)

	)

2258 #define 
	#CAN_F11R1_FB1
 ((
uint32_t
)0x00000002)

	)

2259 #define 
	#CAN_F11R1_FB2
 ((
uint32_t
)0x00000004)

	)

2260 #define 
	#CAN_F11R1_FB3
 ((
uint32_t
)0x00000008)

	)

2261 #define 
	#CAN_F11R1_FB4
 ((
uint32_t
)0x00000010)

	)

2262 #define 
	#CAN_F11R1_FB5
 ((
uint32_t
)0x00000020)

	)

2263 #define 
	#CAN_F11R1_FB6
 ((
uint32_t
)0x00000040)

	)

2264 #define 
	#CAN_F11R1_FB7
 ((
uint32_t
)0x00000080)

	)

2265 #define 
	#CAN_F11R1_FB8
 ((
uint32_t
)0x00000100)

	)

2266 #define 
	#CAN_F11R1_FB9
 ((
uint32_t
)0x00000200)

	)

2267 #define 
	#CAN_F11R1_FB10
 ((
uint32_t
)0x00000400)

	)

2268 #define 
	#CAN_F11R1_FB11
 ((
uint32_t
)0x00000800)

	)

2269 #define 
	#CAN_F11R1_FB12
 ((
uint32_t
)0x00001000)

	)

2270 #define 
	#CAN_F11R1_FB13
 ((
uint32_t
)0x00002000)

	)

2271 #define 
	#CAN_F11R1_FB14
 ((
uint32_t
)0x00004000)

	)

2272 #define 
	#CAN_F11R1_FB15
 ((
uint32_t
)0x00008000)

	)

2273 #define 
	#CAN_F11R1_FB16
 ((
uint32_t
)0x00010000)

	)

2274 #define 
	#CAN_F11R1_FB17
 ((
uint32_t
)0x00020000)

	)

2275 #define 
	#CAN_F11R1_FB18
 ((
uint32_t
)0x00040000)

	)

2276 #define 
	#CAN_F11R1_FB19
 ((
uint32_t
)0x00080000)

	)

2277 #define 
	#CAN_F11R1_FB20
 ((
uint32_t
)0x00100000)

	)

2278 #define 
	#CAN_F11R1_FB21
 ((
uint32_t
)0x00200000)

	)

2279 #define 
	#CAN_F11R1_FB22
 ((
uint32_t
)0x00400000)

	)

2280 #define 
	#CAN_F11R1_FB23
 ((
uint32_t
)0x00800000)

	)

2281 #define 
	#CAN_F11R1_FB24
 ((
uint32_t
)0x01000000)

	)

2282 #define 
	#CAN_F11R1_FB25
 ((
uint32_t
)0x02000000)

	)

2283 #define 
	#CAN_F11R1_FB26
 ((
uint32_t
)0x04000000)

	)

2284 #define 
	#CAN_F11R1_FB27
 ((
uint32_t
)0x08000000)

	)

2285 #define 
	#CAN_F11R1_FB28
 ((
uint32_t
)0x10000000)

	)

2286 #define 
	#CAN_F11R1_FB29
 ((
uint32_t
)0x20000000)

	)

2287 #define 
	#CAN_F11R1_FB30
 ((
uint32_t
)0x40000000)

	)

2288 #define 
	#CAN_F11R1_FB31
 ((
uint32_t
)0x80000000)

	)

2291 #define 
	#CAN_F12R1_FB0
 ((
uint32_t
)0x00000001)

	)

2292 #define 
	#CAN_F12R1_FB1
 ((
uint32_t
)0x00000002)

	)

2293 #define 
	#CAN_F12R1_FB2
 ((
uint32_t
)0x00000004)

	)

2294 #define 
	#CAN_F12R1_FB3
 ((
uint32_t
)0x00000008)

	)

2295 #define 
	#CAN_F12R1_FB4
 ((
uint32_t
)0x00000010)

	)

2296 #define 
	#CAN_F12R1_FB5
 ((
uint32_t
)0x00000020)

	)

2297 #define 
	#CAN_F12R1_FB6
 ((
uint32_t
)0x00000040)

	)

2298 #define 
	#CAN_F12R1_FB7
 ((
uint32_t
)0x00000080)

	)

2299 #define 
	#CAN_F12R1_FB8
 ((
uint32_t
)0x00000100)

	)

2300 #define 
	#CAN_F12R1_FB9
 ((
uint32_t
)0x00000200)

	)

2301 #define 
	#CAN_F12R1_FB10
 ((
uint32_t
)0x00000400)

	)

2302 #define 
	#CAN_F12R1_FB11
 ((
uint32_t
)0x00000800)

	)

2303 #define 
	#CAN_F12R1_FB12
 ((
uint32_t
)0x00001000)

	)

2304 #define 
	#CAN_F12R1_FB13
 ((
uint32_t
)0x00002000)

	)

2305 #define 
	#CAN_F12R1_FB14
 ((
uint32_t
)0x00004000)

	)

2306 #define 
	#CAN_F12R1_FB15
 ((
uint32_t
)0x00008000)

	)

2307 #define 
	#CAN_F12R1_FB16
 ((
uint32_t
)0x00010000)

	)

2308 #define 
	#CAN_F12R1_FB17
 ((
uint32_t
)0x00020000)

	)

2309 #define 
	#CAN_F12R1_FB18
 ((
uint32_t
)0x00040000)

	)

2310 #define 
	#CAN_F12R1_FB19
 ((
uint32_t
)0x00080000)

	)

2311 #define 
	#CAN_F12R1_FB20
 ((
uint32_t
)0x00100000)

	)

2312 #define 
	#CAN_F12R1_FB21
 ((
uint32_t
)0x00200000)

	)

2313 #define 
	#CAN_F12R1_FB22
 ((
uint32_t
)0x00400000)

	)

2314 #define 
	#CAN_F12R1_FB23
 ((
uint32_t
)0x00800000)

	)

2315 #define 
	#CAN_F12R1_FB24
 ((
uint32_t
)0x01000000)

	)

2316 #define 
	#CAN_F12R1_FB25
 ((
uint32_t
)0x02000000)

	)

2317 #define 
	#CAN_F12R1_FB26
 ((
uint32_t
)0x04000000)

	)

2318 #define 
	#CAN_F12R1_FB27
 ((
uint32_t
)0x08000000)

	)

2319 #define 
	#CAN_F12R1_FB28
 ((
uint32_t
)0x10000000)

	)

2320 #define 
	#CAN_F12R1_FB29
 ((
uint32_t
)0x20000000)

	)

2321 #define 
	#CAN_F12R1_FB30
 ((
uint32_t
)0x40000000)

	)

2322 #define 
	#CAN_F12R1_FB31
 ((
uint32_t
)0x80000000)

	)

2325 #define 
	#CAN_F13R1_FB0
 ((
uint32_t
)0x00000001)

	)

2326 #define 
	#CAN_F13R1_FB1
 ((
uint32_t
)0x00000002)

	)

2327 #define 
	#CAN_F13R1_FB2
 ((
uint32_t
)0x00000004)

	)

2328 #define 
	#CAN_F13R1_FB3
 ((
uint32_t
)0x00000008)

	)

2329 #define 
	#CAN_F13R1_FB4
 ((
uint32_t
)0x00000010)

	)

2330 #define 
	#CAN_F13R1_FB5
 ((
uint32_t
)0x00000020)

	)

2331 #define 
	#CAN_F13R1_FB6
 ((
uint32_t
)0x00000040)

	)

2332 #define 
	#CAN_F13R1_FB7
 ((
uint32_t
)0x00000080)

	)

2333 #define 
	#CAN_F13R1_FB8
 ((
uint32_t
)0x00000100)

	)

2334 #define 
	#CAN_F13R1_FB9
 ((
uint32_t
)0x00000200)

	)

2335 #define 
	#CAN_F13R1_FB10
 ((
uint32_t
)0x00000400)

	)

2336 #define 
	#CAN_F13R1_FB11
 ((
uint32_t
)0x00000800)

	)

2337 #define 
	#CAN_F13R1_FB12
 ((
uint32_t
)0x00001000)

	)

2338 #define 
	#CAN_F13R1_FB13
 ((
uint32_t
)0x00002000)

	)

2339 #define 
	#CAN_F13R1_FB14
 ((
uint32_t
)0x00004000)

	)

2340 #define 
	#CAN_F13R1_FB15
 ((
uint32_t
)0x00008000)

	)

2341 #define 
	#CAN_F13R1_FB16
 ((
uint32_t
)0x00010000)

	)

2342 #define 
	#CAN_F13R1_FB17
 ((
uint32_t
)0x00020000)

	)

2343 #define 
	#CAN_F13R1_FB18
 ((
uint32_t
)0x00040000)

	)

2344 #define 
	#CAN_F13R1_FB19
 ((
uint32_t
)0x00080000)

	)

2345 #define 
	#CAN_F13R1_FB20
 ((
uint32_t
)0x00100000)

	)

2346 #define 
	#CAN_F13R1_FB21
 ((
uint32_t
)0x00200000)

	)

2347 #define 
	#CAN_F13R1_FB22
 ((
uint32_t
)0x00400000)

	)

2348 #define 
	#CAN_F13R1_FB23
 ((
uint32_t
)0x00800000)

	)

2349 #define 
	#CAN_F13R1_FB24
 ((
uint32_t
)0x01000000)

	)

2350 #define 
	#CAN_F13R1_FB25
 ((
uint32_t
)0x02000000)

	)

2351 #define 
	#CAN_F13R1_FB26
 ((
uint32_t
)0x04000000)

	)

2352 #define 
	#CAN_F13R1_FB27
 ((
uint32_t
)0x08000000)

	)

2353 #define 
	#CAN_F13R1_FB28
 ((
uint32_t
)0x10000000)

	)

2354 #define 
	#CAN_F13R1_FB29
 ((
uint32_t
)0x20000000)

	)

2355 #define 
	#CAN_F13R1_FB30
 ((
uint32_t
)0x40000000)

	)

2356 #define 
	#CAN_F13R1_FB31
 ((
uint32_t
)0x80000000)

	)

2359 #define 
	#CAN_F0R2_FB0
 ((
uint32_t
)0x00000001)

	)

2360 #define 
	#CAN_F0R2_FB1
 ((
uint32_t
)0x00000002)

	)

2361 #define 
	#CAN_F0R2_FB2
 ((
uint32_t
)0x00000004)

	)

2362 #define 
	#CAN_F0R2_FB3
 ((
uint32_t
)0x00000008)

	)

2363 #define 
	#CAN_F0R2_FB4
 ((
uint32_t
)0x00000010)

	)

2364 #define 
	#CAN_F0R2_FB5
 ((
uint32_t
)0x00000020)

	)

2365 #define 
	#CAN_F0R2_FB6
 ((
uint32_t
)0x00000040)

	)

2366 #define 
	#CAN_F0R2_FB7
 ((
uint32_t
)0x00000080)

	)

2367 #define 
	#CAN_F0R2_FB8
 ((
uint32_t
)0x00000100)

	)

2368 #define 
	#CAN_F0R2_FB9
 ((
uint32_t
)0x00000200)

	)

2369 #define 
	#CAN_F0R2_FB10
 ((
uint32_t
)0x00000400)

	)

2370 #define 
	#CAN_F0R2_FB11
 ((
uint32_t
)0x00000800)

	)

2371 #define 
	#CAN_F0R2_FB12
 ((
uint32_t
)0x00001000)

	)

2372 #define 
	#CAN_F0R2_FB13
 ((
uint32_t
)0x00002000)

	)

2373 #define 
	#CAN_F0R2_FB14
 ((
uint32_t
)0x00004000)

	)

2374 #define 
	#CAN_F0R2_FB15
 ((
uint32_t
)0x00008000)

	)

2375 #define 
	#CAN_F0R2_FB16
 ((
uint32_t
)0x00010000)

	)

2376 #define 
	#CAN_F0R2_FB17
 ((
uint32_t
)0x00020000)

	)

2377 #define 
	#CAN_F0R2_FB18
 ((
uint32_t
)0x00040000)

	)

2378 #define 
	#CAN_F0R2_FB19
 ((
uint32_t
)0x00080000)

	)

2379 #define 
	#CAN_F0R2_FB20
 ((
uint32_t
)0x00100000)

	)

2380 #define 
	#CAN_F0R2_FB21
 ((
uint32_t
)0x00200000)

	)

2381 #define 
	#CAN_F0R2_FB22
 ((
uint32_t
)0x00400000)

	)

2382 #define 
	#CAN_F0R2_FB23
 ((
uint32_t
)0x00800000)

	)

2383 #define 
	#CAN_F0R2_FB24
 ((
uint32_t
)0x01000000)

	)

2384 #define 
	#CAN_F0R2_FB25
 ((
uint32_t
)0x02000000)

	)

2385 #define 
	#CAN_F0R2_FB26
 ((
uint32_t
)0x04000000)

	)

2386 #define 
	#CAN_F0R2_FB27
 ((
uint32_t
)0x08000000)

	)

2387 #define 
	#CAN_F0R2_FB28
 ((
uint32_t
)0x10000000)

	)

2388 #define 
	#CAN_F0R2_FB29
 ((
uint32_t
)0x20000000)

	)

2389 #define 
	#CAN_F0R2_FB30
 ((
uint32_t
)0x40000000)

	)

2390 #define 
	#CAN_F0R2_FB31
 ((
uint32_t
)0x80000000)

	)

2393 #define 
	#CAN_F1R2_FB0
 ((
uint32_t
)0x00000001)

	)

2394 #define 
	#CAN_F1R2_FB1
 ((
uint32_t
)0x00000002)

	)

2395 #define 
	#CAN_F1R2_FB2
 ((
uint32_t
)0x00000004)

	)

2396 #define 
	#CAN_F1R2_FB3
 ((
uint32_t
)0x00000008)

	)

2397 #define 
	#CAN_F1R2_FB4
 ((
uint32_t
)0x00000010)

	)

2398 #define 
	#CAN_F1R2_FB5
 ((
uint32_t
)0x00000020)

	)

2399 #define 
	#CAN_F1R2_FB6
 ((
uint32_t
)0x00000040)

	)

2400 #define 
	#CAN_F1R2_FB7
 ((
uint32_t
)0x00000080)

	)

2401 #define 
	#CAN_F1R2_FB8
 ((
uint32_t
)0x00000100)

	)

2402 #define 
	#CAN_F1R2_FB9
 ((
uint32_t
)0x00000200)

	)

2403 #define 
	#CAN_F1R2_FB10
 ((
uint32_t
)0x00000400)

	)

2404 #define 
	#CAN_F1R2_FB11
 ((
uint32_t
)0x00000800)

	)

2405 #define 
	#CAN_F1R2_FB12
 ((
uint32_t
)0x00001000)

	)

2406 #define 
	#CAN_F1R2_FB13
 ((
uint32_t
)0x00002000)

	)

2407 #define 
	#CAN_F1R2_FB14
 ((
uint32_t
)0x00004000)

	)

2408 #define 
	#CAN_F1R2_FB15
 ((
uint32_t
)0x00008000)

	)

2409 #define 
	#CAN_F1R2_FB16
 ((
uint32_t
)0x00010000)

	)

2410 #define 
	#CAN_F1R2_FB17
 ((
uint32_t
)0x00020000)

	)

2411 #define 
	#CAN_F1R2_FB18
 ((
uint32_t
)0x00040000)

	)

2412 #define 
	#CAN_F1R2_FB19
 ((
uint32_t
)0x00080000)

	)

2413 #define 
	#CAN_F1R2_FB20
 ((
uint32_t
)0x00100000)

	)

2414 #define 
	#CAN_F1R2_FB21
 ((
uint32_t
)0x00200000)

	)

2415 #define 
	#CAN_F1R2_FB22
 ((
uint32_t
)0x00400000)

	)

2416 #define 
	#CAN_F1R2_FB23
 ((
uint32_t
)0x00800000)

	)

2417 #define 
	#CAN_F1R2_FB24
 ((
uint32_t
)0x01000000)

	)

2418 #define 
	#CAN_F1R2_FB25
 ((
uint32_t
)0x02000000)

	)

2419 #define 
	#CAN_F1R2_FB26
 ((
uint32_t
)0x04000000)

	)

2420 #define 
	#CAN_F1R2_FB27
 ((
uint32_t
)0x08000000)

	)

2421 #define 
	#CAN_F1R2_FB28
 ((
uint32_t
)0x10000000)

	)

2422 #define 
	#CAN_F1R2_FB29
 ((
uint32_t
)0x20000000)

	)

2423 #define 
	#CAN_F1R2_FB30
 ((
uint32_t
)0x40000000)

	)

2424 #define 
	#CAN_F1R2_FB31
 ((
uint32_t
)0x80000000)

	)

2427 #define 
	#CAN_F2R2_FB0
 ((
uint32_t
)0x00000001)

	)

2428 #define 
	#CAN_F2R2_FB1
 ((
uint32_t
)0x00000002)

	)

2429 #define 
	#CAN_F2R2_FB2
 ((
uint32_t
)0x00000004)

	)

2430 #define 
	#CAN_F2R2_FB3
 ((
uint32_t
)0x00000008)

	)

2431 #define 
	#CAN_F2R2_FB4
 ((
uint32_t
)0x00000010)

	)

2432 #define 
	#CAN_F2R2_FB5
 ((
uint32_t
)0x00000020)

	)

2433 #define 
	#CAN_F2R2_FB6
 ((
uint32_t
)0x00000040)

	)

2434 #define 
	#CAN_F2R2_FB7
 ((
uint32_t
)0x00000080)

	)

2435 #define 
	#CAN_F2R2_FB8
 ((
uint32_t
)0x00000100)

	)

2436 #define 
	#CAN_F2R2_FB9
 ((
uint32_t
)0x00000200)

	)

2437 #define 
	#CAN_F2R2_FB10
 ((
uint32_t
)0x00000400)

	)

2438 #define 
	#CAN_F2R2_FB11
 ((
uint32_t
)0x00000800)

	)

2439 #define 
	#CAN_F2R2_FB12
 ((
uint32_t
)0x00001000)

	)

2440 #define 
	#CAN_F2R2_FB13
 ((
uint32_t
)0x00002000)

	)

2441 #define 
	#CAN_F2R2_FB14
 ((
uint32_t
)0x00004000)

	)

2442 #define 
	#CAN_F2R2_FB15
 ((
uint32_t
)0x00008000)

	)

2443 #define 
	#CAN_F2R2_FB16
 ((
uint32_t
)0x00010000)

	)

2444 #define 
	#CAN_F2R2_FB17
 ((
uint32_t
)0x00020000)

	)

2445 #define 
	#CAN_F2R2_FB18
 ((
uint32_t
)0x00040000)

	)

2446 #define 
	#CAN_F2R2_FB19
 ((
uint32_t
)0x00080000)

	)

2447 #define 
	#CAN_F2R2_FB20
 ((
uint32_t
)0x00100000)

	)

2448 #define 
	#CAN_F2R2_FB21
 ((
uint32_t
)0x00200000)

	)

2449 #define 
	#CAN_F2R2_FB22
 ((
uint32_t
)0x00400000)

	)

2450 #define 
	#CAN_F2R2_FB23
 ((
uint32_t
)0x00800000)

	)

2451 #define 
	#CAN_F2R2_FB24
 ((
uint32_t
)0x01000000)

	)

2452 #define 
	#CAN_F2R2_FB25
 ((
uint32_t
)0x02000000)

	)

2453 #define 
	#CAN_F2R2_FB26
 ((
uint32_t
)0x04000000)

	)

2454 #define 
	#CAN_F2R2_FB27
 ((
uint32_t
)0x08000000)

	)

2455 #define 
	#CAN_F2R2_FB28
 ((
uint32_t
)0x10000000)

	)

2456 #define 
	#CAN_F2R2_FB29
 ((
uint32_t
)0x20000000)

	)

2457 #define 
	#CAN_F2R2_FB30
 ((
uint32_t
)0x40000000)

	)

2458 #define 
	#CAN_F2R2_FB31
 ((
uint32_t
)0x80000000)

	)

2461 #define 
	#CAN_F3R2_FB0
 ((
uint32_t
)0x00000001)

	)

2462 #define 
	#CAN_F3R2_FB1
 ((
uint32_t
)0x00000002)

	)

2463 #define 
	#CAN_F3R2_FB2
 ((
uint32_t
)0x00000004)

	)

2464 #define 
	#CAN_F3R2_FB3
 ((
uint32_t
)0x00000008)

	)

2465 #define 
	#CAN_F3R2_FB4
 ((
uint32_t
)0x00000010)

	)

2466 #define 
	#CAN_F3R2_FB5
 ((
uint32_t
)0x00000020)

	)

2467 #define 
	#CAN_F3R2_FB6
 ((
uint32_t
)0x00000040)

	)

2468 #define 
	#CAN_F3R2_FB7
 ((
uint32_t
)0x00000080)

	)

2469 #define 
	#CAN_F3R2_FB8
 ((
uint32_t
)0x00000100)

	)

2470 #define 
	#CAN_F3R2_FB9
 ((
uint32_t
)0x00000200)

	)

2471 #define 
	#CAN_F3R2_FB10
 ((
uint32_t
)0x00000400)

	)

2472 #define 
	#CAN_F3R2_FB11
 ((
uint32_t
)0x00000800)

	)

2473 #define 
	#CAN_F3R2_FB12
 ((
uint32_t
)0x00001000)

	)

2474 #define 
	#CAN_F3R2_FB13
 ((
uint32_t
)0x00002000)

	)

2475 #define 
	#CAN_F3R2_FB14
 ((
uint32_t
)0x00004000)

	)

2476 #define 
	#CAN_F3R2_FB15
 ((
uint32_t
)0x00008000)

	)

2477 #define 
	#CAN_F3R2_FB16
 ((
uint32_t
)0x00010000)

	)

2478 #define 
	#CAN_F3R2_FB17
 ((
uint32_t
)0x00020000)

	)

2479 #define 
	#CAN_F3R2_FB18
 ((
uint32_t
)0x00040000)

	)

2480 #define 
	#CAN_F3R2_FB19
 ((
uint32_t
)0x00080000)

	)

2481 #define 
	#CAN_F3R2_FB20
 ((
uint32_t
)0x00100000)

	)

2482 #define 
	#CAN_F3R2_FB21
 ((
uint32_t
)0x00200000)

	)

2483 #define 
	#CAN_F3R2_FB22
 ((
uint32_t
)0x00400000)

	)

2484 #define 
	#CAN_F3R2_FB23
 ((
uint32_t
)0x00800000)

	)

2485 #define 
	#CAN_F3R2_FB24
 ((
uint32_t
)0x01000000)

	)

2486 #define 
	#CAN_F3R2_FB25
 ((
uint32_t
)0x02000000)

	)

2487 #define 
	#CAN_F3R2_FB26
 ((
uint32_t
)0x04000000)

	)

2488 #define 
	#CAN_F3R2_FB27
 ((
uint32_t
)0x08000000)

	)

2489 #define 
	#CAN_F3R2_FB28
 ((
uint32_t
)0x10000000)

	)

2490 #define 
	#CAN_F3R2_FB29
 ((
uint32_t
)0x20000000)

	)

2491 #define 
	#CAN_F3R2_FB30
 ((
uint32_t
)0x40000000)

	)

2492 #define 
	#CAN_F3R2_FB31
 ((
uint32_t
)0x80000000)

	)

2495 #define 
	#CAN_F4R2_FB0
 ((
uint32_t
)0x00000001)

	)

2496 #define 
	#CAN_F4R2_FB1
 ((
uint32_t
)0x00000002)

	)

2497 #define 
	#CAN_F4R2_FB2
 ((
uint32_t
)0x00000004)

	)

2498 #define 
	#CAN_F4R2_FB3
 ((
uint32_t
)0x00000008)

	)

2499 #define 
	#CAN_F4R2_FB4
 ((
uint32_t
)0x00000010)

	)

2500 #define 
	#CAN_F4R2_FB5
 ((
uint32_t
)0x00000020)

	)

2501 #define 
	#CAN_F4R2_FB6
 ((
uint32_t
)0x00000040)

	)

2502 #define 
	#CAN_F4R2_FB7
 ((
uint32_t
)0x00000080)

	)

2503 #define 
	#CAN_F4R2_FB8
 ((
uint32_t
)0x00000100)

	)

2504 #define 
	#CAN_F4R2_FB9
 ((
uint32_t
)0x00000200)

	)

2505 #define 
	#CAN_F4R2_FB10
 ((
uint32_t
)0x00000400)

	)

2506 #define 
	#CAN_F4R2_FB11
 ((
uint32_t
)0x00000800)

	)

2507 #define 
	#CAN_F4R2_FB12
 ((
uint32_t
)0x00001000)

	)

2508 #define 
	#CAN_F4R2_FB13
 ((
uint32_t
)0x00002000)

	)

2509 #define 
	#CAN_F4R2_FB14
 ((
uint32_t
)0x00004000)

	)

2510 #define 
	#CAN_F4R2_FB15
 ((
uint32_t
)0x00008000)

	)

2511 #define 
	#CAN_F4R2_FB16
 ((
uint32_t
)0x00010000)

	)

2512 #define 
	#CAN_F4R2_FB17
 ((
uint32_t
)0x00020000)

	)

2513 #define 
	#CAN_F4R2_FB18
 ((
uint32_t
)0x00040000)

	)

2514 #define 
	#CAN_F4R2_FB19
 ((
uint32_t
)0x00080000)

	)

2515 #define 
	#CAN_F4R2_FB20
 ((
uint32_t
)0x00100000)

	)

2516 #define 
	#CAN_F4R2_FB21
 ((
uint32_t
)0x00200000)

	)

2517 #define 
	#CAN_F4R2_FB22
 ((
uint32_t
)0x00400000)

	)

2518 #define 
	#CAN_F4R2_FB23
 ((
uint32_t
)0x00800000)

	)

2519 #define 
	#CAN_F4R2_FB24
 ((
uint32_t
)0x01000000)

	)

2520 #define 
	#CAN_F4R2_FB25
 ((
uint32_t
)0x02000000)

	)

2521 #define 
	#CAN_F4R2_FB26
 ((
uint32_t
)0x04000000)

	)

2522 #define 
	#CAN_F4R2_FB27
 ((
uint32_t
)0x08000000)

	)

2523 #define 
	#CAN_F4R2_FB28
 ((
uint32_t
)0x10000000)

	)

2524 #define 
	#CAN_F4R2_FB29
 ((
uint32_t
)0x20000000)

	)

2525 #define 
	#CAN_F4R2_FB30
 ((
uint32_t
)0x40000000)

	)

2526 #define 
	#CAN_F4R2_FB31
 ((
uint32_t
)0x80000000)

	)

2529 #define 
	#CAN_F5R2_FB0
 ((
uint32_t
)0x00000001)

	)

2530 #define 
	#CAN_F5R2_FB1
 ((
uint32_t
)0x00000002)

	)

2531 #define 
	#CAN_F5R2_FB2
 ((
uint32_t
)0x00000004)

	)

2532 #define 
	#CAN_F5R2_FB3
 ((
uint32_t
)0x00000008)

	)

2533 #define 
	#CAN_F5R2_FB4
 ((
uint32_t
)0x00000010)

	)

2534 #define 
	#CAN_F5R2_FB5
 ((
uint32_t
)0x00000020)

	)

2535 #define 
	#CAN_F5R2_FB6
 ((
uint32_t
)0x00000040)

	)

2536 #define 
	#CAN_F5R2_FB7
 ((
uint32_t
)0x00000080)

	)

2537 #define 
	#CAN_F5R2_FB8
 ((
uint32_t
)0x00000100)

	)

2538 #define 
	#CAN_F5R2_FB9
 ((
uint32_t
)0x00000200)

	)

2539 #define 
	#CAN_F5R2_FB10
 ((
uint32_t
)0x00000400)

	)

2540 #define 
	#CAN_F5R2_FB11
 ((
uint32_t
)0x00000800)

	)

2541 #define 
	#CAN_F5R2_FB12
 ((
uint32_t
)0x00001000)

	)

2542 #define 
	#CAN_F5R2_FB13
 ((
uint32_t
)0x00002000)

	)

2543 #define 
	#CAN_F5R2_FB14
 ((
uint32_t
)0x00004000)

	)

2544 #define 
	#CAN_F5R2_FB15
 ((
uint32_t
)0x00008000)

	)

2545 #define 
	#CAN_F5R2_FB16
 ((
uint32_t
)0x00010000)

	)

2546 #define 
	#CAN_F5R2_FB17
 ((
uint32_t
)0x00020000)

	)

2547 #define 
	#CAN_F5R2_FB18
 ((
uint32_t
)0x00040000)

	)

2548 #define 
	#CAN_F5R2_FB19
 ((
uint32_t
)0x00080000)

	)

2549 #define 
	#CAN_F5R2_FB20
 ((
uint32_t
)0x00100000)

	)

2550 #define 
	#CAN_F5R2_FB21
 ((
uint32_t
)0x00200000)

	)

2551 #define 
	#CAN_F5R2_FB22
 ((
uint32_t
)0x00400000)

	)

2552 #define 
	#CAN_F5R2_FB23
 ((
uint32_t
)0x00800000)

	)

2553 #define 
	#CAN_F5R2_FB24
 ((
uint32_t
)0x01000000)

	)

2554 #define 
	#CAN_F5R2_FB25
 ((
uint32_t
)0x02000000)

	)

2555 #define 
	#CAN_F5R2_FB26
 ((
uint32_t
)0x04000000)

	)

2556 #define 
	#CAN_F5R2_FB27
 ((
uint32_t
)0x08000000)

	)

2557 #define 
	#CAN_F5R2_FB28
 ((
uint32_t
)0x10000000)

	)

2558 #define 
	#CAN_F5R2_FB29
 ((
uint32_t
)0x20000000)

	)

2559 #define 
	#CAN_F5R2_FB30
 ((
uint32_t
)0x40000000)

	)

2560 #define 
	#CAN_F5R2_FB31
 ((
uint32_t
)0x80000000)

	)

2563 #define 
	#CAN_F6R2_FB0
 ((
uint32_t
)0x00000001)

	)

2564 #define 
	#CAN_F6R2_FB1
 ((
uint32_t
)0x00000002)

	)

2565 #define 
	#CAN_F6R2_FB2
 ((
uint32_t
)0x00000004)

	)

2566 #define 
	#CAN_F6R2_FB3
 ((
uint32_t
)0x00000008)

	)

2567 #define 
	#CAN_F6R2_FB4
 ((
uint32_t
)0x00000010)

	)

2568 #define 
	#CAN_F6R2_FB5
 ((
uint32_t
)0x00000020)

	)

2569 #define 
	#CAN_F6R2_FB6
 ((
uint32_t
)0x00000040)

	)

2570 #define 
	#CAN_F6R2_FB7
 ((
uint32_t
)0x00000080)

	)

2571 #define 
	#CAN_F6R2_FB8
 ((
uint32_t
)0x00000100)

	)

2572 #define 
	#CAN_F6R2_FB9
 ((
uint32_t
)0x00000200)

	)

2573 #define 
	#CAN_F6R2_FB10
 ((
uint32_t
)0x00000400)

	)

2574 #define 
	#CAN_F6R2_FB11
 ((
uint32_t
)0x00000800)

	)

2575 #define 
	#CAN_F6R2_FB12
 ((
uint32_t
)0x00001000)

	)

2576 #define 
	#CAN_F6R2_FB13
 ((
uint32_t
)0x00002000)

	)

2577 #define 
	#CAN_F6R2_FB14
 ((
uint32_t
)0x00004000)

	)

2578 #define 
	#CAN_F6R2_FB15
 ((
uint32_t
)0x00008000)

	)

2579 #define 
	#CAN_F6R2_FB16
 ((
uint32_t
)0x00010000)

	)

2580 #define 
	#CAN_F6R2_FB17
 ((
uint32_t
)0x00020000)

	)

2581 #define 
	#CAN_F6R2_FB18
 ((
uint32_t
)0x00040000)

	)

2582 #define 
	#CAN_F6R2_FB19
 ((
uint32_t
)0x00080000)

	)

2583 #define 
	#CAN_F6R2_FB20
 ((
uint32_t
)0x00100000)

	)

2584 #define 
	#CAN_F6R2_FB21
 ((
uint32_t
)0x00200000)

	)

2585 #define 
	#CAN_F6R2_FB22
 ((
uint32_t
)0x00400000)

	)

2586 #define 
	#CAN_F6R2_FB23
 ((
uint32_t
)0x00800000)

	)

2587 #define 
	#CAN_F6R2_FB24
 ((
uint32_t
)0x01000000)

	)

2588 #define 
	#CAN_F6R2_FB25
 ((
uint32_t
)0x02000000)

	)

2589 #define 
	#CAN_F6R2_FB26
 ((
uint32_t
)0x04000000)

	)

2590 #define 
	#CAN_F6R2_FB27
 ((
uint32_t
)0x08000000)

	)

2591 #define 
	#CAN_F6R2_FB28
 ((
uint32_t
)0x10000000)

	)

2592 #define 
	#CAN_F6R2_FB29
 ((
uint32_t
)0x20000000)

	)

2593 #define 
	#CAN_F6R2_FB30
 ((
uint32_t
)0x40000000)

	)

2594 #define 
	#CAN_F6R2_FB31
 ((
uint32_t
)0x80000000)

	)

2597 #define 
	#CAN_F7R2_FB0
 ((
uint32_t
)0x00000001)

	)

2598 #define 
	#CAN_F7R2_FB1
 ((
uint32_t
)0x00000002)

	)

2599 #define 
	#CAN_F7R2_FB2
 ((
uint32_t
)0x00000004)

	)

2600 #define 
	#CAN_F7R2_FB3
 ((
uint32_t
)0x00000008)

	)

2601 #define 
	#CAN_F7R2_FB4
 ((
uint32_t
)0x00000010)

	)

2602 #define 
	#CAN_F7R2_FB5
 ((
uint32_t
)0x00000020)

	)

2603 #define 
	#CAN_F7R2_FB6
 ((
uint32_t
)0x00000040)

	)

2604 #define 
	#CAN_F7R2_FB7
 ((
uint32_t
)0x00000080)

	)

2605 #define 
	#CAN_F7R2_FB8
 ((
uint32_t
)0x00000100)

	)

2606 #define 
	#CAN_F7R2_FB9
 ((
uint32_t
)0x00000200)

	)

2607 #define 
	#CAN_F7R2_FB10
 ((
uint32_t
)0x00000400)

	)

2608 #define 
	#CAN_F7R2_FB11
 ((
uint32_t
)0x00000800)

	)

2609 #define 
	#CAN_F7R2_FB12
 ((
uint32_t
)0x00001000)

	)

2610 #define 
	#CAN_F7R2_FB13
 ((
uint32_t
)0x00002000)

	)

2611 #define 
	#CAN_F7R2_FB14
 ((
uint32_t
)0x00004000)

	)

2612 #define 
	#CAN_F7R2_FB15
 ((
uint32_t
)0x00008000)

	)

2613 #define 
	#CAN_F7R2_FB16
 ((
uint32_t
)0x00010000)

	)

2614 #define 
	#CAN_F7R2_FB17
 ((
uint32_t
)0x00020000)

	)

2615 #define 
	#CAN_F7R2_FB18
 ((
uint32_t
)0x00040000)

	)

2616 #define 
	#CAN_F7R2_FB19
 ((
uint32_t
)0x00080000)

	)

2617 #define 
	#CAN_F7R2_FB20
 ((
uint32_t
)0x00100000)

	)

2618 #define 
	#CAN_F7R2_FB21
 ((
uint32_t
)0x00200000)

	)

2619 #define 
	#CAN_F7R2_FB22
 ((
uint32_t
)0x00400000)

	)

2620 #define 
	#CAN_F7R2_FB23
 ((
uint32_t
)0x00800000)

	)

2621 #define 
	#CAN_F7R2_FB24
 ((
uint32_t
)0x01000000)

	)

2622 #define 
	#CAN_F7R2_FB25
 ((
uint32_t
)0x02000000)

	)

2623 #define 
	#CAN_F7R2_FB26
 ((
uint32_t
)0x04000000)

	)

2624 #define 
	#CAN_F7R2_FB27
 ((
uint32_t
)0x08000000)

	)

2625 #define 
	#CAN_F7R2_FB28
 ((
uint32_t
)0x10000000)

	)

2626 #define 
	#CAN_F7R2_FB29
 ((
uint32_t
)0x20000000)

	)

2627 #define 
	#CAN_F7R2_FB30
 ((
uint32_t
)0x40000000)

	)

2628 #define 
	#CAN_F7R2_FB31
 ((
uint32_t
)0x80000000)

	)

2631 #define 
	#CAN_F8R2_FB0
 ((
uint32_t
)0x00000001)

	)

2632 #define 
	#CAN_F8R2_FB1
 ((
uint32_t
)0x00000002)

	)

2633 #define 
	#CAN_F8R2_FB2
 ((
uint32_t
)0x00000004)

	)

2634 #define 
	#CAN_F8R2_FB3
 ((
uint32_t
)0x00000008)

	)

2635 #define 
	#CAN_F8R2_FB4
 ((
uint32_t
)0x00000010)

	)

2636 #define 
	#CAN_F8R2_FB5
 ((
uint32_t
)0x00000020)

	)

2637 #define 
	#CAN_F8R2_FB6
 ((
uint32_t
)0x00000040)

	)

2638 #define 
	#CAN_F8R2_FB7
 ((
uint32_t
)0x00000080)

	)

2639 #define 
	#CAN_F8R2_FB8
 ((
uint32_t
)0x00000100)

	)

2640 #define 
	#CAN_F8R2_FB9
 ((
uint32_t
)0x00000200)

	)

2641 #define 
	#CAN_F8R2_FB10
 ((
uint32_t
)0x00000400)

	)

2642 #define 
	#CAN_F8R2_FB11
 ((
uint32_t
)0x00000800)

	)

2643 #define 
	#CAN_F8R2_FB12
 ((
uint32_t
)0x00001000)

	)

2644 #define 
	#CAN_F8R2_FB13
 ((
uint32_t
)0x00002000)

	)

2645 #define 
	#CAN_F8R2_FB14
 ((
uint32_t
)0x00004000)

	)

2646 #define 
	#CAN_F8R2_FB15
 ((
uint32_t
)0x00008000)

	)

2647 #define 
	#CAN_F8R2_FB16
 ((
uint32_t
)0x00010000)

	)

2648 #define 
	#CAN_F8R2_FB17
 ((
uint32_t
)0x00020000)

	)

2649 #define 
	#CAN_F8R2_FB18
 ((
uint32_t
)0x00040000)

	)

2650 #define 
	#CAN_F8R2_FB19
 ((
uint32_t
)0x00080000)

	)

2651 #define 
	#CAN_F8R2_FB20
 ((
uint32_t
)0x00100000)

	)

2652 #define 
	#CAN_F8R2_FB21
 ((
uint32_t
)0x00200000)

	)

2653 #define 
	#CAN_F8R2_FB22
 ((
uint32_t
)0x00400000)

	)

2654 #define 
	#CAN_F8R2_FB23
 ((
uint32_t
)0x00800000)

	)

2655 #define 
	#CAN_F8R2_FB24
 ((
uint32_t
)0x01000000)

	)

2656 #define 
	#CAN_F8R2_FB25
 ((
uint32_t
)0x02000000)

	)

2657 #define 
	#CAN_F8R2_FB26
 ((
uint32_t
)0x04000000)

	)

2658 #define 
	#CAN_F8R2_FB27
 ((
uint32_t
)0x08000000)

	)

2659 #define 
	#CAN_F8R2_FB28
 ((
uint32_t
)0x10000000)

	)

2660 #define 
	#CAN_F8R2_FB29
 ((
uint32_t
)0x20000000)

	)

2661 #define 
	#CAN_F8R2_FB30
 ((
uint32_t
)0x40000000)

	)

2662 #define 
	#CAN_F8R2_FB31
 ((
uint32_t
)0x80000000)

	)

2665 #define 
	#CAN_F9R2_FB0
 ((
uint32_t
)0x00000001)

	)

2666 #define 
	#CAN_F9R2_FB1
 ((
uint32_t
)0x00000002)

	)

2667 #define 
	#CAN_F9R2_FB2
 ((
uint32_t
)0x00000004)

	)

2668 #define 
	#CAN_F9R2_FB3
 ((
uint32_t
)0x00000008)

	)

2669 #define 
	#CAN_F9R2_FB4
 ((
uint32_t
)0x00000010)

	)

2670 #define 
	#CAN_F9R2_FB5
 ((
uint32_t
)0x00000020)

	)

2671 #define 
	#CAN_F9R2_FB6
 ((
uint32_t
)0x00000040)

	)

2672 #define 
	#CAN_F9R2_FB7
 ((
uint32_t
)0x00000080)

	)

2673 #define 
	#CAN_F9R2_FB8
 ((
uint32_t
)0x00000100)

	)

2674 #define 
	#CAN_F9R2_FB9
 ((
uint32_t
)0x00000200)

	)

2675 #define 
	#CAN_F9R2_FB10
 ((
uint32_t
)0x00000400)

	)

2676 #define 
	#CAN_F9R2_FB11
 ((
uint32_t
)0x00000800)

	)

2677 #define 
	#CAN_F9R2_FB12
 ((
uint32_t
)0x00001000)

	)

2678 #define 
	#CAN_F9R2_FB13
 ((
uint32_t
)0x00002000)

	)

2679 #define 
	#CAN_F9R2_FB14
 ((
uint32_t
)0x00004000)

	)

2680 #define 
	#CAN_F9R2_FB15
 ((
uint32_t
)0x00008000)

	)

2681 #define 
	#CAN_F9R2_FB16
 ((
uint32_t
)0x00010000)

	)

2682 #define 
	#CAN_F9R2_FB17
 ((
uint32_t
)0x00020000)

	)

2683 #define 
	#CAN_F9R2_FB18
 ((
uint32_t
)0x00040000)

	)

2684 #define 
	#CAN_F9R2_FB19
 ((
uint32_t
)0x00080000)

	)

2685 #define 
	#CAN_F9R2_FB20
 ((
uint32_t
)0x00100000)

	)

2686 #define 
	#CAN_F9R2_FB21
 ((
uint32_t
)0x00200000)

	)

2687 #define 
	#CAN_F9R2_FB22
 ((
uint32_t
)0x00400000)

	)

2688 #define 
	#CAN_F9R2_FB23
 ((
uint32_t
)0x00800000)

	)

2689 #define 
	#CAN_F9R2_FB24
 ((
uint32_t
)0x01000000)

	)

2690 #define 
	#CAN_F9R2_FB25
 ((
uint32_t
)0x02000000)

	)

2691 #define 
	#CAN_F9R2_FB26
 ((
uint32_t
)0x04000000)

	)

2692 #define 
	#CAN_F9R2_FB27
 ((
uint32_t
)0x08000000)

	)

2693 #define 
	#CAN_F9R2_FB28
 ((
uint32_t
)0x10000000)

	)

2694 #define 
	#CAN_F9R2_FB29
 ((
uint32_t
)0x20000000)

	)

2695 #define 
	#CAN_F9R2_FB30
 ((
uint32_t
)0x40000000)

	)

2696 #define 
	#CAN_F9R2_FB31
 ((
uint32_t
)0x80000000)

	)

2699 #define 
	#CAN_F10R2_FB0
 ((
uint32_t
)0x00000001)

	)

2700 #define 
	#CAN_F10R2_FB1
 ((
uint32_t
)0x00000002)

	)

2701 #define 
	#CAN_F10R2_FB2
 ((
uint32_t
)0x00000004)

	)

2702 #define 
	#CAN_F10R2_FB3
 ((
uint32_t
)0x00000008)

	)

2703 #define 
	#CAN_F10R2_FB4
 ((
uint32_t
)0x00000010)

	)

2704 #define 
	#CAN_F10R2_FB5
 ((
uint32_t
)0x00000020)

	)

2705 #define 
	#CAN_F10R2_FB6
 ((
uint32_t
)0x00000040)

	)

2706 #define 
	#CAN_F10R2_FB7
 ((
uint32_t
)0x00000080)

	)

2707 #define 
	#CAN_F10R2_FB8
 ((
uint32_t
)0x00000100)

	)

2708 #define 
	#CAN_F10R2_FB9
 ((
uint32_t
)0x00000200)

	)

2709 #define 
	#CAN_F10R2_FB10
 ((
uint32_t
)0x00000400)

	)

2710 #define 
	#CAN_F10R2_FB11
 ((
uint32_t
)0x00000800)

	)

2711 #define 
	#CAN_F10R2_FB12
 ((
uint32_t
)0x00001000)

	)

2712 #define 
	#CAN_F10R2_FB13
 ((
uint32_t
)0x00002000)

	)

2713 #define 
	#CAN_F10R2_FB14
 ((
uint32_t
)0x00004000)

	)

2714 #define 
	#CAN_F10R2_FB15
 ((
uint32_t
)0x00008000)

	)

2715 #define 
	#CAN_F10R2_FB16
 ((
uint32_t
)0x00010000)

	)

2716 #define 
	#CAN_F10R2_FB17
 ((
uint32_t
)0x00020000)

	)

2717 #define 
	#CAN_F10R2_FB18
 ((
uint32_t
)0x00040000)

	)

2718 #define 
	#CAN_F10R2_FB19
 ((
uint32_t
)0x00080000)

	)

2719 #define 
	#CAN_F10R2_FB20
 ((
uint32_t
)0x00100000)

	)

2720 #define 
	#CAN_F10R2_FB21
 ((
uint32_t
)0x00200000)

	)

2721 #define 
	#CAN_F10R2_FB22
 ((
uint32_t
)0x00400000)

	)

2722 #define 
	#CAN_F10R2_FB23
 ((
uint32_t
)0x00800000)

	)

2723 #define 
	#CAN_F10R2_FB24
 ((
uint32_t
)0x01000000)

	)

2724 #define 
	#CAN_F10R2_FB25
 ((
uint32_t
)0x02000000)

	)

2725 #define 
	#CAN_F10R2_FB26
 ((
uint32_t
)0x04000000)

	)

2726 #define 
	#CAN_F10R2_FB27
 ((
uint32_t
)0x08000000)

	)

2727 #define 
	#CAN_F10R2_FB28
 ((
uint32_t
)0x10000000)

	)

2728 #define 
	#CAN_F10R2_FB29
 ((
uint32_t
)0x20000000)

	)

2729 #define 
	#CAN_F10R2_FB30
 ((
uint32_t
)0x40000000)

	)

2730 #define 
	#CAN_F10R2_FB31
 ((
uint32_t
)0x80000000)

	)

2733 #define 
	#CAN_F11R2_FB0
 ((
uint32_t
)0x00000001)

	)

2734 #define 
	#CAN_F11R2_FB1
 ((
uint32_t
)0x00000002)

	)

2735 #define 
	#CAN_F11R2_FB2
 ((
uint32_t
)0x00000004)

	)

2736 #define 
	#CAN_F11R2_FB3
 ((
uint32_t
)0x00000008)

	)

2737 #define 
	#CAN_F11R2_FB4
 ((
uint32_t
)0x00000010)

	)

2738 #define 
	#CAN_F11R2_FB5
 ((
uint32_t
)0x00000020)

	)

2739 #define 
	#CAN_F11R2_FB6
 ((
uint32_t
)0x00000040)

	)

2740 #define 
	#CAN_F11R2_FB7
 ((
uint32_t
)0x00000080)

	)

2741 #define 
	#CAN_F11R2_FB8
 ((
uint32_t
)0x00000100)

	)

2742 #define 
	#CAN_F11R2_FB9
 ((
uint32_t
)0x00000200)

	)

2743 #define 
	#CAN_F11R2_FB10
 ((
uint32_t
)0x00000400)

	)

2744 #define 
	#CAN_F11R2_FB11
 ((
uint32_t
)0x00000800)

	)

2745 #define 
	#CAN_F11R2_FB12
 ((
uint32_t
)0x00001000)

	)

2746 #define 
	#CAN_F11R2_FB13
 ((
uint32_t
)0x00002000)

	)

2747 #define 
	#CAN_F11R2_FB14
 ((
uint32_t
)0x00004000)

	)

2748 #define 
	#CAN_F11R2_FB15
 ((
uint32_t
)0x00008000)

	)

2749 #define 
	#CAN_F11R2_FB16
 ((
uint32_t
)0x00010000)

	)

2750 #define 
	#CAN_F11R2_FB17
 ((
uint32_t
)0x00020000)

	)

2751 #define 
	#CAN_F11R2_FB18
 ((
uint32_t
)0x00040000)

	)

2752 #define 
	#CAN_F11R2_FB19
 ((
uint32_t
)0x00080000)

	)

2753 #define 
	#CAN_F11R2_FB20
 ((
uint32_t
)0x00100000)

	)

2754 #define 
	#CAN_F11R2_FB21
 ((
uint32_t
)0x00200000)

	)

2755 #define 
	#CAN_F11R2_FB22
 ((
uint32_t
)0x00400000)

	)

2756 #define 
	#CAN_F11R2_FB23
 ((
uint32_t
)0x00800000)

	)

2757 #define 
	#CAN_F11R2_FB24
 ((
uint32_t
)0x01000000)

	)

2758 #define 
	#CAN_F11R2_FB25
 ((
uint32_t
)0x02000000)

	)

2759 #define 
	#CAN_F11R2_FB26
 ((
uint32_t
)0x04000000)

	)

2760 #define 
	#CAN_F11R2_FB27
 ((
uint32_t
)0x08000000)

	)

2761 #define 
	#CAN_F11R2_FB28
 ((
uint32_t
)0x10000000)

	)

2762 #define 
	#CAN_F11R2_FB29
 ((
uint32_t
)0x20000000)

	)

2763 #define 
	#CAN_F11R2_FB30
 ((
uint32_t
)0x40000000)

	)

2764 #define 
	#CAN_F11R2_FB31
 ((
uint32_t
)0x80000000)

	)

2767 #define 
	#CAN_F12R2_FB0
 ((
uint32_t
)0x00000001)

	)

2768 #define 
	#CAN_F12R2_FB1
 ((
uint32_t
)0x00000002)

	)

2769 #define 
	#CAN_F12R2_FB2
 ((
uint32_t
)0x00000004)

	)

2770 #define 
	#CAN_F12R2_FB3
 ((
uint32_t
)0x00000008)

	)

2771 #define 
	#CAN_F12R2_FB4
 ((
uint32_t
)0x00000010)

	)

2772 #define 
	#CAN_F12R2_FB5
 ((
uint32_t
)0x00000020)

	)

2773 #define 
	#CAN_F12R2_FB6
 ((
uint32_t
)0x00000040)

	)

2774 #define 
	#CAN_F12R2_FB7
 ((
uint32_t
)0x00000080)

	)

2775 #define 
	#CAN_F12R2_FB8
 ((
uint32_t
)0x00000100)

	)

2776 #define 
	#CAN_F12R2_FB9
 ((
uint32_t
)0x00000200)

	)

2777 #define 
	#CAN_F12R2_FB10
 ((
uint32_t
)0x00000400)

	)

2778 #define 
	#CAN_F12R2_FB11
 ((
uint32_t
)0x00000800)

	)

2779 #define 
	#CAN_F12R2_FB12
 ((
uint32_t
)0x00001000)

	)

2780 #define 
	#CAN_F12R2_FB13
 ((
uint32_t
)0x00002000)

	)

2781 #define 
	#CAN_F12R2_FB14
 ((
uint32_t
)0x00004000)

	)

2782 #define 
	#CAN_F12R2_FB15
 ((
uint32_t
)0x00008000)

	)

2783 #define 
	#CAN_F12R2_FB16
 ((
uint32_t
)0x00010000)

	)

2784 #define 
	#CAN_F12R2_FB17
 ((
uint32_t
)0x00020000)

	)

2785 #define 
	#CAN_F12R2_FB18
 ((
uint32_t
)0x00040000)

	)

2786 #define 
	#CAN_F12R2_FB19
 ((
uint32_t
)0x00080000)

	)

2787 #define 
	#CAN_F12R2_FB20
 ((
uint32_t
)0x00100000)

	)

2788 #define 
	#CAN_F12R2_FB21
 ((
uint32_t
)0x00200000)

	)

2789 #define 
	#CAN_F12R2_FB22
 ((
uint32_t
)0x00400000)

	)

2790 #define 
	#CAN_F12R2_FB23
 ((
uint32_t
)0x00800000)

	)

2791 #define 
	#CAN_F12R2_FB24
 ((
uint32_t
)0x01000000)

	)

2792 #define 
	#CAN_F12R2_FB25
 ((
uint32_t
)0x02000000)

	)

2793 #define 
	#CAN_F12R2_FB26
 ((
uint32_t
)0x04000000)

	)

2794 #define 
	#CAN_F12R2_FB27
 ((
uint32_t
)0x08000000)

	)

2795 #define 
	#CAN_F12R2_FB28
 ((
uint32_t
)0x10000000)

	)

2796 #define 
	#CAN_F12R2_FB29
 ((
uint32_t
)0x20000000)

	)

2797 #define 
	#CAN_F12R2_FB30
 ((
uint32_t
)0x40000000)

	)

2798 #define 
	#CAN_F12R2_FB31
 ((
uint32_t
)0x80000000)

	)

2801 #define 
	#CAN_F13R2_FB0
 ((
uint32_t
)0x00000001)

	)

2802 #define 
	#CAN_F13R2_FB1
 ((
uint32_t
)0x00000002)

	)

2803 #define 
	#CAN_F13R2_FB2
 ((
uint32_t
)0x00000004)

	)

2804 #define 
	#CAN_F13R2_FB3
 ((
uint32_t
)0x00000008)

	)

2805 #define 
	#CAN_F13R2_FB4
 ((
uint32_t
)0x00000010)

	)

2806 #define 
	#CAN_F13R2_FB5
 ((
uint32_t
)0x00000020)

	)

2807 #define 
	#CAN_F13R2_FB6
 ((
uint32_t
)0x00000040)

	)

2808 #define 
	#CAN_F13R2_FB7
 ((
uint32_t
)0x00000080)

	)

2809 #define 
	#CAN_F13R2_FB8
 ((
uint32_t
)0x00000100)

	)

2810 #define 
	#CAN_F13R2_FB9
 ((
uint32_t
)0x00000200)

	)

2811 #define 
	#CAN_F13R2_FB10
 ((
uint32_t
)0x00000400)

	)

2812 #define 
	#CAN_F13R2_FB11
 ((
uint32_t
)0x00000800)

	)

2813 #define 
	#CAN_F13R2_FB12
 ((
uint32_t
)0x00001000)

	)

2814 #define 
	#CAN_F13R2_FB13
 ((
uint32_t
)0x00002000)

	)

2815 #define 
	#CAN_F13R2_FB14
 ((
uint32_t
)0x00004000)

	)

2816 #define 
	#CAN_F13R2_FB15
 ((
uint32_t
)0x00008000)

	)

2817 #define 
	#CAN_F13R2_FB16
 ((
uint32_t
)0x00010000)

	)

2818 #define 
	#CAN_F13R2_FB17
 ((
uint32_t
)0x00020000)

	)

2819 #define 
	#CAN_F13R2_FB18
 ((
uint32_t
)0x00040000)

	)

2820 #define 
	#CAN_F13R2_FB19
 ((
uint32_t
)0x00080000)

	)

2821 #define 
	#CAN_F13R2_FB20
 ((
uint32_t
)0x00100000)

	)

2822 #define 
	#CAN_F13R2_FB21
 ((
uint32_t
)0x00200000)

	)

2823 #define 
	#CAN_F13R2_FB22
 ((
uint32_t
)0x00400000)

	)

2824 #define 
	#CAN_F13R2_FB23
 ((
uint32_t
)0x00800000)

	)

2825 #define 
	#CAN_F13R2_FB24
 ((
uint32_t
)0x01000000)

	)

2826 #define 
	#CAN_F13R2_FB25
 ((
uint32_t
)0x02000000)

	)

2827 #define 
	#CAN_F13R2_FB26
 ((
uint32_t
)0x04000000)

	)

2828 #define 
	#CAN_F13R2_FB27
 ((
uint32_t
)0x08000000)

	)

2829 #define 
	#CAN_F13R2_FB28
 ((
uint32_t
)0x10000000)

	)

2830 #define 
	#CAN_F13R2_FB29
 ((
uint32_t
)0x20000000)

	)

2831 #define 
	#CAN_F13R2_FB30
 ((
uint32_t
)0x40000000)

	)

2832 #define 
	#CAN_F13R2_FB31
 ((
uint32_t
)0x80000000)

	)

2840 #define 
	#CRC_DR_DR
 ((
uint32_t
)0xFFFFFFFF)

	)

2844 #define 
	#CRC_IDR_IDR
 ((
uint8_t
)0xFF)

	)

2848 #define 
	#CRC_CR_RESET
 ((
uint8_t
)0x01)

	)

2856 #define 
	#CRYP_CR_ALGODIR
 ((
uint32_t
)0x00000004)

	)

2858 #define 
	#CRYP_CR_ALGOMODE
 ((
uint32_t
)0x00000038)

	)

2859 #define 
	#CRYP_CR_ALGOMODE_0
 ((
uint32_t
)0x00000008)

	)

2860 #define 
	#CRYP_CR_ALGOMODE_1
 ((
uint32_t
)0x00000010)

	)

2861 #define 
	#CRYP_CR_ALGOMODE_2
 ((
uint32_t
)0x00000020)

	)

2862 #define 
	#CRYP_CR_ALGOMODE_TDES_ECB
 ((
uint32_t
)0x00000000)

	)

2863 #define 
	#CRYP_CR_ALGOMODE_TDES_CBC
 ((
uint32_t
)0x00000008)

	)

2864 #define 
	#CRYP_CR_ALGOMODE_DES_ECB
 ((
uint32_t
)0x00000010)

	)

2865 #define 
	#CRYP_CR_ALGOMODE_DES_CBC
 ((
uint32_t
)0x00000018)

	)

2866 #define 
	#CRYP_CR_ALGOMODE_AES_ECB
 ((
uint32_t
)0x00000020)

	)

2867 #define 
	#CRYP_CR_ALGOMODE_AES_CBC
 ((
uint32_t
)0x00000028)

	)

2868 #define 
	#CRYP_CR_ALGOMODE_AES_CTR
 ((
uint32_t
)0x00000030)

	)

2869 #define 
	#CRYP_CR_ALGOMODE_AES_KEY
 ((
uint32_t
)0x00000038)

	)

2871 #define 
	#CRYP_CR_DATATYPE
 ((
uint32_t
)0x000000C0)

	)

2872 #define 
	#CRYP_CR_DATATYPE_0
 ((
uint32_t
)0x00000040)

	)

2873 #define 
	#CRYP_CR_DATATYPE_1
 ((
uint32_t
)0x00000080)

	)

2874 #define 
	#CRYP_CR_KEYSIZE
 ((
uint32_t
)0x00000300)

	)

2875 #define 
	#CRYP_CR_KEYSIZE_0
 ((
uint32_t
)0x00000100)

	)

2876 #define 
	#CRYP_CR_KEYSIZE_1
 ((
uint32_t
)0x00000200)

	)

2877 #define 
	#CRYP_CR_FFLUSH
 ((
uint32_t
)0x00004000)

	)

2878 #define 
	#CRYP_CR_CRYPEN
 ((
uint32_t
)0x00008000)

	)

2880 #define 
	#CRYP_SR_IFEM
 ((
uint32_t
)0x00000001)

	)

2881 #define 
	#CRYP_SR_IFNF
 ((
uint32_t
)0x00000002)

	)

2882 #define 
	#CRYP_SR_OFNE
 ((
uint32_t
)0x00000004)

	)

2883 #define 
	#CRYP_SR_OFFU
 ((
uint32_t
)0x00000008)

	)

2884 #define 
	#CRYP_SR_BUSY
 ((
uint32_t
)0x00000010)

	)

2886 #define 
	#CRYP_DMACR_DIEN
 ((
uint32_t
)0x00000001)

	)

2887 #define 
	#CRYP_DMACR_DOEN
 ((
uint32_t
)0x00000002)

	)

2889 #define 
	#CRYP_IMSCR_INIM
 ((
uint32_t
)0x00000001)

	)

2890 #define 
	#CRYP_IMSCR_OUTIM
 ((
uint32_t
)0x00000002)

	)

2892 #define 
	#CRYP_RISR_OUTRIS
 ((
uint32_t
)0x00000001)

	)

2893 #define 
	#CRYP_RISR_INRIS
 ((
uint32_t
)0x00000002)

	)

2895 #define 
	#CRYP_MISR_INMIS
 ((
uint32_t
)0x00000001)

	)

2896 #define 
	#CRYP_MISR_OUTMIS
 ((
uint32_t
)0x00000002)

	)

2904 #define 
	#DAC_CR_EN1
 ((
uint32_t
)0x00000001)

	)

2905 #define 
	#DAC_CR_BOFF1
 ((
uint32_t
)0x00000002)

	)

2906 #define 
	#DAC_CR_TEN1
 ((
uint32_t
)0x00000004)

	)

2908 #define 
	#DAC_CR_TSEL1
 ((
uint32_t
)0x00000038)

	)

2909 #define 
	#DAC_CR_TSEL1_0
 ((
uint32_t
)0x00000008)

	)

2910 #define 
	#DAC_CR_TSEL1_1
 ((
uint32_t
)0x00000010)

	)

2911 #define 
	#DAC_CR_TSEL1_2
 ((
uint32_t
)0x00000020)

	)

2913 #define 
	#DAC_CR_WAVE1
 ((
uint32_t
)0x000000C0)

	)

2914 #define 
	#DAC_CR_WAVE1_0
 ((
uint32_t
)0x00000040)

	)

2915 #define 
	#DAC_CR_WAVE1_1
 ((
uint32_t
)0x00000080)

	)

2917 #define 
	#DAC_CR_MAMP1
 ((
uint32_t
)0x00000F00)

	)

2918 #define 
	#DAC_CR_MAMP1_0
 ((
uint32_t
)0x00000100)

	)

2919 #define 
	#DAC_CR_MAMP1_1
 ((
uint32_t
)0x00000200)

	)

2920 #define 
	#DAC_CR_MAMP1_2
 ((
uint32_t
)0x00000400)

	)

2921 #define 
	#DAC_CR_MAMP1_3
 ((
uint32_t
)0x00000800)

	)

2923 #define 
	#DAC_CR_DMAEN1
 ((
uint32_t
)0x00001000)

	)

2924 #define 
	#DAC_CR_EN2
 ((
uint32_t
)0x00010000)

	)

2925 #define 
	#DAC_CR_BOFF2
 ((
uint32_t
)0x00020000)

	)

2926 #define 
	#DAC_CR_TEN2
 ((
uint32_t
)0x00040000)

	)

2928 #define 
	#DAC_CR_TSEL2
 ((
uint32_t
)0x00380000)

	)

2929 #define 
	#DAC_CR_TSEL2_0
 ((
uint32_t
)0x00080000)

	)

2930 #define 
	#DAC_CR_TSEL2_1
 ((
uint32_t
)0x00100000)

	)

2931 #define 
	#DAC_CR_TSEL2_2
 ((
uint32_t
)0x00200000)

	)

2933 #define 
	#DAC_CR_WAVE2
 ((
uint32_t
)0x00C00000)

	)

2934 #define 
	#DAC_CR_WAVE2_0
 ((
uint32_t
)0x00400000)

	)

2935 #define 
	#DAC_CR_WAVE2_1
 ((
uint32_t
)0x00800000)

	)

2937 #define 
	#DAC_CR_MAMP2
 ((
uint32_t
)0x0F000000)

	)

2938 #define 
	#DAC_CR_MAMP2_0
 ((
uint32_t
)0x01000000)

	)

2939 #define 
	#DAC_CR_MAMP2_1
 ((
uint32_t
)0x02000000)

	)

2940 #define 
	#DAC_CR_MAMP2_2
 ((
uint32_t
)0x04000000)

	)

2941 #define 
	#DAC_CR_MAMP2_3
 ((
uint32_t
)0x08000000)

	)

2943 #define 
	#DAC_CR_DMAEN2
 ((
uint32_t
)0x10000000)

	)

2946 #define 
	#DAC_SWTRIGR_SWTRIG1
 ((
uint8_t
)0x01)

	)

2947 #define 
	#DAC_SWTRIGR_SWTRIG2
 ((
uint8_t
)0x02)

	)

2950 #define 
	#DAC_DHR12R1_DACC1DHR
 ((
uint16_t
)0x0FFF)

	)

2953 #define 
	#DAC_DHR12L1_DACC1DHR
 ((
uint16_t
)0xFFF0)

	)

2956 #define 
	#DAC_DHR8R1_DACC1DHR
 ((
uint8_t
)0xFF)

	)

2959 #define 
	#DAC_DHR12R2_DACC2DHR
 ((
uint16_t
)0x0FFF)

	)

2962 #define 
	#DAC_DHR12L2_DACC2DHR
 ((
uint16_t
)0xFFF0)

	)

2965 #define 
	#DAC_DHR8R2_DACC2DHR
 ((
uint8_t
)0xFF)

	)

2968 #define 
	#DAC_DHR12RD_DACC1DHR
 ((
uint32_t
)0x00000FFF)

	)

2969 #define 
	#DAC_DHR12RD_DACC2DHR
 ((
uint32_t
)0x0FFF0000)

	)

2972 #define 
	#DAC_DHR12LD_DACC1DHR
 ((
uint32_t
)0x0000FFF0)

	)

2973 #define 
	#DAC_DHR12LD_DACC2DHR
 ((
uint32_t
)0xFFF00000)

	)

2976 #define 
	#DAC_DHR8RD_DACC1DHR
 ((
uint16_t
)0x00FF)

	)

2977 #define 
	#DAC_DHR8RD_DACC2DHR
 ((
uint16_t
)0xFF00)

	)

2980 #define 
	#DAC_DOR1_DACC1DOR
 ((
uint16_t
)0x0FFF)

	)

2983 #define 
	#DAC_DOR2_DACC2DOR
 ((
uint16_t
)0x0FFF)

	)

2986 #define 
	#DAC_SR_DMAUDR1
 ((
uint32_t
)0x00002000)

	)

2987 #define 
	#DAC_SR_DMAUDR2
 ((
uint32_t
)0x20000000)

	)

3001 #define 
	#DCMI_CR_CAPTURE
 ((
uint32_t
)0x00000001)

	)

3002 #define 
	#DCMI_CR_CM
 ((
uint32_t
)0x00000002)

	)

3003 #define 
	#DCMI_CR_CROP
 ((
uint32_t
)0x00000004)

	)

3004 #define 
	#DCMI_CR_JPEG
 ((
uint32_t
)0x00000008)

	)

3005 #define 
	#DCMI_CR_ESS
 ((
uint32_t
)0x00000010)

	)

3006 #define 
	#DCMI_CR_PCKPOL
 ((
uint32_t
)0x00000020)

	)

3007 #define 
	#DCMI_CR_HSPOL
 ((
uint32_t
)0x00000040)

	)

3008 #define 
	#DCMI_CR_VSPOL
 ((
uint32_t
)0x00000080)

	)

3009 #define 
	#DCMI_CR_FCRC_0
 ((
uint32_t
)0x00000100)

	)

3010 #define 
	#DCMI_CR_FCRC_1
 ((
uint32_t
)0x00000200)

	)

3011 #define 
	#DCMI_CR_EDM_0
 ((
uint32_t
)0x00000400)

	)

3012 #define 
	#DCMI_CR_EDM_1
 ((
uint32_t
)0x00000800)

	)

3013 #define 
	#DCMI_CR_CRE
 ((
uint32_t
)0x00001000)

	)

3014 #define 
	#DCMI_CR_ENABLE
 ((
uint32_t
)0x00004000)

	)

3017 #define 
	#DCMI_SR_HSYNC
 ((
uint32_t
)0x00000001)

	)

3018 #define 
	#DCMI_SR_VSYNC
 ((
uint32_t
)0x00000002)

	)

3019 #define 
	#DCMI_SR_FNE
 ((
uint32_t
)0x00000004)

	)

3022 #define 
	#DCMI_RISR_FRAME_RIS
 ((
uint32_t
)0x00000001)

	)

3023 #define 
	#DCMI_RISR_OVF_RIS
 ((
uint32_t
)0x00000002)

	)

3024 #define 
	#DCMI_RISR_ERR_RIS
 ((
uint32_t
)0x00000004)

	)

3025 #define 
	#DCMI_RISR_VSYNC_RIS
 ((
uint32_t
)0x00000008)

	)

3026 #define 
	#DCMI_RISR_LINE_RIS
 ((
uint32_t
)0x00000010)

	)

3029 #define 
	#DCMI_IER_FRAME_IE
 ((
uint32_t
)0x00000001)

	)

3030 #define 
	#DCMI_IER_OVF_IE
 ((
uint32_t
)0x00000002)

	)

3031 #define 
	#DCMI_IER_ERR_IE
 ((
uint32_t
)0x00000004)

	)

3032 #define 
	#DCMI_IER_VSYNC_IE
 ((
uint32_t
)0x00000008)

	)

3033 #define 
	#DCMI_IER_LINE_IE
 ((
uint32_t
)0x00000010)

	)

3036 #define 
	#DCMI_MISR_FRAME_MIS
 ((
uint32_t
)0x00000001)

	)

3037 #define 
	#DCMI_MISR_OVF_MIS
 ((
uint32_t
)0x00000002)

	)

3038 #define 
	#DCMI_MISR_ERR_MIS
 ((
uint32_t
)0x00000004)

	)

3039 #define 
	#DCMI_MISR_VSYNC_MIS
 ((
uint32_t
)0x00000008)

	)

3040 #define 
	#DCMI_MISR_LINE_MIS
 ((
uint32_t
)0x00000010)

	)

3043 #define 
	#DCMI_ICR_FRAME_ISC
 ((
uint32_t
)0x00000001)

	)

3044 #define 
	#DCMI_ICR_OVF_ISC
 ((
uint32_t
)0x00000002)

	)

3045 #define 
	#DCMI_ICR_ERR_ISC
 ((
uint32_t
)0x00000004)

	)

3046 #define 
	#DCMI_ICR_VSYNC_ISC
 ((
uint32_t
)0x00000008)

	)

3047 #define 
	#DCMI_ICR_LINE_ISC
 ((
uint32_t
)0x00000010)

	)

3055 #define 
	#DMA_SxCR_CHSEL
 ((
uint32_t
)0x0E000000)

	)

3056 #define 
	#DMA_SxCR_CHSEL_0
 ((
uint32_t
)0x02000000)

	)

3057 #define 
	#DMA_SxCR_CHSEL_1
 ((
uint32_t
)0x04000000)

	)

3058 #define 
	#DMA_SxCR_CHSEL_2
 ((
uint32_t
)0x08000000)

	)

3059 #define 
	#DMA_SxCR_MBURST
 ((
uint32_t
)0x01800000)

	)

3060 #define 
	#DMA_SxCR_MBURST_0
 ((
uint32_t
)0x00800000)

	)

3061 #define 
	#DMA_SxCR_MBURST_1
 ((
uint32_t
)0x01000000)

	)

3062 #define 
	#DMA_SxCR_PBURST
 ((
uint32_t
)0x00600000)

	)

3063 #define 
	#DMA_SxCR_PBURST_0
 ((
uint32_t
)0x00200000)

	)

3064 #define 
	#DMA_SxCR_PBURST_1
 ((
uint32_t
)0x00400000)

	)

3065 #define 
	#DMA_SxCR_ACK
 ((
uint32_t
)0x00100000)

	)

3066 #define 
	#DMA_SxCR_CT
 ((
uint32_t
)0x00080000)

	)

3067 #define 
	#DMA_SxCR_DBM
 ((
uint32_t
)0x00040000)

	)

3068 #define 
	#DMA_SxCR_PL
 ((
uint32_t
)0x00030000)

	)

3069 #define 
	#DMA_SxCR_PL_0
 ((
uint32_t
)0x00010000)

	)

3070 #define 
	#DMA_SxCR_PL_1
 ((
uint32_t
)0x00020000)

	)

3071 #define 
	#DMA_SxCR_PINCOS
 ((
uint32_t
)0x00008000)

	)

3072 #define 
	#DMA_SxCR_MSIZE
 ((
uint32_t
)0x00006000)

	)

3073 #define 
	#DMA_SxCR_MSIZE_0
 ((
uint32_t
)0x00002000)

	)

3074 #define 
	#DMA_SxCR_MSIZE_1
 ((
uint32_t
)0x00004000)

	)

3075 #define 
	#DMA_SxCR_PSIZE
 ((
uint32_t
)0x00001800)

	)

3076 #define 
	#DMA_SxCR_PSIZE_0
 ((
uint32_t
)0x00000800)

	)

3077 #define 
	#DMA_SxCR_PSIZE_1
 ((
uint32_t
)0x00001000)

	)

3078 #define 
	#DMA_SxCR_MINC
 ((
uint32_t
)0x00000400)

	)

3079 #define 
	#DMA_SxCR_PINC
 ((
uint32_t
)0x00000200)

	)

3080 #define 
	#DMA_SxCR_CIRC
 ((
uint32_t
)0x00000100)

	)

3081 #define 
	#DMA_SxCR_DIR
 ((
uint32_t
)0x000000C0)

	)

3082 #define 
	#DMA_SxCR_DIR_0
 ((
uint32_t
)0x00000040)

	)

3083 #define 
	#DMA_SxCR_DIR_1
 ((
uint32_t
)0x00000080)

	)

3084 #define 
	#DMA_SxCR_PFCTRL
 ((
uint32_t
)0x00000020)

	)

3085 #define 
	#DMA_SxCR_TCIE
 ((
uint32_t
)0x00000010)

	)

3086 #define 
	#DMA_SxCR_HTIE
 ((
uint32_t
)0x00000008)

	)

3087 #define 
	#DMA_SxCR_TEIE
 ((
uint32_t
)0x00000004)

	)

3088 #define 
	#DMA_SxCR_DMEIE
 ((
uint32_t
)0x00000002)

	)

3089 #define 
	#DMA_SxCR_EN
 ((
uint32_t
)0x00000001)

	)

3092 #define 
	#DMA_SxNDT
 ((
uint32_t
)0x0000FFFF)

	)

3093 #define 
	#DMA_SxNDT_0
 ((
uint32_t
)0x00000001)

	)

3094 #define 
	#DMA_SxNDT_1
 ((
uint32_t
)0x00000002)

	)

3095 #define 
	#DMA_SxNDT_2
 ((
uint32_t
)0x00000004)

	)

3096 #define 
	#DMA_SxNDT_3
 ((
uint32_t
)0x00000008)

	)

3097 #define 
	#DMA_SxNDT_4
 ((
uint32_t
)0x00000010)

	)

3098 #define 
	#DMA_SxNDT_5
 ((
uint32_t
)0x00000020)

	)

3099 #define 
	#DMA_SxNDT_6
 ((
uint32_t
)0x00000040)

	)

3100 #define 
	#DMA_SxNDT_7
 ((
uint32_t
)0x00000080)

	)

3101 #define 
	#DMA_SxNDT_8
 ((
uint32_t
)0x00000100)

	)

3102 #define 
	#DMA_SxNDT_9
 ((
uint32_t
)0x00000200)

	)

3103 #define 
	#DMA_SxNDT_10
 ((
uint32_t
)0x00000400)

	)

3104 #define 
	#DMA_SxNDT_11
 ((
uint32_t
)0x00000800)

	)

3105 #define 
	#DMA_SxNDT_12
 ((
uint32_t
)0x00001000)

	)

3106 #define 
	#DMA_SxNDT_13
 ((
uint32_t
)0x00002000)

	)

3107 #define 
	#DMA_SxNDT_14
 ((
uint32_t
)0x00004000)

	)

3108 #define 
	#DMA_SxNDT_15
 ((
uint32_t
)0x00008000)

	)

3111 #define 
	#DMA_SxFCR_FEIE
 ((
uint32_t
)0x00000080)

	)

3112 #define 
	#DMA_SxFCR_FS
 ((
uint32_t
)0x00000038)

	)

3113 #define 
	#DMA_SxFCR_FS_0
 ((
uint32_t
)0x00000008)

	)

3114 #define 
	#DMA_SxFCR_FS_1
 ((
uint32_t
)0x00000010)

	)

3115 #define 
	#DMA_SxFCR_FS_2
 ((
uint32_t
)0x00000020)

	)

3116 #define 
	#DMA_SxFCR_DMDIS
 ((
uint32_t
)0x00000004)

	)

3117 #define 
	#DMA_SxFCR_FTH
 ((
uint32_t
)0x00000003)

	)

3118 #define 
	#DMA_SxFCR_FTH_0
 ((
uint32_t
)0x00000001)

	)

3119 #define 
	#DMA_SxFCR_FTH_1
 ((
uint32_t
)0x00000002)

	)

3122 #define 
	#DMA_LISR_TCIF3
 ((
uint32_t
)0x08000000)

	)

3123 #define 
	#DMA_LISR_HTIF3
 ((
uint32_t
)0x04000000)

	)

3124 #define 
	#DMA_LISR_TEIF3
 ((
uint32_t
)0x02000000)

	)

3125 #define 
	#DMA_LISR_DMEIF3
 ((
uint32_t
)0x01000000)

	)

3126 #define 
	#DMA_LISR_FEIF3
 ((
uint32_t
)0x00400000)

	)

3127 #define 
	#DMA_LISR_TCIF2
 ((
uint32_t
)0x00200000)

	)

3128 #define 
	#DMA_LISR_HTIF2
 ((
uint32_t
)0x00100000)

	)

3129 #define 
	#DMA_LISR_TEIF2
 ((
uint32_t
)0x00080000)

	)

3130 #define 
	#DMA_LISR_DMEIF2
 ((
uint32_t
)0x00040000)

	)

3131 #define 
	#DMA_LISR_FEIF2
 ((
uint32_t
)0x00010000)

	)

3132 #define 
	#DMA_LISR_TCIF1
 ((
uint32_t
)0x00000800)

	)

3133 #define 
	#DMA_LISR_HTIF1
 ((
uint32_t
)0x00000400)

	)

3134 #define 
	#DMA_LISR_TEIF1
 ((
uint32_t
)0x00000200)

	)

3135 #define 
	#DMA_LISR_DMEIF1
 ((
uint32_t
)0x00000100)

	)

3136 #define 
	#DMA_LISR_FEIF1
 ((
uint32_t
)0x00000040)

	)

3137 #define 
	#DMA_LISR_TCIF0
 ((
uint32_t
)0x00000020)

	)

3138 #define 
	#DMA_LISR_HTIF0
 ((
uint32_t
)0x00000010)

	)

3139 #define 
	#DMA_LISR_TEIF0
 ((
uint32_t
)0x00000008)

	)

3140 #define 
	#DMA_LISR_DMEIF0
 ((
uint32_t
)0x00000004)

	)

3141 #define 
	#DMA_LISR_FEIF0
 ((
uint32_t
)0x00000001)

	)

3144 #define 
	#DMA_HISR_TCIF7
 ((
uint32_t
)0x08000000)

	)

3145 #define 
	#DMA_HISR_HTIF7
 ((
uint32_t
)0x04000000)

	)

3146 #define 
	#DMA_HISR_TEIF7
 ((
uint32_t
)0x02000000)

	)

3147 #define 
	#DMA_HISR_DMEIF7
 ((
uint32_t
)0x01000000)

	)

3148 #define 
	#DMA_HISR_FEIF7
 ((
uint32_t
)0x00400000)

	)

3149 #define 
	#DMA_HISR_TCIF6
 ((
uint32_t
)0x00200000)

	)

3150 #define 
	#DMA_HISR_HTIF6
 ((
uint32_t
)0x00100000)

	)

3151 #define 
	#DMA_HISR_TEIF6
 ((
uint32_t
)0x00080000)

	)

3152 #define 
	#DMA_HISR_DMEIF6
 ((
uint32_t
)0x00040000)

	)

3153 #define 
	#DMA_HISR_FEIF6
 ((
uint32_t
)0x00010000)

	)

3154 #define 
	#DMA_HISR_TCIF5
 ((
uint32_t
)0x00000800)

	)

3155 #define 
	#DMA_HISR_HTIF5
 ((
uint32_t
)0x00000400)

	)

3156 #define 
	#DMA_HISR_TEIF5
 ((
uint32_t
)0x00000200)

	)

3157 #define 
	#DMA_HISR_DMEIF5
 ((
uint32_t
)0x00000100)

	)

3158 #define 
	#DMA_HISR_FEIF5
 ((
uint32_t
)0x00000040)

	)

3159 #define 
	#DMA_HISR_TCIF4
 ((
uint32_t
)0x00000020)

	)

3160 #define 
	#DMA_HISR_HTIF4
 ((
uint32_t
)0x00000010)

	)

3161 #define 
	#DMA_HISR_TEIF4
 ((
uint32_t
)0x00000008)

	)

3162 #define 
	#DMA_HISR_DMEIF4
 ((
uint32_t
)0x00000004)

	)

3163 #define 
	#DMA_HISR_FEIF4
 ((
uint32_t
)0x00000001)

	)

3166 #define 
	#DMA_LIFCR_CTCIF3
 ((
uint32_t
)0x08000000)

	)

3167 #define 
	#DMA_LIFCR_CHTIF3
 ((
uint32_t
)0x04000000)

	)

3168 #define 
	#DMA_LIFCR_CTEIF3
 ((
uint32_t
)0x02000000)

	)

3169 #define 
	#DMA_LIFCR_CDMEIF3
 ((
uint32_t
)0x01000000)

	)

3170 #define 
	#DMA_LIFCR_CFEIF3
 ((
uint32_t
)0x00400000)

	)

3171 #define 
	#DMA_LIFCR_CTCIF2
 ((
uint32_t
)0x00200000)

	)

3172 #define 
	#DMA_LIFCR_CHTIF2
 ((
uint32_t
)0x00100000)

	)

3173 #define 
	#DMA_LIFCR_CTEIF2
 ((
uint32_t
)0x00080000)

	)

3174 #define 
	#DMA_LIFCR_CDMEIF2
 ((
uint32_t
)0x00040000)

	)

3175 #define 
	#DMA_LIFCR_CFEIF2
 ((
uint32_t
)0x00010000)

	)

3176 #define 
	#DMA_LIFCR_CTCIF1
 ((
uint32_t
)0x00000800)

	)

3177 #define 
	#DMA_LIFCR_CHTIF1
 ((
uint32_t
)0x00000400)

	)

3178 #define 
	#DMA_LIFCR_CTEIF1
 ((
uint32_t
)0x00000200)

	)

3179 #define 
	#DMA_LIFCR_CDMEIF1
 ((
uint32_t
)0x00000100)

	)

3180 #define 
	#DMA_LIFCR_CFEIF1
 ((
uint32_t
)0x00000040)

	)

3181 #define 
	#DMA_LIFCR_CTCIF0
 ((
uint32_t
)0x00000020)

	)

3182 #define 
	#DMA_LIFCR_CHTIF0
 ((
uint32_t
)0x00000010)

	)

3183 #define 
	#DMA_LIFCR_CTEIF0
 ((
uint32_t
)0x00000008)

	)

3184 #define 
	#DMA_LIFCR_CDMEIF0
 ((
uint32_t
)0x00000004)

	)

3185 #define 
	#DMA_LIFCR_CFEIF0
 ((
uint32_t
)0x00000001)

	)

3188 #define 
	#DMA_HIFCR_CTCIF7
 ((
uint32_t
)0x08000000)

	)

3189 #define 
	#DMA_HIFCR_CHTIF7
 ((
uint32_t
)0x04000000)

	)

3190 #define 
	#DMA_HIFCR_CTEIF7
 ((
uint32_t
)0x02000000)

	)

3191 #define 
	#DMA_HIFCR_CDMEIF7
 ((
uint32_t
)0x01000000)

	)

3192 #define 
	#DMA_HIFCR_CFEIF7
 ((
uint32_t
)0x00400000)

	)

3193 #define 
	#DMA_HIFCR_CTCIF6
 ((
uint32_t
)0x00200000)

	)

3194 #define 
	#DMA_HIFCR_CHTIF6
 ((
uint32_t
)0x00100000)

	)

3195 #define 
	#DMA_HIFCR_CTEIF6
 ((
uint32_t
)0x00080000)

	)

3196 #define 
	#DMA_HIFCR_CDMEIF6
 ((
uint32_t
)0x00040000)

	)

3197 #define 
	#DMA_HIFCR_CFEIF6
 ((
uint32_t
)0x00010000)

	)

3198 #define 
	#DMA_HIFCR_CTCIF5
 ((
uint32_t
)0x00000800)

	)

3199 #define 
	#DMA_HIFCR_CHTIF5
 ((
uint32_t
)0x00000400)

	)

3200 #define 
	#DMA_HIFCR_CTEIF5
 ((
uint32_t
)0x00000200)

	)

3201 #define 
	#DMA_HIFCR_CDMEIF5
 ((
uint32_t
)0x00000100)

	)

3202 #define 
	#DMA_HIFCR_CFEIF5
 ((
uint32_t
)0x00000040)

	)

3203 #define 
	#DMA_HIFCR_CTCIF4
 ((
uint32_t
)0x00000020)

	)

3204 #define 
	#DMA_HIFCR_CHTIF4
 ((
uint32_t
)0x00000010)

	)

3205 #define 
	#DMA_HIFCR_CTEIF4
 ((
uint32_t
)0x00000008)

	)

3206 #define 
	#DMA_HIFCR_CDMEIF4
 ((
uint32_t
)0x00000004)

	)

3207 #define 
	#DMA_HIFCR_CFEIF4
 ((
uint32_t
)0x00000001)

	)

3215 #define 
	#EXTI_IMR_MR0
 ((
uint32_t
)0x00000001)

	)

3216 #define 
	#EXTI_IMR_MR1
 ((
uint32_t
)0x00000002)

	)

3217 #define 
	#EXTI_IMR_MR2
 ((
uint32_t
)0x00000004)

	)

3218 #define 
	#EXTI_IMR_MR3
 ((
uint32_t
)0x00000008)

	)

3219 #define 
	#EXTI_IMR_MR4
 ((
uint32_t
)0x00000010)

	)

3220 #define 
	#EXTI_IMR_MR5
 ((
uint32_t
)0x00000020)

	)

3221 #define 
	#EXTI_IMR_MR6
 ((
uint32_t
)0x00000040)

	)

3222 #define 
	#EXTI_IMR_MR7
 ((
uint32_t
)0x00000080)

	)

3223 #define 
	#EXTI_IMR_MR8
 ((
uint32_t
)0x00000100)

	)

3224 #define 
	#EXTI_IMR_MR9
 ((
uint32_t
)0x00000200)

	)

3225 #define 
	#EXTI_IMR_MR10
 ((
uint32_t
)0x00000400)

	)

3226 #define 
	#EXTI_IMR_MR11
 ((
uint32_t
)0x00000800)

	)

3227 #define 
	#EXTI_IMR_MR12
 ((
uint32_t
)0x00001000)

	)

3228 #define 
	#EXTI_IMR_MR13
 ((
uint32_t
)0x00002000)

	)

3229 #define 
	#EXTI_IMR_MR14
 ((
uint32_t
)0x00004000)

	)

3230 #define 
	#EXTI_IMR_MR15
 ((
uint32_t
)0x00008000)

	)

3231 #define 
	#EXTI_IMR_MR16
 ((
uint32_t
)0x00010000)

	)

3232 #define 
	#EXTI_IMR_MR17
 ((
uint32_t
)0x00020000)

	)

3233 #define 
	#EXTI_IMR_MR18
 ((
uint32_t
)0x00040000)

	)

3234 #define 
	#EXTI_IMR_MR19
 ((
uint32_t
)0x00080000)

	)

3237 #define 
	#EXTI_EMR_MR0
 ((
uint32_t
)0x00000001)

	)

3238 #define 
	#EXTI_EMR_MR1
 ((
uint32_t
)0x00000002)

	)

3239 #define 
	#EXTI_EMR_MR2
 ((
uint32_t
)0x00000004)

	)

3240 #define 
	#EXTI_EMR_MR3
 ((
uint32_t
)0x00000008)

	)

3241 #define 
	#EXTI_EMR_MR4
 ((
uint32_t
)0x00000010)

	)

3242 #define 
	#EXTI_EMR_MR5
 ((
uint32_t
)0x00000020)

	)

3243 #define 
	#EXTI_EMR_MR6
 ((
uint32_t
)0x00000040)

	)

3244 #define 
	#EXTI_EMR_MR7
 ((
uint32_t
)0x00000080)

	)

3245 #define 
	#EXTI_EMR_MR8
 ((
uint32_t
)0x00000100)

	)

3246 #define 
	#EXTI_EMR_MR9
 ((
uint32_t
)0x00000200)

	)

3247 #define 
	#EXTI_EMR_MR10
 ((
uint32_t
)0x00000400)

	)

3248 #define 
	#EXTI_EMR_MR11
 ((
uint32_t
)0x00000800)

	)

3249 #define 
	#EXTI_EMR_MR12
 ((
uint32_t
)0x00001000)

	)

3250 #define 
	#EXTI_EMR_MR13
 ((
uint32_t
)0x00002000)

	)

3251 #define 
	#EXTI_EMR_MR14
 ((
uint32_t
)0x00004000)

	)

3252 #define 
	#EXTI_EMR_MR15
 ((
uint32_t
)0x00008000)

	)

3253 #define 
	#EXTI_EMR_MR16
 ((
uint32_t
)0x00010000)

	)

3254 #define 
	#EXTI_EMR_MR17
 ((
uint32_t
)0x00020000)

	)

3255 #define 
	#EXTI_EMR_MR18
 ((
uint32_t
)0x00040000)

	)

3256 #define 
	#EXTI_EMR_MR19
 ((
uint32_t
)0x00080000)

	)

3259 #define 
	#EXTI_RTSR_TR0
 ((
uint32_t
)0x00000001)

	)

3260 #define 
	#EXTI_RTSR_TR1
 ((
uint32_t
)0x00000002)

	)

3261 #define 
	#EXTI_RTSR_TR2
 ((
uint32_t
)0x00000004)

	)

3262 #define 
	#EXTI_RTSR_TR3
 ((
uint32_t
)0x00000008)

	)

3263 #define 
	#EXTI_RTSR_TR4
 ((
uint32_t
)0x00000010)

	)

3264 #define 
	#EXTI_RTSR_TR5
 ((
uint32_t
)0x00000020)

	)

3265 #define 
	#EXTI_RTSR_TR6
 ((
uint32_t
)0x00000040)

	)

3266 #define 
	#EXTI_RTSR_TR7
 ((
uint32_t
)0x00000080)

	)

3267 #define 
	#EXTI_RTSR_TR8
 ((
uint32_t
)0x00000100)

	)

3268 #define 
	#EXTI_RTSR_TR9
 ((
uint32_t
)0x00000200)

	)

3269 #define 
	#EXTI_RTSR_TR10
 ((
uint32_t
)0x00000400)

	)

3270 #define 
	#EXTI_RTSR_TR11
 ((
uint32_t
)0x00000800)

	)

3271 #define 
	#EXTI_RTSR_TR12
 ((
uint32_t
)0x00001000)

	)

3272 #define 
	#EXTI_RTSR_TR13
 ((
uint32_t
)0x00002000)

	)

3273 #define 
	#EXTI_RTSR_TR14
 ((
uint32_t
)0x00004000)

	)

3274 #define 
	#EXTI_RTSR_TR15
 ((
uint32_t
)0x00008000)

	)

3275 #define 
	#EXTI_RTSR_TR16
 ((
uint32_t
)0x00010000)

	)

3276 #define 
	#EXTI_RTSR_TR17
 ((
uint32_t
)0x00020000)

	)

3277 #define 
	#EXTI_RTSR_TR18
 ((
uint32_t
)0x00040000)

	)

3278 #define 
	#EXTI_RTSR_TR19
 ((
uint32_t
)0x00080000)

	)

3281 #define 
	#EXTI_FTSR_TR0
 ((
uint32_t
)0x00000001)

	)

3282 #define 
	#EXTI_FTSR_TR1
 ((
uint32_t
)0x00000002)

	)

3283 #define 
	#EXTI_FTSR_TR2
 ((
uint32_t
)0x00000004)

	)

3284 #define 
	#EXTI_FTSR_TR3
 ((
uint32_t
)0x00000008)

	)

3285 #define 
	#EXTI_FTSR_TR4
 ((
uint32_t
)0x00000010)

	)

3286 #define 
	#EXTI_FTSR_TR5
 ((
uint32_t
)0x00000020)

	)

3287 #define 
	#EXTI_FTSR_TR6
 ((
uint32_t
)0x00000040)

	)

3288 #define 
	#EXTI_FTSR_TR7
 ((
uint32_t
)0x00000080)

	)

3289 #define 
	#EXTI_FTSR_TR8
 ((
uint32_t
)0x00000100)

	)

3290 #define 
	#EXTI_FTSR_TR9
 ((
uint32_t
)0x00000200)

	)

3291 #define 
	#EXTI_FTSR_TR10
 ((
uint32_t
)0x00000400)

	)

3292 #define 
	#EXTI_FTSR_TR11
 ((
uint32_t
)0x00000800)

	)

3293 #define 
	#EXTI_FTSR_TR12
 ((
uint32_t
)0x00001000)

	)

3294 #define 
	#EXTI_FTSR_TR13
 ((
uint32_t
)0x00002000)

	)

3295 #define 
	#EXTI_FTSR_TR14
 ((
uint32_t
)0x00004000)

	)

3296 #define 
	#EXTI_FTSR_TR15
 ((
uint32_t
)0x00008000)

	)

3297 #define 
	#EXTI_FTSR_TR16
 ((
uint32_t
)0x00010000)

	)

3298 #define 
	#EXTI_FTSR_TR17
 ((
uint32_t
)0x00020000)

	)

3299 #define 
	#EXTI_FTSR_TR18
 ((
uint32_t
)0x00040000)

	)

3300 #define 
	#EXTI_FTSR_TR19
 ((
uint32_t
)0x00080000)

	)

3303 #define 
	#EXTI_SWIER_SWIER0
 ((
uint32_t
)0x00000001)

	)

3304 #define 
	#EXTI_SWIER_SWIER1
 ((
uint32_t
)0x00000002)

	)

3305 #define 
	#EXTI_SWIER_SWIER2
 ((
uint32_t
)0x00000004)

	)

3306 #define 
	#EXTI_SWIER_SWIER3
 ((
uint32_t
)0x00000008)

	)

3307 #define 
	#EXTI_SWIER_SWIER4
 ((
uint32_t
)0x00000010)

	)

3308 #define 
	#EXTI_SWIER_SWIER5
 ((
uint32_t
)0x00000020)

	)

3309 #define 
	#EXTI_SWIER_SWIER6
 ((
uint32_t
)0x00000040)

	)

3310 #define 
	#EXTI_SWIER_SWIER7
 ((
uint32_t
)0x00000080)

	)

3311 #define 
	#EXTI_SWIER_SWIER8
 ((
uint32_t
)0x00000100)

	)

3312 #define 
	#EXTI_SWIER_SWIER9
 ((
uint32_t
)0x00000200)

	)

3313 #define 
	#EXTI_SWIER_SWIER10
 ((
uint32_t
)0x00000400)

	)

3314 #define 
	#EXTI_SWIER_SWIER11
 ((
uint32_t
)0x00000800)

	)

3315 #define 
	#EXTI_SWIER_SWIER12
 ((
uint32_t
)0x00001000)

	)

3316 #define 
	#EXTI_SWIER_SWIER13
 ((
uint32_t
)0x00002000)

	)

3317 #define 
	#EXTI_SWIER_SWIER14
 ((
uint32_t
)0x00004000)

	)

3318 #define 
	#EXTI_SWIER_SWIER15
 ((
uint32_t
)0x00008000)

	)

3319 #define 
	#EXTI_SWIER_SWIER16
 ((
uint32_t
)0x00010000)

	)

3320 #define 
	#EXTI_SWIER_SWIER17
 ((
uint32_t
)0x00020000)

	)

3321 #define 
	#EXTI_SWIER_SWIER18
 ((
uint32_t
)0x00040000)

	)

3322 #define 
	#EXTI_SWIER_SWIER19
 ((
uint32_t
)0x00080000)

	)

3325 #define 
	#EXTI_PR_PR0
 ((
uint32_t
)0x00000001)

	)

3326 #define 
	#EXTI_PR_PR1
 ((
uint32_t
)0x00000002)

	)

3327 #define 
	#EXTI_PR_PR2
 ((
uint32_t
)0x00000004)

	)

3328 #define 
	#EXTI_PR_PR3
 ((
uint32_t
)0x00000008)

	)

3329 #define 
	#EXTI_PR_PR4
 ((
uint32_t
)0x00000010)

	)

3330 #define 
	#EXTI_PR_PR5
 ((
uint32_t
)0x00000020)

	)

3331 #define 
	#EXTI_PR_PR6
 ((
uint32_t
)0x00000040)

	)

3332 #define 
	#EXTI_PR_PR7
 ((
uint32_t
)0x00000080)

	)

3333 #define 
	#EXTI_PR_PR8
 ((
uint32_t
)0x00000100)

	)

3334 #define 
	#EXTI_PR_PR9
 ((
uint32_t
)0x00000200)

	)

3335 #define 
	#EXTI_PR_PR10
 ((
uint32_t
)0x00000400)

	)

3336 #define 
	#EXTI_PR_PR11
 ((
uint32_t
)0x00000800)

	)

3337 #define 
	#EXTI_PR_PR12
 ((
uint32_t
)0x00001000)

	)

3338 #define 
	#EXTI_PR_PR13
 ((
uint32_t
)0x00002000)

	)

3339 #define 
	#EXTI_PR_PR14
 ((
uint32_t
)0x00004000)

	)

3340 #define 
	#EXTI_PR_PR15
 ((
uint32_t
)0x00008000)

	)

3341 #define 
	#EXTI_PR_PR16
 ((
uint32_t
)0x00010000)

	)

3342 #define 
	#EXTI_PR_PR17
 ((
uint32_t
)0x00020000)

	)

3343 #define 
	#EXTI_PR_PR18
 ((
uint32_t
)0x00040000)

	)

3344 #define 
	#EXTI_PR_PR19
 ((
uint32_t
)0x00080000)

	)

3352 #define 
	#FLASH_ACR_LATENCY
 ((
uint32_t
)0x00000007)

	)

3353 #define 
	#FLASH_ACR_LATENCY_0WS
 ((
uint32_t
)0x00000000)

	)

3354 #define 
	#FLASH_ACR_LATENCY_1WS
 ((
uint32_t
)0x00000001)

	)

3355 #define 
	#FLASH_ACR_LATENCY_2WS
 ((
uint32_t
)0x00000002)

	)

3356 #define 
	#FLASH_ACR_LATENCY_3WS
 ((
uint32_t
)0x00000003)

	)

3357 #define 
	#FLASH_ACR_LATENCY_4WS
 ((
uint32_t
)0x00000004)

	)

3358 #define 
	#FLASH_ACR_LATENCY_5WS
 ((
uint32_t
)0x00000005)

	)

3359 #define 
	#FLASH_ACR_LATENCY_6WS
 ((
uint32_t
)0x00000006)

	)

3360 #define 
	#FLASH_ACR_LATENCY_7WS
 ((
uint32_t
)0x00000007)

	)

3362 #define 
	#FLASH_ACR_PRFTEN
 ((
uint32_t
)0x00000100)

	)

3363 #define 
	#FLASH_ACR_ICEN
 ((
uint32_t
)0x00000200)

	)

3364 #define 
	#FLASH_ACR_DCEN
 ((
uint32_t
)0x00000400)

	)

3365 #define 
	#FLASH_ACR_ICRST
 ((
uint32_t
)0x00000800)

	)

3366 #define 
	#FLASH_ACR_DCRST
 ((
uint32_t
)0x00001000)

	)

3367 #define 
	#FLASH_ACR_BYTE0_ADDRESS
 ((
uint32_t
)0x40023C00)

	)

3368 #define 
	#FLASH_ACR_BYTE2_ADDRESS
 ((
uint32_t
)0x40023C03)

	)

3371 #define 
	#FLASH_SR_EOP
 ((
uint32_t
)0x00000001)

	)

3372 #define 
	#FLASH_SR_SOP
 ((
uint32_t
)0x00000002)

	)

3373 #define 
	#FLASH_SR_WRPERR
 ((
uint32_t
)0x00000010)

	)

3374 #define 
	#FLASH_SR_PGAERR
 ((
uint32_t
)0x00000020)

	)

3375 #define 
	#FLASH_SR_PGPERR
 ((
uint32_t
)0x00000040)

	)

3376 #define 
	#FLASH_SR_PGSERR
 ((
uint32_t
)0x00000080)

	)

3377 #define 
	#FLASH_SR_BSY
 ((
uint32_t
)0x00010000)

	)

3380 #define 
	#FLASH_CR_PG
 ((
uint32_t
)0x00000001)

	)

3381 #define 
	#FLASH_CR_SER
 ((
uint32_t
)0x00000002)

	)

3382 #define 
	#FLASH_CR_MER
 ((
uint32_t
)0x00000004)

	)

3383 #define 
	#FLASH_CR_SNB_0
 ((
uint32_t
)0x00000008)

	)

3384 #define 
	#FLASH_CR_SNB_1
 ((
uint32_t
)0x00000010)

	)

3385 #define 
	#FLASH_CR_SNB_2
 ((
uint32_t
)0x00000020)

	)

3386 #define 
	#FLASH_CR_SNB_3
 ((
uint32_t
)0x00000040)

	)

3387 #define 
	#FLASH_CR_PSIZE_0
 ((
uint32_t
)0x00000100)

	)

3388 #define 
	#FLASH_CR_PSIZE_1
 ((
uint32_t
)0x00000200)

	)

3389 #define 
	#FLASH_CR_STRT
 ((
uint32_t
)0x00010000)

	)

3390 #define 
	#FLASH_CR_EOPIE
 ((
uint32_t
)0x01000000)

	)

3391 #define 
	#FLASH_CR_LOCK
 ((
uint32_t
)0x80000000)

	)

3394 #define 
	#FLASH_OPTCR_OPTLOCK
 ((
uint32_t
)0x00000001)

	)

3395 #define 
	#FLASH_OPTCR_OPTSTRT
 ((
uint32_t
)0x00000002)

	)

3396 #define 
	#FLASH_OPTCR_BOR_LEV_0
 ((
uint32_t
)0x00000004)

	)

3397 #define 
	#FLASH_OPTCR_BOR_LEV_1
 ((
uint32_t
)0x00000008)

	)

3398 #define 
	#FLASH_OPTCR_BOR_LEV
 ((
uint32_t
)0x0000000C)

	)

3399 #define 
	#FLASH_OPTCR_WDG_SW
 ((
uint32_t
)0x00000020)

	)

3400 #define 
	#FLASH_OPTCR_nRST_STOP
 ((
uint32_t
)0x00000040)

	)

3401 #define 
	#FLASH_OPTCR_nRST_STDBY
 ((
uint32_t
)0x00000080)

	)

3402 #define 
	#FLASH_OPTCR_RDP_0
 ((
uint32_t
)0x00000100)

	)

3403 #define 
	#FLASH_OPTCR_RDP_1
 ((
uint32_t
)0x00000200)

	)

3404 #define 
	#FLASH_OPTCR_RDP_2
 ((
uint32_t
)0x00000400)

	)

3405 #define 
	#FLASH_OPTCR_RDP_3
 ((
uint32_t
)0x00000800)

	)

3406 #define 
	#FLASH_OPTCR_RDP_4
 ((
uint32_t
)0x00001000)

	)

3407 #define 
	#FLASH_OPTCR_RDP_5
 ((
uint32_t
)0x00002000)

	)

3408 #define 
	#FLASH_OPTCR_RDP_6
 ((
uint32_t
)0x00004000)

	)

3409 #define 
	#FLASH_OPTCR_RDP_7
 ((
uint32_t
)0x00008000)

	)

3410 #define 
	#FLASH_OPTCR_nWRP_0
 ((
uint32_t
)0x00010000)

	)

3411 #define 
	#FLASH_OPTCR_nWRP_1
 ((
uint32_t
)0x00020000)

	)

3412 #define 
	#FLASH_OPTCR_nWRP_2
 ((
uint32_t
)0x00040000)

	)

3413 #define 
	#FLASH_OPTCR_nWRP_3
 ((
uint32_t
)0x00080000)

	)

3414 #define 
	#FLASH_OPTCR_nWRP_4
 ((
uint32_t
)0x00100000)

	)

3415 #define 
	#FLASH_OPTCR_nWRP_5
 ((
uint32_t
)0x00200000)

	)

3416 #define 
	#FLASH_OPTCR_nWRP_6
 ((
uint32_t
)0x00400000)

	)

3417 #define 
	#FLASH_OPTCR_nWRP_7
 ((
uint32_t
)0x00800000)

	)

3418 #define 
	#FLASH_OPTCR_nWRP_8
 ((
uint32_t
)0x01000000)

	)

3419 #define 
	#FLASH_OPTCR_nWRP_9
 ((
uint32_t
)0x02000000)

	)

3420 #define 
	#FLASH_OPTCR_nWRP_10
 ((
uint32_t
)0x04000000)

	)

3421 #define 
	#FLASH_OPTCR_nWRP_11
 ((
uint32_t
)0x08000000)

	)

3429 #define 
	#FSMC_BCR1_MBKEN
 ((
uint32_t
)0x00000001)

	)

3430 #define 
	#FSMC_BCR1_MUXEN
 ((
uint32_t
)0x00000002)

	)

3432 #define 
	#FSMC_BCR1_MTYP
 ((
uint32_t
)0x0000000C)

	)

3433 #define 
	#FSMC_BCR1_MTYP_0
 ((
uint32_t
)0x00000004)

	)

3434 #define 
	#FSMC_BCR1_MTYP_1
 ((
uint32_t
)0x00000008)

	)

3436 #define 
	#FSMC_BCR1_MWID
 ((
uint32_t
)0x00000030)

	)

3437 #define 
	#FSMC_BCR1_MWID_0
 ((
uint32_t
)0x00000010)

	)

3438 #define 
	#FSMC_BCR1_MWID_1
 ((
uint32_t
)0x00000020)

	)

3440 #define 
	#FSMC_BCR1_FACCEN
 ((
uint32_t
)0x00000040)

	)

3441 #define 
	#FSMC_BCR1_BURSTEN
 ((
uint32_t
)0x00000100)

	)

3442 #define 
	#FSMC_BCR1_WAITPOL
 ((
uint32_t
)0x00000200)

	)

3443 #define 
	#FSMC_BCR1_WRAPMOD
 ((
uint32_t
)0x00000400)

	)

3444 #define 
	#FSMC_BCR1_WAITCFG
 ((
uint32_t
)0x00000800)

	)

3445 #define 
	#FSMC_BCR1_WREN
 ((
uint32_t
)0x00001000)

	)

3446 #define 
	#FSMC_BCR1_WAITEN
 ((
uint32_t
)0x00002000)

	)

3447 #define 
	#FSMC_BCR1_EXTMOD
 ((
uint32_t
)0x00004000)

	)

3448 #define 
	#FSMC_BCR1_ASYNCWAIT
 ((
uint32_t
)0x00008000)

	)

3449 #define 
	#FSMC_BCR1_CBURSTRW
 ((
uint32_t
)0x00080000)

	)

3452 #define 
	#FSMC_BCR2_MBKEN
 ((
uint32_t
)0x00000001)

	)

3453 #define 
	#FSMC_BCR2_MUXEN
 ((
uint32_t
)0x00000002)

	)

3455 #define 
	#FSMC_BCR2_MTYP
 ((
uint32_t
)0x0000000C)

	)

3456 #define 
	#FSMC_BCR2_MTYP_0
 ((
uint32_t
)0x00000004)

	)

3457 #define 
	#FSMC_BCR2_MTYP_1
 ((
uint32_t
)0x00000008)

	)

3459 #define 
	#FSMC_BCR2_MWID
 ((
uint32_t
)0x00000030)

	)

3460 #define 
	#FSMC_BCR2_MWID_0
 ((
uint32_t
)0x00000010)

	)

3461 #define 
	#FSMC_BCR2_MWID_1
 ((
uint32_t
)0x00000020)

	)

3463 #define 
	#FSMC_BCR2_FACCEN
 ((
uint32_t
)0x00000040)

	)

3464 #define 
	#FSMC_BCR2_BURSTEN
 ((
uint32_t
)0x00000100)

	)

3465 #define 
	#FSMC_BCR2_WAITPOL
 ((
uint32_t
)0x00000200)

	)

3466 #define 
	#FSMC_BCR2_WRAPMOD
 ((
uint32_t
)0x00000400)

	)

3467 #define 
	#FSMC_BCR2_WAITCFG
 ((
uint32_t
)0x00000800)

	)

3468 #define 
	#FSMC_BCR2_WREN
 ((
uint32_t
)0x00001000)

	)

3469 #define 
	#FSMC_BCR2_WAITEN
 ((
uint32_t
)0x00002000)

	)

3470 #define 
	#FSMC_BCR2_EXTMOD
 ((
uint32_t
)0x00004000)

	)

3471 #define 
	#FSMC_BCR2_ASYNCWAIT
 ((
uint32_t
)0x00008000)

	)

3472 #define 
	#FSMC_BCR2_CBURSTRW
 ((
uint32_t
)0x00080000)

	)

3475 #define 
	#FSMC_BCR3_MBKEN
 ((
uint32_t
)0x00000001)

	)

3476 #define 
	#FSMC_BCR3_MUXEN
 ((
uint32_t
)0x00000002)

	)

3478 #define 
	#FSMC_BCR3_MTYP
 ((
uint32_t
)0x0000000C)

	)

3479 #define 
	#FSMC_BCR3_MTYP_0
 ((
uint32_t
)0x00000004)

	)

3480 #define 
	#FSMC_BCR3_MTYP_1
 ((
uint32_t
)0x00000008)

	)

3482 #define 
	#FSMC_BCR3_MWID
 ((
uint32_t
)0x00000030)

	)

3483 #define 
	#FSMC_BCR3_MWID_0
 ((
uint32_t
)0x00000010)

	)

3484 #define 
	#FSMC_BCR3_MWID_1
 ((
uint32_t
)0x00000020)

	)

3486 #define 
	#FSMC_BCR3_FACCEN
 ((
uint32_t
)0x00000040)

	)

3487 #define 
	#FSMC_BCR3_BURSTEN
 ((
uint32_t
)0x00000100)

	)

3488 #define 
	#FSMC_BCR3_WAITPOL
 ((
uint32_t
)0x00000200)

	)

3489 #define 
	#FSMC_BCR3_WRAPMOD
 ((
uint32_t
)0x00000400)

	)

3490 #define 
	#FSMC_BCR3_WAITCFG
 ((
uint32_t
)0x00000800)

	)

3491 #define 
	#FSMC_BCR3_WREN
 ((
uint32_t
)0x00001000)

	)

3492 #define 
	#FSMC_BCR3_WAITEN
 ((
uint32_t
)0x00002000)

	)

3493 #define 
	#FSMC_BCR3_EXTMOD
 ((
uint32_t
)0x00004000)

	)

3494 #define 
	#FSMC_BCR3_ASYNCWAIT
 ((
uint32_t
)0x00008000)

	)

3495 #define 
	#FSMC_BCR3_CBURSTRW
 ((
uint32_t
)0x00080000)

	)

3498 #define 
	#FSMC_BCR4_MBKEN
 ((
uint32_t
)0x00000001)

	)

3499 #define 
	#FSMC_BCR4_MUXEN
 ((
uint32_t
)0x00000002)

	)

3501 #define 
	#FSMC_BCR4_MTYP
 ((
uint32_t
)0x0000000C)

	)

3502 #define 
	#FSMC_BCR4_MTYP_0
 ((
uint32_t
)0x00000004)

	)

3503 #define 
	#FSMC_BCR4_MTYP_1
 ((
uint32_t
)0x00000008)

	)

3505 #define 
	#FSMC_BCR4_MWID
 ((
uint32_t
)0x00000030)

	)

3506 #define 
	#FSMC_BCR4_MWID_0
 ((
uint32_t
)0x00000010)

	)

3507 #define 
	#FSMC_BCR4_MWID_1
 ((
uint32_t
)0x00000020)

	)

3509 #define 
	#FSMC_BCR4_FACCEN
 ((
uint32_t
)0x00000040)

	)

3510 #define 
	#FSMC_BCR4_BURSTEN
 ((
uint32_t
)0x00000100)

	)

3511 #define 
	#FSMC_BCR4_WAITPOL
 ((
uint32_t
)0x00000200)

	)

3512 #define 
	#FSMC_BCR4_WRAPMOD
 ((
uint32_t
)0x00000400)

	)

3513 #define 
	#FSMC_BCR4_WAITCFG
 ((
uint32_t
)0x00000800)

	)

3514 #define 
	#FSMC_BCR4_WREN
 ((
uint32_t
)0x00001000)

	)

3515 #define 
	#FSMC_BCR4_WAITEN
 ((
uint32_t
)0x00002000)

	)

3516 #define 
	#FSMC_BCR4_EXTMOD
 ((
uint32_t
)0x00004000)

	)

3517 #define 
	#FSMC_BCR4_ASYNCWAIT
 ((
uint32_t
)0x00008000)

	)

3518 #define 
	#FSMC_BCR4_CBURSTRW
 ((
uint32_t
)0x00080000)

	)

3521 #define 
	#FSMC_BTR1_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3522 #define 
	#FSMC_BTR1_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3523 #define 
	#FSMC_BTR1_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3524 #define 
	#FSMC_BTR1_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3525 #define 
	#FSMC_BTR1_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3527 #define 
	#FSMC_BTR1_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3528 #define 
	#FSMC_BTR1_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3529 #define 
	#FSMC_BTR1_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3530 #define 
	#FSMC_BTR1_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3531 #define 
	#FSMC_BTR1_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3533 #define 
	#FSMC_BTR1_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3534 #define 
	#FSMC_BTR1_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3535 #define 
	#FSMC_BTR1_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3536 #define 
	#FSMC_BTR1_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3537 #define 
	#FSMC_BTR1_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3539 #define 
	#FSMC_BTR1_BUSTURN
 ((
uint32_t
)0x000F0000)

	)

3540 #define 
	#FSMC_BTR1_BUSTURN_0
 ((
uint32_t
)0x00010000)

	)

3541 #define 
	#FSMC_BTR1_BUSTURN_1
 ((
uint32_t
)0x00020000)

	)

3542 #define 
	#FSMC_BTR1_BUSTURN_2
 ((
uint32_t
)0x00040000)

	)

3543 #define 
	#FSMC_BTR1_BUSTURN_3
 ((
uint32_t
)0x00080000)

	)

3545 #define 
	#FSMC_BTR1_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3546 #define 
	#FSMC_BTR1_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3547 #define 
	#FSMC_BTR1_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3548 #define 
	#FSMC_BTR1_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3549 #define 
	#FSMC_BTR1_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3551 #define 
	#FSMC_BTR1_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3552 #define 
	#FSMC_BTR1_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3553 #define 
	#FSMC_BTR1_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3554 #define 
	#FSMC_BTR1_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3555 #define 
	#FSMC_BTR1_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3557 #define 
	#FSMC_BTR1_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3558 #define 
	#FSMC_BTR1_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3559 #define 
	#FSMC_BTR1_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3562 #define 
	#FSMC_BTR2_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3563 #define 
	#FSMC_BTR2_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3564 #define 
	#FSMC_BTR2_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3565 #define 
	#FSMC_BTR2_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3566 #define 
	#FSMC_BTR2_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3568 #define 
	#FSMC_BTR2_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3569 #define 
	#FSMC_BTR2_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3570 #define 
	#FSMC_BTR2_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3571 #define 
	#FSMC_BTR2_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3572 #define 
	#FSMC_BTR2_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3574 #define 
	#FSMC_BTR2_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3575 #define 
	#FSMC_BTR2_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3576 #define 
	#FSMC_BTR2_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3577 #define 
	#FSMC_BTR2_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3578 #define 
	#FSMC_BTR2_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3580 #define 
	#FSMC_BTR2_BUSTURN
 ((
uint32_t
)0x000F0000)

	)

3581 #define 
	#FSMC_BTR2_BUSTURN_0
 ((
uint32_t
)0x00010000)

	)

3582 #define 
	#FSMC_BTR2_BUSTURN_1
 ((
uint32_t
)0x00020000)

	)

3583 #define 
	#FSMC_BTR2_BUSTURN_2
 ((
uint32_t
)0x00040000)

	)

3584 #define 
	#FSMC_BTR2_BUSTURN_3
 ((
uint32_t
)0x00080000)

	)

3586 #define 
	#FSMC_BTR2_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3587 #define 
	#FSMC_BTR2_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3588 #define 
	#FSMC_BTR2_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3589 #define 
	#FSMC_BTR2_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3590 #define 
	#FSMC_BTR2_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3592 #define 
	#FSMC_BTR2_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3593 #define 
	#FSMC_BTR2_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3594 #define 
	#FSMC_BTR2_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3595 #define 
	#FSMC_BTR2_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3596 #define 
	#FSMC_BTR2_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3598 #define 
	#FSMC_BTR2_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3599 #define 
	#FSMC_BTR2_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3600 #define 
	#FSMC_BTR2_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3603 #define 
	#FSMC_BTR3_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3604 #define 
	#FSMC_BTR3_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3605 #define 
	#FSMC_BTR3_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3606 #define 
	#FSMC_BTR3_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3607 #define 
	#FSMC_BTR3_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3609 #define 
	#FSMC_BTR3_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3610 #define 
	#FSMC_BTR3_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3611 #define 
	#FSMC_BTR3_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3612 #define 
	#FSMC_BTR3_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3613 #define 
	#FSMC_BTR3_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3615 #define 
	#FSMC_BTR3_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3616 #define 
	#FSMC_BTR3_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3617 #define 
	#FSMC_BTR3_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3618 #define 
	#FSMC_BTR3_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3619 #define 
	#FSMC_BTR3_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3621 #define 
	#FSMC_BTR3_BUSTURN
 ((
uint32_t
)0x000F0000)

	)

3622 #define 
	#FSMC_BTR3_BUSTURN_0
 ((
uint32_t
)0x00010000)

	)

3623 #define 
	#FSMC_BTR3_BUSTURN_1
 ((
uint32_t
)0x00020000)

	)

3624 #define 
	#FSMC_BTR3_BUSTURN_2
 ((
uint32_t
)0x00040000)

	)

3625 #define 
	#FSMC_BTR3_BUSTURN_3
 ((
uint32_t
)0x00080000)

	)

3627 #define 
	#FSMC_BTR3_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3628 #define 
	#FSMC_BTR3_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3629 #define 
	#FSMC_BTR3_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3630 #define 
	#FSMC_BTR3_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3631 #define 
	#FSMC_BTR3_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3633 #define 
	#FSMC_BTR3_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3634 #define 
	#FSMC_BTR3_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3635 #define 
	#FSMC_BTR3_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3636 #define 
	#FSMC_BTR3_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3637 #define 
	#FSMC_BTR3_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3639 #define 
	#FSMC_BTR3_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3640 #define 
	#FSMC_BTR3_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3641 #define 
	#FSMC_BTR3_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3644 #define 
	#FSMC_BTR4_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3645 #define 
	#FSMC_BTR4_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3646 #define 
	#FSMC_BTR4_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3647 #define 
	#FSMC_BTR4_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3648 #define 
	#FSMC_BTR4_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3650 #define 
	#FSMC_BTR4_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3651 #define 
	#FSMC_BTR4_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3652 #define 
	#FSMC_BTR4_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3653 #define 
	#FSMC_BTR4_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3654 #define 
	#FSMC_BTR4_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3656 #define 
	#FSMC_BTR4_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3657 #define 
	#FSMC_BTR4_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3658 #define 
	#FSMC_BTR4_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3659 #define 
	#FSMC_BTR4_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3660 #define 
	#FSMC_BTR4_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3662 #define 
	#FSMC_BTR4_BUSTURN
 ((
uint32_t
)0x000F0000)

	)

3663 #define 
	#FSMC_BTR4_BUSTURN_0
 ((
uint32_t
)0x00010000)

	)

3664 #define 
	#FSMC_BTR4_BUSTURN_1
 ((
uint32_t
)0x00020000)

	)

3665 #define 
	#FSMC_BTR4_BUSTURN_2
 ((
uint32_t
)0x00040000)

	)

3666 #define 
	#FSMC_BTR4_BUSTURN_3
 ((
uint32_t
)0x00080000)

	)

3668 #define 
	#FSMC_BTR4_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3669 #define 
	#FSMC_BTR4_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3670 #define 
	#FSMC_BTR4_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3671 #define 
	#FSMC_BTR4_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3672 #define 
	#FSMC_BTR4_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3674 #define 
	#FSMC_BTR4_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3675 #define 
	#FSMC_BTR4_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3676 #define 
	#FSMC_BTR4_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3677 #define 
	#FSMC_BTR4_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3678 #define 
	#FSMC_BTR4_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3680 #define 
	#FSMC_BTR4_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3681 #define 
	#FSMC_BTR4_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3682 #define 
	#FSMC_BTR4_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3685 #define 
	#FSMC_BWTR1_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3686 #define 
	#FSMC_BWTR1_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3687 #define 
	#FSMC_BWTR1_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3688 #define 
	#FSMC_BWTR1_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3689 #define 
	#FSMC_BWTR1_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3691 #define 
	#FSMC_BWTR1_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3692 #define 
	#FSMC_BWTR1_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3693 #define 
	#FSMC_BWTR1_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3694 #define 
	#FSMC_BWTR1_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3695 #define 
	#FSMC_BWTR1_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3697 #define 
	#FSMC_BWTR1_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3698 #define 
	#FSMC_BWTR1_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3699 #define 
	#FSMC_BWTR1_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3700 #define 
	#FSMC_BWTR1_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3701 #define 
	#FSMC_BWTR1_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3703 #define 
	#FSMC_BWTR1_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3704 #define 
	#FSMC_BWTR1_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3705 #define 
	#FSMC_BWTR1_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3706 #define 
	#FSMC_BWTR1_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3707 #define 
	#FSMC_BWTR1_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3709 #define 
	#FSMC_BWTR1_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3710 #define 
	#FSMC_BWTR1_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3711 #define 
	#FSMC_BWTR1_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3712 #define 
	#FSMC_BWTR1_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3713 #define 
	#FSMC_BWTR1_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3715 #define 
	#FSMC_BWTR1_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3716 #define 
	#FSMC_BWTR1_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3717 #define 
	#FSMC_BWTR1_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3720 #define 
	#FSMC_BWTR2_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3721 #define 
	#FSMC_BWTR2_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3722 #define 
	#FSMC_BWTR2_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3723 #define 
	#FSMC_BWTR2_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3724 #define 
	#FSMC_BWTR2_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3726 #define 
	#FSMC_BWTR2_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3727 #define 
	#FSMC_BWTR2_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3728 #define 
	#FSMC_BWTR2_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3729 #define 
	#FSMC_BWTR2_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3730 #define 
	#FSMC_BWTR2_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3732 #define 
	#FSMC_BWTR2_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3733 #define 
	#FSMC_BWTR2_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3734 #define 
	#FSMC_BWTR2_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3735 #define 
	#FSMC_BWTR2_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3736 #define 
	#FSMC_BWTR2_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3738 #define 
	#FSMC_BWTR2_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3739 #define 
	#FSMC_BWTR2_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3740 #define 
	#FSMC_BWTR2_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3741 #define 
	#FSMC_BWTR2_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3742 #define 
	#FSMC_BWTR2_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3744 #define 
	#FSMC_BWTR2_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3745 #define 
	#FSMC_BWTR2_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3746 #define 
	#FSMC_BWTR2_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3747 #define 
	#FSMC_BWTR2_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3748 #define 
	#FSMC_BWTR2_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3750 #define 
	#FSMC_BWTR2_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3751 #define 
	#FSMC_BWTR2_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3752 #define 
	#FSMC_BWTR2_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3755 #define 
	#FSMC_BWTR3_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3756 #define 
	#FSMC_BWTR3_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3757 #define 
	#FSMC_BWTR3_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3758 #define 
	#FSMC_BWTR3_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3759 #define 
	#FSMC_BWTR3_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3761 #define 
	#FSMC_BWTR3_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3762 #define 
	#FSMC_BWTR3_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3763 #define 
	#FSMC_BWTR3_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3764 #define 
	#FSMC_BWTR3_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3765 #define 
	#FSMC_BWTR3_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3767 #define 
	#FSMC_BWTR3_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3768 #define 
	#FSMC_BWTR3_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3769 #define 
	#FSMC_BWTR3_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3770 #define 
	#FSMC_BWTR3_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3771 #define 
	#FSMC_BWTR3_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3773 #define 
	#FSMC_BWTR3_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3774 #define 
	#FSMC_BWTR3_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3775 #define 
	#FSMC_BWTR3_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3776 #define 
	#FSMC_BWTR3_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3777 #define 
	#FSMC_BWTR3_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3779 #define 
	#FSMC_BWTR3_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3780 #define 
	#FSMC_BWTR3_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3781 #define 
	#FSMC_BWTR3_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3782 #define 
	#FSMC_BWTR3_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3783 #define 
	#FSMC_BWTR3_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3785 #define 
	#FSMC_BWTR3_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3786 #define 
	#FSMC_BWTR3_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3787 #define 
	#FSMC_BWTR3_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3790 #define 
	#FSMC_BWTR4_ADDSET
 ((
uint32_t
)0x0000000F)

	)

3791 #define 
	#FSMC_BWTR4_ADDSET_0
 ((
uint32_t
)0x00000001)

	)

3792 #define 
	#FSMC_BWTR4_ADDSET_1
 ((
uint32_t
)0x00000002)

	)

3793 #define 
	#FSMC_BWTR4_ADDSET_2
 ((
uint32_t
)0x00000004)

	)

3794 #define 
	#FSMC_BWTR4_ADDSET_3
 ((
uint32_t
)0x00000008)

	)

3796 #define 
	#FSMC_BWTR4_ADDHLD
 ((
uint32_t
)0x000000F0)

	)

3797 #define 
	#FSMC_BWTR4_ADDHLD_0
 ((
uint32_t
)0x00000010)

	)

3798 #define 
	#FSMC_BWTR4_ADDHLD_1
 ((
uint32_t
)0x00000020)

	)

3799 #define 
	#FSMC_BWTR4_ADDHLD_2
 ((
uint32_t
)0x00000040)

	)

3800 #define 
	#FSMC_BWTR4_ADDHLD_3
 ((
uint32_t
)0x00000080)

	)

3802 #define 
	#FSMC_BWTR4_DATAST
 ((
uint32_t
)0x0000FF00)

	)

3803 #define 
	#FSMC_BWTR4_DATAST_0
 ((
uint32_t
)0x00000100)

	)

3804 #define 
	#FSMC_BWTR4_DATAST_1
 ((
uint32_t
)0x00000200)

	)

3805 #define 
	#FSMC_BWTR4_DATAST_2
 ((
uint32_t
)0x00000400)

	)

3806 #define 
	#FSMC_BWTR4_DATAST_3
 ((
uint32_t
)0x00000800)

	)

3808 #define 
	#FSMC_BWTR4_CLKDIV
 ((
uint32_t
)0x00F00000)

	)

3809 #define 
	#FSMC_BWTR4_CLKDIV_0
 ((
uint32_t
)0x00100000)

	)

3810 #define 
	#FSMC_BWTR4_CLKDIV_1
 ((
uint32_t
)0x00200000)

	)

3811 #define 
	#FSMC_BWTR4_CLKDIV_2
 ((
uint32_t
)0x00400000)

	)

3812 #define 
	#FSMC_BWTR4_CLKDIV_3
 ((
uint32_t
)0x00800000)

	)

3814 #define 
	#FSMC_BWTR4_DATLAT
 ((
uint32_t
)0x0F000000)

	)

3815 #define 
	#FSMC_BWTR4_DATLAT_0
 ((
uint32_t
)0x01000000)

	)

3816 #define 
	#FSMC_BWTR4_DATLAT_1
 ((
uint32_t
)0x02000000)

	)

3817 #define 
	#FSMC_BWTR4_DATLAT_2
 ((
uint32_t
)0x04000000)

	)

3818 #define 
	#FSMC_BWTR4_DATLAT_3
 ((
uint32_t
)0x08000000)

	)

3820 #define 
	#FSMC_BWTR4_ACCMOD
 ((
uint32_t
)0x30000000)

	)

3821 #define 
	#FSMC_BWTR4_ACCMOD_0
 ((
uint32_t
)0x10000000)

	)

3822 #define 
	#FSMC_BWTR4_ACCMOD_1
 ((
uint32_t
)0x20000000)

	)

3825 #define 
	#FSMC_PCR2_PWAITEN
 ((
uint32_t
)0x00000002)

	)

3826 #define 
	#FSMC_PCR2_PBKEN
 ((
uint32_t
)0x00000004)

	)

3827 #define 
	#FSMC_PCR2_PTYP
 ((
uint32_t
)0x00000008)

	)

3829 #define 
	#FSMC_PCR2_PWID
 ((
uint32_t
)0x00000030)

	)

3830 #define 
	#FSMC_PCR2_PWID_0
 ((
uint32_t
)0x00000010)

	)

3831 #define 
	#FSMC_PCR2_PWID_1
 ((
uint32_t
)0x00000020)

	)

3833 #define 
	#FSMC_PCR2_ECCEN
 ((
uint32_t
)0x00000040)

	)

3835 #define 
	#FSMC_PCR2_TCLR
 ((
uint32_t
)0x00001E00)

	)

3836 #define 
	#FSMC_PCR2_TCLR_0
 ((
uint32_t
)0x00000200)

	)

3837 #define 
	#FSMC_PCR2_TCLR_1
 ((
uint32_t
)0x00000400)

	)

3838 #define 
	#FSMC_PCR2_TCLR_2
 ((
uint32_t
)0x00000800)

	)

3839 #define 
	#FSMC_PCR2_TCLR_3
 ((
uint32_t
)0x00001000)

	)

3841 #define 
	#FSMC_PCR2_TAR
 ((
uint32_t
)0x0001E000)

	)

3842 #define 
	#FSMC_PCR2_TAR_0
 ((
uint32_t
)0x00002000)

	)

3843 #define 
	#FSMC_PCR2_TAR_1
 ((
uint32_t
)0x00004000)

	)

3844 #define 
	#FSMC_PCR2_TAR_2
 ((
uint32_t
)0x00008000)

	)

3845 #define 
	#FSMC_PCR2_TAR_3
 ((
uint32_t
)0x00010000)

	)

3847 #define 
	#FSMC_PCR2_ECCPS
 ((
uint32_t
)0x000E0000)

	)

3848 #define 
	#FSMC_PCR2_ECCPS_0
 ((
uint32_t
)0x00020000)

	)

3849 #define 
	#FSMC_PCR2_ECCPS_1
 ((
uint32_t
)0x00040000)

	)

3850 #define 
	#FSMC_PCR2_ECCPS_2
 ((
uint32_t
)0x00080000)

	)

3853 #define 
	#FSMC_PCR3_PWAITEN
 ((
uint32_t
)0x00000002)

	)

3854 #define 
	#FSMC_PCR3_PBKEN
 ((
uint32_t
)0x00000004)

	)

3855 #define 
	#FSMC_PCR3_PTYP
 ((
uint32_t
)0x00000008)

	)

3857 #define 
	#FSMC_PCR3_PWID
 ((
uint32_t
)0x00000030)

	)

3858 #define 
	#FSMC_PCR3_PWID_0
 ((
uint32_t
)0x00000010)

	)

3859 #define 
	#FSMC_PCR3_PWID_1
 ((
uint32_t
)0x00000020)

	)

3861 #define 
	#FSMC_PCR3_ECCEN
 ((
uint32_t
)0x00000040)

	)

3863 #define 
	#FSMC_PCR3_TCLR
 ((
uint32_t
)0x00001E00)

	)

3864 #define 
	#FSMC_PCR3_TCLR_0
 ((
uint32_t
)0x00000200)

	)

3865 #define 
	#FSMC_PCR3_TCLR_1
 ((
uint32_t
)0x00000400)

	)

3866 #define 
	#FSMC_PCR3_TCLR_2
 ((
uint32_t
)0x00000800)

	)

3867 #define 
	#FSMC_PCR3_TCLR_3
 ((
uint32_t
)0x00001000)

	)

3869 #define 
	#FSMC_PCR3_TAR
 ((
uint32_t
)0x0001E000)

	)

3870 #define 
	#FSMC_PCR3_TAR_0
 ((
uint32_t
)0x00002000)

	)

3871 #define 
	#FSMC_PCR3_TAR_1
 ((
uint32_t
)0x00004000)

	)

3872 #define 
	#FSMC_PCR3_TAR_2
 ((
uint32_t
)0x00008000)

	)

3873 #define 
	#FSMC_PCR3_TAR_3
 ((
uint32_t
)0x00010000)

	)

3875 #define 
	#FSMC_PCR3_ECCPS
 ((
uint32_t
)0x000E0000)

	)

3876 #define 
	#FSMC_PCR3_ECCPS_0
 ((
uint32_t
)0x00020000)

	)

3877 #define 
	#FSMC_PCR3_ECCPS_1
 ((
uint32_t
)0x00040000)

	)

3878 #define 
	#FSMC_PCR3_ECCPS_2
 ((
uint32_t
)0x00080000)

	)

3881 #define 
	#FSMC_PCR4_PWAITEN
 ((
uint32_t
)0x00000002)

	)

3882 #define 
	#FSMC_PCR4_PBKEN
 ((
uint32_t
)0x00000004)

	)

3883 #define 
	#FSMC_PCR4_PTYP
 ((
uint32_t
)0x00000008)

	)

3885 #define 
	#FSMC_PCR4_PWID
 ((
uint32_t
)0x00000030)

	)

3886 #define 
	#FSMC_PCR4_PWID_0
 ((
uint32_t
)0x00000010)

	)

3887 #define 
	#FSMC_PCR4_PWID_1
 ((
uint32_t
)0x00000020)

	)

3889 #define 
	#FSMC_PCR4_ECCEN
 ((
uint32_t
)0x00000040)

	)

3891 #define 
	#FSMC_PCR4_TCLR
 ((
uint32_t
)0x00001E00)

	)

3892 #define 
	#FSMC_PCR4_TCLR_0
 ((
uint32_t
)0x00000200)

	)

3893 #define 
	#FSMC_PCR4_TCLR_1
 ((
uint32_t
)0x00000400)

	)

3894 #define 
	#FSMC_PCR4_TCLR_2
 ((
uint32_t
)0x00000800)

	)

3895 #define 
	#FSMC_PCR4_TCLR_3
 ((
uint32_t
)0x00001000)

	)

3897 #define 
	#FSMC_PCR4_TAR
 ((
uint32_t
)0x0001E000)

	)

3898 #define 
	#FSMC_PCR4_TAR_0
 ((
uint32_t
)0x00002000)

	)

3899 #define 
	#FSMC_PCR4_TAR_1
 ((
uint32_t
)0x00004000)

	)

3900 #define 
	#FSMC_PCR4_TAR_2
 ((
uint32_t
)0x00008000)

	)

3901 #define 
	#FSMC_PCR4_TAR_3
 ((
uint32_t
)0x00010000)

	)

3903 #define 
	#FSMC_PCR4_ECCPS
 ((
uint32_t
)0x000E0000)

	)

3904 #define 
	#FSMC_PCR4_ECCPS_0
 ((
uint32_t
)0x00020000)

	)

3905 #define 
	#FSMC_PCR4_ECCPS_1
 ((
uint32_t
)0x00040000)

	)

3906 #define 
	#FSMC_PCR4_ECCPS_2
 ((
uint32_t
)0x00080000)

	)

3909 #define 
	#FSMC_SR2_IRS
 ((
uint8_t
)0x01)

	)

3910 #define 
	#FSMC_SR2_ILS
 ((
uint8_t
)0x02)

	)

3911 #define 
	#FSMC_SR2_IFS
 ((
uint8_t
)0x04)

	)

3912 #define 
	#FSMC_SR2_IREN
 ((
uint8_t
)0x08)

	)

3913 #define 
	#FSMC_SR2_ILEN
 ((
uint8_t
)0x10)

	)

3914 #define 
	#FSMC_SR2_IFEN
 ((
uint8_t
)0x20)

	)

3915 #define 
	#FSMC_SR2_FEMPT
 ((
uint8_t
)0x40)

	)

3918 #define 
	#FSMC_SR3_IRS
 ((
uint8_t
)0x01)

	)

3919 #define 
	#FSMC_SR3_ILS
 ((
uint8_t
)0x02)

	)

3920 #define 
	#FSMC_SR3_IFS
 ((
uint8_t
)0x04)

	)

3921 #define 
	#FSMC_SR3_IREN
 ((
uint8_t
)0x08)

	)

3922 #define 
	#FSMC_SR3_ILEN
 ((
uint8_t
)0x10)

	)

3923 #define 
	#FSMC_SR3_IFEN
 ((
uint8_t
)0x20)

	)

3924 #define 
	#FSMC_SR3_FEMPT
 ((
uint8_t
)0x40)

	)

3927 #define 
	#FSMC_SR4_IRS
 ((
uint8_t
)0x01)

	)

3928 #define 
	#FSMC_SR4_ILS
 ((
uint8_t
)0x02)

	)

3929 #define 
	#FSMC_SR4_IFS
 ((
uint8_t
)0x04)

	)

3930 #define 
	#FSMC_SR4_IREN
 ((
uint8_t
)0x08)

	)

3931 #define 
	#FSMC_SR4_ILEN
 ((
uint8_t
)0x10)

	)

3932 #define 
	#FSMC_SR4_IFEN
 ((
uint8_t
)0x20)

	)

3933 #define 
	#FSMC_SR4_FEMPT
 ((
uint8_t
)0x40)

	)

3936 #define 
	#FSMC_PMEM2_MEMSET2
 ((
uint32_t
)0x000000FF)

	)

3937 #define 
	#FSMC_PMEM2_MEMSET2_0
 ((
uint32_t
)0x00000001)

	)

3938 #define 
	#FSMC_PMEM2_MEMSET2_1
 ((
uint32_t
)0x00000002)

	)

3939 #define 
	#FSMC_PMEM2_MEMSET2_2
 ((
uint32_t
)0x00000004)

	)

3940 #define 
	#FSMC_PMEM2_MEMSET2_3
 ((
uint32_t
)0x00000008)

	)

3941 #define 
	#FSMC_PMEM2_MEMSET2_4
 ((
uint32_t
)0x00000010)

	)

3942 #define 
	#FSMC_PMEM2_MEMSET2_5
 ((
uint32_t
)0x00000020)

	)

3943 #define 
	#FSMC_PMEM2_MEMSET2_6
 ((
uint32_t
)0x00000040)

	)

3944 #define 
	#FSMC_PMEM2_MEMSET2_7
 ((
uint32_t
)0x00000080)

	)

3946 #define 
	#FSMC_PMEM2_MEMWAIT2
 ((
uint32_t
)0x0000FF00)

	)

3947 #define 
	#FSMC_PMEM2_MEMWAIT2_0
 ((
uint32_t
)0x00000100)

	)

3948 #define 
	#FSMC_PMEM2_MEMWAIT2_1
 ((
uint32_t
)0x00000200)

	)

3949 #define 
	#FSMC_PMEM2_MEMWAIT2_2
 ((
uint32_t
)0x00000400)

	)

3950 #define 
	#FSMC_PMEM2_MEMWAIT2_3
 ((
uint32_t
)0x00000800)

	)

3951 #define 
	#FSMC_PMEM2_MEMWAIT2_4
 ((
uint32_t
)0x00001000)

	)

3952 #define 
	#FSMC_PMEM2_MEMWAIT2_5
 ((
uint32_t
)0x00002000)

	)

3953 #define 
	#FSMC_PMEM2_MEMWAIT2_6
 ((
uint32_t
)0x00004000)

	)

3954 #define 
	#FSMC_PMEM2_MEMWAIT2_7
 ((
uint32_t
)0x00008000)

	)

3956 #define 
	#FSMC_PMEM2_MEMHOLD2
 ((
uint32_t
)0x00FF0000)

	)

3957 #define 
	#FSMC_PMEM2_MEMHOLD2_0
 ((
uint32_t
)0x00010000)

	)

3958 #define 
	#FSMC_PMEM2_MEMHOLD2_1
 ((
uint32_t
)0x00020000)

	)

3959 #define 
	#FSMC_PMEM2_MEMHOLD2_2
 ((
uint32_t
)0x00040000)

	)

3960 #define 
	#FSMC_PMEM2_MEMHOLD2_3
 ((
uint32_t
)0x00080000)

	)

3961 #define 
	#FSMC_PMEM2_MEMHOLD2_4
 ((
uint32_t
)0x00100000)

	)

3962 #define 
	#FSMC_PMEM2_MEMHOLD2_5
 ((
uint32_t
)0x00200000)

	)

3963 #define 
	#FSMC_PMEM2_MEMHOLD2_6
 ((
uint32_t
)0x00400000)

	)

3964 #define 
	#FSMC_PMEM2_MEMHOLD2_7
 ((
uint32_t
)0x00800000)

	)

3966 #define 
	#FSMC_PMEM2_MEMHIZ2
 ((
uint32_t
)0xFF000000)

	)

3967 #define 
	#FSMC_PMEM2_MEMHIZ2_0
 ((
uint32_t
)0x01000000)

	)

3968 #define 
	#FSMC_PMEM2_MEMHIZ2_1
 ((
uint32_t
)0x02000000)

	)

3969 #define 
	#FSMC_PMEM2_MEMHIZ2_2
 ((
uint32_t
)0x04000000)

	)

3970 #define 
	#FSMC_PMEM2_MEMHIZ2_3
 ((
uint32_t
)0x08000000)

	)

3971 #define 
	#FSMC_PMEM2_MEMHIZ2_4
 ((
uint32_t
)0x10000000)

	)

3972 #define 
	#FSMC_PMEM2_MEMHIZ2_5
 ((
uint32_t
)0x20000000)

	)

3973 #define 
	#FSMC_PMEM2_MEMHIZ2_6
 ((
uint32_t
)0x40000000)

	)

3974 #define 
	#FSMC_PMEM2_MEMHIZ2_7
 ((
uint32_t
)0x80000000)

	)

3977 #define 
	#FSMC_PMEM3_MEMSET3
 ((
uint32_t
)0x000000FF)

	)

3978 #define 
	#FSMC_PMEM3_MEMSET3_0
 ((
uint32_t
)0x00000001)

	)

3979 #define 
	#FSMC_PMEM3_MEMSET3_1
 ((
uint32_t
)0x00000002)

	)

3980 #define 
	#FSMC_PMEM3_MEMSET3_2
 ((
uint32_t
)0x00000004)

	)

3981 #define 
	#FSMC_PMEM3_MEMSET3_3
 ((
uint32_t
)0x00000008)

	)

3982 #define 
	#FSMC_PMEM3_MEMSET3_4
 ((
uint32_t
)0x00000010)

	)

3983 #define 
	#FSMC_PMEM3_MEMSET3_5
 ((
uint32_t
)0x00000020)

	)

3984 #define 
	#FSMC_PMEM3_MEMSET3_6
 ((
uint32_t
)0x00000040)

	)

3985 #define 
	#FSMC_PMEM3_MEMSET3_7
 ((
uint32_t
)0x00000080)

	)

3987 #define 
	#FSMC_PMEM3_MEMWAIT3
 ((
uint32_t
)0x0000FF00)

	)

3988 #define 
	#FSMC_PMEM3_MEMWAIT3_0
 ((
uint32_t
)0x00000100)

	)

3989 #define 
	#FSMC_PMEM3_MEMWAIT3_1
 ((
uint32_t
)0x00000200)

	)

3990 #define 
	#FSMC_PMEM3_MEMWAIT3_2
 ((
uint32_t
)0x00000400)

	)

3991 #define 
	#FSMC_PMEM3_MEMWAIT3_3
 ((
uint32_t
)0x00000800)

	)

3992 #define 
	#FSMC_PMEM3_MEMWAIT3_4
 ((
uint32_t
)0x00001000)

	)

3993 #define 
	#FSMC_PMEM3_MEMWAIT3_5
 ((
uint32_t
)0x00002000)

	)

3994 #define 
	#FSMC_PMEM3_MEMWAIT3_6
 ((
uint32_t
)0x00004000)

	)

3995 #define 
	#FSMC_PMEM3_MEMWAIT3_7
 ((
uint32_t
)0x00008000)

	)

3997 #define 
	#FSMC_PMEM3_MEMHOLD3
 ((
uint32_t
)0x00FF0000)

	)

3998 #define 
	#FSMC_PMEM3_MEMHOLD3_0
 ((
uint32_t
)0x00010000)

	)

3999 #define 
	#FSMC_PMEM3_MEMHOLD3_1
 ((
uint32_t
)0x00020000)

	)

4000 #define 
	#FSMC_PMEM3_MEMHOLD3_2
 ((
uint32_t
)0x00040000)

	)

4001 #define 
	#FSMC_PMEM3_MEMHOLD3_3
 ((
uint32_t
)0x00080000)

	)

4002 #define 
	#FSMC_PMEM3_MEMHOLD3_4
 ((
uint32_t
)0x00100000)

	)

4003 #define 
	#FSMC_PMEM3_MEMHOLD3_5
 ((
uint32_t
)0x00200000)

	)

4004 #define 
	#FSMC_PMEM3_MEMHOLD3_6
 ((
uint32_t
)0x00400000)

	)

4005 #define 
	#FSMC_PMEM3_MEMHOLD3_7
 ((
uint32_t
)0x00800000)

	)

4007 #define 
	#FSMC_PMEM3_MEMHIZ3
 ((
uint32_t
)0xFF000000)

	)

4008 #define 
	#FSMC_PMEM3_MEMHIZ3_0
 ((
uint32_t
)0x01000000)

	)

4009 #define 
	#FSMC_PMEM3_MEMHIZ3_1
 ((
uint32_t
)0x02000000)

	)

4010 #define 
	#FSMC_PMEM3_MEMHIZ3_2
 ((
uint32_t
)0x04000000)

	)

4011 #define 
	#FSMC_PMEM3_MEMHIZ3_3
 ((
uint32_t
)0x08000000)

	)

4012 #define 
	#FSMC_PMEM3_MEMHIZ3_4
 ((
uint32_t
)0x10000000)

	)

4013 #define 
	#FSMC_PMEM3_MEMHIZ3_5
 ((
uint32_t
)0x20000000)

	)

4014 #define 
	#FSMC_PMEM3_MEMHIZ3_6
 ((
uint32_t
)0x40000000)

	)

4015 #define 
	#FSMC_PMEM3_MEMHIZ3_7
 ((
uint32_t
)0x80000000)

	)

4018 #define 
	#FSMC_PMEM4_MEMSET4
 ((
uint32_t
)0x000000FF)

	)

4019 #define 
	#FSMC_PMEM4_MEMSET4_0
 ((
uint32_t
)0x00000001)

	)

4020 #define 
	#FSMC_PMEM4_MEMSET4_1
 ((
uint32_t
)0x00000002)

	)

4021 #define 
	#FSMC_PMEM4_MEMSET4_2
 ((
uint32_t
)0x00000004)

	)

4022 #define 
	#FSMC_PMEM4_MEMSET4_3
 ((
uint32_t
)0x00000008)

	)

4023 #define 
	#FSMC_PMEM4_MEMSET4_4
 ((
uint32_t
)0x00000010)

	)

4024 #define 
	#FSMC_PMEM4_MEMSET4_5
 ((
uint32_t
)0x00000020)

	)

4025 #define 
	#FSMC_PMEM4_MEMSET4_6
 ((
uint32_t
)0x00000040)

	)

4026 #define 
	#FSMC_PMEM4_MEMSET4_7
 ((
uint32_t
)0x00000080)

	)

4028 #define 
	#FSMC_PMEM4_MEMWAIT4
 ((
uint32_t
)0x0000FF00)

	)

4029 #define 
	#FSMC_PMEM4_MEMWAIT4_0
 ((
uint32_t
)0x00000100)

	)

4030 #define 
	#FSMC_PMEM4_MEMWAIT4_1
 ((
uint32_t
)0x00000200)

	)

4031 #define 
	#FSMC_PMEM4_MEMWAIT4_2
 ((
uint32_t
)0x00000400)

	)

4032 #define 
	#FSMC_PMEM4_MEMWAIT4_3
 ((
uint32_t
)0x00000800)

	)

4033 #define 
	#FSMC_PMEM4_MEMWAIT4_4
 ((
uint32_t
)0x00001000)

	)

4034 #define 
	#FSMC_PMEM4_MEMWAIT4_5
 ((
uint32_t
)0x00002000)

	)

4035 #define 
	#FSMC_PMEM4_MEMWAIT4_6
 ((
uint32_t
)0x00004000)

	)

4036 #define 
	#FSMC_PMEM4_MEMWAIT4_7
 ((
uint32_t
)0x00008000)

	)

4038 #define 
	#FSMC_PMEM4_MEMHOLD4
 ((
uint32_t
)0x00FF0000)

	)

4039 #define 
	#FSMC_PMEM4_MEMHOLD4_0
 ((
uint32_t
)0x00010000)

	)

4040 #define 
	#FSMC_PMEM4_MEMHOLD4_1
 ((
uint32_t
)0x00020000)

	)

4041 #define 
	#FSMC_PMEM4_MEMHOLD4_2
 ((
uint32_t
)0x00040000)

	)

4042 #define 
	#FSMC_PMEM4_MEMHOLD4_3
 ((
uint32_t
)0x00080000)

	)

4043 #define 
	#FSMC_PMEM4_MEMHOLD4_4
 ((
uint32_t
)0x00100000)

	)

4044 #define 
	#FSMC_PMEM4_MEMHOLD4_5
 ((
uint32_t
)0x00200000)

	)

4045 #define 
	#FSMC_PMEM4_MEMHOLD4_6
 ((
uint32_t
)0x00400000)

	)

4046 #define 
	#FSMC_PMEM4_MEMHOLD4_7
 ((
uint32_t
)0x00800000)

	)

4048 #define 
	#FSMC_PMEM4_MEMHIZ4
 ((
uint32_t
)0xFF000000)

	)

4049 #define 
	#FSMC_PMEM4_MEMHIZ4_0
 ((
uint32_t
)0x01000000)

	)

4050 #define 
	#FSMC_PMEM4_MEMHIZ4_1
 ((
uint32_t
)0x02000000)

	)

4051 #define 
	#FSMC_PMEM4_MEMHIZ4_2
 ((
uint32_t
)0x04000000)

	)

4052 #define 
	#FSMC_PMEM4_MEMHIZ4_3
 ((
uint32_t
)0x08000000)

	)

4053 #define 
	#FSMC_PMEM4_MEMHIZ4_4
 ((
uint32_t
)0x10000000)

	)

4054 #define 
	#FSMC_PMEM4_MEMHIZ4_5
 ((
uint32_t
)0x20000000)

	)

4055 #define 
	#FSMC_PMEM4_MEMHIZ4_6
 ((
uint32_t
)0x40000000)

	)

4056 #define 
	#FSMC_PMEM4_MEMHIZ4_7
 ((
uint32_t
)0x80000000)

	)

4059 #define 
	#FSMC_PATT2_ATTSET2
 ((
uint32_t
)0x000000FF)

	)

4060 #define 
	#FSMC_PATT2_ATTSET2_0
 ((
uint32_t
)0x00000001)

	)

4061 #define 
	#FSMC_PATT2_ATTSET2_1
 ((
uint32_t
)0x00000002)

	)

4062 #define 
	#FSMC_PATT2_ATTSET2_2
 ((
uint32_t
)0x00000004)

	)

4063 #define 
	#FSMC_PATT2_ATTSET2_3
 ((
uint32_t
)0x00000008)

	)

4064 #define 
	#FSMC_PATT2_ATTSET2_4
 ((
uint32_t
)0x00000010)

	)

4065 #define 
	#FSMC_PATT2_ATTSET2_5
 ((
uint32_t
)0x00000020)

	)

4066 #define 
	#FSMC_PATT2_ATTSET2_6
 ((
uint32_t
)0x00000040)

	)

4067 #define 
	#FSMC_PATT2_ATTSET2_7
 ((
uint32_t
)0x00000080)

	)

4069 #define 
	#FSMC_PATT2_ATTWAIT2
 ((
uint32_t
)0x0000FF00)

	)

4070 #define 
	#FSMC_PATT2_ATTWAIT2_0
 ((
uint32_t
)0x00000100)

	)

4071 #define 
	#FSMC_PATT2_ATTWAIT2_1
 ((
uint32_t
)0x00000200)

	)

4072 #define 
	#FSMC_PATT2_ATTWAIT2_2
 ((
uint32_t
)0x00000400)

	)

4073 #define 
	#FSMC_PATT2_ATTWAIT2_3
 ((
uint32_t
)0x00000800)

	)

4074 #define 
	#FSMC_PATT2_ATTWAIT2_4
 ((
uint32_t
)0x00001000)

	)

4075 #define 
	#FSMC_PATT2_ATTWAIT2_5
 ((
uint32_t
)0x00002000)

	)

4076 #define 
	#FSMC_PATT2_ATTWAIT2_6
 ((
uint32_t
)0x00004000)

	)

4077 #define 
	#FSMC_PATT2_ATTWAIT2_7
 ((
uint32_t
)0x00008000)

	)

4079 #define 
	#FSMC_PATT2_ATTHOLD2
 ((
uint32_t
)0x00FF0000)

	)

4080 #define 
	#FSMC_PATT2_ATTHOLD2_0
 ((
uint32_t
)0x00010000)

	)

4081 #define 
	#FSMC_PATT2_ATTHOLD2_1
 ((
uint32_t
)0x00020000)

	)

4082 #define 
	#FSMC_PATT2_ATTHOLD2_2
 ((
uint32_t
)0x00040000)

	)

4083 #define 
	#FSMC_PATT2_ATTHOLD2_3
 ((
uint32_t
)0x00080000)

	)

4084 #define 
	#FSMC_PATT2_ATTHOLD2_4
 ((
uint32_t
)0x00100000)

	)

4085 #define 
	#FSMC_PATT2_ATTHOLD2_5
 ((
uint32_t
)0x00200000)

	)

4086 #define 
	#FSMC_PATT2_ATTHOLD2_6
 ((
uint32_t
)0x00400000)

	)

4087 #define 
	#FSMC_PATT2_ATTHOLD2_7
 ((
uint32_t
)0x00800000)

	)

4089 #define 
	#FSMC_PATT2_ATTHIZ2
 ((
uint32_t
)0xFF000000)

	)

4090 #define 
	#FSMC_PATT2_ATTHIZ2_0
 ((
uint32_t
)0x01000000)

	)

4091 #define 
	#FSMC_PATT2_ATTHIZ2_1
 ((
uint32_t
)0x02000000)

	)

4092 #define 
	#FSMC_PATT2_ATTHIZ2_2
 ((
uint32_t
)0x04000000)

	)

4093 #define 
	#FSMC_PATT2_ATTHIZ2_3
 ((
uint32_t
)0x08000000)

	)

4094 #define 
	#FSMC_PATT2_ATTHIZ2_4
 ((
uint32_t
)0x10000000)

	)

4095 #define 
	#FSMC_PATT2_ATTHIZ2_5
 ((
uint32_t
)0x20000000)

	)

4096 #define 
	#FSMC_PATT2_ATTHIZ2_6
 ((
uint32_t
)0x40000000)

	)

4097 #define 
	#FSMC_PATT2_ATTHIZ2_7
 ((
uint32_t
)0x80000000)

	)

4100 #define 
	#FSMC_PATT3_ATTSET3
 ((
uint32_t
)0x000000FF)

	)

4101 #define 
	#FSMC_PATT3_ATTSET3_0
 ((
uint32_t
)0x00000001)

	)

4102 #define 
	#FSMC_PATT3_ATTSET3_1
 ((
uint32_t
)0x00000002)

	)

4103 #define 
	#FSMC_PATT3_ATTSET3_2
 ((
uint32_t
)0x00000004)

	)

4104 #define 
	#FSMC_PATT3_ATTSET3_3
 ((
uint32_t
)0x00000008)

	)

4105 #define 
	#FSMC_PATT3_ATTSET3_4
 ((
uint32_t
)0x00000010)

	)

4106 #define 
	#FSMC_PATT3_ATTSET3_5
 ((
uint32_t
)0x00000020)

	)

4107 #define 
	#FSMC_PATT3_ATTSET3_6
 ((
uint32_t
)0x00000040)

	)

4108 #define 
	#FSMC_PATT3_ATTSET3_7
 ((
uint32_t
)0x00000080)

	)

4110 #define 
	#FSMC_PATT3_ATTWAIT3
 ((
uint32_t
)0x0000FF00)

	)

4111 #define 
	#FSMC_PATT3_ATTWAIT3_0
 ((
uint32_t
)0x00000100)

	)

4112 #define 
	#FSMC_PATT3_ATTWAIT3_1
 ((
uint32_t
)0x00000200)

	)

4113 #define 
	#FSMC_PATT3_ATTWAIT3_2
 ((
uint32_t
)0x00000400)

	)

4114 #define 
	#FSMC_PATT3_ATTWAIT3_3
 ((
uint32_t
)0x00000800)

	)

4115 #define 
	#FSMC_PATT3_ATTWAIT3_4
 ((
uint32_t
)0x00001000)

	)

4116 #define 
	#FSMC_PATT3_ATTWAIT3_5
 ((
uint32_t
)0x00002000)

	)

4117 #define 
	#FSMC_PATT3_ATTWAIT3_6
 ((
uint32_t
)0x00004000)

	)

4118 #define 
	#FSMC_PATT3_ATTWAIT3_7
 ((
uint32_t
)0x00008000)

	)

4120 #define 
	#FSMC_PATT3_ATTHOLD3
 ((
uint32_t
)0x00FF0000)

	)

4121 #define 
	#FSMC_PATT3_ATTHOLD3_0
 ((
uint32_t
)0x00010000)

	)

4122 #define 
	#FSMC_PATT3_ATTHOLD3_1
 ((
uint32_t
)0x00020000)

	)

4123 #define 
	#FSMC_PATT3_ATTHOLD3_2
 ((
uint32_t
)0x00040000)

	)

4124 #define 
	#FSMC_PATT3_ATTHOLD3_3
 ((
uint32_t
)0x00080000)

	)

4125 #define 
	#FSMC_PATT3_ATTHOLD3_4
 ((
uint32_t
)0x00100000)

	)

4126 #define 
	#FSMC_PATT3_ATTHOLD3_5
 ((
uint32_t
)0x00200000)

	)

4127 #define 
	#FSMC_PATT3_ATTHOLD3_6
 ((
uint32_t
)0x00400000)

	)

4128 #define 
	#FSMC_PATT3_ATTHOLD3_7
 ((
uint32_t
)0x00800000)

	)

4130 #define 
	#FSMC_PATT3_ATTHIZ3
 ((
uint32_t
)0xFF000000)

	)

4131 #define 
	#FSMC_PATT3_ATTHIZ3_0
 ((
uint32_t
)0x01000000)

	)

4132 #define 
	#FSMC_PATT3_ATTHIZ3_1
 ((
uint32_t
)0x02000000)

	)

4133 #define 
	#FSMC_PATT3_ATTHIZ3_2
 ((
uint32_t
)0x04000000)

	)

4134 #define 
	#FSMC_PATT3_ATTHIZ3_3
 ((
uint32_t
)0x08000000)

	)

4135 #define 
	#FSMC_PATT3_ATTHIZ3_4
 ((
uint32_t
)0x10000000)

	)

4136 #define 
	#FSMC_PATT3_ATTHIZ3_5
 ((
uint32_t
)0x20000000)

	)

4137 #define 
	#FSMC_PATT3_ATTHIZ3_6
 ((
uint32_t
)0x40000000)

	)

4138 #define 
	#FSMC_PATT3_ATTHIZ3_7
 ((
uint32_t
)0x80000000)

	)

4141 #define 
	#FSMC_PATT4_ATTSET4
 ((
uint32_t
)0x000000FF)

	)

4142 #define 
	#FSMC_PATT4_ATTSET4_0
 ((
uint32_t
)0x00000001)

	)

4143 #define 
	#FSMC_PATT4_ATTSET4_1
 ((
uint32_t
)0x00000002)

	)

4144 #define 
	#FSMC_PATT4_ATTSET4_2
 ((
uint32_t
)0x00000004)

	)

4145 #define 
	#FSMC_PATT4_ATTSET4_3
 ((
uint32_t
)0x00000008)

	)

4146 #define 
	#FSMC_PATT4_ATTSET4_4
 ((
uint32_t
)0x00000010)

	)

4147 #define 
	#FSMC_PATT4_ATTSET4_5
 ((
uint32_t
)0x00000020)

	)

4148 #define 
	#FSMC_PATT4_ATTSET4_6
 ((
uint32_t
)0x00000040)

	)

4149 #define 
	#FSMC_PATT4_ATTSET4_7
 ((
uint32_t
)0x00000080)

	)

4151 #define 
	#FSMC_PATT4_ATTWAIT4
 ((
uint32_t
)0x0000FF00)

	)

4152 #define 
	#FSMC_PATT4_ATTWAIT4_0
 ((
uint32_t
)0x00000100)

	)

4153 #define 
	#FSMC_PATT4_ATTWAIT4_1
 ((
uint32_t
)0x00000200)

	)

4154 #define 
	#FSMC_PATT4_ATTWAIT4_2
 ((
uint32_t
)0x00000400)

	)

4155 #define 
	#FSMC_PATT4_ATTWAIT4_3
 ((
uint32_t
)0x00000800)

	)

4156 #define 
	#FSMC_PATT4_ATTWAIT4_4
 ((
uint32_t
)0x00001000)

	)

4157 #define 
	#FSMC_PATT4_ATTWAIT4_5
 ((
uint32_t
)0x00002000)

	)

4158 #define 
	#FSMC_PATT4_ATTWAIT4_6
 ((
uint32_t
)0x00004000)

	)

4159 #define 
	#FSMC_PATT4_ATTWAIT4_7
 ((
uint32_t
)0x00008000)

	)

4161 #define 
	#FSMC_PATT4_ATTHOLD4
 ((
uint32_t
)0x00FF0000)

	)

4162 #define 
	#FSMC_PATT4_ATTHOLD4_0
 ((
uint32_t
)0x00010000)

	)

4163 #define 
	#FSMC_PATT4_ATTHOLD4_1
 ((
uint32_t
)0x00020000)

	)

4164 #define 
	#FSMC_PATT4_ATTHOLD4_2
 ((
uint32_t
)0x00040000)

	)

4165 #define 
	#FSMC_PATT4_ATTHOLD4_3
 ((
uint32_t
)0x00080000)

	)

4166 #define 
	#FSMC_PATT4_ATTHOLD4_4
 ((
uint32_t
)0x00100000)

	)

4167 #define 
	#FSMC_PATT4_ATTHOLD4_5
 ((
uint32_t
)0x00200000)

	)

4168 #define 
	#FSMC_PATT4_ATTHOLD4_6
 ((
uint32_t
)0x00400000)

	)

4169 #define 
	#FSMC_PATT4_ATTHOLD4_7
 ((
uint32_t
)0x00800000)

	)

4171 #define 
	#FSMC_PATT4_ATTHIZ4
 ((
uint32_t
)0xFF000000)

	)

4172 #define 
	#FSMC_PATT4_ATTHIZ4_0
 ((
uint32_t
)0x01000000)

	)

4173 #define 
	#FSMC_PATT4_ATTHIZ4_1
 ((
uint32_t
)0x02000000)

	)

4174 #define 
	#FSMC_PATT4_ATTHIZ4_2
 ((
uint32_t
)0x04000000)

	)

4175 #define 
	#FSMC_PATT4_ATTHIZ4_3
 ((
uint32_t
)0x08000000)

	)

4176 #define 
	#FSMC_PATT4_ATTHIZ4_4
 ((
uint32_t
)0x10000000)

	)

4177 #define 
	#FSMC_PATT4_ATTHIZ4_5
 ((
uint32_t
)0x20000000)

	)

4178 #define 
	#FSMC_PATT4_ATTHIZ4_6
 ((
uint32_t
)0x40000000)

	)

4179 #define 
	#FSMC_PATT4_ATTHIZ4_7
 ((
uint32_t
)0x80000000)

	)

4182 #define 
	#FSMC_PIO4_IOSET4
 ((
uint32_t
)0x000000FF)

	)

4183 #define 
	#FSMC_PIO4_IOSET4_0
 ((
uint32_t
)0x00000001)

	)

4184 #define 
	#FSMC_PIO4_IOSET4_1
 ((
uint32_t
)0x00000002)

	)

4185 #define 
	#FSMC_PIO4_IOSET4_2
 ((
uint32_t
)0x00000004)

	)

4186 #define 
	#FSMC_PIO4_IOSET4_3
 ((
uint32_t
)0x00000008)

	)

4187 #define 
	#FSMC_PIO4_IOSET4_4
 ((
uint32_t
)0x00000010)

	)

4188 #define 
	#FSMC_PIO4_IOSET4_5
 ((
uint32_t
)0x00000020)

	)

4189 #define 
	#FSMC_PIO4_IOSET4_6
 ((
uint32_t
)0x00000040)

	)

4190 #define 
	#FSMC_PIO4_IOSET4_7
 ((
uint32_t
)0x00000080)

	)

4192 #define 
	#FSMC_PIO4_IOWAIT4
 ((
uint32_t
)0x0000FF00)

	)

4193 #define 
	#FSMC_PIO4_IOWAIT4_0
 ((
uint32_t
)0x00000100)

	)

4194 #define 
	#FSMC_PIO4_IOWAIT4_1
 ((
uint32_t
)0x00000200)

	)

4195 #define 
	#FSMC_PIO4_IOWAIT4_2
 ((
uint32_t
)0x00000400)

	)

4196 #define 
	#FSMC_PIO4_IOWAIT4_3
 ((
uint32_t
)0x00000800)

	)

4197 #define 
	#FSMC_PIO4_IOWAIT4_4
 ((
uint32_t
)0x00001000)

	)

4198 #define 
	#FSMC_PIO4_IOWAIT4_5
 ((
uint32_t
)0x00002000)

	)

4199 #define 
	#FSMC_PIO4_IOWAIT4_6
 ((
uint32_t
)0x00004000)

	)

4200 #define 
	#FSMC_PIO4_IOWAIT4_7
 ((
uint32_t
)0x00008000)

	)

4202 #define 
	#FSMC_PIO4_IOHOLD4
 ((
uint32_t
)0x00FF0000)

	)

4203 #define 
	#FSMC_PIO4_IOHOLD4_0
 ((
uint32_t
)0x00010000)

	)

4204 #define 
	#FSMC_PIO4_IOHOLD4_1
 ((
uint32_t
)0x00020000)

	)

4205 #define 
	#FSMC_PIO4_IOHOLD4_2
 ((
uint32_t
)0x00040000)

	)

4206 #define 
	#FSMC_PIO4_IOHOLD4_3
 ((
uint32_t
)0x00080000)

	)

4207 #define 
	#FSMC_PIO4_IOHOLD4_4
 ((
uint32_t
)0x00100000)

	)

4208 #define 
	#FSMC_PIO4_IOHOLD4_5
 ((
uint32_t
)0x00200000)

	)

4209 #define 
	#FSMC_PIO4_IOHOLD4_6
 ((
uint32_t
)0x00400000)

	)

4210 #define 
	#FSMC_PIO4_IOHOLD4_7
 ((
uint32_t
)0x00800000)

	)

4212 #define 
	#FSMC_PIO4_IOHIZ4
 ((
uint32_t
)0xFF000000)

	)

4213 #define 
	#FSMC_PIO4_IOHIZ4_0
 ((
uint32_t
)0x01000000)

	)

4214 #define 
	#FSMC_PIO4_IOHIZ4_1
 ((
uint32_t
)0x02000000)

	)

4215 #define 
	#FSMC_PIO4_IOHIZ4_2
 ((
uint32_t
)0x04000000)

	)

4216 #define 
	#FSMC_PIO4_IOHIZ4_3
 ((
uint32_t
)0x08000000)

	)

4217 #define 
	#FSMC_PIO4_IOHIZ4_4
 ((
uint32_t
)0x10000000)

	)

4218 #define 
	#FSMC_PIO4_IOHIZ4_5
 ((
uint32_t
)0x20000000)

	)

4219 #define 
	#FSMC_PIO4_IOHIZ4_6
 ((
uint32_t
)0x40000000)

	)

4220 #define 
	#FSMC_PIO4_IOHIZ4_7
 ((
uint32_t
)0x80000000)

	)

4223 #define 
	#FSMC_ECCR2_ECC2
 ((
uint32_t
)0xFFFFFFFF)

	)

4226 #define 
	#FSMC_ECCR3_ECC3
 ((
uint32_t
)0xFFFFFFFF)

	)

4234 #define 
	#GPIO_MODER_MODER0
 ((
uint32_t
)0x00000003)

	)

4235 #define 
	#GPIO_MODER_MODER0_0
 ((
uint32_t
)0x00000001)

	)

4236 #define 
	#GPIO_MODER_MODER0_1
 ((
uint32_t
)0x00000002)

	)

4238 #define 
	#GPIO_MODER_MODER1
 ((
uint32_t
)0x0000000C)

	)

4239 #define 
	#GPIO_MODER_MODER1_0
 ((
uint32_t
)0x00000004)

	)

4240 #define 
	#GPIO_MODER_MODER1_1
 ((
uint32_t
)0x00000008)

	)

4242 #define 
	#GPIO_MODER_MODER2
 ((
uint32_t
)0x00000030)

	)

4243 #define 
	#GPIO_MODER_MODER2_0
 ((
uint32_t
)0x00000010)

	)

4244 #define 
	#GPIO_MODER_MODER2_1
 ((
uint32_t
)0x00000020)

	)

4246 #define 
	#GPIO_MODER_MODER3
 ((
uint32_t
)0x000000C0)

	)

4247 #define 
	#GPIO_MODER_MODER3_0
 ((
uint32_t
)0x00000040)

	)

4248 #define 
	#GPIO_MODER_MODER3_1
 ((
uint32_t
)0x00000080)

	)

4250 #define 
	#GPIO_MODER_MODER4
 ((
uint32_t
)0x00000300)

	)

4251 #define 
	#GPIO_MODER_MODER4_0
 ((
uint32_t
)0x00000100)

	)

4252 #define 
	#GPIO_MODER_MODER4_1
 ((
uint32_t
)0x00000200)

	)

4254 #define 
	#GPIO_MODER_MODER5
 ((
uint32_t
)0x00000C00)

	)

4255 #define 
	#GPIO_MODER_MODER5_0
 ((
uint32_t
)0x00000400)

	)

4256 #define 
	#GPIO_MODER_MODER5_1
 ((
uint32_t
)0x00000800)

	)

4258 #define 
	#GPIO_MODER_MODER6
 ((
uint32_t
)0x00003000)

	)

4259 #define 
	#GPIO_MODER_MODER6_0
 ((
uint32_t
)0x00001000)

	)

4260 #define 
	#GPIO_MODER_MODER6_1
 ((
uint32_t
)0x00002000)

	)

4262 #define 
	#GPIO_MODER_MODER7
 ((
uint32_t
)0x0000C000)

	)

4263 #define 
	#GPIO_MODER_MODER7_0
 ((
uint32_t
)0x00004000)

	)

4264 #define 
	#GPIO_MODER_MODER7_1
 ((
uint32_t
)0x00008000)

	)

4266 #define 
	#GPIO_MODER_MODER8
 ((
uint32_t
)0x00030000)

	)

4267 #define 
	#GPIO_MODER_MODER8_0
 ((
uint32_t
)0x00010000)

	)

4268 #define 
	#GPIO_MODER_MODER8_1
 ((
uint32_t
)0x00020000)

	)

4270 #define 
	#GPIO_MODER_MODER9
 ((
uint32_t
)0x000C0000)

	)

4271 #define 
	#GPIO_MODER_MODER9_0
 ((
uint32_t
)0x00040000)

	)

4272 #define 
	#GPIO_MODER_MODER9_1
 ((
uint32_t
)0x00080000)

	)

4274 #define 
	#GPIO_MODER_MODER10
 ((
uint32_t
)0x00300000)

	)

4275 #define 
	#GPIO_MODER_MODER10_0
 ((
uint32_t
)0x00100000)

	)

4276 #define 
	#GPIO_MODER_MODER10_1
 ((
uint32_t
)0x00200000)

	)

4278 #define 
	#GPIO_MODER_MODER11
 ((
uint32_t
)0x00C00000)

	)

4279 #define 
	#GPIO_MODER_MODER11_0
 ((
uint32_t
)0x00400000)

	)

4280 #define 
	#GPIO_MODER_MODER11_1
 ((
uint32_t
)0x00800000)

	)

4282 #define 
	#GPIO_MODER_MODER12
 ((
uint32_t
)0x03000000)

	)

4283 #define 
	#GPIO_MODER_MODER12_0
 ((
uint32_t
)0x01000000)

	)

4284 #define 
	#GPIO_MODER_MODER12_1
 ((
uint32_t
)0x02000000)

	)

4286 #define 
	#GPIO_MODER_MODER13
 ((
uint32_t
)0x0C000000)

	)

4287 #define 
	#GPIO_MODER_MODER13_0
 ((
uint32_t
)0x04000000)

	)

4288 #define 
	#GPIO_MODER_MODER13_1
 ((
uint32_t
)0x08000000)

	)

4290 #define 
	#GPIO_MODER_MODER14
 ((
uint32_t
)0x30000000)

	)

4291 #define 
	#GPIO_MODER_MODER14_0
 ((
uint32_t
)0x10000000)

	)

4292 #define 
	#GPIO_MODER_MODER14_1
 ((
uint32_t
)0x20000000)

	)

4294 #define 
	#GPIO_MODER_MODER15
 ((
uint32_t
)0xC0000000)

	)

4295 #define 
	#GPIO_MODER_MODER15_0
 ((
uint32_t
)0x40000000)

	)

4296 #define 
	#GPIO_MODER_MODER15_1
 ((
uint32_t
)0x80000000)

	)

4299 #define 
	#GPIO_OTYPER_OT_0
 ((
uint32_t
)0x00000001)

	)

4300 #define 
	#GPIO_OTYPER_OT_1
 ((
uint32_t
)0x00000002)

	)

4301 #define 
	#GPIO_OTYPER_OT_2
 ((
uint32_t
)0x00000004)

	)

4302 #define 
	#GPIO_OTYPER_OT_3
 ((
uint32_t
)0x00000008)

	)

4303 #define 
	#GPIO_OTYPER_OT_4
 ((
uint32_t
)0x00000010)

	)

4304 #define 
	#GPIO_OTYPER_OT_5
 ((
uint32_t
)0x00000020)

	)

4305 #define 
	#GPIO_OTYPER_OT_6
 ((
uint32_t
)0x00000040)

	)

4306 #define 
	#GPIO_OTYPER_OT_7
 ((
uint32_t
)0x00000080)

	)

4307 #define 
	#GPIO_OTYPER_OT_8
 ((
uint32_t
)0x00000100)

	)

4308 #define 
	#GPIO_OTYPER_OT_9
 ((
uint32_t
)0x00000200)

	)

4309 #define 
	#GPIO_OTYPER_OT_10
 ((
uint32_t
)0x00000400)

	)

4310 #define 
	#GPIO_OTYPER_OT_11
 ((
uint32_t
)0x00000800)

	)

4311 #define 
	#GPIO_OTYPER_OT_12
 ((
uint32_t
)0x00001000)

	)

4312 #define 
	#GPIO_OTYPER_OT_13
 ((
uint32_t
)0x00002000)

	)

4313 #define 
	#GPIO_OTYPER_OT_14
 ((
uint32_t
)0x00004000)

	)

4314 #define 
	#GPIO_OTYPER_OT_15
 ((
uint32_t
)0x00008000)

	)

4317 #define 
	#GPIO_OSPEEDER_OSPEEDR0
 ((
uint32_t
)0x00000003)

	)

4318 #define 
	#GPIO_OSPEEDER_OSPEEDR0_0
 ((
uint32_t
)0x00000001)

	)

4319 #define 
	#GPIO_OSPEEDER_OSPEEDR0_1
 ((
uint32_t
)0x00000002)

	)

4321 #define 
	#GPIO_OSPEEDER_OSPEEDR1
 ((
uint32_t
)0x0000000C)

	)

4322 #define 
	#GPIO_OSPEEDER_OSPEEDR1_0
 ((
uint32_t
)0x00000004)

	)

4323 #define 
	#GPIO_OSPEEDER_OSPEEDR1_1
 ((
uint32_t
)0x00000008)

	)

4325 #define 
	#GPIO_OSPEEDER_OSPEEDR2
 ((
uint32_t
)0x00000030)

	)

4326 #define 
	#GPIO_OSPEEDER_OSPEEDR2_0
 ((
uint32_t
)0x00000010)

	)

4327 #define 
	#GPIO_OSPEEDER_OSPEEDR2_1
 ((
uint32_t
)0x00000020)

	)

4329 #define 
	#GPIO_OSPEEDER_OSPEEDR3
 ((
uint32_t
)0x000000C0)

	)

4330 #define 
	#GPIO_OSPEEDER_OSPEEDR3_0
 ((
uint32_t
)0x00000040)

	)

4331 #define 
	#GPIO_OSPEEDER_OSPEEDR3_1
 ((
uint32_t
)0x00000080)

	)

4333 #define 
	#GPIO_OSPEEDER_OSPEEDR4
 ((
uint32_t
)0x00000300)

	)

4334 #define 
	#GPIO_OSPEEDER_OSPEEDR4_0
 ((
uint32_t
)0x00000100)

	)

4335 #define 
	#GPIO_OSPEEDER_OSPEEDR4_1
 ((
uint32_t
)0x00000200)

	)

4337 #define 
	#GPIO_OSPEEDER_OSPEEDR5
 ((
uint32_t
)0x00000C00)

	)

4338 #define 
	#GPIO_OSPEEDER_OSPEEDR5_0
 ((
uint32_t
)0x00000400)

	)

4339 #define 
	#GPIO_OSPEEDER_OSPEEDR5_1
 ((
uint32_t
)0x00000800)

	)

4341 #define 
	#GPIO_OSPEEDER_OSPEEDR6
 ((
uint32_t
)0x00003000)

	)

4342 #define 
	#GPIO_OSPEEDER_OSPEEDR6_0
 ((
uint32_t
)0x00001000)

	)

4343 #define 
	#GPIO_OSPEEDER_OSPEEDR6_1
 ((
uint32_t
)0x00002000)

	)

4345 #define 
	#GPIO_OSPEEDER_OSPEEDR7
 ((
uint32_t
)0x0000C000)

	)

4346 #define 
	#GPIO_OSPEEDER_OSPEEDR7_0
 ((
uint32_t
)0x00004000)

	)

4347 #define 
	#GPIO_OSPEEDER_OSPEEDR7_1
 ((
uint32_t
)0x00008000)

	)

4349 #define 
	#GPIO_OSPEEDER_OSPEEDR8
 ((
uint32_t
)0x00030000)

	)

4350 #define 
	#GPIO_OSPEEDER_OSPEEDR8_0
 ((
uint32_t
)0x00010000)

	)

4351 #define 
	#GPIO_OSPEEDER_OSPEEDR8_1
 ((
uint32_t
)0x00020000)

	)

4353 #define 
	#GPIO_OSPEEDER_OSPEEDR9
 ((
uint32_t
)0x000C0000)

	)

4354 #define 
	#GPIO_OSPEEDER_OSPEEDR9_0
 ((
uint32_t
)0x00040000)

	)

4355 #define 
	#GPIO_OSPEEDER_OSPEEDR9_1
 ((
uint32_t
)0x00080000)

	)

4357 #define 
	#GPIO_OSPEEDER_OSPEEDR10
 ((
uint32_t
)0x00300000)

	)

4358 #define 
	#GPIO_OSPEEDER_OSPEEDR10_0
 ((
uint32_t
)0x00100000)

	)

4359 #define 
	#GPIO_OSPEEDER_OSPEEDR10_1
 ((
uint32_t
)0x00200000)

	)

4361 #define 
	#GPIO_OSPEEDER_OSPEEDR11
 ((
uint32_t
)0x00C00000)

	)

4362 #define 
	#GPIO_OSPEEDER_OSPEEDR11_0
 ((
uint32_t
)0x00400000)

	)

4363 #define 
	#GPIO_OSPEEDER_OSPEEDR11_1
 ((
uint32_t
)0x00800000)

	)

4365 #define 
	#GPIO_OSPEEDER_OSPEEDR12
 ((
uint32_t
)0x03000000)

	)

4366 #define 
	#GPIO_OSPEEDER_OSPEEDR12_0
 ((
uint32_t
)0x01000000)

	)

4367 #define 
	#GPIO_OSPEEDER_OSPEEDR12_1
 ((
uint32_t
)0x02000000)

	)

4369 #define 
	#GPIO_OSPEEDER_OSPEEDR13
 ((
uint32_t
)0x0C000000)

	)

4370 #define 
	#GPIO_OSPEEDER_OSPEEDR13_0
 ((
uint32_t
)0x04000000)

	)

4371 #define 
	#GPIO_OSPEEDER_OSPEEDR13_1
 ((
uint32_t
)0x08000000)

	)

4373 #define 
	#GPIO_OSPEEDER_OSPEEDR14
 ((
uint32_t
)0x30000000)

	)

4374 #define 
	#GPIO_OSPEEDER_OSPEEDR14_0
 ((
uint32_t
)0x10000000)

	)

4375 #define 
	#GPIO_OSPEEDER_OSPEEDR14_1
 ((
uint32_t
)0x20000000)

	)

4377 #define 
	#GPIO_OSPEEDER_OSPEEDR15
 ((
uint32_t
)0xC0000000)

	)

4378 #define 
	#GPIO_OSPEEDER_OSPEEDR15_0
 ((
uint32_t
)0x40000000)

	)

4379 #define 
	#GPIO_OSPEEDER_OSPEEDR15_1
 ((
uint32_t
)0x80000000)

	)

4382 #define 
	#GPIO_PUPDR_PUPDR0
 ((
uint32_t
)0x00000003)

	)

4383 #define 
	#GPIO_PUPDR_PUPDR0_0
 ((
uint32_t
)0x00000001)

	)

4384 #define 
	#GPIO_PUPDR_PUPDR0_1
 ((
uint32_t
)0x00000002)

	)

4386 #define 
	#GPIO_PUPDR_PUPDR1
 ((
uint32_t
)0x0000000C)

	)

4387 #define 
	#GPIO_PUPDR_PUPDR1_0
 ((
uint32_t
)0x00000004)

	)

4388 #define 
	#GPIO_PUPDR_PUPDR1_1
 ((
uint32_t
)0x00000008)

	)

4390 #define 
	#GPIO_PUPDR_PUPDR2
 ((
uint32_t
)0x00000030)

	)

4391 #define 
	#GPIO_PUPDR_PUPDR2_0
 ((
uint32_t
)0x00000010)

	)

4392 #define 
	#GPIO_PUPDR_PUPDR2_1
 ((
uint32_t
)0x00000020)

	)

4394 #define 
	#GPIO_PUPDR_PUPDR3
 ((
uint32_t
)0x000000C0)

	)

4395 #define 
	#GPIO_PUPDR_PUPDR3_0
 ((
uint32_t
)0x00000040)

	)

4396 #define 
	#GPIO_PUPDR_PUPDR3_1
 ((
uint32_t
)0x00000080)

	)

4398 #define 
	#GPIO_PUPDR_PUPDR4
 ((
uint32_t
)0x00000300)

	)

4399 #define 
	#GPIO_PUPDR_PUPDR4_0
 ((
uint32_t
)0x00000100)

	)

4400 #define 
	#GPIO_PUPDR_PUPDR4_1
 ((
uint32_t
)0x00000200)

	)

4402 #define 
	#GPIO_PUPDR_PUPDR5
 ((
uint32_t
)0x00000C00)

	)

4403 #define 
	#GPIO_PUPDR_PUPDR5_0
 ((
uint32_t
)0x00000400)

	)

4404 #define 
	#GPIO_PUPDR_PUPDR5_1
 ((
uint32_t
)0x00000800)

	)

4406 #define 
	#GPIO_PUPDR_PUPDR6
 ((
uint32_t
)0x00003000)

	)

4407 #define 
	#GPIO_PUPDR_PUPDR6_0
 ((
uint32_t
)0x00001000)

	)

4408 #define 
	#GPIO_PUPDR_PUPDR6_1
 ((
uint32_t
)0x00002000)

	)

4410 #define 
	#GPIO_PUPDR_PUPDR7
 ((
uint32_t
)0x0000C000)

	)

4411 #define 
	#GPIO_PUPDR_PUPDR7_0
 ((
uint32_t
)0x00004000)

	)

4412 #define 
	#GPIO_PUPDR_PUPDR7_1
 ((
uint32_t
)0x00008000)

	)

4414 #define 
	#GPIO_PUPDR_PUPDR8
 ((
uint32_t
)0x00030000)

	)

4415 #define 
	#GPIO_PUPDR_PUPDR8_0
 ((
uint32_t
)0x00010000)

	)

4416 #define 
	#GPIO_PUPDR_PUPDR8_1
 ((
uint32_t
)0x00020000)

	)

4418 #define 
	#GPIO_PUPDR_PUPDR9
 ((
uint32_t
)0x000C0000)

	)

4419 #define 
	#GPIO_PUPDR_PUPDR9_0
 ((
uint32_t
)0x00040000)

	)

4420 #define 
	#GPIO_PUPDR_PUPDR9_1
 ((
uint32_t
)0x00080000)

	)

4422 #define 
	#GPIO_PUPDR_PUPDR10
 ((
uint32_t
)0x00300000)

	)

4423 #define 
	#GPIO_PUPDR_PUPDR10_0
 ((
uint32_t
)0x00100000)

	)

4424 #define 
	#GPIO_PUPDR_PUPDR10_1
 ((
uint32_t
)0x00200000)

	)

4426 #define 
	#GPIO_PUPDR_PUPDR11
 ((
uint32_t
)0x00C00000)

	)

4427 #define 
	#GPIO_PUPDR_PUPDR11_0
 ((
uint32_t
)0x00400000)

	)

4428 #define 
	#GPIO_PUPDR_PUPDR11_1
 ((
uint32_t
)0x00800000)

	)

4430 #define 
	#GPIO_PUPDR_PUPDR12
 ((
uint32_t
)0x03000000)

	)

4431 #define 
	#GPIO_PUPDR_PUPDR12_0
 ((
uint32_t
)0x01000000)

	)

4432 #define 
	#GPIO_PUPDR_PUPDR12_1
 ((
uint32_t
)0x02000000)

	)

4434 #define 
	#GPIO_PUPDR_PUPDR13
 ((
uint32_t
)0x0C000000)

	)

4435 #define 
	#GPIO_PUPDR_PUPDR13_0
 ((
uint32_t
)0x04000000)

	)

4436 #define 
	#GPIO_PUPDR_PUPDR13_1
 ((
uint32_t
)0x08000000)

	)

4438 #define 
	#GPIO_PUPDR_PUPDR14
 ((
uint32_t
)0x30000000)

	)

4439 #define 
	#GPIO_PUPDR_PUPDR14_0
 ((
uint32_t
)0x10000000)

	)

4440 #define 
	#GPIO_PUPDR_PUPDR14_1
 ((
uint32_t
)0x20000000)

	)

4442 #define 
	#GPIO_PUPDR_PUPDR15
 ((
uint32_t
)0xC0000000)

	)

4443 #define 
	#GPIO_PUPDR_PUPDR15_0
 ((
uint32_t
)0x40000000)

	)

4444 #define 
	#GPIO_PUPDR_PUPDR15_1
 ((
uint32_t
)0x80000000)

	)

4447 #define 
	#GPIO_OTYPER_IDR_0
 ((
uint32_t
)0x00000001)

	)

4448 #define 
	#GPIO_OTYPER_IDR_1
 ((
uint32_t
)0x00000002)

	)

4449 #define 
	#GPIO_OTYPER_IDR_2
 ((
uint32_t
)0x00000004)

	)

4450 #define 
	#GPIO_OTYPER_IDR_3
 ((
uint32_t
)0x00000008)

	)

4451 #define 
	#GPIO_OTYPER_IDR_4
 ((
uint32_t
)0x00000010)

	)

4452 #define 
	#GPIO_OTYPER_IDR_5
 ((
uint32_t
)0x00000020)

	)

4453 #define 
	#GPIO_OTYPER_IDR_6
 ((
uint32_t
)0x00000040)

	)

4454 #define 
	#GPIO_OTYPER_IDR_7
 ((
uint32_t
)0x00000080)

	)

4455 #define 
	#GPIO_OTYPER_IDR_8
 ((
uint32_t
)0x00000100)

	)

4456 #define 
	#GPIO_OTYPER_IDR_9
 ((
uint32_t
)0x00000200)

	)

4457 #define 
	#GPIO_OTYPER_IDR_10
 ((
uint32_t
)0x00000400)

	)

4458 #define 
	#GPIO_OTYPER_IDR_11
 ((
uint32_t
)0x00000800)

	)

4459 #define 
	#GPIO_OTYPER_IDR_12
 ((
uint32_t
)0x00001000)

	)

4460 #define 
	#GPIO_OTYPER_IDR_13
 ((
uint32_t
)0x00002000)

	)

4461 #define 
	#GPIO_OTYPER_IDR_14
 ((
uint32_t
)0x00004000)

	)

4462 #define 
	#GPIO_OTYPER_IDR_15
 ((
uint32_t
)0x00008000)

	)

4465 #define 
	#GPIO_OTYPER_ODR_0
 ((
uint32_t
)0x00000001)

	)

4466 #define 
	#GPIO_OTYPER_ODR_1
 ((
uint32_t
)0x00000002)

	)

4467 #define 
	#GPIO_OTYPER_ODR_2
 ((
uint32_t
)0x00000004)

	)

4468 #define 
	#GPIO_OTYPER_ODR_3
 ((
uint32_t
)0x00000008)

	)

4469 #define 
	#GPIO_OTYPER_ODR_4
 ((
uint32_t
)0x00000010)

	)

4470 #define 
	#GPIO_OTYPER_ODR_5
 ((
uint32_t
)0x00000020)

	)

4471 #define 
	#GPIO_OTYPER_ODR_6
 ((
uint32_t
)0x00000040)

	)

4472 #define 
	#GPIO_OTYPER_ODR_7
 ((
uint32_t
)0x00000080)

	)

4473 #define 
	#GPIO_OTYPER_ODR_8
 ((
uint32_t
)0x00000100)

	)

4474 #define 
	#GPIO_OTYPER_ODR_9
 ((
uint32_t
)0x00000200)

	)

4475 #define 
	#GPIO_OTYPER_ODR_10
 ((
uint32_t
)0x00000400)

	)

4476 #define 
	#GPIO_OTYPER_ODR_11
 ((
uint32_t
)0x00000800)

	)

4477 #define 
	#GPIO_OTYPER_ODR_12
 ((
uint32_t
)0x00001000)

	)

4478 #define 
	#GPIO_OTYPER_ODR_13
 ((
uint32_t
)0x00002000)

	)

4479 #define 
	#GPIO_OTYPER_ODR_14
 ((
uint32_t
)0x00004000)

	)

4480 #define 
	#GPIO_OTYPER_ODR_15
 ((
uint32_t
)0x00008000)

	)

4483 #define 
	#GPIO_BSRR_BS_0
 ((
uint32_t
)0x00000001)

	)

4484 #define 
	#GPIO_BSRR_BS_1
 ((
uint32_t
)0x00000002)

	)

4485 #define 
	#GPIO_BSRR_BS_2
 ((
uint32_t
)0x00000004)

	)

4486 #define 
	#GPIO_BSRR_BS_3
 ((
uint32_t
)0x00000008)

	)

4487 #define 
	#GPIO_BSRR_BS_4
 ((
uint32_t
)0x00000010)

	)

4488 #define 
	#GPIO_BSRR_BS_5
 ((
uint32_t
)0x00000020)

	)

4489 #define 
	#GPIO_BSRR_BS_6
 ((
uint32_t
)0x00000040)

	)

4490 #define 
	#GPIO_BSRR_BS_7
 ((
uint32_t
)0x00000080)

	)

4491 #define 
	#GPIO_BSRR_BS_8
 ((
uint32_t
)0x00000100)

	)

4492 #define 
	#GPIO_BSRR_BS_9
 ((
uint32_t
)0x00000200)

	)

4493 #define 
	#GPIO_BSRR_BS_10
 ((
uint32_t
)0x00000400)

	)

4494 #define 
	#GPIO_BSRR_BS_11
 ((
uint32_t
)0x00000800)

	)

4495 #define 
	#GPIO_BSRR_BS_12
 ((
uint32_t
)0x00001000)

	)

4496 #define 
	#GPIO_BSRR_BS_13
 ((
uint32_t
)0x00002000)

	)

4497 #define 
	#GPIO_BSRR_BS_14
 ((
uint32_t
)0x00004000)

	)

4498 #define 
	#GPIO_BSRR_BS_15
 ((
uint32_t
)0x00008000)

	)

4499 #define 
	#GPIO_BSRR_BR_0
 ((
uint32_t
)0x00010000)

	)

4500 #define 
	#GPIO_BSRR_BR_1
 ((
uint32_t
)0x00020000)

	)

4501 #define 
	#GPIO_BSRR_BR_2
 ((
uint32_t
)0x00040000)

	)

4502 #define 
	#GPIO_BSRR_BR_3
 ((
uint32_t
)0x00080000)

	)

4503 #define 
	#GPIO_BSRR_BR_4
 ((
uint32_t
)0x00100000)

	)

4504 #define 
	#GPIO_BSRR_BR_5
 ((
uint32_t
)0x00200000)

	)

4505 #define 
	#GPIO_BSRR_BR_6
 ((
uint32_t
)0x00400000)

	)

4506 #define 
	#GPIO_BSRR_BR_7
 ((
uint32_t
)0x00800000)

	)

4507 #define 
	#GPIO_BSRR_BR_8
 ((
uint32_t
)0x01000000)

	)

4508 #define 
	#GPIO_BSRR_BR_9
 ((
uint32_t
)0x02000000)

	)

4509 #define 
	#GPIO_BSRR_BR_10
 ((
uint32_t
)0x04000000)

	)

4510 #define 
	#GPIO_BSRR_BR_11
 ((
uint32_t
)0x08000000)

	)

4511 #define 
	#GPIO_BSRR_BR_12
 ((
uint32_t
)0x10000000)

	)

4512 #define 
	#GPIO_BSRR_BR_13
 ((
uint32_t
)0x20000000)

	)

4513 #define 
	#GPIO_BSRR_BR_14
 ((
uint32_t
)0x40000000)

	)

4514 #define 
	#GPIO_BSRR_BR_15
 ((
uint32_t
)0x80000000)

	)

4522 #define 
	#HASH_CR_INIT
 ((
uint32_t
)0x00000004)

	)

4523 #define 
	#HASH_CR_DMAE
 ((
uint32_t
)0x00000008)

	)

4524 #define 
	#HASH_CR_DATATYPE
 ((
uint32_t
)0x00000030)

	)

4525 #define 
	#HASH_CR_DATATYPE_0
 ((
uint32_t
)0x00000010)

	)

4526 #define 
	#HASH_CR_DATATYPE_1
 ((
uint32_t
)0x00000020)

	)

4527 #define 
	#HASH_CR_MODE
 ((
uint32_t
)0x00000040)

	)

4528 #define 
	#HASH_CR_ALGO
 ((
uint32_t
)0x00000080)

	)

4529 #define 
	#HASH_CR_NBW
 ((
uint32_t
)0x00000F00)

	)

4530 #define 
	#HASH_CR_NBW_0
 ((
uint32_t
)0x00000100)

	)

4531 #define 
	#HASH_CR_NBW_1
 ((
uint32_t
)0x00000200)

	)

4532 #define 
	#HASH_CR_NBW_2
 ((
uint32_t
)0x00000400)

	)

4533 #define 
	#HASH_CR_NBW_3
 ((
uint32_t
)0x00000800)

	)

4534 #define 
	#HASH_CR_DINNE
 ((
uint32_t
)0x00001000)

	)

4535 #define 
	#HASH_CR_LKEY
 ((
uint32_t
)0x00010000)

	)

4538 #define 
	#HASH_STR_NBW
 ((
uint32_t
)0x0000001F)

	)

4539 #define 
	#HASH_STR_NBW_0
 ((
uint32_t
)0x00000001)

	)

4540 #define 
	#HASH_STR_NBW_1
 ((
uint32_t
)0x00000002)

	)

4541 #define 
	#HASH_STR_NBW_2
 ((
uint32_t
)0x00000004)

	)

4542 #define 
	#HASH_STR_NBW_3
 ((
uint32_t
)0x00000008)

	)

4543 #define 
	#HASH_STR_NBW_4
 ((
uint32_t
)0x00000010)

	)

4544 #define 
	#HASH_STR_DCAL
 ((
uint32_t
)0x00000100)

	)

4547 #define 
	#HASH_IMR_DINIM
 ((
uint32_t
)0x00000001)

	)

4548 #define 
	#HASH_IMR_DCIM
 ((
uint32_t
)0x00000002)

	)

4551 #define 
	#HASH_SR_DINIS
 ((
uint32_t
)0x00000001)

	)

4552 #define 
	#HASH_SR_DCIS
 ((
uint32_t
)0x00000002)

	)

4553 #define 
	#HASH_SR_DMAS
 ((
uint32_t
)0x00000004)

	)

4554 #define 
	#HASH_SR_BUSY
 ((
uint32_t
)0x00000008)

	)

4562 #define 
	#I2C_CR1_PE
 ((
uint16_t
)0x0001)

	)

4563 #define 
	#I2C_CR1_SMBUS
 ((
uint16_t
)0x0002)

	)

4564 #define 
	#I2C_CR1_SMBTYPE
 ((
uint16_t
)0x0008)

	)

4565 #define 
	#I2C_CR1_ENARP
 ((
uint16_t
)0x0010)

	)

4566 #define 
	#I2C_CR1_ENPEC
 ((
uint16_t
)0x0020)

	)

4567 #define 
	#I2C_CR1_ENGC
 ((
uint16_t
)0x0040)

	)

4568 #define 
	#I2C_CR1_NOSTRETCH
 ((
uint16_t
)0x0080)

	)

4569 #define 
	#I2C_CR1_START
 ((
uint16_t
)0x0100)

	)

4570 #define 
	#I2C_CR1_STOP
 ((
uint16_t
)0x0200)

	)

4571 #define 
	#I2C_CR1_ACK
 ((
uint16_t
)0x0400)

	)

4572 #define 
	#I2C_CR1_POS
 ((
uint16_t
)0x0800)

	)

4573 #define 
	#I2C_CR1_PEC
 ((
uint16_t
)0x1000)

	)

4574 #define 
	#I2C_CR1_ALERT
 ((
uint16_t
)0x2000)

	)

4575 #define 
	#I2C_CR1_SWRST
 ((
uint16_t
)0x8000)

	)

4578 #define 
	#I2C_CR2_FREQ
 ((
uint16_t
)0x003F)

	)

4579 #define 
	#I2C_CR2_FREQ_0
 ((
uint16_t
)0x0001)

	)

4580 #define 
	#I2C_CR2_FREQ_1
 ((
uint16_t
)0x0002)

	)

4581 #define 
	#I2C_CR2_FREQ_2
 ((
uint16_t
)0x0004)

	)

4582 #define 
	#I2C_CR2_FREQ_3
 ((
uint16_t
)0x0008)

	)

4583 #define 
	#I2C_CR2_FREQ_4
 ((
uint16_t
)0x0010)

	)

4584 #define 
	#I2C_CR2_FREQ_5
 ((
uint16_t
)0x0020)

	)

4586 #define 
	#I2C_CR2_ITERREN
 ((
uint16_t
)0x0100)

	)

4587 #define 
	#I2C_CR2_ITEVTEN
 ((
uint16_t
)0x0200)

	)

4588 #define 
	#I2C_CR2_ITBUFEN
 ((
uint16_t
)0x0400)

	)

4589 #define 
	#I2C_CR2_DMAEN
 ((
uint16_t
)0x0800)

	)

4590 #define 
	#I2C_CR2_LAST
 ((
uint16_t
)0x1000)

	)

4593 #define 
	#I2C_OAR1_ADD1_7
 ((
uint16_t
)0x00FE)

	)

4594 #define 
	#I2C_OAR1_ADD8_9
 ((
uint16_t
)0x0300)

	)

4596 #define 
	#I2C_OAR1_ADD0
 ((
uint16_t
)0x0001)

	)

4597 #define 
	#I2C_OAR1_ADD1
 ((
uint16_t
)0x0002)

	)

4598 #define 
	#I2C_OAR1_ADD2
 ((
uint16_t
)0x0004)

	)

4599 #define 
	#I2C_OAR1_ADD3
 ((
uint16_t
)0x0008)

	)

4600 #define 
	#I2C_OAR1_ADD4
 ((
uint16_t
)0x0010)

	)

4601 #define 
	#I2C_OAR1_ADD5
 ((
uint16_t
)0x0020)

	)

4602 #define 
	#I2C_OAR1_ADD6
 ((
uint16_t
)0x0040)

	)

4603 #define 
	#I2C_OAR1_ADD7
 ((
uint16_t
)0x0080)

	)

4604 #define 
	#I2C_OAR1_ADD8
 ((
uint16_t
)0x0100)

	)

4605 #define 
	#I2C_OAR1_ADD9
 ((
uint16_t
)0x0200)

	)

4607 #define 
	#I2C_OAR1_ADDMODE
 ((
uint16_t
)0x8000)

	)

4610 #define 
	#I2C_OAR2_ENDUAL
 ((
uint8_t
)0x01)

	)

4611 #define 
	#I2C_OAR2_ADD2
 ((
uint8_t
)0xFE)

	)

4614 #define 
	#I2C_DR_DR
 ((
uint8_t
)0xFF)

	)

4617 #define 
	#I2C_SR1_SB
 ((
uint16_t
)0x0001)

	)

4618 #define 
	#I2C_SR1_ADDR
 ((
uint16_t
)0x0002)

	)

4619 #define 
	#I2C_SR1_BTF
 ((
uint16_t
)0x0004)

	)

4620 #define 
	#I2C_SR1_ADD10
 ((
uint16_t
)0x0008)

	)

4621 #define 
	#I2C_SR1_STOPF
 ((
uint16_t
)0x0010)

	)

4622 #define 
	#I2C_SR1_RXNE
 ((
uint16_t
)0x0040)

	)

4623 #define 
	#I2C_SR1_TXE
 ((
uint16_t
)0x0080)

	)

4624 #define 
	#I2C_SR1_BERR
 ((
uint16_t
)0x0100)

	)

4625 #define 
	#I2C_SR1_ARLO
 ((
uint16_t
)0x0200)

	)

4626 #define 
	#I2C_SR1_AF
 ((
uint16_t
)0x0400)

	)

4627 #define 
	#I2C_SR1_OVR
 ((
uint16_t
)0x0800)

	)

4628 #define 
	#I2C_SR1_PECERR
 ((
uint16_t
)0x1000)

	)

4629 #define 
	#I2C_SR1_TIMEOUT
 ((
uint16_t
)0x4000)

	)

4630 #define 
	#I2C_SR1_SMBALERT
 ((
uint16_t
)0x8000)

	)

4633 #define 
	#I2C_SR2_MSL
 ((
uint16_t
)0x0001)

	)

4634 #define 
	#I2C_SR2_BUSY
 ((
uint16_t
)0x0002)

	)

4635 #define 
	#I2C_SR2_TRA
 ((
uint16_t
)0x0004)

	)

4636 #define 
	#I2C_SR2_GENCALL
 ((
uint16_t
)0x0010)

	)

4637 #define 
	#I2C_SR2_SMBDEFAULT
 ((
uint16_t
)0x0020)

	)

4638 #define 
	#I2C_SR2_SMBHOST
 ((
uint16_t
)0x0040)

	)

4639 #define 
	#I2C_SR2_DUALF
 ((
uint16_t
)0x0080)

	)

4640 #define 
	#I2C_SR2_PEC
 ((
uint16_t
)0xFF00)

	)

4643 #define 
	#I2C_CCR_CCR
 ((
uint16_t
)0x0FFF)

	)

4644 #define 
	#I2C_CCR_DUTY
 ((
uint16_t
)0x4000)

	)

4645 #define 
	#I2C_CCR_FS
 ((
uint16_t
)0x8000)

	)

4648 #define 
	#I2C_TRISE_TRISE
 ((
uint8_t
)0x3F)

	)

4656 #define 
	#IWDG_KR_KEY
 ((
uint16_t
)0xFFFF)

	)

4659 #define 
	#IWDG_PR_PR
 ((
uint8_t
)0x07)

	)

4660 #define 
	#IWDG_PR_PR_0
 ((
uint8_t
)0x01)

	)

4661 #define 
	#IWDG_PR_PR_1
 ((
uint8_t
)0x02)

	)

4662 #define 
	#IWDG_PR_PR_2
 ((
uint8_t
)0x04)

	)

4665 #define 
	#IWDG_RLR_RL
 ((
uint16_t
)0x0FFF)

	)

4668 #define 
	#IWDG_SR_PVU
 ((
uint8_t
)0x01)

	)

4669 #define 
	#IWDG_SR_RVU
 ((
uint8_t
)0x02)

	)

4677 #define 
	#PWR_CR_LPDS
 ((
uint16_t
)0x0001)

	)

4678 #define 
	#PWR_CR_PDDS
 ((
uint16_t
)0x0002)

	)

4679 #define 
	#PWR_CR_CWUF
 ((
uint16_t
)0x0004)

	)

4680 #define 
	#PWR_CR_CSBF
 ((
uint16_t
)0x0008)

	)

4681 #define 
	#PWR_CR_PVDE
 ((
uint16_t
)0x0010)

	)

4683 #define 
	#PWR_CR_PLS
 ((
uint16_t
)0x00E0)

	)

4684 #define 
	#PWR_CR_PLS_0
 ((
uint16_t
)0x0020)

	)

4685 #define 
	#PWR_CR_PLS_1
 ((
uint16_t
)0x0040)

	)

4686 #define 
	#PWR_CR_PLS_2
 ((
uint16_t
)0x0080)

	)

4690 #define 
	#PWR_CR_PLS_LEV0
 ((
uint16_t
)0x0000)

	)

4691 #define 
	#PWR_CR_PLS_LEV1
 ((
uint16_t
)0x0020)

	)

4692 #define 
	#PWR_CR_PLS_LEV2
 ((
uint16_t
)0x0040)

	)

4693 #define 
	#PWR_CR_PLS_LEV3
 ((
uint16_t
)0x0060)

	)

4694 #define 
	#PWR_CR_PLS_LEV4
 ((
uint16_t
)0x0080)

	)

4695 #define 
	#PWR_CR_PLS_LEV5
 ((
uint16_t
)0x00A0)

	)

4696 #define 
	#PWR_CR_PLS_LEV6
 ((
uint16_t
)0x00C0)

	)

4697 #define 
	#PWR_CR_PLS_LEV7
 ((
uint16_t
)0x00E0)

	)

4699 #define 
	#PWR_CR_DBP
 ((
uint16_t
)0x0100)

	)

4700 #define 
	#PWR_CR_FPDS
 ((
uint16_t
)0x0200)

	)

4701 #define 
	#PWR_CR_PMODE
 ((
uint16_t
)0x4000)

	)

4704 #define 
	#PWR_CSR_WUF
 ((
uint16_t
)0x0001)

	)

4705 #define 
	#PWR_CSR_SBF
 ((
uint16_t
)0x0002)

	)

4706 #define 
	#PWR_CSR_PVDO
 ((
uint16_t
)0x0004)

	)

4707 #define 
	#PWR_CSR_BRR
 ((
uint16_t
)0x0008)

	)

4708 #define 
	#PWR_CSR_EWUP
 ((
uint16_t
)0x0100)

	)

4709 #define 
	#PWR_CSR_BRE
 ((
uint16_t
)0x0200)

	)

4710 #define 
	#PWR_CSR_REGRDY
 ((
uint16_t
)0x4000)

	)

4718 #define 
	#RCC_CR_HSION
 ((
uint32_t
)0x00000001)

	)

4719 #define 
	#RCC_CR_HSIRDY
 ((
uint32_t
)0x00000002)

	)

4721 #define 
	#RCC_CR_HSITRIM
 ((
uint32_t
)0x000000F8)

	)

4722 #define 
	#RCC_CR_HSITRIM_0
 ((
uint32_t
)0x00000008)

	)

4723 #define 
	#RCC_CR_HSITRIM_1
 ((
uint32_t
)0x00000010)

	)

4724 #define 
	#RCC_CR_HSITRIM_2
 ((
uint32_t
)0x00000020)

	)

4725 #define 
	#RCC_CR_HSITRIM_3
 ((
uint32_t
)0x00000040)

	)

4726 #define 
	#RCC_CR_HSITRIM_4
 ((
uint32_t
)0x00000080)

	)

4728 #define 
	#RCC_CR_HSICAL
 ((
uint32_t
)0x0000FF00)

	)

4729 #define 
	#RCC_CR_HSICAL_0
 ((
uint32_t
)0x00000100)

	)

4730 #define 
	#RCC_CR_HSICAL_1
 ((
uint32_t
)0x00000200)

	)

4731 #define 
	#RCC_CR_HSICAL_2
 ((
uint32_t
)0x00000400)

	)

4732 #define 
	#RCC_CR_HSICAL_3
 ((
uint32_t
)0x00000800)

	)

4733 #define 
	#RCC_CR_HSICAL_4
 ((
uint32_t
)0x00001000)

	)

4734 #define 
	#RCC_CR_HSICAL_5
 ((
uint32_t
)0x00002000)

	)

4735 #define 
	#RCC_CR_HSICAL_6
 ((
uint32_t
)0x00004000)

	)

4736 #define 
	#RCC_CR_HSICAL_7
 ((
uint32_t
)0x00008000)

	)

4738 #define 
	#RCC_CR_HSEON
 ((
uint32_t
)0x00010000)

	)

4739 #define 
	#RCC_CR_HSERDY
 ((
uint32_t
)0x00020000)

	)

4740 #define 
	#RCC_CR_HSEBYP
 ((
uint32_t
)0x00040000)

	)

4741 #define 
	#RCC_CR_CSSON
 ((
uint32_t
)0x00080000)

	)

4742 #define 
	#RCC_CR_PLLON
 ((
uint32_t
)0x01000000)

	)

4743 #define 
	#RCC_CR_PLLRDY
 ((
uint32_t
)0x02000000)

	)

4744 #define 
	#RCC_CR_PLLI2SON
 ((
uint32_t
)0x04000000)

	)

4745 #define 
	#RCC_CR_PLLI2SRDY
 ((
uint32_t
)0x08000000)

	)

4748 #define 
	#RCC_PLLCFGR_PLLM
 ((
uint32_t
)0x0000003F)

	)

4749 #define 
	#RCC_PLLCFGR_PLLM_0
 ((
uint32_t
)0x00000001)

	)

4750 #define 
	#RCC_PLLCFGR_PLLM_1
 ((
uint32_t
)0x00000002)

	)

4751 #define 
	#RCC_PLLCFGR_PLLM_2
 ((
uint32_t
)0x00000004)

	)

4752 #define 
	#RCC_PLLCFGR_PLLM_3
 ((
uint32_t
)0x00000008)

	)

4753 #define 
	#RCC_PLLCFGR_PLLM_4
 ((
uint32_t
)0x00000010)

	)

4754 #define 
	#RCC_PLLCFGR_PLLM_5
 ((
uint32_t
)0x00000020)

	)

4756 #define 
	#RCC_PLLCFGR_PLLN
 ((
uint32_t
)0x00007FC0)

	)

4757 #define 
	#RCC_PLLCFGR_PLLN_0
 ((
uint32_t
)0x00000040)

	)

4758 #define 
	#RCC_PLLCFGR_PLLN_1
 ((
uint32_t
)0x00000080)

	)

4759 #define 
	#RCC_PLLCFGR_PLLN_2
 ((
uint32_t
)0x00000100)

	)

4760 #define 
	#RCC_PLLCFGR_PLLN_3
 ((
uint32_t
)0x00000200)

	)

4761 #define 
	#RCC_PLLCFGR_PLLN_4
 ((
uint32_t
)0x00000400)

	)

4762 #define 
	#RCC_PLLCFGR_PLLN_5
 ((
uint32_t
)0x00000800)

	)

4763 #define 
	#RCC_PLLCFGR_PLLN_6
 ((
uint32_t
)0x00001000)

	)

4764 #define 
	#RCC_PLLCFGR_PLLN_7
 ((
uint32_t
)0x00002000)

	)

4765 #define 
	#RCC_PLLCFGR_PLLN_8
 ((
uint32_t
)0x00004000)

	)

4767 #define 
	#RCC_PLLCFGR_PLLP
 ((
uint32_t
)0x00030000)

	)

4768 #define 
	#RCC_PLLCFGR_PLLP_0
 ((
uint32_t
)0x00010000)

	)

4769 #define 
	#RCC_PLLCFGR_PLLP_1
 ((
uint32_t
)0x00020000)

	)

4771 #define 
	#RCC_PLLCFGR_PLLSRC
 ((
uint32_t
)0x00400000)

	)

4772 #define 
	#RCC_PLLCFGR_PLLSRC_HSE
 ((
uint32_t
)0x00400000)

	)

4773 #define 
	#RCC_PLLCFGR_PLLSRC_HSI
 ((
uint32_t
)0x00000000)

	)

4775 #define 
	#RCC_PLLCFGR_PLLQ
 ((
uint32_t
)0x0F000000)

	)

4776 #define 
	#RCC_PLLCFGR_PLLQ_0
 ((
uint32_t
)0x01000000)

	)

4777 #define 
	#RCC_PLLCFGR_PLLQ_1
 ((
uint32_t
)0x02000000)

	)

4778 #define 
	#RCC_PLLCFGR_PLLQ_2
 ((
uint32_t
)0x04000000)

	)

4779 #define 
	#RCC_PLLCFGR_PLLQ_3
 ((
uint32_t
)0x08000000)

	)

4783 #define 
	#RCC_CFGR_SW
 ((
uint32_t
)0x00000003)

	)

4784 #define 
	#RCC_CFGR_SW_0
 ((
uint32_t
)0x00000001)

	)

4785 #define 
	#RCC_CFGR_SW_1
 ((
uint32_t
)0x00000002)

	)

4787 #define 
	#RCC_CFGR_SW_HSI
 ((
uint32_t
)0x00000000)

	)

4788 #define 
	#RCC_CFGR_SW_HSE
 ((
uint32_t
)0x00000001)

	)

4789 #define 
	#RCC_CFGR_SW_PLL
 ((
uint32_t
)0x00000002)

	)

4792 #define 
	#RCC_CFGR_SWS
 ((
uint32_t
)0x0000000C)

	)

4793 #define 
	#RCC_CFGR_SWS_0
 ((
uint32_t
)0x00000004)

	)

4794 #define 
	#RCC_CFGR_SWS_1
 ((
uint32_t
)0x00000008)

	)

4796 #define 
	#RCC_CFGR_SWS_HSI
 ((
uint32_t
)0x00000000)

	)

4797 #define 
	#RCC_CFGR_SWS_HSE
 ((
uint32_t
)0x00000004)

	)

4798 #define 
	#RCC_CFGR_SWS_PLL
 ((
uint32_t
)0x00000008)

	)

4801 #define 
	#RCC_CFGR_HPRE
 ((
uint32_t
)0x000000F0)

	)

4802 #define 
	#RCC_CFGR_HPRE_0
 ((
uint32_t
)0x00000010)

	)

4803 #define 
	#RCC_CFGR_HPRE_1
 ((
uint32_t
)0x00000020)

	)

4804 #define 
	#RCC_CFGR_HPRE_2
 ((
uint32_t
)0x00000040)

	)

4805 #define 
	#RCC_CFGR_HPRE_3
 ((
uint32_t
)0x00000080)

	)

4807 #define 
	#RCC_CFGR_HPRE_DIV1
 ((
uint32_t
)0x00000000)

	)

4808 #define 
	#RCC_CFGR_HPRE_DIV2
 ((
uint32_t
)0x00000080)

	)

4809 #define 
	#RCC_CFGR_HPRE_DIV4
 ((
uint32_t
)0x00000090)

	)

4810 #define 
	#RCC_CFGR_HPRE_DIV8
 ((
uint32_t
)0x000000A0)

	)

4811 #define 
	#RCC_CFGR_HPRE_DIV16
 ((
uint32_t
)0x000000B0)

	)

4812 #define 
	#RCC_CFGR_HPRE_DIV64
 ((
uint32_t
)0x000000C0)

	)

4813 #define 
	#RCC_CFGR_HPRE_DIV128
 ((
uint32_t
)0x000000D0)

	)

4814 #define 
	#RCC_CFGR_HPRE_DIV256
 ((
uint32_t
)0x000000E0)

	)

4815 #define 
	#RCC_CFGR_HPRE_DIV512
 ((
uint32_t
)0x000000F0)

	)

4818 #define 
	#RCC_CFGR_PPRE1
 ((
uint32_t
)0x00001C00)

	)

4819 #define 
	#RCC_CFGR_PPRE1_0
 ((
uint32_t
)0x00000400)

	)

4820 #define 
	#RCC_CFGR_PPRE1_1
 ((
uint32_t
)0x00000800)

	)

4821 #define 
	#RCC_CFGR_PPRE1_2
 ((
uint32_t
)0x00001000)

	)

4823 #define 
	#RCC_CFGR_PPRE1_DIV1
 ((
uint32_t
)0x00000000)

	)

4824 #define 
	#RCC_CFGR_PPRE1_DIV2
 ((
uint32_t
)0x00001000)

	)

4825 #define 
	#RCC_CFGR_PPRE1_DIV4
 ((
uint32_t
)0x00001400)

	)

4826 #define 
	#RCC_CFGR_PPRE1_DIV8
 ((
uint32_t
)0x00001800)

	)

4827 #define 
	#RCC_CFGR_PPRE1_DIV16
 ((
uint32_t
)0x00001C00)

	)

4830 #define 
	#RCC_CFGR_PPRE2
 ((
uint32_t
)0x0000E000)

	)

4831 #define 
	#RCC_CFGR_PPRE2_0
 ((
uint32_t
)0x00002000)

	)

4832 #define 
	#RCC_CFGR_PPRE2_1
 ((
uint32_t
)0x00004000)

	)

4833 #define 
	#RCC_CFGR_PPRE2_2
 ((
uint32_t
)0x00008000)

	)

4835 #define 
	#RCC_CFGR_PPRE2_DIV1
 ((
uint32_t
)0x00000000)

	)

4836 #define 
	#RCC_CFGR_PPRE2_DIV2
 ((
uint32_t
)0x00008000)

	)

4837 #define 
	#RCC_CFGR_PPRE2_DIV4
 ((
uint32_t
)0x0000A000)

	)

4838 #define 
	#RCC_CFGR_PPRE2_DIV8
 ((
uint32_t
)0x0000C000)

	)

4839 #define 
	#RCC_CFGR_PPRE2_DIV16
 ((
uint32_t
)0x0000E00)

	)

4842 #define 
	#RCC_CFGR_RTCPRE
 ((
uint32_t
)0x001F0000)

	)

4843 #define 
	#RCC_CFGR_RTCPRE_0
 ((
uint32_t
)0x00010000)

	)

4844 #define 
	#RCC_CFGR_RTCPRE_1
 ((
uint32_t
)0x00020000)

	)

4845 #define 
	#RCC_CFGR_RTCPRE_2
 ((
uint32_t
)0x00040000)

	)

4846 #define 
	#RCC_CFGR_RTCPRE_3
 ((
uint32_t
)0x00080000)

	)

4847 #define 
	#RCC_CFGR_RTCPRE_4
 ((
uint32_t
)0x00100000)

	)

4850 #define 
	#RCC_CFGR_MCO1
 ((
uint32_t
)0x00600000)

	)

4851 #define 
	#RCC_CFGR_MCO1_0
 ((
uint32_t
)0x00200000)

	)

4852 #define 
	#RCC_CFGR_MCO1_1
 ((
uint32_t
)0x00400000)

	)

4854 #define 
	#RCC_CFGR_I2SSRC
 ((
uint32_t
)0x00800000)

	)

4856 #define 
	#RCC_CFGR_MCO1PRE
 ((
uint32_t
)0x07000000)

	)

4857 #define 
	#RCC_CFGR_MCO1PRE_0
 ((
uint32_t
)0x01000000)

	)

4858 #define 
	#RCC_CFGR_MCO1PRE_1
 ((
uint32_t
)0x02000000)

	)

4859 #define 
	#RCC_CFGR_MCO1PRE_2
 ((
uint32_t
)0x04000000)

	)

4861 #define 
	#RCC_CFGR_MCO2PRE
 ((
uint32_t
)0x38000000)

	)

4862 #define 
	#RCC_CFGR_MCO2PRE_0
 ((
uint32_t
)0x08000000)

	)

4863 #define 
	#RCC_CFGR_MCO2PRE_1
 ((
uint32_t
)0x10000000)

	)

4864 #define 
	#RCC_CFGR_MCO2PRE_2
 ((
uint32_t
)0x20000000)

	)

4866 #define 
	#RCC_CFGR_MCO2
 ((
uint32_t
)0xC0000000)

	)

4867 #define 
	#RCC_CFGR_MCO2_0
 ((
uint32_t
)0x40000000)

	)

4868 #define 
	#RCC_CFGR_MCO2_1
 ((
uint32_t
)0x80000000)

	)

4871 #define 
	#RCC_CIR_LSIRDYF
 ((
uint32_t
)0x00000001)

	)

4872 #define 
	#RCC_CIR_LSERDYF
 ((
uint32_t
)0x00000002)

	)

4873 #define 
	#RCC_CIR_HSIRDYF
 ((
uint32_t
)0x00000004)

	)

4874 #define 
	#RCC_CIR_HSERDYF
 ((
uint32_t
)0x00000008)

	)

4875 #define 
	#RCC_CIR_PLLRDYF
 ((
uint32_t
)0x00000010)

	)

4876 #define 
	#RCC_CIR_PLLI2SRDYF
 ((
uint32_t
)0x00000020)

	)

4877 #define 
	#RCC_CIR_CSSF
 ((
uint32_t
)0x00000080)

	)

4878 #define 
	#RCC_CIR_LSIRDYIE
 ((
uint32_t
)0x00000100)

	)

4879 #define 
	#RCC_CIR_LSERDYIE
 ((
uint32_t
)0x00000200)

	)

4880 #define 
	#RCC_CIR_HSIRDYIE
 ((
uint32_t
)0x00000400)

	)

4881 #define 
	#RCC_CIR_HSERDYIE
 ((
uint32_t
)0x00000800)

	)

4882 #define 
	#RCC_CIR_PLLRDYIE
 ((
uint32_t
)0x00001000)

	)

4883 #define 
	#RCC_CIR_PLLI2SRDYIE
 ((
uint32_t
)0x00002000)

	)

4884 #define 
	#RCC_CIR_LSIRDYC
 ((
uint32_t
)0x00010000)

	)

4885 #define 
	#RCC_CIR_LSERDYC
 ((
uint32_t
)0x00020000)

	)

4886 #define 
	#RCC_CIR_HSIRDYC
 ((
uint32_t
)0x00040000)

	)

4887 #define 
	#RCC_CIR_HSERDYC
 ((
uint32_t
)0x00080000)

	)

4888 #define 
	#RCC_CIR_PLLRDYC
 ((
uint32_t
)0x00100000)

	)

4889 #define 
	#RCC_CIR_PLLI2SRDYC
 ((
uint32_t
)0x00200000)

	)

4890 #define 
	#RCC_CIR_CSSC
 ((
uint32_t
)0x00800000)

	)

4893 #define 
	#RCC_AHB1RSTR_GPIOARST
 ((
uint32_t
)0x00000001)

	)

4894 #define 
	#RCC_AHB1RSTR_GPIOBRST
 ((
uint32_t
)0x00000002)

	)

4895 #define 
	#RCC_AHB1RSTR_GPIOCRST
 ((
uint32_t
)0x00000004)

	)

4896 #define 
	#RCC_AHB1RSTR_GPIODRST
 ((
uint32_t
)0x00000008)

	)

4897 #define 
	#RCC_AHB1RSTR_GPIOERST
 ((
uint32_t
)0x00000010)

	)

4898 #define 
	#RCC_AHB1RSTR_GPIOFRST
 ((
uint32_t
)0x00000020)

	)

4899 #define 
	#RCC_AHB1RSTR_GPIOGRST
 ((
uint32_t
)0x00000040)

	)

4900 #define 
	#RCC_AHB1RSTR_GPIOHRST
 ((
uint32_t
)0x00000080)

	)

4901 #define 
	#RCC_AHB1RSTR_GPIOIRST
 ((
uint32_t
)0x00000100)

	)

4902 #define 
	#RCC_AHB1RSTR_CRCRST
 ((
uint32_t
)0x00001000)

	)

4903 #define 
	#RCC_AHB1RSTR_DMA1RST
 ((
uint32_t
)0x00200000)

	)

4904 #define 
	#RCC_AHB1RSTR_DMA2RST
 ((
uint32_t
)0x00400000)

	)

4905 #define 
	#RCC_AHB1RSTR_ETHMACRST
 ((
uint32_t
)0x02000000)

	)

4906 #define 
	#RCC_AHB1RSTR_OTGHRST
 ((
uint32_t
)0x10000000)

	)

4909 #define 
	#RCC_AHB2RSTR_DCMIRST
 ((
uint32_t
)0x00000001)

	)

4910 #define 
	#RCC_AHB2RSTR_CRYPRST
 ((
uint32_t
)0x00000010)

	)

4911 #define 
	#RCC_AHB2RSTR_HSAHRST
 ((
uint32_t
)0x00000020)

	)

4912 #define 
	#RCC_AHB2RSTR_RNGRST
 ((
uint32_t
)0x00000040)

	)

4913 #define 
	#RCC_AHB2RSTR_OTGFSRST
 ((
uint32_t
)0x00000080)

	)

4916 #define 
	#RCC_AHB3RSTR_FSMCRST
 ((
uint32_t
)0x00000001)

	)

4919 #define 
	#RCC_APB1RSTR_TIM2RST
 ((
uint32_t
)0x00000001)

	)

4920 #define 
	#RCC_APB1RSTR_TIM3RST
 ((
uint32_t
)0x00000002)

	)

4921 #define 
	#RCC_APB1RSTR_TIM4RST
 ((
uint32_t
)0x00000004)

	)

4922 #define 
	#RCC_APB1RSTR_TIM5RST
 ((
uint32_t
)0x00000008)

	)

4923 #define 
	#RCC_APB1RSTR_TIM6RST
 ((
uint32_t
)0x00000010)

	)

4924 #define 
	#RCC_APB1RSTR_TIM7RST
 ((
uint32_t
)0x00000020)

	)

4925 #define 
	#RCC_APB1RSTR_TIM12RST
 ((
uint32_t
)0x00000040)

	)

4926 #define 
	#RCC_APB1RSTR_TIM13RST
 ((
uint32_t
)0x00000080)

	)

4927 #define 
	#RCC_APB1RSTR_TIM14RST
 ((
uint32_t
)0x00000100)

	)

4928 #define 
	#RCC_APB1RSTR_WWDGEN
 ((
uint32_t
)0x00000800)

	)

4929 #define 
	#RCC_APB1RSTR_SPI2RST
 ((
uint32_t
)0x00008000)

	)

4930 #define 
	#RCC_APB1RSTR_SPI3RST
 ((
uint32_t
)0x00010000)

	)

4931 #define 
	#RCC_APB1RSTR_USART2RST
 ((
uint32_t
)0x00020000)

	)

4932 #define 
	#RCC_APB1RSTR_USART3RST
 ((
uint32_t
)0x00040000)

	)

4933 #define 
	#RCC_APB1RSTR_UART4RST
 ((
uint32_t
)0x00080000)

	)

4934 #define 
	#RCC_APB1RSTR_UART5RST
 ((
uint32_t
)0x00100000)

	)

4935 #define 
	#RCC_APB1RSTR_I2C1RST
 ((
uint32_t
)0x00200000)

	)

4936 #define 
	#RCC_APB1RSTR_I2C2RST
 ((
uint32_t
)0x00400000)

	)

4937 #define 
	#RCC_APB1RSTR_I2C3RST
 ((
uint32_t
)0x00800000)

	)

4938 #define 
	#RCC_APB1RSTR_CAN1RST
 ((
uint32_t
)0x02000000)

	)

4939 #define 
	#RCC_APB1RSTR_CAN2RST
 ((
uint32_t
)0x04000000)

	)

4940 #define 
	#RCC_APB1RSTR_PWRRST
 ((
uint32_t
)0x10000000)

	)

4941 #define 
	#RCC_APB1RSTR_DACRST
 ((
uint32_t
)0x20000000)

	)

4944 #define 
	#RCC_APB2RSTR_TIM1RST
 ((
uint32_t
)0x00000001)

	)

4945 #define 
	#RCC_APB2RSTR_TIM8RST
 ((
uint32_t
)0x00000002)

	)

4946 #define 
	#RCC_APB2RSTR_USART1RST
 ((
uint32_t
)0x00000010)

	)

4947 #define 
	#RCC_APB2RSTR_USART6RST
 ((
uint32_t
)0x00000020)

	)

4948 #define 
	#RCC_APB2RSTR_ADCRST
 ((
uint32_t
)0x00000100)

	)

4949 #define 
	#RCC_APB2RSTR_SDIORST
 ((
uint32_t
)0x00000800)

	)

4950 #define 
	#RCC_APB2RSTR_SPI1
 ((
uint32_t
)0x00001000)

	)

4951 #define 
	#RCC_APB2RSTR_SYSCFGRST
 ((
uint32_t
)0x00004000)

	)

4952 #define 
	#RCC_APB2RSTR_TIM9RST
 ((
uint32_t
)0x00010000)

	)

4953 #define 
	#RCC_APB2RSTR_TIM10RST
 ((
uint32_t
)0x00020000)

	)

4954 #define 
	#RCC_APB2RSTR_TIM11RST
 ((
uint32_t
)0x00040000)

	)

4957 #define 
	#RCC_AHB1ENR_GPIOAEN
 ((
uint32_t
)0x00000001)

	)

4958 #define 
	#RCC_AHB1ENR_GPIOBEN
 ((
uint32_t
)0x00000002)

	)

4959 #define 
	#RCC_AHB1ENR_GPIOCEN
 ((
uint32_t
)0x00000004)

	)

4960 #define 
	#RCC_AHB1ENR_GPIODEN
 ((
uint32_t
)0x00000008)

	)

4961 #define 
	#RCC_AHB1ENR_GPIOEEN
 ((
uint32_t
)0x00000010)

	)

4962 #define 
	#RCC_AHB1ENR_GPIOFEN
 ((
uint32_t
)0x00000020)

	)

4963 #define 
	#RCC_AHB1ENR_GPIOGEN
 ((
uint32_t
)0x00000040)

	)

4964 #define 
	#RCC_AHB1ENR_GPIOHEN
 ((
uint32_t
)0x00000080)

	)

4965 #define 
	#RCC_AHB1ENR_GPIOIEN
 ((
uint32_t
)0x00000100)

	)

4966 #define 
	#RCC_AHB1ENR_CRCEN
 ((
uint32_t
)0x00001000)

	)

4967 #define 
	#RCC_AHB1ENR_BKPSRAMEN
 ((
uint32_t
)0x00040000)

	)

4968 #define 
	#RCC_AHB1ENR_DMA1EN
 ((
uint32_t
)0x00200000)

	)

4969 #define 
	#RCC_AHB1ENR_DMA2EN
 ((
uint32_t
)0x00400000)

	)

4970 #define 
	#RCC_AHB1ENR_ETHMACEN
 ((
uint32_t
)0x02000000)

	)

4971 #define 
	#RCC_AHB1ENR_ETHMACTXEN
 ((
uint32_t
)0x04000000)

	)

4972 #define 
	#RCC_AHB1ENR_ETHMACRXEN
 ((
uint32_t
)0x08000000)

	)

4973 #define 
	#RCC_AHB1ENR_ETHMACPTPEN
 ((
uint32_t
)0x10000000)

	)

4974 #define 
	#RCC_AHB1ENR_OTGHSEN
 ((
uint32_t
)0x20000000)

	)

4975 #define 
	#RCC_AHB1ENR_OTGHSULPIEN
 ((
uint32_t
)0x40000000)

	)

4978 #define 
	#RCC_AHB2ENR_DCMIEN
 ((
uint32_t
)0x00000001)

	)

4979 #define 
	#RCC_AHB2ENR_CRYPEN
 ((
uint32_t
)0x00000010)

	)

4980 #define 
	#RCC_AHB2ENR_HASHEN
 ((
uint32_t
)0x00000020)

	)

4981 #define 
	#RCC_AHB2ENR_RNGEN
 ((
uint32_t
)0x00000040)

	)

4982 #define 
	#RCC_AHB2ENR_OTGFSEN
 ((
uint32_t
)0x00000080)

	)

4985 #define 
	#RCC_AHB3ENR_FSMCEN
 ((
uint32_t
)0x00000001)

	)

4988 #define 
	#RCC_APB1ENR_TIM2EN
 ((
uint32_t
)0x00000001)

	)

4989 #define 
	#RCC_APB1ENR_TIM3EN
 ((
uint32_t
)0x00000002)

	)

4990 #define 
	#RCC_APB1ENR_TIM4EN
 ((
uint32_t
)0x00000004)

	)

4991 #define 
	#RCC_APB1ENR_TIM5EN
 ((
uint32_t
)0x00000008)

	)

4992 #define 
	#RCC_APB1ENR_TIM6EN
 ((
uint32_t
)0x00000010)

	)

4993 #define 
	#RCC_APB1ENR_TIM7EN
 ((
uint32_t
)0x00000020)

	)

4994 #define 
	#RCC_APB1ENR_TIM12EN
 ((
uint32_t
)0x00000040)

	)

4995 #define 
	#RCC_APB1ENR_TIM13EN
 ((
uint32_t
)0x00000080)

	)

4996 #define 
	#RCC_APB1ENR_TIM14EN
 ((
uint32_t
)0x00000100)

	)

4997 #define 
	#RCC_APB1ENR_WWDGEN
 ((
uint32_t
)0x00000800)

	)

4998 #define 
	#RCC_APB1ENR_SPI2EN
 ((
uint32_t
)0x00004000)

	)

4999 #define 
	#RCC_APB1ENR_SPI3EN
 ((
uint32_t
)0x00008000)

	)

5000 #define 
	#RCC_APB1ENR_USART2EN
 ((
uint32_t
)0x00020000)

	)

5001 #define 
	#RCC_APB1ENR_USART3EN
 ((
uint32_t
)0x00040000)

	)

5002 #define 
	#RCC_APB1ENR_UART4EN
 ((
uint32_t
)0x00080000)

	)

5003 #define 
	#RCC_APB1ENR_UART5EN
 ((
uint32_t
)0x00100000)

	)

5004 #define 
	#RCC_APB1ENR_I2C1EN
 ((
uint32_t
)0x00200000)

	)

5005 #define 
	#RCC_APB1ENR_I2C2EN
 ((
uint32_t
)0x00400000)

	)

5006 #define 
	#RCC_APB1ENR_I2C3EN
 ((
uint32_t
)0x00800000)

	)

5007 #define 
	#RCC_APB1ENR_CAN1EN
 ((
uint32_t
)0x02000000)

	)

5008 #define 
	#RCC_APB1ENR_CAN2EN
 ((
uint32_t
)0x04000000)

	)

5009 #define 
	#RCC_APB1ENR_PWREN
 ((
uint32_t
)0x10000000)

	)

5010 #define 
	#RCC_APB1ENR_DACEN
 ((
uint32_t
)0x20000000)

	)

5013 #define 
	#RCC_APB2ENR_TIM1EN
 ((
uint32_t
)0x00000001)

	)

5014 #define 
	#RCC_APB2ENR_TIM8EN
 ((
uint32_t
)0x00000002)

	)

5015 #define 
	#RCC_APB2ENR_USART1EN
 ((
uint32_t
)0x00000010)

	)

5016 #define 
	#RCC_APB2ENR_USART6EN
 ((
uint32_t
)0x00000020)

	)

5017 #define 
	#RCC_APB2ENR_ADC1EN
 ((
uint32_t
)0x00000100)

	)

5018 #define 
	#RCC_APB2ENR_ADC2EN
 ((
uint32_t
)0x00000200)

	)

5019 #define 
	#RCC_APB2ENR_ADC3EN
 ((
uint32_t
)0x00000400)

	)

5020 #define 
	#RCC_APB2ENR_SDIOEN
 ((
uint32_t
)0x00000800)

	)

5021 #define 
	#RCC_APB2ENR_SPI1EN
 ((
uint32_t
)0x00001000)

	)

5022 #define 
	#RCC_APB2ENR_SYSCFGEN
 ((
uint32_t
)0x00004000)

	)

5023 #define 
	#RCC_APB2ENR_TIM11EN
 ((
uint32_t
)0x00040000)

	)

5024 #define 
	#RCC_APB2ENR_TIM10EN
 ((
uint32_t
)0x00020000)

	)

5025 #define 
	#RCC_APB2ENR_TIM9EN
 ((
uint32_t
)0x00010000)

	)

5028 #define 
	#RCC_AHB1LPENR_GPIOALPEN
 ((
uint32_t
)0x00000001)

	)

5029 #define 
	#RCC_AHB1LPENR_GPIOBLPEN
 ((
uint32_t
)0x00000002)

	)

5030 #define 
	#RCC_AHB1LPENR_GPIOCLPEN
 ((
uint32_t
)0x00000004)

	)

5031 #define 
	#RCC_AHB1LPENR_GPIODLPEN
 ((
uint32_t
)0x00000008)

	)

5032 #define 
	#RCC_AHB1LPENR_GPIOELPEN
 ((
uint32_t
)0x00000010)

	)

5033 #define 
	#RCC_AHB1LPENR_GPIOFLPEN
 ((
uint32_t
)0x00000020)

	)

5034 #define 
	#RCC_AHB1LPENR_GPIOGLPEN
 ((
uint32_t
)0x00000040)

	)

5035 #define 
	#RCC_AHB1LPENR_GPIOHLPEN
 ((
uint32_t
)0x00000080)

	)

5036 #define 
	#RCC_AHB1LPENR_GPIOILPEN
 ((
uint32_t
)0x00000100)

	)

5037 #define 
	#RCC_AHB1LPENR_CRCLPEN
 ((
uint32_t
)0x00001000)

	)

5038 #define 
	#RCC_AHB1LPENR_FLITFLPEN
 ((
uint32_t
)0x00008000)

	)

5039 #define 
	#RCC_AHB1LPENR_SRAM1LPEN
 ((
uint32_t
)0x00010000)

	)

5040 #define 
	#RCC_AHB1LPENR_SRAM2LPEN
 ((
uint32_t
)0x00020000)

	)

5041 #define 
	#RCC_AHB1LPENR_BKPSRAMLPEN
 ((
uint32_t
)0x00040000)

	)

5042 #define 
	#RCC_AHB1LPENR_DMA1LPEN
 ((
uint32_t
)0x00200000)

	)

5043 #define 
	#RCC_AHB1LPENR_DMA2LPEN
 ((
uint32_t
)0x00400000)

	)

5044 #define 
	#RCC_AHB1LPENR_ETHMACLPEN
 ((
uint32_t
)0x02000000)

	)

5045 #define 
	#RCC_AHB1LPENR_ETHMACTXLPEN
 ((
uint32_t
)0x04000000)

	)

5046 #define 
	#RCC_AHB1LPENR_ETHMACRXLPEN
 ((
uint32_t
)0x08000000)

	)

5047 #define 
	#RCC_AHB1LPENR_ETHMACPTPLPEN
 ((
uint32_t
)0x10000000)

	)

5048 #define 
	#RCC_AHB1LPENR_OTGHSLPEN
 ((
uint32_t
)0x20000000)

	)

5049 #define 
	#RCC_AHB1LPENR_OTGHSULPILPEN
 ((
uint32_t
)0x40000000)

	)

5052 #define 
	#RCC_AHB2LPENR_DCMILPEN
 ((
uint32_t
)0x00000001)

	)

5053 #define 
	#RCC_AHB2LPENR_CRYPLPEN
 ((
uint32_t
)0x00000010)

	)

5054 #define 
	#RCC_AHB2LPENR_HASHLPEN
 ((
uint32_t
)0x00000020)

	)

5055 #define 
	#RCC_AHB2LPENR_RNGLPEN
 ((
uint32_t
)0x00000040)

	)

5056 #define 
	#RCC_AHB2LPENR_OTGFSLPEN
 ((
uint32_t
)0x00000080)

	)

5059 #define 
	#RCC_AHB3LPENR_FSMCLPEN
 ((
uint32_t
)0x00000001)

	)

5062 #define 
	#RCC_APB1LPENR_TIM2LPEN
 ((
uint32_t
)0x00000001)

	)

5063 #define 
	#RCC_APB1LPENR_TIM3LPEN
 ((
uint32_t
)0x00000002)

	)

5064 #define 
	#RCC_APB1LPENR_TIM4LPEN
 ((
uint32_t
)0x00000004)

	)

5065 #define 
	#RCC_APB1LPENR_TIM5LPEN
 ((
uint32_t
)0x00000008)

	)

5066 #define 
	#RCC_APB1LPENR_TIM6LPEN
 ((
uint32_t
)0x00000010)

	)

5067 #define 
	#RCC_APB1LPENR_TIM7LPEN
 ((
uint32_t
)0x00000020)

	)

5068 #define 
	#RCC_APB1LPENR_TIM12LPEN
 ((
uint32_t
)0x00000040)

	)

5069 #define 
	#RCC_APB1LPENR_TIM13LPEN
 ((
uint32_t
)0x00000080)

	)

5070 #define 
	#RCC_APB1LPENR_TIM14LPEN
 ((
uint32_t
)0x00000100)

	)

5071 #define 
	#RCC_APB1LPENR_WWDGLPEN
 ((
uint32_t
)0x00000800)

	)

5072 #define 
	#RCC_APB1LPENR_SPI2LPEN
 ((
uint32_t
)0x00004000)

	)

5073 #define 
	#RCC_APB1LPENR_SPI3LPEN
 ((
uint32_t
)0x00008000)

	)

5074 #define 
	#RCC_APB1LPENR_USART2LPEN
 ((
uint32_t
)0x00020000)

	)

5075 #define 
	#RCC_APB1LPENR_USART3LPEN
 ((
uint32_t
)0x00040000)

	)

5076 #define 
	#RCC_APB1LPENR_UART4LPEN
 ((
uint32_t
)0x00080000)

	)

5077 #define 
	#RCC_APB1LPENR_UART5LPEN
 ((
uint32_t
)0x00100000)

	)

5078 #define 
	#RCC_APB1LPENR_I2C1LPEN
 ((
uint32_t
)0x00200000)

	)

5079 #define 
	#RCC_APB1LPENR_I2C2LPEN
 ((
uint32_t
)0x00400000)

	)

5080 #define 
	#RCC_APB1LPENR_I2C3LPEN
 ((
uint32_t
)0x00800000)

	)

5081 #define 
	#RCC_APB1LPENR_CAN1LPEN
 ((
uint32_t
)0x02000000)

	)

5082 #define 
	#RCC_APB1LPENR_CAN2LPEN
 ((
uint32_t
)0x04000000)

	)

5083 #define 
	#RCC_APB1LPENR_PWRLPEN
 ((
uint32_t
)0x10000000)

	)

5084 #define 
	#RCC_APB1LPENR_DACLPEN
 ((
uint32_t
)0x20000000)

	)

5087 #define 
	#RCC_APB2LPENR_TIM1LPEN
 ((
uint32_t
)0x00000001)

	)

5088 #define 
	#RCC_APB2LPENR_TIM8LPEN
 ((
uint32_t
)0x00000002)

	)

5089 #define 
	#RCC_APB2LPENR_USART1LPEN
 ((
uint32_t
)0x00000010)

	)

5090 #define 
	#RCC_APB2LPENR_USART6LPEN
 ((
uint32_t
)0x00000020)

	)

5091 #define 
	#RCC_APB2LPENR_ADC1LPEN
 ((
uint32_t
)0x00000100)

	)

5092 #define 
	#RCC_APB2LPENR_ADC2PEN
 ((
uint32_t
)0x00000200)

	)

5093 #define 
	#RCC_APB2LPENR_ADC3LPEN
 ((
uint32_t
)0x00000400)

	)

5094 #define 
	#RCC_APB2LPENR_SDIOLPEN
 ((
uint32_t
)0x00000800)

	)

5095 #define 
	#RCC_APB2LPENR_SPI1LPEN
 ((
uint32_t
)0x00001000)

	)

5096 #define 
	#RCC_APB2LPENR_SYSCFGLPEN
 ((
uint32_t
)0x00004000)

	)

5097 #define 
	#RCC_APB2LPENR_TIM9LPEN
 ((
uint32_t
)0x00010000)

	)

5098 #define 
	#RCC_APB2LPENR_TIM10LPEN
 ((
uint32_t
)0x00020000)

	)

5099 #define 
	#RCC_APB2LPENR_TIM11LPEN
 ((
uint32_t
)0x00040000)

	)

5102 #define 
	#RCC_BDCR_LSEON
 ((
uint32_t
)0x00000001)

	)

5103 #define 
	#RCC_BDCR_LSERDY
 ((
uint32_t
)0x00000002)

	)

5104 #define 
	#RCC_BDCR_LSEBYP
 ((
uint32_t
)0x00000004)

	)

5106 #define 
	#RCC_BDCR_RTCSEL
 ((
uint32_t
)0x00000300)

	)

5107 #define 
	#RCC_BDCR_RTCSEL_0
 ((
uint32_t
)0x00000100)

	)

5108 #define 
	#RCC_BDCR_RTCSEL_1
 ((
uint32_t
)0x00000200)

	)

5110 #define 
	#RCC_BDCR_RTCEN
 ((
uint32_t
)0x00008000)

	)

5111 #define 
	#RCC_BDCR_BDRST
 ((
uint32_t
)0x00010000)

	)

5114 #define 
	#RCC_CSR_LSION
 ((
uint32_t
)0x00000001)

	)

5115 #define 
	#RCC_CSR_LSIRDY
 ((
uint32_t
)0x00000002)

	)

5116 #define 
	#RCC_CSR_RMVF
 ((
uint32_t
)0x01000000)

	)

5117 #define 
	#RCC_CSR_BORRSTF
 ((
uint32_t
)0x02000000)

	)

5118 #define 
	#RCC_CSR_PADRSTF
 ((
uint32_t
)0x04000000)

	)

5119 #define 
	#RCC_CSR_PORRSTF
 ((
uint32_t
)0x08000000)

	)

5120 #define 
	#RCC_CSR_SFTRSTF
 ((
uint32_t
)0x10000000)

	)

5121 #define 
	#RCC_CSR_WDGRSTF
 ((
uint32_t
)0x20000000)

	)

5122 #define 
	#RCC_CSR_WWDGRSTF
 ((
uint32_t
)0x40000000)

	)

5123 #define 
	#RCC_CSR_LPWRRSTF
 ((
uint32_t
)0x80000000)

	)

5126 #define 
	#RCC_SSCGR_MODPER
 ((
uint32_t
)0x00001FFF)

	)

5127 #define 
	#RCC_SSCGR_INCSTEP
 ((
uint32_t
)0x0FFFE000)

	)

5128 #define 
	#RCC_SSCGR_SPREADSEL
 ((
uint32_t
)0x40000000)

	)

5129 #define 
	#RCC_SSCGR_SSCGEN
 ((
uint32_t
)0x80000000)

	)

5132 #define 
	#RCC_PLLI2SCFGR_PLLI2SN
 ((
uint32_t
)0x00007FC0)

	)

5133 #define 
	#RCC_PLLI2SCFGR_PLLI2SR
 ((
uint32_t
)0x70000000)

	)

5141 #define 
	#RNG_CR_RNGEN
 ((
uint32_t
)0x00000004)

	)

5142 #define 
	#RNG_CR_IE
 ((
uint32_t
)0x00000008)

	)

5145 #define 
	#RNG_SR_DRDY
 ((
uint32_t
)0x00000001)

	)

5146 #define 
	#RNG_SR_CECS
 ((
uint32_t
)0x00000002)

	)

5147 #define 
	#RNG_SR_SECS
 ((
uint32_t
)0x00000004)

	)

5148 #define 
	#RNG_SR_CEIS
 ((
uint32_t
)0x00000020)

	)

5149 #define 
	#RNG_SR_SEIS
 ((
uint32_t
)0x00000040)

	)

5157 #define 
	#RTC_TR_PM
 ((
uint32_t
)0x00400000)

	)

5158 #define 
	#RTC_TR_HT
 ((
uint32_t
)0x00300000)

	)

5159 #define 
	#RTC_TR_HT_0
 ((
uint32_t
)0x00100000)

	)

5160 #define 
	#RTC_TR_HT_1
 ((
uint32_t
)0x00200000)

	)

5161 #define 
	#RTC_TR_HU
 ((
uint32_t
)0x000F0000)

	)

5162 #define 
	#RTC_TR_HU_0
 ((
uint32_t
)0x00010000)

	)

5163 #define 
	#RTC_TR_HU_1
 ((
uint32_t
)0x00020000)

	)

5164 #define 
	#RTC_TR_HU_2
 ((
uint32_t
)0x00040000)

	)

5165 #define 
	#RTC_TR_HU_3
 ((
uint32_t
)0x00080000)

	)

5166 #define 
	#RTC_TR_MNT
 ((
uint32_t
)0x00007000)

	)

5167 #define 
	#RTC_TR_MNT_0
 ((
uint32_t
)0x00001000)

	)

5168 #define 
	#RTC_TR_MNT_1
 ((
uint32_t
)0x00002000)

	)

5169 #define 
	#RTC_TR_MNT_2
 ((
uint32_t
)0x00004000)

	)

5170 #define 
	#RTC_TR_MNU
 ((
uint32_t
)0x00000F00)

	)

5171 #define 
	#RTC_TR_MNU_0
 ((
uint32_t
)0x00000100)

	)

5172 #define 
	#RTC_TR_MNU_1
 ((
uint32_t
)0x00000200)

	)

5173 #define 
	#RTC_TR_MNU_2
 ((
uint32_t
)0x00000400)

	)

5174 #define 
	#RTC_TR_MNU_3
 ((
uint32_t
)0x00000800)

	)

5175 #define 
	#RTC_TR_ST
 ((
uint32_t
)0x00000070)

	)

5176 #define 
	#RTC_TR_ST_0
 ((
uint32_t
)0x00000010)

	)

5177 #define 
	#RTC_TR_ST_1
 ((
uint32_t
)0x00000020)

	)

5178 #define 
	#RTC_TR_ST_2
 ((
uint32_t
)0x00000040)

	)

5179 #define 
	#RTC_TR_SU
 ((
uint32_t
)0x0000000F)

	)

5180 #define 
	#RTC_TR_SU_0
 ((
uint32_t
)0x00000001)

	)

5181 #define 
	#RTC_TR_SU_1
 ((
uint32_t
)0x00000002)

	)

5182 #define 
	#RTC_TR_SU_2
 ((
uint32_t
)0x00000004)

	)

5183 #define 
	#RTC_TR_SU_3
 ((
uint32_t
)0x00000008)

	)

5186 #define 
	#RTC_DR_YT
 ((
uint32_t
)0x00F00000)

	)

5187 #define 
	#RTC_DR_YT_0
 ((
uint32_t
)0x00100000)

	)

5188 #define 
	#RTC_DR_YT_1
 ((
uint32_t
)0x00200000)

	)

5189 #define 
	#RTC_DR_YT_2
 ((
uint32_t
)0x00400000)

	)

5190 #define 
	#RTC_DR_YT_3
 ((
uint32_t
)0x00800000)

	)

5191 #define 
	#RTC_DR_YU
 ((
uint32_t
)0x000F0000)

	)

5192 #define 
	#RTC_DR_YU_0
 ((
uint32_t
)0x00010000)

	)

5193 #define 
	#RTC_DR_YU_1
 ((
uint32_t
)0x00020000)

	)

5194 #define 
	#RTC_DR_YU_2
 ((
uint32_t
)0x00040000)

	)

5195 #define 
	#RTC_DR_YU_3
 ((
uint32_t
)0x00080000)

	)

5196 #define 
	#RTC_DR_WDU
 ((
uint32_t
)0x0000E000)

	)

5197 #define 
	#RTC_DR_WDU_0
 ((
uint32_t
)0x00002000)

	)

5198 #define 
	#RTC_DR_WDU_1
 ((
uint32_t
)0x00004000)

	)

5199 #define 
	#RTC_DR_WDU_2
 ((
uint32_t
)0x00008000)

	)

5200 #define 
	#RTC_DR_MT
 ((
uint32_t
)0x00001000)

	)

5201 #define 
	#RTC_DR_MU
 ((
uint32_t
)0x00000F00)

	)

5202 #define 
	#RTC_DR_MU_0
 ((
uint32_t
)0x00000100)

	)

5203 #define 
	#RTC_DR_MU_1
 ((
uint32_t
)0x00000200)

	)

5204 #define 
	#RTC_DR_MU_2
 ((
uint32_t
)0x00000400)

	)

5205 #define 
	#RTC_DR_MU_3
 ((
uint32_t
)0x00000800)

	)

5206 #define 
	#RTC_DR_DT
 ((
uint32_t
)0x00000030)

	)

5207 #define 
	#RTC_DR_DT_0
 ((
uint32_t
)0x00000010)

	)

5208 #define 
	#RTC_DR_DT_1
 ((
uint32_t
)0x00000020)

	)

5209 #define 
	#RTC_DR_DU
 ((
uint32_t
)0x0000000F)

	)

5210 #define 
	#RTC_DR_DU_0
 ((
uint32_t
)0x00000001)

	)

5211 #define 
	#RTC_DR_DU_1
 ((
uint32_t
)0x00000002)

	)

5212 #define 
	#RTC_DR_DU_2
 ((
uint32_t
)0x00000004)

	)

5213 #define 
	#RTC_DR_DU_3
 ((
uint32_t
)0x00000008)

	)

5216 #define 
	#RTC_CR_COE
 ((
uint32_t
)0x00800000)

	)

5217 #define 
	#RTC_CR_OSEL
 ((
uint32_t
)0x00600000)

	)

5218 #define 
	#RTC_CR_OSEL_0
 ((
uint32_t
)0x00200000)

	)

5219 #define 
	#RTC_CR_OSEL_1
 ((
uint32_t
)0x00400000)

	)

5220 #define 
	#RTC_CR_POL
 ((
uint32_t
)0x00100000)

	)

5221 #define 
	#RTC_CR_COSEL
 ((
uint32_t
)0x00080000)

	)

5222 #define 
	#RTC_CR_BCK
 ((
uint32_t
)0x00040000)

	)

5223 #define 
	#RTC_CR_SUB1H
 ((
uint32_t
)0x00020000)

	)

5224 #define 
	#RTC_CR_ADD1H
 ((
uint32_t
)0x00010000)

	)

5225 #define 
	#RTC_CR_TSIE
 ((
uint32_t
)0x00008000)

	)

5226 #define 
	#RTC_CR_WUTIE
 ((
uint32_t
)0x00004000)

	)

5227 #define 
	#RTC_CR_ALRBIE
 ((
uint32_t
)0x00002000)

	)

5228 #define 
	#RTC_CR_ALRAIE
 ((
uint32_t
)0x00001000)

	)

5229 #define 
	#RTC_CR_TSE
 ((
uint32_t
)0x00000800)

	)

5230 #define 
	#RTC_CR_WUTE
 ((
uint32_t
)0x00000400)

	)

5231 #define 
	#RTC_CR_ALRBE
 ((
uint32_t
)0x00000200)

	)

5232 #define 
	#RTC_CR_ALRAE
 ((
uint32_t
)0x00000100)

	)

5233 #define 
	#RTC_CR_DCE
 ((
uint32_t
)0x00000080)

	)

5234 #define 
	#RTC_CR_FMT
 ((
uint32_t
)0x00000040)

	)

5235 #define 
	#RTC_CR_BYPSHAD
 ((
uint32_t
)0x00000020)

	)

5236 #define 
	#RTC_CR_REFCKON
 ((
uint32_t
)0x00000010)

	)

5237 #define 
	#RTC_CR_TSEDGE
 ((
uint32_t
)0x00000008)

	)

5238 #define 
	#RTC_CR_WUCKSEL
 ((
uint32_t
)0x00000007)

	)

5239 #define 
	#RTC_CR_WUCKSEL_0
 ((
uint32_t
)0x00000001)

	)

5240 #define 
	#RTC_CR_WUCKSEL_1
 ((
uint32_t
)0x00000002)

	)

5241 #define 
	#RTC_CR_WUCKSEL_2
 ((
uint32_t
)0x00000004)

	)

5244 #define 
	#RTC_ISR_RECALPF
 ((
uint32_t
)0x00010000)

	)

5245 #define 
	#RTC_ISR_TAMP1F
 ((
uint32_t
)0x00002000)

	)

5246 #define 
	#RTC_ISR_TSOVF
 ((
uint32_t
)0x00001000)

	)

5247 #define 
	#RTC_ISR_TSF
 ((
uint32_t
)0x00000800)

	)

5248 #define 
	#RTC_ISR_WUTF
 ((
uint32_t
)0x00000400)

	)

5249 #define 
	#RTC_ISR_ALRBF
 ((
uint32_t
)0x00000200)

	)

5250 #define 
	#RTC_ISR_ALRAF
 ((
uint32_t
)0x00000100)

	)

5251 #define 
	#RTC_ISR_INIT
 ((
uint32_t
)0x00000080)

	)

5252 #define 
	#RTC_ISR_INITF
 ((
uint32_t
)0x00000040)

	)

5253 #define 
	#RTC_ISR_RSF
 ((
uint32_t
)0x00000020)

	)

5254 #define 
	#RTC_ISR_INITS
 ((
uint32_t
)0x00000010)

	)

5255 #define 
	#RTC_ISR_SHPF
 ((
uint32_t
)0x00000008)

	)

5256 #define 
	#RTC_ISR_WUTWF
 ((
uint32_t
)0x00000004)

	)

5257 #define 
	#RTC_ISR_ALRBWF
 ((
uint32_t
)0x00000002)

	)

5258 #define 
	#RTC_ISR_ALRAWF
 ((
uint32_t
)0x00000001)

	)

5261 #define 
	#RTC_PRER_PREDIV_A
 ((
uint32_t
)0x007F0000)

	)

5262 #define 
	#RTC_PRER_PREDIV_S
 ((
uint32_t
)0x00001FFF)

	)

5265 #define 
	#RTC_WUTR_WUT
 ((
uint32_t
)0x0000FFFF)

	)

5268 #define 
	#RTC_CALIBR_DCS
 ((
uint32_t
)0x00000080)

	)

5269 #define 
	#RTC_CALIBR_DC
 ((
uint32_t
)0x0000001F)

	)

5272 #define 
	#RTC_ALRMAR_MSK4
 ((
uint32_t
)0x80000000)

	)

5273 #define 
	#RTC_ALRMAR_WDSEL
 ((
uint32_t
)0x40000000)

	)

5274 #define 
	#RTC_ALRMAR_DT
 ((
uint32_t
)0x30000000)

	)

5275 #define 
	#RTC_ALRMAR_DT_0
 ((
uint32_t
)0x10000000)

	)

5276 #define 
	#RTC_ALRMAR_DT_1
 ((
uint32_t
)0x20000000)

	)

5277 #define 
	#RTC_ALRMAR_DU
 ((
uint32_t
)0x0F000000)

	)

5278 #define 
	#RTC_ALRMAR_DU_0
 ((
uint32_t
)0x01000000)

	)

5279 #define 
	#RTC_ALRMAR_DU_1
 ((
uint32_t
)0x02000000)

	)

5280 #define 
	#RTC_ALRMAR_DU_2
 ((
uint32_t
)0x04000000)

	)

5281 #define 
	#RTC_ALRMAR_DU_3
 ((
uint32_t
)0x08000000)

	)

5282 #define 
	#RTC_ALRMAR_MSK3
 ((
uint32_t
)0x00800000)

	)

5283 #define 
	#RTC_ALRMAR_PM
 ((
uint32_t
)0x00400000)

	)

5284 #define 
	#RTC_ALRMAR_HT
 ((
uint32_t
)0x00300000)

	)

5285 #define 
	#RTC_ALRMAR_HT_0
 ((
uint32_t
)0x00100000)

	)

5286 #define 
	#RTC_ALRMAR_HT_1
 ((
uint32_t
)0x00200000)

	)

5287 #define 
	#RTC_ALRMAR_HU
 ((
uint32_t
)0x000F0000)

	)

5288 #define 
	#RTC_ALRMAR_HU_0
 ((
uint32_t
)0x00010000)

	)

5289 #define 
	#RTC_ALRMAR_HU_1
 ((
uint32_t
)0x00020000)

	)

5290 #define 
	#RTC_ALRMAR_HU_2
 ((
uint32_t
)0x00040000)

	)

5291 #define 
	#RTC_ALRMAR_HU_3
 ((
uint32_t
)0x00080000)

	)

5292 #define 
	#RTC_ALRMAR_MSK2
 ((
uint32_t
)0x00008000)

	)

5293 #define 
	#RTC_ALRMAR_MNT
 ((
uint32_t
)0x00007000)

	)

5294 #define 
	#RTC_ALRMAR_MNT_0
 ((
uint32_t
)0x00001000)

	)

5295 #define 
	#RTC_ALRMAR_MNT_1
 ((
uint32_t
)0x00002000)

	)

5296 #define 
	#RTC_ALRMAR_MNT_2
 ((
uint32_t
)0x00004000)

	)

5297 #define 
	#RTC_ALRMAR_MNU
 ((
uint32_t
)0x00000F00)

	)

5298 #define 
	#RTC_ALRMAR_MNU_0
 ((
uint32_t
)0x00000100)

	)

5299 #define 
	#RTC_ALRMAR_MNU_1
 ((
uint32_t
)0x00000200)

	)

5300 #define 
	#RTC_ALRMAR_MNU_2
 ((
uint32_t
)0x00000400)

	)

5301 #define 
	#RTC_ALRMAR_MNU_3
 ((
uint32_t
)0x00000800)

	)

5302 #define 
	#RTC_ALRMAR_MSK1
 ((
uint32_t
)0x00000080)

	)

5303 #define 
	#RTC_ALRMAR_ST
 ((
uint32_t
)0x00000070)

	)

5304 #define 
	#RTC_ALRMAR_ST_0
 ((
uint32_t
)0x00000010)

	)

5305 #define 
	#RTC_ALRMAR_ST_1
 ((
uint32_t
)0x00000020)

	)

5306 #define 
	#RTC_ALRMAR_ST_2
 ((
uint32_t
)0x00000040)

	)

5307 #define 
	#RTC_ALRMAR_SU
 ((
uint32_t
)0x0000000F)

	)

5308 #define 
	#RTC_ALRMAR_SU_0
 ((
uint32_t
)0x00000001)

	)

5309 #define 
	#RTC_ALRMAR_SU_1
 ((
uint32_t
)0x00000002)

	)

5310 #define 
	#RTC_ALRMAR_SU_2
 ((
uint32_t
)0x00000004)

	)

5311 #define 
	#RTC_ALRMAR_SU_3
 ((
uint32_t
)0x00000008)

	)

5314 #define 
	#RTC_ALRMBR_MSK4
 ((
uint32_t
)0x80000000)

	)

5315 #define 
	#RTC_ALRMBR_WDSEL
 ((
uint32_t
)0x40000000)

	)

5316 #define 
	#RTC_ALRMBR_DT
 ((
uint32_t
)0x30000000)

	)

5317 #define 
	#RTC_ALRMBR_DT_0
 ((
uint32_t
)0x10000000)

	)

5318 #define 
	#RTC_ALRMBR_DT_1
 ((
uint32_t
)0x20000000)

	)

5319 #define 
	#RTC_ALRMBR_DU
 ((
uint32_t
)0x0F000000)

	)

5320 #define 
	#RTC_ALRMBR_DU_0
 ((
uint32_t
)0x01000000)

	)

5321 #define 
	#RTC_ALRMBR_DU_1
 ((
uint32_t
)0x02000000)

	)

5322 #define 
	#RTC_ALRMBR_DU_2
 ((
uint32_t
)0x04000000)

	)

5323 #define 
	#RTC_ALRMBR_DU_3
 ((
uint32_t
)0x08000000)

	)

5324 #define 
	#RTC_ALRMBR_MSK3
 ((
uint32_t
)0x00800000)

	)

5325 #define 
	#RTC_ALRMBR_PM
 ((
uint32_t
)0x00400000)

	)

5326 #define 
	#RTC_ALRMBR_HT
 ((
uint32_t
)0x00300000)

	)

5327 #define 
	#RTC_ALRMBR_HT_0
 ((
uint32_t
)0x00100000)

	)

5328 #define 
	#RTC_ALRMBR_HT_1
 ((
uint32_t
)0x00200000)

	)

5329 #define 
	#RTC_ALRMBR_HU
 ((
uint32_t
)0x000F0000)

	)

5330 #define 
	#RTC_ALRMBR_HU_0
 ((
uint32_t
)0x00010000)

	)

5331 #define 
	#RTC_ALRMBR_HU_1
 ((
uint32_t
)0x00020000)

	)

5332 #define 
	#RTC_ALRMBR_HU_2
 ((
uint32_t
)0x00040000)

	)

5333 #define 
	#RTC_ALRMBR_HU_3
 ((
uint32_t
)0x00080000)

	)

5334 #define 
	#RTC_ALRMBR_MSK2
 ((
uint32_t
)0x00008000)

	)

5335 #define 
	#RTC_ALRMBR_MNT
 ((
uint32_t
)0x00007000)

	)

5336 #define 
	#RTC_ALRMBR_MNT_0
 ((
uint32_t
)0x00001000)

	)

5337 #define 
	#RTC_ALRMBR_MNT_1
 ((
uint32_t
)0x00002000)

	)

5338 #define 
	#RTC_ALRMBR_MNT_2
 ((
uint32_t
)0x00004000)

	)

5339 #define 
	#RTC_ALRMBR_MNU
 ((
uint32_t
)0x00000F00)

	)

5340 #define 
	#RTC_ALRMBR_MNU_0
 ((
uint32_t
)0x00000100)

	)

5341 #define 
	#RTC_ALRMBR_MNU_1
 ((
uint32_t
)0x00000200)

	)

5342 #define 
	#RTC_ALRMBR_MNU_2
 ((
uint32_t
)0x00000400)

	)

5343 #define 
	#RTC_ALRMBR_MNU_3
 ((
uint32_t
)0x00000800)

	)

5344 #define 
	#RTC_ALRMBR_MSK1
 ((
uint32_t
)0x00000080)

	)

5345 #define 
	#RTC_ALRMBR_ST
 ((
uint32_t
)0x00000070)

	)

5346 #define 
	#RTC_ALRMBR_ST_0
 ((
uint32_t
)0x00000010)

	)

5347 #define 
	#RTC_ALRMBR_ST_1
 ((
uint32_t
)0x00000020)

	)

5348 #define 
	#RTC_ALRMBR_ST_2
 ((
uint32_t
)0x00000040)

	)

5349 #define 
	#RTC_ALRMBR_SU
 ((
uint32_t
)0x0000000F)

	)

5350 #define 
	#RTC_ALRMBR_SU_0
 ((
uint32_t
)0x00000001)

	)

5351 #define 
	#RTC_ALRMBR_SU_1
 ((
uint32_t
)0x00000002)

	)

5352 #define 
	#RTC_ALRMBR_SU_2
 ((
uint32_t
)0x00000004)

	)

5353 #define 
	#RTC_ALRMBR_SU_3
 ((
uint32_t
)0x00000008)

	)

5356 #define 
	#RTC_WPR_KEY
 ((
uint32_t
)0x000000FF)

	)

5359 #define 
	#RTC_SSR_SS
 ((
uint32_t
)0x0000FFFF)

	)

5362 #define 
	#RTC_SHIFTR_SUBFS
 ((
uint32_t
)0x00007FFF)

	)

5363 #define 
	#RTC_SHIFTR_ADD1S
 ((
uint32_t
)0x80000000)

	)

5366 #define 
	#RTC_TSTR_PM
 ((
uint32_t
)0x00400000)

	)

5367 #define 
	#RTC_TSTR_HT
 ((
uint32_t
)0x00300000)

	)

5368 #define 
	#RTC_TSTR_HT_0
 ((
uint32_t
)0x00100000)

	)

5369 #define 
	#RTC_TSTR_HT_1
 ((
uint32_t
)0x00200000)

	)

5370 #define 
	#RTC_TSTR_HU
 ((
uint32_t
)0x000F0000)

	)

5371 #define 
	#RTC_TSTR_HU_0
 ((
uint32_t
)0x00010000)

	)

5372 #define 
	#RTC_TSTR_HU_1
 ((
uint32_t
)0x00020000)

	)

5373 #define 
	#RTC_TSTR_HU_2
 ((
uint32_t
)0x00040000)

	)

5374 #define 
	#RTC_TSTR_HU_3
 ((
uint32_t
)0x00080000)

	)

5375 #define 
	#RTC_TSTR_MNT
 ((
uint32_t
)0x00007000)

	)

5376 #define 
	#RTC_TSTR_MNT_0
 ((
uint32_t
)0x00001000)

	)

5377 #define 
	#RTC_TSTR_MNT_1
 ((
uint32_t
)0x00002000)

	)

5378 #define 
	#RTC_TSTR_MNT_2
 ((
uint32_t
)0x00004000)

	)

5379 #define 
	#RTC_TSTR_MNU
 ((
uint32_t
)0x00000F00)

	)

5380 #define 
	#RTC_TSTR_MNU_0
 ((
uint32_t
)0x00000100)

	)

5381 #define 
	#RTC_TSTR_MNU_1
 ((
uint32_t
)0x00000200)

	)

5382 #define 
	#RTC_TSTR_MNU_2
 ((
uint32_t
)0x00000400)

	)

5383 #define 
	#RTC_TSTR_MNU_3
 ((
uint32_t
)0x00000800)

	)

5384 #define 
	#RTC_TSTR_ST
 ((
uint32_t
)0x00000070)

	)

5385 #define 
	#RTC_TSTR_ST_0
 ((
uint32_t
)0x00000010)

	)

5386 #define 
	#RTC_TSTR_ST_1
 ((
uint32_t
)0x00000020)

	)

5387 #define 
	#RTC_TSTR_ST_2
 ((
uint32_t
)0x00000040)

	)

5388 #define 
	#RTC_TSTR_SU
 ((
uint32_t
)0x0000000F)

	)

5389 #define 
	#RTC_TSTR_SU_0
 ((
uint32_t
)0x00000001)

	)

5390 #define 
	#RTC_TSTR_SU_1
 ((
uint32_t
)0x00000002)

	)

5391 #define 
	#RTC_TSTR_SU_2
 ((
uint32_t
)0x00000004)

	)

5392 #define 
	#RTC_TSTR_SU_3
 ((
uint32_t
)0x00000008)

	)

5395 #define 
	#RTC_TSDR_WDU
 ((
uint32_t
)0x0000E000)

	)

5396 #define 
	#RTC_TSDR_WDU_0
 ((
uint32_t
)0x00002000)

	)

5397 #define 
	#RTC_TSDR_WDU_1
 ((
uint32_t
)0x00004000)

	)

5398 #define 
	#RTC_TSDR_WDU_2
 ((
uint32_t
)0x00008000)

	)

5399 #define 
	#RTC_TSDR_MT
 ((
uint32_t
)0x00001000)

	)

5400 #define 
	#RTC_TSDR_MU
 ((
uint32_t
)0x00000F00)

	)

5401 #define 
	#RTC_TSDR_MU_0
 ((
uint32_t
)0x00000100)

	)

5402 #define 
	#RTC_TSDR_MU_1
 ((
uint32_t
)0x00000200)

	)

5403 #define 
	#RTC_TSDR_MU_2
 ((
uint32_t
)0x00000400)

	)

5404 #define 
	#RTC_TSDR_MU_3
 ((
uint32_t
)0x00000800)

	)

5405 #define 
	#RTC_TSDR_DT
 ((
uint32_t
)0x00000030)

	)

5406 #define 
	#RTC_TSDR_DT_0
 ((
uint32_t
)0x00000010)

	)

5407 #define 
	#RTC_TSDR_DT_1
 ((
uint32_t
)0x00000020)

	)

5408 #define 
	#RTC_TSDR_DU
 ((
uint32_t
)0x0000000F)

	)

5409 #define 
	#RTC_TSDR_DU_0
 ((
uint32_t
)0x00000001)

	)

5410 #define 
	#RTC_TSDR_DU_1
 ((
uint32_t
)0x00000002)

	)

5411 #define 
	#RTC_TSDR_DU_2
 ((
uint32_t
)0x00000004)

	)

5412 #define 
	#RTC_TSDR_DU_3
 ((
uint32_t
)0x00000008)

	)

5415 #define 
	#RTC_TSSSR_SS
 ((
uint32_t
)0x0000FFFF)

	)

5418 #define 
	#RTC_CALR_CALP
 ((
uint32_t
)0x00008000)

	)

5419 #define 
	#RTC_CALR_CALW8
 ((
uint32_t
)0x00004000)

	)

5420 #define 
	#RTC_CALR_CALW16
 ((
uint32_t
)0x00002000)

	)

5421 #define 
	#RTC_CALR_CALM
 ((
uint32_t
)0x000001FF)

	)

5422 #define 
	#RTC_CALR_CALM_0
 ((
uint32_t
)0x00000001)

	)

5423 #define 
	#RTC_CALR_CALM_1
 ((
uint32_t
)0x00000002)

	)

5424 #define 
	#RTC_CALR_CALM_2
 ((
uint32_t
)0x00000004)

	)

5425 #define 
	#RTC_CALR_CALM_3
 ((
uint32_t
)0x00000008)

	)

5426 #define 
	#RTC_CALR_CALM_4
 ((
uint32_t
)0x00000010)

	)

5427 #define 
	#RTC_CALR_CALM_5
 ((
uint32_t
)0x00000020)

	)

5428 #define 
	#RTC_CALR_CALM_6
 ((
uint32_t
)0x00000040)

	)

5429 #define 
	#RTC_CALR_CALM_7
 ((
uint32_t
)0x00000080)

	)

5430 #define 
	#RTC_CALR_CALM_8
 ((
uint32_t
)0x00000100)

	)

5433 #define 
	#RTC_TAFCR_ALARMOUTTYPE
 ((
uint32_t
)0x00040000)

	)

5434 #define 
	#RTC_TAFCR_TSINSEL
 ((
uint32_t
)0x00020000)

	)

5435 #define 
	#RTC_TAFCR_TAMPINSEL
 ((
uint32_t
)0x00010000)

	)

5436 #define 
	#RTC_TAFCR_TAMPPUDIS
 ((
uint32_t
)0x00008000)

	)

5437 #define 
	#RTC_TAFCR_TAMPPRCH
 ((
uint32_t
)0x00006000)

	)

5438 #define 
	#RTC_TAFCR_TAMPPRCH_0
 ((
uint32_t
)0x00002000)

	)

5439 #define 
	#RTC_TAFCR_TAMPPRCH_1
 ((
uint32_t
)0x00004000)

	)

5440 #define 
	#RTC_TAFCR_TAMPFLT
 ((
uint32_t
)0x00001800)

	)

5441 #define 
	#RTC_TAFCR_TAMPFLT_0
 ((
uint32_t
)0x00000800)

	)

5442 #define 
	#RTC_TAFCR_TAMPFLT_1
 ((
uint32_t
)0x00001000)

	)

5443 #define 
	#RTC_TAFCR_TAMPFREQ
 ((
uint32_t
)0x00000700)

	)

5444 #define 
	#RTC_TAFCR_TAMPFREQ_0
 ((
uint32_t
)0x00000100)

	)

5445 #define 
	#RTC_TAFCR_TAMPFREQ_1
 ((
uint32_t
)0x00000200)

	)

5446 #define 
	#RTC_TAFCR_TAMPFREQ_2
 ((
uint32_t
)0x00000400)

	)

5447 #define 
	#RTC_TAFCR_TAMPTS
 ((
uint32_t
)0x00000080)

	)

5448 #define 
	#RTC_TAFCR_TAMPIE
 ((
uint32_t
)0x00000004)

	)

5449 #define 
	#RTC_TAFCR_TAMP1TRG
 ((
uint32_t
)0x00000002)

	)

5450 #define 
	#RTC_TAFCR_TAMP1E
 ((
uint32_t
)0x00000001)

	)

5453 #define 
	#RTC_ALRMASSR_MASKSS
 ((
uint32_t
)0x0F000000)

	)

5454 #define 
	#RTC_ALRMASSR_MASKSS_0
 ((
uint32_t
)0x01000000)

	)

5455 #define 
	#RTC_ALRMASSR_MASKSS_1
 ((
uint32_t
)0x02000000)

	)

5456 #define 
	#RTC_ALRMASSR_MASKSS_2
 ((
uint32_t
)0x04000000)

	)

5457 #define 
	#RTC_ALRMASSR_MASKSS_3
 ((
uint32_t
)0x08000000)

	)

5458 #define 
	#RTC_ALRMASSR_SS
 ((
uint32_t
)0x00007FFF)

	)

5461 #define 
	#RTC_ALRMBSSR_MASKSS
 ((
uint32_t
)0x0F000000)

	)

5462 #define 
	#RTC_ALRMBSSR_MASKSS_0
 ((
uint32_t
)0x01000000)

	)

5463 #define 
	#RTC_ALRMBSSR_MASKSS_1
 ((
uint32_t
)0x02000000)

	)

5464 #define 
	#RTC_ALRMBSSR_MASKSS_2
 ((
uint32_t
)0x04000000)

	)

5465 #define 
	#RTC_ALRMBSSR_MASKSS_3
 ((
uint32_t
)0x08000000)

	)

5466 #define 
	#RTC_ALRMBSSR_SS
 ((
uint32_t
)0x00007FFF)

	)

5469 #define 
	#RTC_BKP0R
 ((
uint32_t
)0xFFFFFFFF)

	)

5472 #define 
	#RTC_BKP1R
 ((
uint32_t
)0xFFFFFFFF)

	)

5475 #define 
	#RTC_BKP2R
 ((
uint32_t
)0xFFFFFFFF)

	)

5478 #define 
	#RTC_BKP3R
 ((
uint32_t
)0xFFFFFFFF)

	)

5481 #define 
	#RTC_BKP4R
 ((
uint32_t
)0xFFFFFFFF)

	)

5484 #define 
	#RTC_BKP5R
 ((
uint32_t
)0xFFFFFFFF)

	)

5487 #define 
	#RTC_BKP6R
 ((
uint32_t
)0xFFFFFFFF)

	)

5490 #define 
	#RTC_BKP7R
 ((
uint32_t
)0xFFFFFFFF)

	)

5493 #define 
	#RTC_BKP8R
 ((
uint32_t
)0xFFFFFFFF)

	)

5496 #define 
	#RTC_BKP9R
 ((
uint32_t
)0xFFFFFFFF)

	)

5499 #define 
	#RTC_BKP10R
 ((
uint32_t
)0xFFFFFFFF)

	)

5502 #define 
	#RTC_BKP11R
 ((
uint32_t
)0xFFFFFFFF)

	)

5505 #define 
	#RTC_BKP12R
 ((
uint32_t
)0xFFFFFFFF)

	)

5508 #define 
	#RTC_BKP13R
 ((
uint32_t
)0xFFFFFFFF)

	)

5511 #define 
	#RTC_BKP14R
 ((
uint32_t
)0xFFFFFFFF)

	)

5514 #define 
	#RTC_BKP15R
 ((
uint32_t
)0xFFFFFFFF)

	)

5517 #define 
	#RTC_BKP16R
 ((
uint32_t
)0xFFFFFFFF)

	)

5520 #define 
	#RTC_BKP17R
 ((
uint32_t
)0xFFFFFFFF)

	)

5523 #define 
	#RTC_BKP18R
 ((
uint32_t
)0xFFFFFFFF)

	)

5526 #define 
	#RTC_BKP19R
 ((
uint32_t
)0xFFFFFFFF)

	)

5534 #define 
	#SDIO_POWER_PWRCTRL
 ((
uint8_t
)0x03)

	)

5535 #define 
	#SDIO_POWER_PWRCTRL_0
 ((
uint8_t
)0x01)

	)

5536 #define 
	#SDIO_POWER_PWRCTRL_1
 ((
uint8_t
)0x02)

	)

5539 #define 
	#SDIO_CLKCR_CLKDIV
 ((
uint16_t
)0x00FF)

	)

5540 #define 
	#SDIO_CLKCR_CLKEN
 ((
uint16_t
)0x0100)

	)

5541 #define 
	#SDIO_CLKCR_PWRSAV
 ((
uint16_t
)0x0200)

	)

5542 #define 
	#SDIO_CLKCR_BYPASS
 ((
uint16_t
)0x0400)

	)

5544 #define 
	#SDIO_CLKCR_WIDBUS
 ((
uint16_t
)0x1800)

	)

5545 #define 
	#SDIO_CLKCR_WIDBUS_0
 ((
uint16_t
)0x0800)

	)

5546 #define 
	#SDIO_CLKCR_WIDBUS_1
 ((
uint16_t
)0x1000)

	)

5548 #define 
	#SDIO_CLKCR_NEGEDGE
 ((
uint16_t
)0x2000)

	)

5549 #define 
	#SDIO_CLKCR_HWFC_EN
 ((
uint16_t
)0x4000)

	)

5552 #define 
	#SDIO_ARG_CMDARG
 ((
uint32_t
)0xFFFFFFFF)

	)

5555 #define 
	#SDIO_CMD_CMDINDEX
 ((
uint16_t
)0x003F)

	)

5557 #define 
	#SDIO_CMD_WAITRESP
 ((
uint16_t
)0x00C0)

	)

5558 #define 
	#SDIO_CMD_WAITRESP_0
 ((
uint16_t
)0x0040)

	)

5559 #define 
	#SDIO_CMD_WAITRESP_1
 ((
uint16_t
)0x0080)

	)

5561 #define 
	#SDIO_CMD_WAITINT
 ((
uint16_t
)0x0100)

	)

5562 #define 
	#SDIO_CMD_WAITPEND
 ((
uint16_t
)0x0200)

	)

5563 #define 
	#SDIO_CMD_CPSMEN
 ((
uint16_t
)0x0400)

	)

5564 #define 
	#SDIO_CMD_SDIOSUSPEND
 ((
uint16_t
)0x0800)

	)

5565 #define 
	#SDIO_CMD_ENCMDCOMPL
 ((
uint16_t
)0x1000)

	)

5566 #define 
	#SDIO_CMD_NIEN
 ((
uint16_t
)0x2000)

	)

5567 #define 
	#SDIO_CMD_CEATACMD
 ((
uint16_t
)0x4000)

	)

5570 #define 
	#SDIO_RESPCMD_RESPCMD
 ((
uint8_t
)0x3F)

	)

5573 #define 
	#SDIO_RESP0_CARDSTATUS0
 ((
uint32_t
)0xFFFFFFFF)

	)

5576 #define 
	#SDIO_RESP1_CARDSTATUS1
 ((
uint32_t
)0xFFFFFFFF)

	)

5579 #define 
	#SDIO_RESP2_CARDSTATUS2
 ((
uint32_t
)0xFFFFFFFF)

	)

5582 #define 
	#SDIO_RESP3_CARDSTATUS3
 ((
uint32_t
)0xFFFFFFFF)

	)

5585 #define 
	#SDIO_RESP4_CARDSTATUS4
 ((
uint32_t
)0xFFFFFFFF)

	)

5588 #define 
	#SDIO_DTIMER_DATATIME
 ((
uint32_t
)0xFFFFFFFF)

	)

5591 #define 
	#SDIO_DLEN_DATALENGTH
 ((
uint32_t
)0x01FFFFFF)

	)

5594 #define 
	#SDIO_DCTRL_DTEN
 ((
uint16_t
)0x0001)

	)

5595 #define 
	#SDIO_DCTRL_DTDIR
 ((
uint16_t
)0x0002)

	)

5596 #define 
	#SDIO_DCTRL_DTMODE
 ((
uint16_t
)0x0004)

	)

5597 #define 
	#SDIO_DCTRL_DMAEN
 ((
uint16_t
)0x0008)

	)

5599 #define 
	#SDIO_DCTRL_DBLOCKSIZE
 ((
uint16_t
)0x00F0)

	)

5600 #define 
	#SDIO_DCTRL_DBLOCKSIZE_0
 ((
uint16_t
)0x0010)

	)

5601 #define 
	#SDIO_DCTRL_DBLOCKSIZE_1
 ((
uint16_t
)0x0020)

	)

5602 #define 
	#SDIO_DCTRL_DBLOCKSIZE_2
 ((
uint16_t
)0x0040)

	)

5603 #define 
	#SDIO_DCTRL_DBLOCKSIZE_3
 ((
uint16_t
)0x0080)

	)

5605 #define 
	#SDIO_DCTRL_RWSTART
 ((
uint16_t
)0x0100)

	)

5606 #define 
	#SDIO_DCTRL_RWSTOP
 ((
uint16_t
)0x0200)

	)

5607 #define 
	#SDIO_DCTRL_RWMOD
 ((
uint16_t
)0x0400)

	)

5608 #define 
	#SDIO_DCTRL_SDIOEN
 ((
uint16_t
)0x0800)

	)

5611 #define 
	#SDIO_DCOUNT_DATACOUNT
 ((
uint32_t
)0x01FFFFFF)

	)

5614 #define 
	#SDIO_STA_CCRCFAIL
 ((
uint32_t
)0x00000001)

	)

5615 #define 
	#SDIO_STA_DCRCFAIL
 ((
uint32_t
)0x00000002)

	)

5616 #define 
	#SDIO_STA_CTIMEOUT
 ((
uint32_t
)0x00000004)

	)

5617 #define 
	#SDIO_STA_DTIMEOUT
 ((
uint32_t
)0x00000008)

	)

5618 #define 
	#SDIO_STA_TXUNDERR
 ((
uint32_t
)0x00000010)

	)

5619 #define 
	#SDIO_STA_RXOVERR
 ((
uint32_t
)0x00000020)

	)

5620 #define 
	#SDIO_STA_CMDREND
 ((
uint32_t
)0x00000040)

	)

5621 #define 
	#SDIO_STA_CMDSENT
 ((
uint32_t
)0x00000080)

	)

5622 #define 
	#SDIO_STA_DATAEND
 ((
uint32_t
)0x00000100)

	)

5623 #define 
	#SDIO_STA_STBITERR
 ((
uint32_t
)0x00000200)

	)

5624 #define 
	#SDIO_STA_DBCKEND
 ((
uint32_t
)0x00000400)

	)

5625 #define 
	#SDIO_STA_CMDACT
 ((
uint32_t
)0x00000800)

	)

5626 #define 
	#SDIO_STA_TXACT
 ((
uint32_t
)0x00001000)

	)

5627 #define 
	#SDIO_STA_RXACT
 ((
uint32_t
)0x00002000)

	)

5628 #define 
	#SDIO_STA_TXFIFOHE
 ((
uint32_t
)0x00004000)

	)

5629 #define 
	#SDIO_STA_RXFIFOHF
 ((
uint32_t
)0x00008000)

	)

5630 #define 
	#SDIO_STA_TXFIFOF
 ((
uint32_t
)0x00010000)

	)

5631 #define 
	#SDIO_STA_RXFIFOF
 ((
uint32_t
)0x00020000)

	)

5632 #define 
	#SDIO_STA_TXFIFOE
 ((
uint32_t
)0x00040000)

	)

5633 #define 
	#SDIO_STA_RXFIFOE
 ((
uint32_t
)0x00080000)

	)

5634 #define 
	#SDIO_STA_TXDAVL
 ((
uint32_t
)0x00100000)

	)

5635 #define 
	#SDIO_STA_RXDAVL
 ((
uint32_t
)0x00200000)

	)

5636 #define 
	#SDIO_STA_SDIOIT
 ((
uint32_t
)0x00400000)

	)

5637 #define 
	#SDIO_STA_CEATAEND
 ((
uint32_t
)0x00800000)

	)

5640 #define 
	#SDIO_ICR_CCRCFAILC
 ((
uint32_t
)0x00000001)

	)

5641 #define 
	#SDIO_ICR_DCRCFAILC
 ((
uint32_t
)0x00000002)

	)

5642 #define 
	#SDIO_ICR_CTIMEOUTC
 ((
uint32_t
)0x00000004)

	)

5643 #define 
	#SDIO_ICR_DTIMEOUTC
 ((
uint32_t
)0x00000008)

	)

5644 #define 
	#SDIO_ICR_TXUNDERRC
 ((
uint32_t
)0x00000010)

	)

5645 #define 
	#SDIO_ICR_RXOVERRC
 ((
uint32_t
)0x00000020)

	)

5646 #define 
	#SDIO_ICR_CMDRENDC
 ((
uint32_t
)0x00000040)

	)

5647 #define 
	#SDIO_ICR_CMDSENTC
 ((
uint32_t
)0x00000080)

	)

5648 #define 
	#SDIO_ICR_DATAENDC
 ((
uint32_t
)0x00000100)

	)

5649 #define 
	#SDIO_ICR_STBITERRC
 ((
uint32_t
)0x00000200)

	)

5650 #define 
	#SDIO_ICR_DBCKENDC
 ((
uint32_t
)0x00000400)

	)

5651 #define 
	#SDIO_ICR_SDIOITC
 ((
uint32_t
)0x00400000)

	)

5652 #define 
	#SDIO_ICR_CEATAENDC
 ((
uint32_t
)0x00800000)

	)

5655 #define 
	#SDIO_MASK_CCRCFAILIE
 ((
uint32_t
)0x00000001)

	)

5656 #define 
	#SDIO_MASK_DCRCFAILIE
 ((
uint32_t
)0x00000002)

	)

5657 #define 
	#SDIO_MASK_CTIMEOUTIE
 ((
uint32_t
)0x00000004)

	)

5658 #define 
	#SDIO_MASK_DTIMEOUTIE
 ((
uint32_t
)0x00000008)

	)

5659 #define 
	#SDIO_MASK_TXUNDERRIE
 ((
uint32_t
)0x00000010)

	)

5660 #define 
	#SDIO_MASK_RXOVERRIE
 ((
uint32_t
)0x00000020)

	)

5661 #define 
	#SDIO_MASK_CMDRENDIE
 ((
uint32_t
)0x00000040)

	)

5662 #define 
	#SDIO_MASK_CMDSENTIE
 ((
uint32_t
)0x00000080)

	)

5663 #define 
	#SDIO_MASK_DATAENDIE
 ((
uint32_t
)0x00000100)

	)

5664 #define 
	#SDIO_MASK_STBITERRIE
 ((
uint32_t
)0x00000200)

	)

5665 #define 
	#SDIO_MASK_DBCKENDIE
 ((
uint32_t
)0x00000400)

	)

5666 #define 
	#SDIO_MASK_CMDACTIE
 ((
uint32_t
)0x00000800)

	)

5667 #define 
	#SDIO_MASK_TXACTIE
 ((
uint32_t
)0x00001000)

	)

5668 #define 
	#SDIO_MASK_RXACTIE
 ((
uint32_t
)0x00002000)

	)

5669 #define 
	#SDIO_MASK_TXFIFOHEIE
 ((
uint32_t
)0x00004000)

	)

5670 #define 
	#SDIO_MASK_RXFIFOHFIE
 ((
uint32_t
)0x00008000)

	)

5671 #define 
	#SDIO_MASK_TXFIFOFIE
 ((
uint32_t
)0x00010000)

	)

5672 #define 
	#SDIO_MASK_RXFIFOFIE
 ((
uint32_t
)0x00020000)

	)

5673 #define 
	#SDIO_MASK_TXFIFOEIE
 ((
uint32_t
)0x00040000)

	)

5674 #define 
	#SDIO_MASK_RXFIFOEIE
 ((
uint32_t
)0x00080000)

	)

5675 #define 
	#SDIO_MASK_TXDAVLIE
 ((
uint32_t
)0x00100000)

	)

5676 #define 
	#SDIO_MASK_RXDAVLIE
 ((
uint32_t
)0x00200000)

	)

5677 #define 
	#SDIO_MASK_SDIOITIE
 ((
uint32_t
)0x00400000)

	)

5678 #define 
	#SDIO_MASK_CEATAENDIE
 ((
uint32_t
)0x00800000)

	)

5681 #define 
	#SDIO_FIFOCNT_FIFOCOUNT
 ((
uint32_t
)0x00FFFFFF)

	)

5684 #define 
	#SDIO_FIFO_FIFODATA
 ((
uint32_t
)0xFFFFFFFF)

	)

5692 #define 
	#SPI_CR1_CPHA
 ((
uint16_t
)0x0001)

	)

5693 #define 
	#SPI_CR1_CPOL
 ((
uint16_t
)0x0002)

	)

5694 #define 
	#SPI_CR1_MSTR
 ((
uint16_t
)0x0004)

	)

5696 #define 
	#SPI_CR1_BR
 ((
uint16_t
)0x0038)

	)

5697 #define 
	#SPI_CR1_BR_0
 ((
uint16_t
)0x0008)

	)

5698 #define 
	#SPI_CR1_BR_1
 ((
uint16_t
)0x0010)

	)

5699 #define 
	#SPI_CR1_BR_2
 ((
uint16_t
)0x0020)

	)

5701 #define 
	#SPI_CR1_SPE
 ((
uint16_t
)0x0040)

	)

5702 #define 
	#SPI_CR1_LSBFIRST
 ((
uint16_t
)0x0080)

	)

5703 #define 
	#SPI_CR1_SSI
 ((
uint16_t
)0x0100)

	)

5704 #define 
	#SPI_CR1_SSM
 ((
uint16_t
)0x0200)

	)

5705 #define 
	#SPI_CR1_RXONLY
 ((
uint16_t
)0x0400)

	)

5706 #define 
	#SPI_CR1_DFF
 ((
uint16_t
)0x0800)

	)

5707 #define 
	#SPI_CR1_CRCNEXT
 ((
uint16_t
)0x1000)

	)

5708 #define 
	#SPI_CR1_CRCEN
 ((
uint16_t
)0x2000)

	)

5709 #define 
	#SPI_CR1_BIDIOE
 ((
uint16_t
)0x4000)

	)

5710 #define 
	#SPI_CR1_BIDIMODE
 ((
uint16_t
)0x8000)

	)

5713 #define 
	#SPI_CR2_RXDMAEN
 ((
uint8_t
)0x01)

	)

5714 #define 
	#SPI_CR2_TXDMAEN
 ((
uint8_t
)0x02)

	)

5715 #define 
	#SPI_CR2_SSOE
 ((
uint8_t
)0x04)

	)

5716 #define 
	#SPI_CR2_ERRIE
 ((
uint8_t
)0x20)

	)

5717 #define 
	#SPI_CR2_RXNEIE
 ((
uint8_t
)0x40)

	)

5718 #define 
	#SPI_CR2_TXEIE
 ((
uint8_t
)0x80)

	)

5721 #define 
	#SPI_SR_RXNE
 ((
uint8_t
)0x01)

	)

5722 #define 
	#SPI_SR_TXE
 ((
uint8_t
)0x02)

	)

5723 #define 
	#SPI_SR_CHSIDE
 ((
uint8_t
)0x04)

	)

5724 #define 
	#SPI_SR_UDR
 ((
uint8_t
)0x08)

	)

5725 #define 
	#SPI_SR_CRCERR
 ((
uint8_t
)0x10)

	)

5726 #define 
	#SPI_SR_MODF
 ((
uint8_t
)0x20)

	)

5727 #define 
	#SPI_SR_OVR
 ((
uint8_t
)0x40)

	)

5728 #define 
	#SPI_SR_BSY
 ((
uint8_t
)0x80)

	)

5731 #define 
	#SPI_DR_DR
 ((
uint16_t
)0xFFFF)

	)

5734 #define 
	#SPI_CRCPR_CRCPOLY
 ((
uint16_t
)0xFFFF)

	)

5737 #define 
	#SPI_RXCRCR_RXCRC
 ((
uint16_t
)0xFFFF)

	)

5740 #define 
	#SPI_TXCRCR_TXCRC
 ((
uint16_t
)0xFFFF)

	)

5743 #define 
	#SPI_I2SCFGR_CHLEN
 ((
uint16_t
)0x0001)

	)

5745 #define 
	#SPI_I2SCFGR_DATLEN
 ((
uint16_t
)0x0006)

	)

5746 #define 
	#SPI_I2SCFGR_DATLEN_0
 ((
uint16_t
)0x0002)

	)

5747 #define 
	#SPI_I2SCFGR_DATLEN_1
 ((
uint16_t
)0x0004)

	)

5749 #define 
	#SPI_I2SCFGR_CKPOL
 ((
uint16_t
)0x0008)

	)

5751 #define 
	#SPI_I2SCFGR_I2SSTD
 ((
uint16_t
)0x0030)

	)

5752 #define 
	#SPI_I2SCFGR_I2SSTD_0
 ((
uint16_t
)0x0010)

	)

5753 #define 
	#SPI_I2SCFGR_I2SSTD_1
 ((
uint16_t
)0x0020)

	)

5755 #define 
	#SPI_I2SCFGR_PCMSYNC
 ((
uint16_t
)0x0080)

	)

5757 #define 
	#SPI_I2SCFGR_I2SCFG
 ((
uint16_t
)0x0300)

	)

5758 #define 
	#SPI_I2SCFGR_I2SCFG_0
 ((
uint16_t
)0x0100)

	)

5759 #define 
	#SPI_I2SCFGR_I2SCFG_1
 ((
uint16_t
)0x0200)

	)

5761 #define 
	#SPI_I2SCFGR_I2SE
 ((
uint16_t
)0x0400)

	)

5762 #define 
	#SPI_I2SCFGR_I2SMOD
 ((
uint16_t
)0x0800)

	)

5765 #define 
	#SPI_I2SPR_I2SDIV
 ((
uint16_t
)0x00FF)

	)

5766 #define 
	#SPI_I2SPR_ODD
 ((
uint16_t
)0x0100)

	)

5767 #define 
	#SPI_I2SPR_MCKOE
 ((
uint16_t
)0x0200)

	)

5775 #define 
	#SYSCFG_MEMRMP_MEM_MODE
 ((
uint32_t
)0x00000003)

	)

5776 #define 
	#SYSCFG_MEMRMP_MEM_MODE_0
 ((
uint32_t
)0x00000001)

	)

5777 #define 
	#SYSCFG_MEMRMP_MEM_MODE_1
 ((
uint32_t
)0x00000002)

	)

5780 #define 
	#SYSCFG_PMC_MII_RMII
 ((
uint32_t
)0x00800000)

	)

5783 #define 
	#SYSCFG_EXTICR1_EXTI0
 ((
uint16_t
)0x000F)

	)

5784 #define 
	#SYSCFG_EXTICR1_EXTI1
 ((
uint16_t
)0x00F0)

	)

5785 #define 
	#SYSCFG_EXTICR1_EXTI2
 ((
uint16_t
)0x0F00)

	)

5786 #define 
	#SYSCFG_EXTICR1_EXTI3
 ((
uint16_t
)0xF000)

	)

5790 #define 
	#SYSCFG_EXTICR1_EXTI0_PA
 ((
uint16_t
)0x0000)

	)

5791 #define 
	#SYSCFG_EXTICR1_EXTI0_PB
 ((
uint16_t
)0x0001)

	)

5792 #define 
	#SYSCFG_EXTICR1_EXTI0_PC
 ((
uint16_t
)0x0002)

	)

5793 #define 
	#SYSCFG_EXTICR1_EXTI0_PD
 ((
uint16_t
)0x0003)

	)

5794 #define 
	#SYSCFG_EXTICR1_EXTI0_PE
 ((
uint16_t
)0x0004)

	)

5795 #define 
	#SYSCFG_EXTICR1_EXTI0_PF
 ((
uint16_t
)0x0005)

	)

5796 #define 
	#SYSCFG_EXTICR1_EXTI0_PG
 ((
uint16_t
)0x0006)

	)

5797 #define 
	#SYSCFG_EXTICR1_EXTI0_PH
 ((
uint16_t
)0x0007)

	)

5798 #define 
	#SYSCFG_EXTICR1_EXTI0_PI
 ((
uint16_t
)0x0008)

	)

5802 #define 
	#SYSCFG_EXTICR1_EXTI1_PA
 ((
uint16_t
)0x0000)

	)

5803 #define 
	#SYSCFG_EXTICR1_EXTI1_PB
 ((
uint16_t
)0x0010)

	)

5804 #define 
	#SYSCFG_EXTICR1_EXTI1_PC
 ((
uint16_t
)0x0020)

	)

5805 #define 
	#SYSCFG_EXTICR1_EXTI1_PD
 ((
uint16_t
)0x0030)

	)

5806 #define 
	#SYSCFG_EXTICR1_EXTI1_PE
 ((
uint16_t
)0x0040)

	)

5807 #define 
	#SYSCFG_EXTICR1_EXTI1_PF
 ((
uint16_t
)0x0050)

	)

5808 #define 
	#SYSCFG_EXTICR1_EXTI1_PG
 ((
uint16_t
)0x0060)

	)

5809 #define 
	#SYSCFG_EXTICR1_EXTI1_PH
 ((
uint16_t
)0x0070)

	)

5810 #define 
	#SYSCFG_EXTICR1_EXTI1_PI
 ((
uint16_t
)0x0080)

	)

5814 #define 
	#SYSCFG_EXTICR1_EXTI2_PA
 ((
uint16_t
)0x0000)

	)

5815 #define 
	#SYSCFG_EXTICR1_EXTI2_PB
 ((
uint16_t
)0x0100)

	)

5816 #define 
	#SYSCFG_EXTICR1_EXTI2_PC
 ((
uint16_t
)0x0200)

	)

5817 #define 
	#SYSCFG_EXTICR1_EXTI2_PD
 ((
uint16_t
)0x0300)

	)

5818 #define 
	#SYSCFG_EXTICR1_EXTI2_PE
 ((
uint16_t
)0x0400)

	)

5819 #define 
	#SYSCFG_EXTICR1_EXTI2_PF
 ((
uint16_t
)0x0500)

	)

5820 #define 
	#SYSCFG_EXTICR1_EXTI2_PG
 ((
uint16_t
)0x0600)

	)

5821 #define 
	#SYSCFG_EXTICR1_EXTI2_PH
 ((
uint16_t
)0x0700)

	)

5822 #define 
	#SYSCFG_EXTICR1_EXTI2_PI
 ((
uint16_t
)0x0800)

	)

5826 #define 
	#SYSCFG_EXTICR1_EXTI3_PA
 ((
uint16_t
)0x0000)

	)

5827 #define 
	#SYSCFG_EXTICR1_EXTI3_PB
 ((
uint16_t
)0x1000)

	)

5828 #define 
	#SYSCFG_EXTICR1_EXTI3_PC
 ((
uint16_t
)0x2000)

	)

5829 #define 
	#SYSCFG_EXTICR1_EXTI3_PD
 ((
uint16_t
)0x3000)

	)

5830 #define 
	#SYSCFG_EXTICR1_EXTI3_PE
 ((
uint16_t
)0x4000)

	)

5831 #define 
	#SYSCFG_EXTICR1_EXTI3_PF
 ((
uint16_t
)0x5000)

	)

5832 #define 
	#SYSCFG_EXTICR1_EXTI3_PG
 ((
uint16_t
)0x6000)

	)

5833 #define 
	#SYSCFG_EXTICR1_EXTI3_PH
 ((
uint16_t
)0x7000)

	)

5834 #define 
	#SYSCFG_EXTICR1_EXTI3_PI
 ((
uint16_t
)0x8000)

	)

5837 #define 
	#SYSCFG_EXTICR2_EXTI4
 ((
uint16_t
)0x000F)

	)

5838 #define 
	#SYSCFG_EXTICR2_EXTI5
 ((
uint16_t
)0x00F0)

	)

5839 #define 
	#SYSCFG_EXTICR2_EXTI6
 ((
uint16_t
)0x0F00)

	)

5840 #define 
	#SYSCFG_EXTICR2_EXTI7
 ((
uint16_t
)0xF000)

	)

5844 #define 
	#SYSCFG_EXTICR2_EXTI4_PA
 ((
uint16_t
)0x0000)

	)

5845 #define 
	#SYSCFG_EXTICR2_EXTI4_PB
 ((
uint16_t
)0x0001)

	)

5846 #define 
	#SYSCFG_EXTICR2_EXTI4_PC
 ((
uint16_t
)0x0002)

	)

5847 #define 
	#SYSCFG_EXTICR2_EXTI4_PD
 ((
uint16_t
)0x0003)

	)

5848 #define 
	#SYSCFG_EXTICR2_EXTI4_PE
 ((
uint16_t
)0x0004)

	)

5849 #define 
	#SYSCFG_EXTICR2_EXTI4_PF
 ((
uint16_t
)0x0005)

	)

5850 #define 
	#SYSCFG_EXTICR2_EXTI4_PG
 ((
uint16_t
)0x0006)

	)

5851 #define 
	#SYSCFG_EXTICR2_EXTI4_PH
 ((
uint16_t
)0x0007)

	)

5852 #define 
	#SYSCFG_EXTICR2_EXTI4_PI
 ((
uint16_t
)0x0008)

	)

5856 #define 
	#SYSCFG_EXTICR2_EXTI5_PA
 ((
uint16_t
)0x0000)

	)

5857 #define 
	#SYSCFG_EXTICR2_EXTI5_PB
 ((
uint16_t
)0x0010)

	)

5858 #define 
	#SYSCFG_EXTICR2_EXTI5_PC
 ((
uint16_t
)0x0020)

	)

5859 #define 
	#SYSCFG_EXTICR2_EXTI5_PD
 ((
uint16_t
)0x0030)

	)

5860 #define 
	#SYSCFG_EXTICR2_EXTI5_PE
 ((
uint16_t
)0x0040)

	)

5861 #define 
	#SYSCFG_EXTICR2_EXTI5_PF
 ((
uint16_t
)0x0050)

	)

5862 #define 
	#SYSCFG_EXTICR2_EXTI5_PG
 ((
uint16_t
)0x0060)

	)

5863 #define 
	#SYSCFG_EXTICR2_EXTI5_PH
 ((
uint16_t
)0x0070)

	)

5864 #define 
	#SYSCFG_EXTICR2_EXTI5_PI
 ((
uint16_t
)0x0080)

	)

5868 #define 
	#SYSCFG_EXTICR2_EXTI6_PA
 ((
uint16_t
)0x0000)

	)

5869 #define 
	#SYSCFG_EXTICR2_EXTI6_PB
 ((
uint16_t
)0x0100)

	)

5870 #define 
	#SYSCFG_EXTICR2_EXTI6_PC
 ((
uint16_t
)0x0200)

	)

5871 #define 
	#SYSCFG_EXTICR2_EXTI6_PD
 ((
uint16_t
)0x0300)

	)

5872 #define 
	#SYSCFG_EXTICR2_EXTI6_PE
 ((
uint16_t
)0x0400)

	)

5873 #define 
	#SYSCFG_EXTICR2_EXTI6_PF
 ((
uint16_t
)0x0500)

	)

5874 #define 
	#SYSCFG_EXTICR2_EXTI6_PG
 ((
uint16_t
)0x0600)

	)

5875 #define 
	#SYSCFG_EXTICR2_EXTI6_PH
 ((
uint16_t
)0x0700)

	)

5876 #define 
	#SYSCFG_EXTICR2_EXTI6_PI
 ((
uint16_t
)0x0800)

	)

5880 #define 
	#SYSCFG_EXTICR2_EXTI7_PA
 ((
uint16_t
)0x0000)

	)

5881 #define 
	#SYSCFG_EXTICR2_EXTI7_PB
 ((
uint16_t
)0x1000)

	)

5882 #define 
	#SYSCFG_EXTICR2_EXTI7_PC
 ((
uint16_t
)0x2000)

	)

5883 #define 
	#SYSCFG_EXTICR2_EXTI7_PD
 ((
uint16_t
)0x3000)

	)

5884 #define 
	#SYSCFG_EXTICR2_EXTI7_PE
 ((
uint16_t
)0x4000)

	)

5885 #define 
	#SYSCFG_EXTICR2_EXTI7_PF
 ((
uint16_t
)0x5000)

	)

5886 #define 
	#SYSCFG_EXTICR2_EXTI7_PG
 ((
uint16_t
)0x6000)

	)

5887 #define 
	#SYSCFG_EXTICR2_EXTI7_PH
 ((
uint16_t
)0x7000)

	)

5888 #define 
	#SYSCFG_EXTICR2_EXTI7_PI
 ((
uint16_t
)0x8000)

	)

5891 #define 
	#SYSCFG_EXTICR3_EXTI8
 ((
uint16_t
)0x000F)

	)

5892 #define 
	#SYSCFG_EXTICR3_EXTI9
 ((
uint16_t
)0x00F0)

	)

5893 #define 
	#SYSCFG_EXTICR3_EXTI10
 ((
uint16_t
)0x0F00)

	)

5894 #define 
	#SYSCFG_EXTICR3_EXTI11
 ((
uint16_t
)0xF000)

	)

5899 #define 
	#SYSCFG_EXTICR3_EXTI8_PA
 ((
uint16_t
)0x0000)

	)

5900 #define 
	#SYSCFG_EXTICR3_EXTI8_PB
 ((
uint16_t
)0x0001)

	)

5901 #define 
	#SYSCFG_EXTICR3_EXTI8_PC
 ((
uint16_t
)0x0002)

	)

5902 #define 
	#SYSCFG_EXTICR3_EXTI8_PD
 ((
uint16_t
)0x0003)

	)

5903 #define 
	#SYSCFG_EXTICR3_EXTI8_PE
 ((
uint16_t
)0x0004)

	)

5904 #define 
	#SYSCFG_EXTICR3_EXTI8_PF
 ((
uint16_t
)0x0005)

	)

5905 #define 
	#SYSCFG_EXTICR3_EXTI8_PG
 ((
uint16_t
)0x0006)

	)

5906 #define 
	#SYSCFG_EXTICR3_EXTI8_PH
 ((
uint16_t
)0x0007)

	)

5907 #define 
	#SYSCFG_EXTICR3_EXTI8_PI
 ((
uint16_t
)0x0008)

	)

5911 #define 
	#SYSCFG_EXTICR3_EXTI9_PA
 ((
uint16_t
)0x0000)

	)

5912 #define 
	#SYSCFG_EXTICR3_EXTI9_PB
 ((
uint16_t
)0x0010)

	)

5913 #define 
	#SYSCFG_EXTICR3_EXTI9_PC
 ((
uint16_t
)0x0020)

	)

5914 #define 
	#SYSCFG_EXTICR3_EXTI9_PD
 ((
uint16_t
)0x0030)

	)

5915 #define 
	#SYSCFG_EXTICR3_EXTI9_PE
 ((
uint16_t
)0x0040)

	)

5916 #define 
	#SYSCFG_EXTICR3_EXTI9_PF
 ((
uint16_t
)0x0050)

	)

5917 #define 
	#SYSCFG_EXTICR3_EXTI9_PG
 ((
uint16_t
)0x0060)

	)

5918 #define 
	#SYSCFG_EXTICR3_EXTI9_PH
 ((
uint16_t
)0x0070)

	)

5919 #define 
	#SYSCFG_EXTICR3_EXTI9_PI
 ((
uint16_t
)0x0080)

	)

5923 #define 
	#SYSCFG_EXTICR3_EXTI10_PA
 ((
uint16_t
)0x0000)

	)

5924 #define 
	#SYSCFG_EXTICR3_EXTI10_PB
 ((
uint16_t
)0x0100)

	)

5925 #define 
	#SYSCFG_EXTICR3_EXTI10_PC
 ((
uint16_t
)0x0200)

	)

5926 #define 
	#SYSCFG_EXTICR3_EXTI10_PD
 ((
uint16_t
)0x0300)

	)

5927 #define 
	#SYSCFG_EXTICR3_EXTI10_PE
 ((
uint16_t
)0x0400)

	)

5928 #define 
	#SYSCFG_EXTICR3_EXTI10_PF
 ((
uint16_t
)0x0500)

	)

5929 #define 
	#SYSCFG_EXTICR3_EXTI10_PG
 ((
uint16_t
)0x0600)

	)

5930 #define 
	#SYSCFG_EXTICR3_EXTI10_PH
 ((
uint16_t
)0x0700)

	)

5931 #define 
	#SYSCFG_EXTICR3_EXTI10_PI
 ((
uint16_t
)0x0800)

	)

5935 #define 
	#SYSCFG_EXTICR3_EXTI11_PA
 ((
uint16_t
)0x0000)

	)

5936 #define 
	#SYSCFG_EXTICR3_EXTI11_PB
 ((
uint16_t
)0x1000)

	)

5937 #define 
	#SYSCFG_EXTICR3_EXTI11_PC
 ((
uint16_t
)0x2000)

	)

5938 #define 
	#SYSCFG_EXTICR3_EXTI11_PD
 ((
uint16_t
)0x3000)

	)

5939 #define 
	#SYSCFG_EXTICR3_EXTI11_PE
 ((
uint16_t
)0x4000)

	)

5940 #define 
	#SYSCFG_EXTICR3_EXTI11_PF
 ((
uint16_t
)0x5000)

	)

5941 #define 
	#SYSCFG_EXTICR3_EXTI11_PG
 ((
uint16_t
)0x6000)

	)

5942 #define 
	#SYSCFG_EXTICR3_EXTI11_PH
 ((
uint16_t
)0x7000)

	)

5943 #define 
	#SYSCFG_EXTICR3_EXTI11_PI
 ((
uint16_t
)0x8000)

	)

5946 #define 
	#SYSCFG_EXTICR4_EXTI12
 ((
uint16_t
)0x000F)

	)

5947 #define 
	#SYSCFG_EXTICR4_EXTI13
 ((
uint16_t
)0x00F0)

	)

5948 #define 
	#SYSCFG_EXTICR4_EXTI14
 ((
uint16_t
)0x0F00)

	)

5949 #define 
	#SYSCFG_EXTICR4_EXTI15
 ((
uint16_t
)0xF000)

	)

5953 #define 
	#SYSCFG_EXTICR4_EXTI12_PA
 ((
uint16_t
)0x0000)

	)

5954 #define 
	#SYSCFG_EXTICR4_EXTI12_PB
 ((
uint16_t
)0x0001)

	)

5955 #define 
	#SYSCFG_EXTICR4_EXTI12_PC
 ((
uint16_t
)0x0002)

	)

5956 #define 
	#SYSCFG_EXTICR4_EXTI12_PD
 ((
uint16_t
)0x0003)

	)

5957 #define 
	#SYSCFG_EXTICR4_EXTI12_PE
 ((
uint16_t
)0x0004)

	)

5958 #define 
	#SYSCFG_EXTICR4_EXTI12_PF
 ((
uint16_t
)0x0005)

	)

5959 #define 
	#SYSCFG_EXTICR4_EXTI12_PG
 ((
uint16_t
)0x0006)

	)

5960 #define 
	#SYSCFG_EXTICR3_EXTI12_PH
 ((
uint16_t
)0x0007)

	)

5964 #define 
	#SYSCFG_EXTICR4_EXTI13_PA
 ((
uint16_t
)0x0000)

	)

5965 #define 
	#SYSCFG_EXTICR4_EXTI13_PB
 ((
uint16_t
)0x0010)

	)

5966 #define 
	#SYSCFG_EXTICR4_EXTI13_PC
 ((
uint16_t
)0x0020)

	)

5967 #define 
	#SYSCFG_EXTICR4_EXTI13_PD
 ((
uint16_t
)0x0030)

	)

5968 #define 
	#SYSCFG_EXTICR4_EXTI13_PE
 ((
uint16_t
)0x0040)

	)

5969 #define 
	#SYSCFG_EXTICR4_EXTI13_PF
 ((
uint16_t
)0x0050)

	)

5970 #define 
	#SYSCFG_EXTICR4_EXTI13_PG
 ((
uint16_t
)0x0060)

	)

5971 #define 
	#SYSCFG_EXTICR3_EXTI13_PH
 ((
uint16_t
)0x0070)

	)

5975 #define 
	#SYSCFG_EXTICR4_EXTI14_PA
 ((
uint16_t
)0x0000)

	)

5976 #define 
	#SYSCFG_EXTICR4_EXTI14_PB
 ((
uint16_t
)0x0100)

	)

5977 #define 
	#SYSCFG_EXTICR4_EXTI14_PC
 ((
uint16_t
)0x0200)

	)

5978 #define 
	#SYSCFG_EXTICR4_EXTI14_PD
 ((
uint16_t
)0x0300)

	)

5979 #define 
	#SYSCFG_EXTICR4_EXTI14_PE
 ((
uint16_t
)0x0400)

	)

5980 #define 
	#SYSCFG_EXTICR4_EXTI14_PF
 ((
uint16_t
)0x0500)

	)

5981 #define 
	#SYSCFG_EXTICR4_EXTI14_PG
 ((
uint16_t
)0x0600)

	)

5982 #define 
	#SYSCFG_EXTICR3_EXTI14_PH
 ((
uint16_t
)0x0700)

	)

5986 #define 
	#SYSCFG_EXTICR4_EXTI15_PA
 ((
uint16_t
)0x0000)

	)

5987 #define 
	#SYSCFG_EXTICR4_EXTI15_PB
 ((
uint16_t
)0x1000)

	)

5988 #define 
	#SYSCFG_EXTICR4_EXTI15_PC
 ((
uint16_t
)0x2000)

	)

5989 #define 
	#SYSCFG_EXTICR4_EXTI15_PD
 ((
uint16_t
)0x3000)

	)

5990 #define 
	#SYSCFG_EXTICR4_EXTI15_PE
 ((
uint16_t
)0x4000)

	)

5991 #define 
	#SYSCFG_EXTICR4_EXTI15_PF
 ((
uint16_t
)0x5000)

	)

5992 #define 
	#SYSCFG_EXTICR4_EXTI15_PG
 ((
uint16_t
)0x6000)

	)

5993 #define 
	#SYSCFG_EXTICR3_EXTI15_PH
 ((
uint16_t
)0x7000)

	)

5996 #define 
	#SYSCFG_CMPCR_CMP_PD
 ((
uint32_t
)0x00000001)

	)

5997 #define 
	#SYSCFG_CMPCR_READY
 ((
uint32_t
)0x00000100)

	)

6005 #define 
	#TIM_CR1_CEN
 ((
uint16_t
)0x0001)

	)

6006 #define 
	#TIM_CR1_UDIS
 ((
uint16_t
)0x0002)

	)

6007 #define 
	#TIM_CR1_URS
 ((
uint16_t
)0x0004)

	)

6008 #define 
	#TIM_CR1_OPM
 ((
uint16_t
)0x0008)

	)

6009 #define 
	#TIM_CR1_DIR
 ((
uint16_t
)0x0010)

	)

6011 #define 
	#TIM_CR1_CMS
 ((
uint16_t
)0x0060)

	)

6012 #define 
	#TIM_CR1_CMS_0
 ((
uint16_t
)0x0020)

	)

6013 #define 
	#TIM_CR1_CMS_1
 ((
uint16_t
)0x0040)

	)

6015 #define 
	#TIM_CR1_ARPE
 ((
uint16_t
)0x0080)

	)

6017 #define 
	#TIM_CR1_CKD
 ((
uint16_t
)0x0300)

	)

6018 #define 
	#TIM_CR1_CKD_0
 ((
uint16_t
)0x0100)

	)

6019 #define 
	#TIM_CR1_CKD_1
 ((
uint16_t
)0x0200)

	)

6022 #define 
	#TIM_CR2_CCPC
 ((
uint16_t
)0x0001)

	)

6023 #define 
	#TIM_CR2_CCUS
 ((
uint16_t
)0x0004)

	)

6024 #define 
	#TIM_CR2_CCDS
 ((
uint16_t
)0x0008)

	)

6026 #define 
	#TIM_CR2_MMS
 ((
uint16_t
)0x0070)

	)

6027 #define 
	#TIM_CR2_MMS_0
 ((
uint16_t
)0x0010)

	)

6028 #define 
	#TIM_CR2_MMS_1
 ((
uint16_t
)0x0020)

	)

6029 #define 
	#TIM_CR2_MMS_2
 ((
uint16_t
)0x0040)

	)

6031 #define 
	#TIM_CR2_TI1S
 ((
uint16_t
)0x0080)

	)

6032 #define 
	#TIM_CR2_OIS1
 ((
uint16_t
)0x0100)

	)

6033 #define 
	#TIM_CR2_OIS1N
 ((
uint16_t
)0x0200)

	)

6034 #define 
	#TIM_CR2_OIS2
 ((
uint16_t
)0x0400)

	)

6035 #define 
	#TIM_CR2_OIS2N
 ((
uint16_t
)0x0800)

	)

6036 #define 
	#TIM_CR2_OIS3
 ((
uint16_t
)0x1000)

	)

6037 #define 
	#TIM_CR2_OIS3N
 ((
uint16_t
)0x2000)

	)

6038 #define 
	#TIM_CR2_OIS4
 ((
uint16_t
)0x4000)

	)

6041 #define 
	#TIM_SMCR_SMS
 ((
uint16_t
)0x0007)

	)

6042 #define 
	#TIM_SMCR_SMS_0
 ((
uint16_t
)0x0001)

	)

6043 #define 
	#TIM_SMCR_SMS_1
 ((
uint16_t
)0x0002)

	)

6044 #define 
	#TIM_SMCR_SMS_2
 ((
uint16_t
)0x0004)

	)

6046 #define 
	#TIM_SMCR_TS
 ((
uint16_t
)0x0070)

	)

6047 #define 
	#TIM_SMCR_TS_0
 ((
uint16_t
)0x0010)

	)

6048 #define 
	#TIM_SMCR_TS_1
 ((
uint16_t
)0x0020)

	)

6049 #define 
	#TIM_SMCR_TS_2
 ((
uint16_t
)0x0040)

	)

6051 #define 
	#TIM_SMCR_MSM
 ((
uint16_t
)0x0080)

	)

6053 #define 
	#TIM_SMCR_ETF
 ((
uint16_t
)0x0F00)

	)

6054 #define 
	#TIM_SMCR_ETF_0
 ((
uint16_t
)0x0100)

	)

6055 #define 
	#TIM_SMCR_ETF_1
 ((
uint16_t
)0x0200)

	)

6056 #define 
	#TIM_SMCR_ETF_2
 ((
uint16_t
)0x0400)

	)

6057 #define 
	#TIM_SMCR_ETF_3
 ((
uint16_t
)0x0800)

	)

6059 #define 
	#TIM_SMCR_ETPS
 ((
uint16_t
)0x3000)

	)

6060 #define 
	#TIM_SMCR_ETPS_0
 ((
uint16_t
)0x1000)

	)

6061 #define 
	#TIM_SMCR_ETPS_1
 ((
uint16_t
)0x2000)

	)

6063 #define 
	#TIM_SMCR_ECE
 ((
uint16_t
)0x4000)

	)

6064 #define 
	#TIM_SMCR_ETP
 ((
uint16_t
)0x8000)

	)

6067 #define 
	#TIM_DIER_UIE
 ((
uint16_t
)0x0001)

	)

6068 #define 
	#TIM_DIER_CC1IE
 ((
uint16_t
)0x0002)

	)

6069 #define 
	#TIM_DIER_CC2IE
 ((
uint16_t
)0x0004)

	)

6070 #define 
	#TIM_DIER_CC3IE
 ((
uint16_t
)0x0008)

	)

6071 #define 
	#TIM_DIER_CC4IE
 ((
uint16_t
)0x0010)

	)

6072 #define 
	#TIM_DIER_COMIE
 ((
uint16_t
)0x0020)

	)

6073 #define 
	#TIM_DIER_TIE
 ((
uint16_t
)0x0040)

	)

6074 #define 
	#TIM_DIER_BIE
 ((
uint16_t
)0x0080)

	)

6075 #define 
	#TIM_DIER_UDE
 ((
uint16_t
)0x0100)

	)

6076 #define 
	#TIM_DIER_CC1DE
 ((
uint16_t
)0x0200)

	)

6077 #define 
	#TIM_DIER_CC2DE
 ((
uint16_t
)0x0400)

	)

6078 #define 
	#TIM_DIER_CC3DE
 ((
uint16_t
)0x0800)

	)

6079 #define 
	#TIM_DIER_CC4DE
 ((
uint16_t
)0x1000)

	)

6080 #define 
	#TIM_DIER_COMDE
 ((
uint16_t
)0x2000)

	)

6081 #define 
	#TIM_DIER_TDE
 ((
uint16_t
)0x4000)

	)

6084 #define 
	#TIM_SR_UIF
 ((
uint16_t
)0x0001)

	)

6085 #define 
	#TIM_SR_CC1IF
 ((
uint16_t
)0x0002)

	)

6086 #define 
	#TIM_SR_CC2IF
 ((
uint16_t
)0x0004)

	)

6087 #define 
	#TIM_SR_CC3IF
 ((
uint16_t
)0x0008)

	)

6088 #define 
	#TIM_SR_CC4IF
 ((
uint16_t
)0x0010)

	)

6089 #define 
	#TIM_SR_COMIF
 ((
uint16_t
)0x0020)

	)

6090 #define 
	#TIM_SR_TIF
 ((
uint16_t
)0x0040)

	)

6091 #define 
	#TIM_SR_BIF
 ((
uint16_t
)0x0080)

	)

6092 #define 
	#TIM_SR_CC1OF
 ((
uint16_t
)0x0200)

	)

6093 #define 
	#TIM_SR_CC2OF
 ((
uint16_t
)0x0400)

	)

6094 #define 
	#TIM_SR_CC3OF
 ((
uint16_t
)0x0800)

	)

6095 #define 
	#TIM_SR_CC4OF
 ((
uint16_t
)0x1000)

	)

6098 #define 
	#TIM_EGR_UG
 ((
uint8_t
)0x01)

	)

6099 #define 
	#TIM_EGR_CC1G
 ((
uint8_t
)0x02)

	)

6100 #define 
	#TIM_EGR_CC2G
 ((
uint8_t
)0x04)

	)

6101 #define 
	#TIM_EGR_CC3G
 ((
uint8_t
)0x08)

	)

6102 #define 
	#TIM_EGR_CC4G
 ((
uint8_t
)0x10)

	)

6103 #define 
	#TIM_EGR_COMG
 ((
uint8_t
)0x20)

	)

6104 #define 
	#TIM_EGR_TG
 ((
uint8_t
)0x40)

	)

6105 #define 
	#TIM_EGR_BG
 ((
uint8_t
)0x80)

	)

6108 #define 
	#TIM_CCMR1_CC1S
 ((
uint16_t
)0x0003)

	)

6109 #define 
	#TIM_CCMR1_CC1S_0
 ((
uint16_t
)0x0001)

	)

6110 #define 
	#TIM_CCMR1_CC1S_1
 ((
uint16_t
)0x0002)

	)

6112 #define 
	#TIM_CCMR1_OC1FE
 ((
uint16_t
)0x0004)

	)

6113 #define 
	#TIM_CCMR1_OC1PE
 ((
uint16_t
)0x0008)

	)

6115 #define 
	#TIM_CCMR1_OC1M
 ((
uint16_t
)0x0070)

	)

6116 #define 
	#TIM_CCMR1_OC1M_0
 ((
uint16_t
)0x0010)

	)

6117 #define 
	#TIM_CCMR1_OC1M_1
 ((
uint16_t
)0x0020)

	)

6118 #define 
	#TIM_CCMR1_OC1M_2
 ((
uint16_t
)0x0040)

	)

6120 #define 
	#TIM_CCMR1_OC1CE
 ((
uint16_t
)0x0080)

	)

6122 #define 
	#TIM_CCMR1_CC2S
 ((
uint16_t
)0x0300)

	)

6123 #define 
	#TIM_CCMR1_CC2S_0
 ((
uint16_t
)0x0100)

	)

6124 #define 
	#TIM_CCMR1_CC2S_1
 ((
uint16_t
)0x0200)

	)

6126 #define 
	#TIM_CCMR1_OC2FE
 ((
uint16_t
)0x0400)

	)

6127 #define 
	#TIM_CCMR1_OC2PE
 ((
uint16_t
)0x0800)

	)

6129 #define 
	#TIM_CCMR1_OC2M
 ((
uint16_t
)0x7000)

	)

6130 #define 
	#TIM_CCMR1_OC2M_0
 ((
uint16_t
)0x1000)

	)

6131 #define 
	#TIM_CCMR1_OC2M_1
 ((
uint16_t
)0x2000)

	)

6132 #define 
	#TIM_CCMR1_OC2M_2
 ((
uint16_t
)0x4000)

	)

6134 #define 
	#TIM_CCMR1_OC2CE
 ((
uint16_t
)0x8000)

	)

6138 #define 
	#TIM_CCMR1_IC1PSC
 ((
uint16_t
)0x000C)

	)

6139 #define 
	#TIM_CCMR1_IC1PSC_0
 ((
uint16_t
)0x0004)

	)

6140 #define 
	#TIM_CCMR1_IC1PSC_1
 ((
uint16_t
)0x0008)

	)

6142 #define 
	#TIM_CCMR1_IC1F
 ((
uint16_t
)0x00F0)

	)

6143 #define 
	#TIM_CCMR1_IC1F_0
 ((
uint16_t
)0x0010)

	)

6144 #define 
	#TIM_CCMR1_IC1F_1
 ((
uint16_t
)0x0020)

	)

6145 #define 
	#TIM_CCMR1_IC1F_2
 ((
uint16_t
)0x0040)

	)

6146 #define 
	#TIM_CCMR1_IC1F_3
 ((
uint16_t
)0x0080)

	)

6148 #define 
	#TIM_CCMR1_IC2PSC
 ((
uint16_t
)0x0C00)

	)

6149 #define 
	#TIM_CCMR1_IC2PSC_0
 ((
uint16_t
)0x0400)

	)

6150 #define 
	#TIM_CCMR1_IC2PSC_1
 ((
uint16_t
)0x0800)

	)

6152 #define 
	#TIM_CCMR1_IC2F
 ((
uint16_t
)0xF000)

	)

6153 #define 
	#TIM_CCMR1_IC2F_0
 ((
uint16_t
)0x1000)

	)

6154 #define 
	#TIM_CCMR1_IC2F_1
 ((
uint16_t
)0x2000)

	)

6155 #define 
	#TIM_CCMR1_IC2F_2
 ((
uint16_t
)0x4000)

	)

6156 #define 
	#TIM_CCMR1_IC2F_3
 ((
uint16_t
)0x8000)

	)

6159 #define 
	#TIM_CCMR2_CC3S
 ((
uint16_t
)0x0003)

	)

6160 #define 
	#TIM_CCMR2_CC3S_0
 ((
uint16_t
)0x0001)

	)

6161 #define 
	#TIM_CCMR2_CC3S_1
 ((
uint16_t
)0x0002)

	)

6163 #define 
	#TIM_CCMR2_OC3FE
 ((
uint16_t
)0x0004)

	)

6164 #define 
	#TIM_CCMR2_OC3PE
 ((
uint16_t
)0x0008)

	)

6166 #define 
	#TIM_CCMR2_OC3M
 ((
uint16_t
)0x0070)

	)

6167 #define 
	#TIM_CCMR2_OC3M_0
 ((
uint16_t
)0x0010)

	)

6168 #define 
	#TIM_CCMR2_OC3M_1
 ((
uint16_t
)0x0020)

	)

6169 #define 
	#TIM_CCMR2_OC3M_2
 ((
uint16_t
)0x0040)

	)

6171 #define 
	#TIM_CCMR2_OC3CE
 ((
uint16_t
)0x0080)

	)

6173 #define 
	#TIM_CCMR2_CC4S
 ((
uint16_t
)0x0300)

	)

6174 #define 
	#TIM_CCMR2_CC4S_0
 ((
uint16_t
)0x0100)

	)

6175 #define 
	#TIM_CCMR2_CC4S_1
 ((
uint16_t
)0x0200)

	)

6177 #define 
	#TIM_CCMR2_OC4FE
 ((
uint16_t
)0x0400)

	)

6178 #define 
	#TIM_CCMR2_OC4PE
 ((
uint16_t
)0x0800)

	)

6180 #define 
	#TIM_CCMR2_OC4M
 ((
uint16_t
)0x7000)

	)

6181 #define 
	#TIM_CCMR2_OC4M_0
 ((
uint16_t
)0x1000)

	)

6182 #define 
	#TIM_CCMR2_OC4M_1
 ((
uint16_t
)0x2000)

	)

6183 #define 
	#TIM_CCMR2_OC4M_2
 ((
uint16_t
)0x4000)

	)

6185 #define 
	#TIM_CCMR2_OC4CE
 ((
uint16_t
)0x8000)

	)

6189 #define 
	#TIM_CCMR2_IC3PSC
 ((
uint16_t
)0x000C)

	)

6190 #define 
	#TIM_CCMR2_IC3PSC_0
 ((
uint16_t
)0x0004)

	)

6191 #define 
	#TIM_CCMR2_IC3PSC_1
 ((
uint16_t
)0x0008)

	)

6193 #define 
	#TIM_CCMR2_IC3F
 ((
uint16_t
)0x00F0)

	)

6194 #define 
	#TIM_CCMR2_IC3F_0
 ((
uint16_t
)0x0010)

	)

6195 #define 
	#TIM_CCMR2_IC3F_1
 ((
uint16_t
)0x0020)

	)

6196 #define 
	#TIM_CCMR2_IC3F_2
 ((
uint16_t
)0x0040)

	)

6197 #define 
	#TIM_CCMR2_IC3F_3
 ((
uint16_t
)0x0080)

	)

6199 #define 
	#TIM_CCMR2_IC4PSC
 ((
uint16_t
)0x0C00)

	)

6200 #define 
	#TIM_CCMR2_IC4PSC_0
 ((
uint16_t
)0x0400)

	)

6201 #define 
	#TIM_CCMR2_IC4PSC_1
 ((
uint16_t
)0x0800)

	)

6203 #define 
	#TIM_CCMR2_IC4F
 ((
uint16_t
)0xF000)

	)

6204 #define 
	#TIM_CCMR2_IC4F_0
 ((
uint16_t
)0x1000)

	)

6205 #define 
	#TIM_CCMR2_IC4F_1
 ((
uint16_t
)0x2000)

	)

6206 #define 
	#TIM_CCMR2_IC4F_2
 ((
uint16_t
)0x4000)

	)

6207 #define 
	#TIM_CCMR2_IC4F_3
 ((
uint16_t
)0x8000)

	)

6210 #define 
	#TIM_CCER_CC1E
 ((
uint16_t
)0x0001)

	)

6211 #define 
	#TIM_CCER_CC1P
 ((
uint16_t
)0x0002)

	)

6212 #define 
	#TIM_CCER_CC1NE
 ((
uint16_t
)0x0004)

	)

6213 #define 
	#TIM_CCER_CC1NP
 ((
uint16_t
)0x0008)

	)

6214 #define 
	#TIM_CCER_CC2E
 ((
uint16_t
)0x0010)

	)

6215 #define 
	#TIM_CCER_CC2P
 ((
uint16_t
)0x0020)

	)

6216 #define 
	#TIM_CCER_CC2NE
 ((
uint16_t
)0x0040)

	)

6217 #define 
	#TIM_CCER_CC2NP
 ((
uint16_t
)0x0080)

	)

6218 #define 
	#TIM_CCER_CC3E
 ((
uint16_t
)0x0100)

	)

6219 #define 
	#TIM_CCER_CC3P
 ((
uint16_t
)0x0200)

	)

6220 #define 
	#TIM_CCER_CC3NE
 ((
uint16_t
)0x0400)

	)

6221 #define 
	#TIM_CCER_CC3NP
 ((
uint16_t
)0x0800)

	)

6222 #define 
	#TIM_CCER_CC4E
 ((
uint16_t
)0x1000)

	)

6223 #define 
	#TIM_CCER_CC4P
 ((
uint16_t
)0x2000)

	)

6224 #define 
	#TIM_CCER_CC4NP
 ((
uint16_t
)0x8000)

	)

6227 #define 
	#TIM_CNT_CNT
 ((
uint16_t
)0xFFFF)

	)

6230 #define 
	#TIM_PSC_PSC
 ((
uint16_t
)0xFFFF)

	)

6233 #define 
	#TIM_ARR_ARR
 ((
uint16_t
)0xFFFF)

	)

6236 #define 
	#TIM_RCR_REP
 ((
uint8_t
)0xFF)

	)

6239 #define 
	#TIM_CCR1_CCR1
 ((
uint16_t
)0xFFFF)

	)

6242 #define 
	#TIM_CCR2_CCR2
 ((
uint16_t
)0xFFFF)

	)

6245 #define 
	#TIM_CCR3_CCR3
 ((
uint16_t
)0xFFFF)

	)

6248 #define 
	#TIM_CCR4_CCR4
 ((
uint16_t
)0xFFFF)

	)

6251 #define 
	#TIM_BDTR_DTG
 ((
uint16_t
)0x00FF)

	)

6252 #define 
	#TIM_BDTR_DTG_0
 ((
uint16_t
)0x0001)

	)

6253 #define 
	#TIM_BDTR_DTG_1
 ((
uint16_t
)0x0002)

	)

6254 #define 
	#TIM_BDTR_DTG_2
 ((
uint16_t
)0x0004)

	)

6255 #define 
	#TIM_BDTR_DTG_3
 ((
uint16_t
)0x0008)

	)

6256 #define 
	#TIM_BDTR_DTG_4
 ((
uint16_t
)0x0010)

	)

6257 #define 
	#TIM_BDTR_DTG_5
 ((
uint16_t
)0x0020)

	)

6258 #define 
	#TIM_BDTR_DTG_6
 ((
uint16_t
)0x0040)

	)

6259 #define 
	#TIM_BDTR_DTG_7
 ((
uint16_t
)0x0080)

	)

6261 #define 
	#TIM_BDTR_LOCK
 ((
uint16_t
)0x0300)

	)

6262 #define 
	#TIM_BDTR_LOCK_0
 ((
uint16_t
)0x0100)

	)

6263 #define 
	#TIM_BDTR_LOCK_1
 ((
uint16_t
)0x0200)

	)

6265 #define 
	#TIM_BDTR_OSSI
 ((
uint16_t
)0x0400)

	)

6266 #define 
	#TIM_BDTR_OSSR
 ((
uint16_t
)0x0800)

	)

6267 #define 
	#TIM_BDTR_BKE
 ((
uint16_t
)0x1000)

	)

6268 #define 
	#TIM_BDTR_BKP
 ((
uint16_t
)0x2000)

	)

6269 #define 
	#TIM_BDTR_AOE
 ((
uint16_t
)0x4000)

	)

6270 #define 
	#TIM_BDTR_MOE
 ((
uint16_t
)0x8000)

	)

6273 #define 
	#TIM_DCR_DBA
 ((
uint16_t
)0x001F)

	)

6274 #define 
	#TIM_DCR_DBA_0
 ((
uint16_t
)0x0001)

	)

6275 #define 
	#TIM_DCR_DBA_1
 ((
uint16_t
)0x0002)

	)

6276 #define 
	#TIM_DCR_DBA_2
 ((
uint16_t
)0x0004)

	)

6277 #define 
	#TIM_DCR_DBA_3
 ((
uint16_t
)0x0008)

	)

6278 #define 
	#TIM_DCR_DBA_4
 ((
uint16_t
)0x0010)

	)

6280 #define 
	#TIM_DCR_DBL
 ((
uint16_t
)0x1F00)

	)

6281 #define 
	#TIM_DCR_DBL_0
 ((
uint16_t
)0x0100)

	)

6282 #define 
	#TIM_DCR_DBL_1
 ((
uint16_t
)0x0200)

	)

6283 #define 
	#TIM_DCR_DBL_2
 ((
uint16_t
)0x0400)

	)

6284 #define 
	#TIM_DCR_DBL_3
 ((
uint16_t
)0x0800)

	)

6285 #define 
	#TIM_DCR_DBL_4
 ((
uint16_t
)0x1000)

	)

6288 #define 
	#TIM_DMAR_DMAB
 ((
uint16_t
)0xFFFF)

	)

6291 #define 
	#TIM_OR_TI4_RMP
 ((
uint16_t
)0x00C0)

	)

6292 #define 
	#TIM_OR_TI4_RMP_0
 ((
uint16_t
)0x0040)

	)

6293 #define 
	#TIM_OR_TI4_RMP_1
 ((
uint16_t
)0x0080)

	)

6294 #define 
	#TIM_OR_ITR1_RMP
 ((
uint16_t
)0x0C00)

	)

6295 #define 
	#TIM_OR_ITR1_RMP_0
 ((
uint16_t
)0x0400)

	)

6296 #define 
	#TIM_OR_ITR1_RMP_1
 ((
uint16_t
)0x0800)

	)

6305 #define 
	#USART_SR_PE
 ((
uint16_t
)0x0001)

	)

6306 #define 
	#USART_SR_FE
 ((
uint16_t
)0x0002)

	)

6307 #define 
	#USART_SR_NE
 ((
uint16_t
)0x0004)

	)

6308 #define 
	#USART_SR_ORE
 ((
uint16_t
)0x0008)

	)

6309 #define 
	#USART_SR_IDLE
 ((
uint16_t
)0x0010)

	)

6310 #define 
	#USART_SR_RXNE
 ((
uint16_t
)0x0020)

	)

6311 #define 
	#USART_SR_TC
 ((
uint16_t
)0x0040)

	)

6312 #define 
	#USART_SR_TXE
 ((
uint16_t
)0x0080)

	)

6313 #define 
	#USART_SR_LBD
 ((
uint16_t
)0x0100)

	)

6314 #define 
	#USART_SR_CTS
 ((
uint16_t
)0x0200)

	)

6317 #define 
	#USART_DR_DR
 ((
uint16_t
)0x01FF)

	)

6320 #define 
	#USART_BRR_DIV_Fraction
 ((
uint16_t
)0x000F)

	)

6321 #define 
	#USART_BRR_DIV_Mantissa
 ((
uint16_t
)0xFFF0)

	)

6324 #define 
	#USART_CR1_SBK
 ((
uint16_t
)0x0001)

	)

6325 #define 
	#USART_CR1_RWU
 ((
uint16_t
)0x0002)

	)

6326 #define 
	#USART_CR1_RE
 ((
uint16_t
)0x0004)

	)

6327 #define 
	#USART_CR1_TE
 ((
uint16_t
)0x0008)

	)

6328 #define 
	#USART_CR1_IDLEIE
 ((
uint16_t
)0x0010)

	)

6329 #define 
	#USART_CR1_RXNEIE
 ((
uint16_t
)0x0020)

	)

6330 #define 
	#USART_CR1_TCIE
 ((
uint16_t
)0x0040)

	)

6331 #define 
	#USART_CR1_TXEIE
 ((
uint16_t
)0x0080)

	)

6332 #define 
	#USART_CR1_PEIE
 ((
uint16_t
)0x0100)

	)

6333 #define 
	#USART_CR1_PS
 ((
uint16_t
)0x0200)

	)

6334 #define 
	#USART_CR1_PCE
 ((
uint16_t
)0x0400)

	)

6335 #define 
	#USART_CR1_WAKE
 ((
uint16_t
)0x0800)

	)

6336 #define 
	#USART_CR1_M
 ((
uint16_t
)0x1000)

	)

6337 #define 
	#USART_CR1_UE
 ((
uint16_t
)0x2000)

	)

6338 #define 
	#USART_CR1_OVER8
 ((
uint16_t
)0x8000)

	)

6341 #define 
	#USART_CR2_ADD
 ((
uint16_t
)0x000F)

	)

6342 #define 
	#USART_CR2_LBDL
 ((
uint16_t
)0x0020)

	)

6343 #define 
	#USART_CR2_LBDIE
 ((
uint16_t
)0x0040)

	)

6344 #define 
	#USART_CR2_LBCL
 ((
uint16_t
)0x0100)

	)

6345 #define 
	#USART_CR2_CPHA
 ((
uint16_t
)0x0200)

	)

6346 #define 
	#USART_CR2_CPOL
 ((
uint16_t
)0x0400)

	)

6347 #define 
	#USART_CR2_CLKEN
 ((
uint16_t
)0x0800)

	)

6349 #define 
	#USART_CR2_STOP
 ((
uint16_t
)0x3000)

	)

6350 #define 
	#USART_CR2_STOP_0
 ((
uint16_t
)0x1000)

	)

6351 #define 
	#USART_CR2_STOP_1
 ((
uint16_t
)0x2000)

	)

6353 #define 
	#USART_CR2_LINEN
 ((
uint16_t
)0x4000)

	)

6356 #define 
	#USART_CR3_EIE
 ((
uint16_t
)0x0001)

	)

6357 #define 
	#USART_CR3_IREN
 ((
uint16_t
)0x0002)

	)

6358 #define 
	#USART_CR3_IRLP
 ((
uint16_t
)0x0004)

	)

6359 #define 
	#USART_CR3_HDSEL
 ((
uint16_t
)0x0008)

	)

6360 #define 
	#USART_CR3_NACK
 ((
uint16_t
)0x0010)

	)

6361 #define 
	#USART_CR3_SCEN
 ((
uint16_t
)0x0020)

	)

6362 #define 
	#USART_CR3_DMAR
 ((
uint16_t
)0x0040)

	)

6363 #define 
	#USART_CR3_DMAT
 ((
uint16_t
)0x0080)

	)

6364 #define 
	#USART_CR3_RTSE
 ((
uint16_t
)0x0100)

	)

6365 #define 
	#USART_CR3_CTSE
 ((
uint16_t
)0x0200)

	)

6366 #define 
	#USART_CR3_CTSIE
 ((
uint16_t
)0x0400)

	)

6367 #define 
	#USART_CR3_ONEBIT
 ((
uint16_t
)0x0800)

	)

6370 #define 
	#USART_GTPR_PSC
 ((
uint16_t
)0x00FF)

	)

6371 #define 
	#USART_GTPR_PSC_0
 ((
uint16_t
)0x0001)

	)

6372 #define 
	#USART_GTPR_PSC_1
 ((
uint16_t
)0x0002)

	)

6373 #define 
	#USART_GTPR_PSC_2
 ((
uint16_t
)0x0004)

	)

6374 #define 
	#USART_GTPR_PSC_3
 ((
uint16_t
)0x0008)

	)

6375 #define 
	#USART_GTPR_PSC_4
 ((
uint16_t
)0x0010)

	)

6376 #define 
	#USART_GTPR_PSC_5
 ((
uint16_t
)0x0020)

	)

6377 #define 
	#USART_GTPR_PSC_6
 ((
uint16_t
)0x0040)

	)

6378 #define 
	#USART_GTPR_PSC_7
 ((
uint16_t
)0x0080)

	)

6380 #define 
	#USART_GTPR_GT
 ((
uint16_t
)0xFF00)

	)

6388 #define 
	#WWDG_CR_T
 ((
uint8_t
)0x7F)

	)

6389 #define 
	#WWDG_CR_T0
 ((
uint8_t
)0x01)

	)

6390 #define 
	#WWDG_CR_T1
 ((
uint8_t
)0x02)

	)

6391 #define 
	#WWDG_CR_T2
 ((
uint8_t
)0x04)

	)

6392 #define 
	#WWDG_CR_T3
 ((
uint8_t
)0x08)

	)

6393 #define 
	#WWDG_CR_T4
 ((
uint8_t
)0x10)

	)

6394 #define 
	#WWDG_CR_T5
 ((
uint8_t
)0x20)

	)

6395 #define 
	#WWDG_CR_T6
 ((
uint8_t
)0x40)

	)

6397 #define 
	#WWDG_CR_WDGA
 ((
uint8_t
)0x80)

	)

6400 #define 
	#WWDG_CFR_W
 ((
uint16_t
)0x007F)

	)

6401 #define 
	#WWDG_CFR_W0
 ((
uint16_t
)0x0001)

	)

6402 #define 
	#WWDG_CFR_W1
 ((
uint16_t
)0x0002)

	)

6403 #define 
	#WWDG_CFR_W2
 ((
uint16_t
)0x0004)

	)

6404 #define 
	#WWDG_CFR_W3
 ((
uint16_t
)0x0008)

	)

6405 #define 
	#WWDG_CFR_W4
 ((
uint16_t
)0x0010)

	)

6406 #define 
	#WWDG_CFR_W5
 ((
uint16_t
)0x0020)

	)

6407 #define 
	#WWDG_CFR_W6
 ((
uint16_t
)0x0040)

	)

6409 #define 
	#WWDG_CFR_WDGTB
 ((
uint16_t
)0x0180)

	)

6410 #define 
	#WWDG_CFR_WDGTB0
 ((
uint16_t
)0x0080)

	)

6411 #define 
	#WWDG_CFR_WDGTB1
 ((
uint16_t
)0x0100)

	)

6413 #define 
	#WWDG_CFR_EWI
 ((
uint16_t
)0x0200)

	)

6416 #define 
	#WWDG_SR_EWIF
 ((
uint8_t
)0x01)

	)

6425 #define 
	#DBGMCU_IDCODE_DEV_ID
 ((
uint32_t
)0x00000FFF)

	)

6426 #define 
	#DBGMCU_IDCODE_REV_ID
 ((
uint32_t
)0xFFFF0000)

	)

6429 #define 
	#DBGMCU_CR_DBG_SLEEP
 ((
uint32_t
)0x00000001)

	)

6430 #define 
	#DBGMCU_CR_DBG_STOP
 ((
uint32_t
)0x00000002)

	)

6431 #define 
	#DBGMCU_CR_DBG_STANDBY
 ((
uint32_t
)0x00000004)

	)

6432 #define 
	#DBGMCU_CR_TRACE_IOEN
 ((
uint32_t
)0x00000020)

	)

6434 #define 
	#DBGMCU_CR_TRACE_MODE
 ((
uint32_t
)0x000000C0)

	)

6435 #define 
	#DBGMCU_CR_TRACE_MODE_0
 ((
uint32_t
)0x00000040)

	)

6436 #define 
	#DBGMCU_CR_TRACE_MODE_1
 ((
uint32_t
)0x00000080)

	)

6439 #define 
	#DBGMCU_APB1_FZ_DBG_TIM2_STOP
 ((
uint32_t
)0x00000001)

	)

6440 #define 
	#DBGMCU_APB1_FZ_DBG_TIM3_STOP
 ((
uint32_t
)0x00000002)

	)

6441 #define 
	#DBGMCU_APB1_FZ_DBG_TIM4_STOP
 ((
uint32_t
)0x00000004)

	)

6442 #define 
	#DBGMCU_APB1_FZ_DBG_TIM5_STOP
 ((
uint32_t
)0x00000008)

	)

6443 #define 
	#DBGMCU_APB1_FZ_DBG_TIM6_STOP
 ((
uint32_t
)0x00000010)

	)

6444 #define 
	#DBGMCU_APB1_FZ_DBG_TIM7_STOP
 ((
uint32_t
)0x00000020)

	)

6445 #define 
	#DBGMCU_APB1_FZ_DBG_TIM12_STOP
 ((
uint32_t
)0x00000040)

	)

6446 #define 
	#DBGMCU_APB1_FZ_DBG_TIM13_STOP
 ((
uint32_t
)0x00000080)

	)

6447 #define 
	#DBGMCU_APB1_FZ_DBG_TIM14_STOP
 ((
uint32_t
)0x00000100)

	)

6448 #define 
	#DBGMCU_APB1_FZ_DBG_RTC_STOP
 ((
uint32_t
)0x00000400)

	)

6449 #define 
	#DBGMCU_APB1_FZ_DBG_WWDG_STOP
 ((
uint32_t
)0x00000800)

	)

6450 #define 
	#DBGMCU_APB1_FZ_DBG_IWDEG_STOP
 ((
uint32_t
)0x00001000)

	)

6451 #define 
	#DBGMCU_APB1_FZ_DBG_I2C1_SMBUS_TIMEOUT
 ((
uint32_t
)0x00200000)

	)

6452 #define 
	#DBGMCU_APB1_FZ_DBG_I2C2_SMBUS_TIMEOUT
 ((
uint32_t
)0x00400000)

	)

6453 #define 
	#DBGMCU_APB1_FZ_DBG_I2C3_SMBUS_TIMEOUT
 ((
uint32_t
)0x00800000)

	)

6454 #define 
	#DBGMCU_APB1_FZ_DBG_CAN1_STOP
 ((
uint32_t
)0x02000000)

	)

6455 #define 
	#DBGMCU_APB1_FZ_DBG_CAN2_STOP
 ((
uint32_t
)0x04000000)

	)

6458 #define 
	#DBGMCU_APB1_FZ_DBG_TIM1_STOP
 ((
uint32_t
)0x00000001)

	)

6459 #define 
	#DBGMCU_APB1_FZ_DBG_TIM8_STOP
 ((
uint32_t
)0x00000002)

	)

6460 #define 
	#DBGMCU_APB1_FZ_DBG_TIM9_STOP
 ((
uint32_t
)0x00010000)

	)

6461 #define 
	#DBGMCU_APB1_FZ_DBG_TIM10_STOP
 ((
uint32_t
)0x00020000)

	)

6462 #define 
	#DBGMCU_APB1_FZ_DBG_TIM11_STOP
 ((
uint32_t
)0x00040000)

	)

6470 #define 
	#ETH_MACCR_WD
 ((
uint32_t
)0x00800000)

	)

6471 #define 
	#ETH_MACCR_JD
 ((
uint32_t
)0x00400000)

	)

6472 #define 
	#ETH_MACCR_IFG
 ((
uint32_t
)0x000E0000)

	)

6473 #define 
	#ETH_MACCR_IFG_96Bit
 ((
uint32_t
)0x00000000)

	)

6474 #define 
	#ETH_MACCR_IFG_88Bit
 ((
uint32_t
)0x00020000)

	)

6475 #define 
	#ETH_MACCR_IFG_80Bit
 ((
uint32_t
)0x00040000)

	)

6476 #define 
	#ETH_MACCR_IFG_72Bit
 ((
uint32_t
)0x00060000)

	)

6477 #define 
	#ETH_MACCR_IFG_64Bit
 ((
uint32_t
)0x00080000)

	)

6478 #define 
	#ETH_MACCR_IFG_56Bit
 ((
uint32_t
)0x000A0000)

	)

6479 #define 
	#ETH_MACCR_IFG_48Bit
 ((
uint32_t
)0x000C0000)

	)

6480 #define 
	#ETH_MACCR_IFG_40Bit
 ((
uint32_t
)0x000E0000)

	)

6481 #define 
	#ETH_MACCR_CSD
 ((
uint32_t
)0x00010000)

	)

6482 #define 
	#ETH_MACCR_FES
 ((
uint32_t
)0x00004000)

	)

6483 #define 
	#ETH_MACCR_ROD
 ((
uint32_t
)0x00002000)

	)

6484 #define 
	#ETH_MACCR_LM
 ((
uint32_t
)0x00001000)

	)

6485 #define 
	#ETH_MACCR_DM
 ((
uint32_t
)0x00000800)

	)

6486 #define 
	#ETH_MACCR_IPCO
 ((
uint32_t
)0x00000400)

	)

6487 #define 
	#ETH_MACCR_RD
 ((
uint32_t
)0x00000200)

	)

6488 #define 
	#ETH_MACCR_APCS
 ((
uint32_t
)0x00000080)

	)

6489 #define 
	#ETH_MACCR_BL
 ((
uint32_t
)0x00000060)

	)

6491 #define 
	#ETH_MACCR_BL_10
 ((
uint32_t
)0x00000000)

	)

6492 #define 
	#ETH_MACCR_BL_8
 ((
uint32_t
)0x00000020)

	)

6493 #define 
	#ETH_MACCR_BL_4
 ((
uint32_t
)0x00000040)

	)

6494 #define 
	#ETH_MACCR_BL_1
 ((
uint32_t
)0x00000060)

	)

6495 #define 
	#ETH_MACCR_DC
 ((
uint32_t
)0x00000010)

	)

6496 #define 
	#ETH_MACCR_TE
 ((
uint32_t
)0x00000008)

	)

6497 #define 
	#ETH_MACCR_RE
 ((
uint32_t
)0x00000004)

	)

6500 #define 
	#ETH_MACFFR_RA
 ((
uint32_t
)0x80000000)

	)

6501 #define 
	#ETH_MACFFR_HPF
 ((
uint32_t
)0x00000400)

	)

6502 #define 
	#ETH_MACFFR_SAF
 ((
uint32_t
)0x00000200)

	)

6503 #define 
	#ETH_MACFFR_SAIF
 ((
uint32_t
)0x00000100)

	)

6504 #define 
	#ETH_MACFFR_PCF
 ((
uint32_t
)0x000000C0)

	)

6505 #define 
	#ETH_MACFFR_PCF_BlockAll
 ((
uint32_t
)0x00000040)

	)

6506 #define 
	#ETH_MACFFR_PCF_ForwardAll
 ((
uint32_t
)0x00000080)

	)

6507 #define 
	#ETH_MACFFR_PCF_ForwardPassedAddrFilter
 ((
uint32_t
)0x000000C0)

	)

6508 #define 
	#ETH_MACFFR_BFD
 ((
uint32_t
)0x00000020)

	)

6509 #define 
	#ETH_MACFFR_PAM
 ((
uint32_t
)0x00000010)

	)

6510 #define 
	#ETH_MACFFR_DAIF
 ((
uint32_t
)0x00000008)

	)

6511 #define 
	#ETH_MACFFR_HM
 ((
uint32_t
)0x00000004)

	)

6512 #define 
	#ETH_MACFFR_HU
 ((
uint32_t
)0x00000002)

	)

6513 #define 
	#ETH_MACFFR_PM
 ((
uint32_t
)0x00000001)

	)

6516 #define 
	#ETH_MACHTHR_HTH
 ((
uint32_t
)0xFFFFFFFF)

	)

6519 #define 
	#ETH_MACHTLR_HTL
 ((
uint32_t
)0xFFFFFFFF)

	)

6522 #define 
	#ETH_MACMIIAR_PA
 ((
uint32_t
)0x0000F800)

	)

6523 #define 
	#ETH_MACMIIAR_MR
 ((
uint32_t
)0x000007C0)

	)

6524 #define 
	#ETH_MACMIIAR_CR
 ((
uint32_t
)0x0000001C)

	)

6525 #define 
	#ETH_MACMIIAR_CR_Div42
 ((
uint32_t
)0x00000000)

	)

6526 #define 
	#ETH_MACMIIAR_CR_Div62
 ((
uint32_t
)0x00000004)

	)

6527 #define 
	#ETH_MACMIIAR_CR_Div16
 ((
uint32_t
)0x00000008)

	)

6528 #define 
	#ETH_MACMIIAR_CR_Div26
 ((
uint32_t
)0x0000000C)

	)

6529 #define 
	#ETH_MACMIIAR_CR_Div102
 ((
uint32_t
)0x00000010)

	)

6530 #define 
	#ETH_MACMIIAR_MW
 ((
uint32_t
)0x00000002)

	)

6531 #define 
	#ETH_MACMIIAR_MB
 ((
uint32_t
)0x00000001)

	)

6534 #define 
	#ETH_MACMIIDR_MD
 ((
uint32_t
)0x0000FFFF)

	)

6537 #define 
	#ETH_MACFCR_PT
 ((
uint32_t
)0xFFFF0000)

	)

6538 #define 
	#ETH_MACFCR_ZQPD
 ((
uint32_t
)0x00000080)

	)

6539 #define 
	#ETH_MACFCR_PLT
 ((
uint32_t
)0x00000030)

	)

6540 #define 
	#ETH_MACFCR_PLT_Minus4
 ((
uint32_t
)0x00000000)

	)

6541 #define 
	#ETH_MACFCR_PLT_Minus28
 ((
uint32_t
)0x00000010)

	)

6542 #define 
	#ETH_MACFCR_PLT_Minus144
 ((
uint32_t
)0x00000020)

	)

6543 #define 
	#ETH_MACFCR_PLT_Minus256
 ((
uint32_t
)0x00000030)

	)

6544 #define 
	#ETH_MACFCR_UPFD
 ((
uint32_t
)0x00000008)

	)

6545 #define 
	#ETH_MACFCR_RFCE
 ((
uint32_t
)0x00000004)

	)

6546 #define 
	#ETH_MACFCR_TFCE
 ((
uint32_t
)0x00000002)

	)

6547 #define 
	#ETH_MACFCR_FCBBPA
 ((
uint32_t
)0x00000001)

	)

6550 #define 
	#ETH_MACVLANTR_VLANTC
 ((
uint32_t
)0x00010000)

	)

6551 #define 
	#ETH_MACVLANTR_VLANTI
 ((
uint32_t
)0x0000FFFF)

	)

6554 #define 
	#ETH_MACRWUFFR_D
 ((
uint32_t
)0xFFFFFFFF)

	)

6568 #define 
	#ETH_MACPMTCSR_WFFRPR
 ((
uint32_t
)0x80000000)

	)

6569 #define 
	#ETH_MACPMTCSR_GU
 ((
uint32_t
)0x00000200)

	)

6570 #define 
	#ETH_MACPMTCSR_WFR
 ((
uint32_t
)0x00000040)

	)

6571 #define 
	#ETH_MACPMTCSR_MPR
 ((
uint32_t
)0x00000020)

	)

6572 #define 
	#ETH_MACPMTCSR_WFE
 ((
uint32_t
)0x00000004)

	)

6573 #define 
	#ETH_MACPMTCSR_MPE
 ((
uint32_t
)0x00000002)

	)

6574 #define 
	#ETH_MACPMTCSR_PD
 ((
uint32_t
)0x00000001)

	)

6577 #define 
	#ETH_MACSR_TSTS
 ((
uint32_t
)0x00000200)

	)

6578 #define 
	#ETH_MACSR_MMCTS
 ((
uint32_t
)0x00000040)

	)

6579 #define 
	#ETH_MACSR_MMMCRS
 ((
uint32_t
)0x00000020)

	)

6580 #define 
	#ETH_MACSR_MMCS
 ((
uint32_t
)0x00000010)

	)

6581 #define 
	#ETH_MACSR_PMTS
 ((
uint32_t
)0x00000008)

	)

6584 #define 
	#ETH_MACIMR_TSTIM
 ((
uint32_t
)0x00000200)

	)

6585 #define 
	#ETH_MACIMR_PMTIM
 ((
uint32_t
)0x00000008)

	)

6588 #define 
	#ETH_MACA0HR_MACA0H
 ((
uint32_t
)0x0000FFFF)

	)

6591 #define 
	#ETH_MACA0LR_MACA0L
 ((
uint32_t
)0xFFFFFFFF)

	)

6594 #define 
	#ETH_MACA1HR_AE
 ((
uint32_t
)0x80000000)

	)

6595 #define 
	#ETH_MACA1HR_SA
 ((
uint32_t
)0x40000000)

	)

6596 #define 
	#ETH_MACA1HR_MBC
 ((
uint32_t
)0x3F000000)

	)

6597 #define 
	#ETH_MACA1HR_MBC_HBits15_8
 ((
uint32_t
)0x20000000)

	)

6598 #define 
	#ETH_MACA1HR_MBC_HBits7_0
 ((
uint32_t
)0x10000000)

	)

6599 #define 
	#ETH_MACA1HR_MBC_LBits31_24
 ((
uint32_t
)0x08000000)

	)

6600 #define 
	#ETH_MACA1HR_MBC_LBits23_16
 ((
uint32_t
)0x04000000)

	)

6601 #define 
	#ETH_MACA1HR_MBC_LBits15_8
 ((
uint32_t
)0x02000000)

	)

6602 #define 
	#ETH_MACA1HR_MBC_LBits7_0
 ((
uint32_t
)0x01000000)

	)

6603 #define 
	#ETH_MACA1HR_MACA1H
 ((
uint32_t
)0x0000FFFF)

	)

6606 #define 
	#ETH_MACA1LR_MACA1L
 ((
uint32_t
)0xFFFFFFFF)

	)

6609 #define 
	#ETH_MACA2HR_AE
 ((
uint32_t
)0x80000000)

	)

6610 #define 
	#ETH_MACA2HR_SA
 ((
uint32_t
)0x40000000)

	)

6611 #define 
	#ETH_MACA2HR_MBC
 ((
uint32_t
)0x3F000000)

	)

6612 #define 
	#ETH_MACA2HR_MBC_HBits15_8
 ((
uint32_t
)0x20000000)

	)

6613 #define 
	#ETH_MACA2HR_MBC_HBits7_0
 ((
uint32_t
)0x10000000)

	)

6614 #define 
	#ETH_MACA2HR_MBC_LBits31_24
 ((
uint32_t
)0x08000000)

	)

6615 #define 
	#ETH_MACA2HR_MBC_LBits23_16
 ((
uint32_t
)0x04000000)

	)

6616 #define 
	#ETH_MACA2HR_MBC_LBits15_8
 ((
uint32_t
)0x02000000)

	)

6617 #define 
	#ETH_MACA2HR_MBC_LBits7_0
 ((
uint32_t
)0x01000000)

	)

6618 #define 
	#ETH_MACA2HR_MACA2H
 ((
uint32_t
)0x0000FFFF)

	)

6621 #define 
	#ETH_MACA2LR_MACA2L
 ((
uint32_t
)0xFFFFFFFF)

	)

6624 #define 
	#ETH_MACA3HR_AE
 ((
uint32_t
)0x80000000)

	)

6625 #define 
	#ETH_MACA3HR_SA
 ((
uint32_t
)0x40000000)

	)

6626 #define 
	#ETH_MACA3HR_MBC
 ((
uint32_t
)0x3F000000)

	)

6627 #define 
	#ETH_MACA3HR_MBC_HBits15_8
 ((
uint32_t
)0x20000000)

	)

6628 #define 
	#ETH_MACA3HR_MBC_HBits7_0
 ((
uint32_t
)0x10000000)

	)

6629 #define 
	#ETH_MACA3HR_MBC_LBits31_24
 ((
uint32_t
)0x08000000)

	)

6630 #define 
	#ETH_MACA3HR_MBC_LBits23_16
 ((
uint32_t
)0x04000000)

	)

6631 #define 
	#ETH_MACA3HR_MBC_LBits15_8
 ((
uint32_t
)0x02000000)

	)

6632 #define 
	#ETH_MACA3HR_MBC_LBits7_0
 ((
uint32_t
)0x01000000)

	)

6633 #define 
	#ETH_MACA3HR_MACA3H
 ((
uint32_t
)0x0000FFFF)

	)

6636 #define 
	#ETH_MACA3LR_MACA3L
 ((
uint32_t
)0xFFFFFFFF)

	)

6643 #define 
	#ETH_MMCCR_MCFHP
 ((
uint32_t
)0x00000020)

	)

6644 #define 
	#ETH_MMCCR_MCP
 ((
uint32_t
)0x00000010)

	)

6645 #define 
	#ETH_MMCCR_MCF
 ((
uint32_t
)0x00000008)

	)

6646 #define 
	#ETH_MMCCR_ROR
 ((
uint32_t
)0x00000004)

	)

6647 #define 
	#ETH_MMCCR_CSR
 ((
uint32_t
)0x00000002)

	)

6648 #define 
	#ETH_MMCCR_CR
 ((
uint32_t
)0x00000001)

	)

6651 #define 
	#ETH_MMCRIR_RGUFS
 ((
uint32_t
)0x00020000)

	)

6652 #define 
	#ETH_MMCRIR_RFAES
 ((
uint32_t
)0x00000040)

	)

6653 #define 
	#ETH_MMCRIR_RFCES
 ((
uint32_t
)0x00000020)

	)

6656 #define 
	#ETH_MMCTIR_TGFS
 ((
uint32_t
)0x00200000)

	)

6657 #define 
	#ETH_MMCTIR_TGFMSCS
 ((
uint32_t
)0x00008000)

	)

6658 #define 
	#ETH_MMCTIR_TGFSCS
 ((
uint32_t
)0x00004000)

	)

6661 #define 
	#ETH_MMCRIMR_RGUFM
 ((
uint32_t
)0x00020000)

	)

6662 #define 
	#ETH_MMCRIMR_RFAEM
 ((
uint32_t
)0x00000040)

	)

6663 #define 
	#ETH_MMCRIMR_RFCEM
 ((
uint32_t
)0x00000020)

	)

6666 #define 
	#ETH_MMCTIMR_TGFM
 ((
uint32_t
)0x00200000)

	)

6667 #define 
	#ETH_MMCTIMR_TGFMSCM
 ((
uint32_t
)0x00008000)

	)

6668 #define 
	#ETH_MMCTIMR_TGFSCM
 ((
uint32_t
)0x00004000)

	)

6671 #define 
	#ETH_MMCTGFSCCR_TGFSCC
 ((
uint32_t
)0xFFFFFFFF)

	)

6674 #define 
	#ETH_MMCTGFMSCCR_TGFMSCC
 ((
uint32_t
)0xFFFFFFFF)

	)

6677 #define 
	#ETH_MMCTGFCR_TGFC
 ((
uint32_t
)0xFFFFFFFF)

	)

6680 #define 
	#ETH_MMCRFCECR_RFCEC
 ((
uint32_t
)0xFFFFFFFF)

	)

6683 #define 
	#ETH_MMCRFAECR_RFAEC
 ((
uint32_t
)0xFFFFFFFF)

	)

6686 #define 
	#ETH_MMCRGUFCR_RGUFC
 ((
uint32_t
)0xFFFFFFFF)

	)

6693 #define 
	#ETH_PTPTSCR_TSCNT
 ((
uint32_t
)0x00030000)

	)

6694 #define 
	#ETH_PTPTSSR_TSSMRME
 ((
uint32_t
)0x00008000)

	)

6695 #define 
	#ETH_PTPTSSR_TSSEME
 ((
uint32_t
)0x00004000)

	)

6696 #define 
	#ETH_PTPTSSR_TSSIPV4FE
 ((
uint32_t
)0x00002000)

	)

6697 #define 
	#ETH_PTPTSSR_TSSIPV6FE
 ((
uint32_t
)0x00001000)

	)

6698 #define 
	#ETH_PTPTSSR_TSSPTPOEFE
 ((
uint32_t
)0x00000800)

	)

6699 #define 
	#ETH_PTPTSSR_TSPTPPSV2E
 ((
uint32_t
)0x00000400)

	)

6700 #define 
	#ETH_PTPTSSR_TSSSR
 ((
uint32_t
)0x00000200)

	)

6701 #define 
	#ETH_PTPTSSR_TSSARFE
 ((
uint32_t
)0x00000100)

	)

6703 #define 
	#ETH_PTPTSCR_TSARU
 ((
uint32_t
)0x00000020)

	)

6704 #define 
	#ETH_PTPTSCR_TSITE
 ((
uint32_t
)0x00000010)

	)

6705 #define 
	#ETH_PTPTSCR_TSSTU
 ((
uint32_t
)0x00000008)

	)

6706 #define 
	#ETH_PTPTSCR_TSSTI
 ((
uint32_t
)0x00000004)

	)

6707 #define 
	#ETH_PTPTSCR_TSFCU
 ((
uint32_t
)0x00000002)

	)

6708 #define 
	#ETH_PTPTSCR_TSE
 ((
uint32_t
)0x00000001)

	)

6711 #define 
	#ETH_PTPSSIR_STSSI
 ((
uint32_t
)0x000000FF)

	)

6714 #define 
	#ETH_PTPTSHR_STS
 ((
uint32_t
)0xFFFFFFFF)

	)

6717 #define 
	#ETH_PTPTSLR_STPNS
 ((
uint32_t
)0x80000000)

	)

6718 #define 
	#ETH_PTPTSLR_STSS
 ((
uint32_t
)0x7FFFFFFF)

	)

6721 #define 
	#ETH_PTPTSHUR_TSUS
 ((
uint32_t
)0xFFFFFFFF)

	)

6724 #define 
	#ETH_PTPTSLUR_TSUPNS
 ((
uint32_t
)0x80000000)

	)

6725 #define 
	#ETH_PTPTSLUR_TSUSS
 ((
uint32_t
)0x7FFFFFFF)

	)

6728 #define 
	#ETH_PTPTSAR_TSA
 ((
uint32_t
)0xFFFFFFFF)

	)

6731 #define 
	#ETH_PTPTTHR_TTSH
 ((
uint32_t
)0xFFFFFFFF)

	)

6734 #define 
	#ETH_PTPTTLR_TTSL
 ((
uint32_t
)0xFFFFFFFF)

	)

6737 #define 
	#ETH_PTPTSSR_TSTTR
 ((
uint32_t
)0x00000020)

	)

6738 #define 
	#ETH_PTPTSSR_TSSO
 ((
uint32_t
)0x00000010)

	)

6745 #define 
	#ETH_DMABMR_AAB
 ((
uint32_t
)0x02000000)

	)

6746 #define 
	#ETH_DMABMR_FPM
 ((
uint32_t
)0x01000000)

	)

6747 #define 
	#ETH_DMABMR_USP
 ((
uint32_t
)0x00800000)

	)

6748 #define 
	#ETH_DMABMR_RDP
 ((
uint32_t
)0x007E0000)

	)

6749 #define 
	#ETH_DMABMR_RDP_1Beat
 ((
uint32_t
)0x00020000)

	)

6750 #define 
	#ETH_DMABMR_RDP_2Beat
 ((
uint32_t
)0x00040000)

	)

6751 #define 
	#ETH_DMABMR_RDP_4Beat
 ((
uint32_t
)0x00080000)

	)

6752 #define 
	#ETH_DMABMR_RDP_8Beat
 ((
uint32_t
)0x00100000)

	)

6753 #define 
	#ETH_DMABMR_RDP_16Beat
 ((
uint32_t
)0x00200000)

	)

6754 #define 
	#ETH_DMABMR_RDP_32Beat
 ((
uint32_t
)0x00400000)

	)

6755 #define 
	#ETH_DMABMR_RDP_4xPBL_4Beat
 ((
uint32_t
)0x01020000)

	)

6756 #define 
	#ETH_DMABMR_RDP_4xPBL_8Beat
 ((
uint32_t
)0x01040000)

	)

6757 #define 
	#ETH_DMABMR_RDP_4xPBL_16Beat
 ((
uint32_t
)0x01080000)

	)

6758 #define 
	#ETH_DMABMR_RDP_4xPBL_32Beat
 ((
uint32_t
)0x01100000)

	)

6759 #define 
	#ETH_DMABMR_RDP_4xPBL_64Beat
 ((
uint32_t
)0x01200000)

	)

6760 #define 
	#ETH_DMABMR_RDP_4xPBL_128Beat
 ((
uint32_t
)0x01400000)

	)

6761 #define 
	#ETH_DMABMR_FB
 ((
uint32_t
)0x00010000)

	)

6762 #define 
	#ETH_DMABMR_RTPR
 ((
uint32_t
)0x0000C000)

	)

6763 #define 
	#ETH_DMABMR_RTPR_1_1
 ((
uint32_t
)0x00000000)

	)

6764 #define 
	#ETH_DMABMR_RTPR_2_1
 ((
uint32_t
)0x00004000)

	)

6765 #define 
	#ETH_DMABMR_RTPR_3_1
 ((
uint32_t
)0x00008000)

	)

6766 #define 
	#ETH_DMABMR_RTPR_4_1
 ((
uint32_t
)0x0000C000)

	)

6767 #define 
	#ETH_DMABMR_PBL
 ((
uint32_t
)0x00003F00)

	)

6768 #define 
	#ETH_DMABMR_PBL_1Beat
 ((
uint32_t
)0x00000100)

	)

6769 #define 
	#ETH_DMABMR_PBL_2Beat
 ((
uint32_t
)0x00000200)

	)

6770 #define 
	#ETH_DMABMR_PBL_4Beat
 ((
uint32_t
)0x00000400)

	)

6771 #define 
	#ETH_DMABMR_PBL_8Beat
 ((
uint32_t
)0x00000800)

	)

6772 #define 
	#ETH_DMABMR_PBL_16Beat
 ((
uint32_t
)0x00001000)

	)

6773 #define 
	#ETH_DMABMR_PBL_32Beat
 ((
uint32_t
)0x00002000)

	)

6774 #define 
	#ETH_DMABMR_PBL_4xPBL_4Beat
 ((
uint32_t
)0x01000100)

	)

6775 #define 
	#ETH_DMABMR_PBL_4xPBL_8Beat
 ((
uint32_t
)0x01000200)

	)

6776 #define 
	#ETH_DMABMR_PBL_4xPBL_16Beat
 ((
uint32_t
)0x01000400)

	)

6777 #define 
	#ETH_DMABMR_PBL_4xPBL_32Beat
 ((
uint32_t
)0x01000800)

	)

6778 #define 
	#ETH_DMABMR_PBL_4xPBL_64Beat
 ((
uint32_t
)0x01001000)

	)

6779 #define 
	#ETH_DMABMR_PBL_4xPBL_128Beat
 ((
uint32_t
)0x01002000)

	)

6780 #define 
	#ETH_DMABMR_EDE
 ((
uint32_t
)0x00000080)

	)

6781 #define 
	#ETH_DMABMR_DSL
 ((
uint32_t
)0x0000007C)

	)

6782 #define 
	#ETH_DMABMR_DA
 ((
uint32_t
)0x00000002)

	)

6783 #define 
	#ETH_DMABMR_SR
 ((
uint32_t
)0x00000001)

	)

6786 #define 
	#ETH_DMATPDR_TPD
 ((
uint32_t
)0xFFFFFFFF)

	)

6789 #define 
	#ETH_DMARPDR_RPD
 ((
uint32_t
)0xFFFFFFFF)

	)

6792 #define 
	#ETH_DMARDLAR_SRL
 ((
uint32_t
)0xFFFFFFFF)

	)

6795 #define 
	#ETH_DMATDLAR_STL
 ((
uint32_t
)0xFFFFFFFF)

	)

6798 #define 
	#ETH_DMASR_TSTS
 ((
uint32_t
)0x20000000)

	)

6799 #define 
	#ETH_DMASR_PMTS
 ((
uint32_t
)0x10000000)

	)

6800 #define 
	#ETH_DMASR_MMCS
 ((
uint32_t
)0x08000000)

	)

6801 #define 
	#ETH_DMASR_EBS
 ((
uint32_t
)0x03800000)

	)

6803 #define 
	#ETH_DMASR_EBS_DescAccess
 ((
uint32_t
)0x02000000)

	)

6804 #define 
	#ETH_DMASR_EBS_ReadTransf
 ((
uint32_t
)0x01000000)

	)

6805 #define 
	#ETH_DMASR_EBS_DataTransfTx
 ((
uint32_t
)0x00800000)

	)

6806 #define 
	#ETH_DMASR_TPS
 ((
uint32_t
)0x00700000)

	)

6807 #define 
	#ETH_DMASR_TPS_Stopped
 ((
uint32_t
)0x00000000)

	)

6808 #define 
	#ETH_DMASR_TPS_Fetching
 ((
uint32_t
)0x00100000)

	)

6809 #define 
	#ETH_DMASR_TPS_Waiting
 ((
uint32_t
)0x00200000)

	)

6810 #define 
	#ETH_DMASR_TPS_Reading
 ((
uint32_t
)0x00300000)

	)

6811 #define 
	#ETH_DMASR_TPS_Suspended
 ((
uint32_t
)0x00600000)

	)

6812 #define 
	#ETH_DMASR_TPS_Closing
 ((
uint32_t
)0x00700000)

	)

6813 #define 
	#ETH_DMASR_RPS
 ((
uint32_t
)0x000E0000)

	)

6814 #define 
	#ETH_DMASR_RPS_Stopped
 ((
uint32_t
)0x00000000)

	)

6815 #define 
	#ETH_DMASR_RPS_Fetching
 ((
uint32_t
)0x00020000)

	)

6816 #define 
	#ETH_DMASR_RPS_Waiting
 ((
uint32_t
)0x00060000)

	)

6817 #define 
	#ETH_DMASR_RPS_Suspended
 ((
uint32_t
)0x00080000)

	)

6818 #define 
	#ETH_DMASR_RPS_Closing
 ((
uint32_t
)0x000A0000)

	)

6819 #define 
	#ETH_DMASR_RPS_Queuing
 ((
uint32_t
)0x000E0000)

	)

6820 #define 
	#ETH_DMASR_NIS
 ((
uint32_t
)0x00010000)

	)

6821 #define 
	#ETH_DMASR_AIS
 ((
uint32_t
)0x00008000)

	)

6822 #define 
	#ETH_DMASR_ERS
 ((
uint32_t
)0x00004000)

	)

6823 #define 
	#ETH_DMASR_FBES
 ((
uint32_t
)0x00002000)

	)

6824 #define 
	#ETH_DMASR_ETS
 ((
uint32_t
)0x00000400)

	)

6825 #define 
	#ETH_DMASR_RWTS
 ((
uint32_t
)0x00000200)

	)

6826 #define 
	#ETH_DMASR_RPSS
 ((
uint32_t
)0x00000100)

	)

6827 #define 
	#ETH_DMASR_RBUS
 ((
uint32_t
)0x00000080)

	)

6828 #define 
	#ETH_DMASR_RS
 ((
uint32_t
)0x00000040)

	)

6829 #define 
	#ETH_DMASR_TUS
 ((
uint32_t
)0x00000020)

	)

6830 #define 
	#ETH_DMASR_ROS
 ((
uint32_t
)0x00000010)

	)

6831 #define 
	#ETH_DMASR_TJTS
 ((
uint32_t
)0x00000008)

	)

6832 #define 
	#ETH_DMASR_TBUS
 ((
uint32_t
)0x00000004)

	)

6833 #define 
	#ETH_DMASR_TPSS
 ((
uint32_t
)0x00000002)

	)

6834 #define 
	#ETH_DMASR_TS
 ((
uint32_t
)0x00000001)

	)

6837 #define 
	#ETH_DMAOMR_DTCEFD
 ((
uint32_t
)0x04000000)

	)

6838 #define 
	#ETH_DMAOMR_RSF
 ((
uint32_t
)0x02000000)

	)

6839 #define 
	#ETH_DMAOMR_DFRF
 ((
uint32_t
)0x01000000)

	)

6840 #define 
	#ETH_DMAOMR_TSF
 ((
uint32_t
)0x00200000)

	)

6841 #define 
	#ETH_DMAOMR_FTF
 ((
uint32_t
)0x00100000)

	)

6842 #define 
	#ETH_DMAOMR_TTC
 ((
uint32_t
)0x0001C000)

	)

6843 #define 
	#ETH_DMAOMR_TTC_64Bytes
 ((
uint32_t
)0x00000000)

	)

6844 #define 
	#ETH_DMAOMR_TTC_128Bytes
 ((
uint32_t
)0x00004000)

	)

6845 #define 
	#ETH_DMAOMR_TTC_192Bytes
 ((
uint32_t
)0x00008000)

	)

6846 #define 
	#ETH_DMAOMR_TTC_256Bytes
 ((
uint32_t
)0x0000C000)

	)

6847 #define 
	#ETH_DMAOMR_TTC_40Bytes
 ((
uint32_t
)0x00010000)

	)

6848 #define 
	#ETH_DMAOMR_TTC_32Bytes
 ((
uint32_t
)0x00014000)

	)

6849 #define 
	#ETH_DMAOMR_TTC_24Bytes
 ((
uint32_t
)0x00018000)

	)

6850 #define 
	#ETH_DMAOMR_TTC_16Bytes
 ((
uint32_t
)0x0001C000)

	)

6851 #define 
	#ETH_DMAOMR_ST
 ((
uint32_t
)0x00002000)

	)

6852 #define 
	#ETH_DMAOMR_FEF
 ((
uint32_t
)0x00000080)

	)

6853 #define 
	#ETH_DMAOMR_FUGF
 ((
uint32_t
)0x00000040)

	)

6854 #define 
	#ETH_DMAOMR_RTC
 ((
uint32_t
)0x00000018)

	)

6855 #define 
	#ETH_DMAOMR_RTC_64Bytes
 ((
uint32_t
)0x00000000)

	)

6856 #define 
	#ETH_DMAOMR_RTC_32Bytes
 ((
uint32_t
)0x00000008)

	)

6857 #define 
	#ETH_DMAOMR_RTC_96Bytes
 ((
uint32_t
)0x00000010)

	)

6858 #define 
	#ETH_DMAOMR_RTC_128Bytes
 ((
uint32_t
)0x00000018)

	)

6859 #define 
	#ETH_DMAOMR_OSF
 ((
uint32_t
)0x00000004)

	)

6860 #define 
	#ETH_DMAOMR_SR
 ((
uint32_t
)0x00000002)

	)

6863 #define 
	#ETH_DMAIER_NISE
 ((
uint32_t
)0x00010000)

	)

6864 #define 
	#ETH_DMAIER_AISE
 ((
uint32_t
)0x00008000)

	)

6865 #define 
	#ETH_DMAIER_ERIE
 ((
uint32_t
)0x00004000)

	)

6866 #define 
	#ETH_DMAIER_FBEIE
 ((
uint32_t
)0x00002000)

	)

6867 #define 
	#ETH_DMAIER_ETIE
 ((
uint32_t
)0x00000400)

	)

6868 #define 
	#ETH_DMAIER_RWTIE
 ((
uint32_t
)0x00000200)

	)

6869 #define 
	#ETH_DMAIER_RPSIE
 ((
uint32_t
)0x00000100)

	)

6870 #define 
	#ETH_DMAIER_RBUIE
 ((
uint32_t
)0x00000080)

	)

6871 #define 
	#ETH_DMAIER_RIE
 ((
uint32_t
)0x00000040)

	)

6872 #define 
	#ETH_DMAIER_TUIE
 ((
uint32_t
)0x00000020)

	)

6873 #define 
	#ETH_DMAIER_ROIE
 ((
uint32_t
)0x00000010)

	)

6874 #define 
	#ETH_DMAIER_TJTIE
 ((
uint32_t
)0x00000008)

	)

6875 #define 
	#ETH_DMAIER_TBUIE
 ((
uint32_t
)0x00000004)

	)

6876 #define 
	#ETH_DMAIER_TPSIE
 ((
uint32_t
)0x00000002)

	)

6877 #define 
	#ETH_DMAIER_TIE
 ((
uint32_t
)0x00000001)

	)

6880 #define 
	#ETH_DMAMFBOCR_OFOC
 ((
uint32_t
)0x10000000)

	)

6881 #define 
	#ETH_DMAMFBOCR_MFA
 ((
uint32_t
)0x0FFE0000)

	)

6882 #define 
	#ETH_DMAMFBOCR_OMFC
 ((
uint32_t
)0x00010000)

	)

6883 #define 
	#ETH_DMAMFBOCR_MFC
 ((
uint32_t
)0x0000FFFF)

	)

6886 #define 
	#ETH_DMACHTDR_HTDAP
 ((
uint32_t
)0xFFFFFFFF)

	)

6889 #define 
	#ETH_DMACHRDR_HRDAP
 ((
uint32_t
)0xFFFFFFFF)

	)

6892 #define 
	#ETH_DMACHTBAR_HTBAP
 ((
uint32_t
)0xFFFFFFFF)

	)

6895 #define 
	#ETH_DMACHRBAR_HRBAP
 ((
uint32_t
)0xFFFFFFFF)

	)

6905 #ifdef 
USE_STDPERIPH_DRIVER


6906 #include 
	~"stm32f4xx_conf.h
"

6913 #define 
	#SET_BIT
(
REG
, 
BIT
) ((REG) |= (BIT))

	)

6915 #define 
	#CLEAR_BIT
(
REG
, 
BIT
) ((REG) &= ~(BIT))

	)

6917 #define 
	#READ_BIT
(
REG
, 
BIT
) ((REG) & (BIT))

	)

6919 #define 
	#CLEAR_REG
(
REG
) ((REG) = (0x0))

	)

6921 #define 
	#WRITE_REG
(
REG
, 
VAL
) ((REG) = (VAL))

	)

6923 #define 
	#READ_REG
(
REG
) ((REG))

	)

6925 #define 
	#MODIFY_REG
(
REG
, 
CLEARMASK
, 
SETMASK
) 
	`WRITE_REG
((REG), (((
	`READ_REG
(REG)) & (~(CLEARMASK))) | (SETMASK)))

	)

6931 #ifdef 
__cplusplus


	@Libraries/Device/STM32F4xx/Include/system_stm32f4xx.h

33 #ifndef 
__SYSTEM_STM32F4XX_H


34 #define 
	#__SYSTEM_STM32F4XX_H


	)

36 #ifdef 
__cplusplus


53 extern 
uint32_t
 
SystemCoreClock
;

80 extern void 
SystemInit
(void);

81 extern void 
SystemCoreClockUpdate
(void);

86 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/misc.h

24 #ifndef 
__MISC_H


25 #define 
	#__MISC_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

50 
uint8_t
 
NVIC_IRQChannel
;

55 
uint8_t
 
NVIC_IRQChannelPreemptionPriority
;

60 
uint8_t
 
NVIC_IRQChannelSubPriority
;

65 
FunctionalState
 
NVIC_IRQChannelCmd
;

68 } 
	tNVIC_InitTypeDef
;

80 #define 
	#NVIC_VectTab_RAM
 ((
uint32_t
)0x20000000)

	)

81 #define 
	#NVIC_VectTab_FLASH
 ((
uint32_t
)0x08000000)

	)

82 #define 
	#IS_NVIC_VECTTAB
(
VECTTAB
) (((VECTTAB) == 
NVIC_VectTab_RAM
) || \

	)

83 ((
VECTTAB
) == 
NVIC_VectTab_FLASH
))

92 #define 
	#NVIC_LP_SEVONPEND
 ((
uint8_t
)0x10)

	)

93 #define 
	#NVIC_LP_SLEEPDEEP
 ((
uint8_t
)0x04)

	)

94 #define 
	#NVIC_LP_SLEEPONEXIT
 ((
uint8_t
)0x02)

	)

95 #define 
	#IS_NVIC_LP
(
LP
) (((LP) == 
NVIC_LP_SEVONPEND
) || \

	)

96 ((
LP
) == 
NVIC_LP_SLEEPDEEP
) || \

97 ((
LP
) == 
NVIC_LP_SLEEPONEXIT
))

106 #define 
	#NVIC_PriorityGroup_0
 ((
uint32_t
)0x700)

	)

108 #define 
	#NVIC_PriorityGroup_1
 ((
uint32_t
)0x600)

	)

110 #define 
	#NVIC_PriorityGroup_2
 ((
uint32_t
)0x500)

	)

112 #define 
	#NVIC_PriorityGroup_3
 ((
uint32_t
)0x400)

	)

114 #define 
	#NVIC_PriorityGroup_4
 ((
uint32_t
)0x300)

	)

117 #define 
	#IS_NVIC_PRIORITY_GROUP
(
GROUP
) (((GROUP) == 
NVIC_PriorityGroup_0
) || \

	)

118 ((
GROUP
) == 
NVIC_PriorityGroup_1
) || \

119 ((
GROUP
) == 
NVIC_PriorityGroup_2
) || \

120 ((
GROUP
) == 
NVIC_PriorityGroup_3
) || \

121 ((
GROUP
) == 
NVIC_PriorityGroup_4
))

123 #define 
	#IS_NVIC_PREEMPTION_PRIORITY
(
PRIORITY
) ((PRIORITY) < 0x10)

	)

125 #define 
	#IS_NVIC_SUB_PRIORITY
(
PRIORITY
) ((PRIORITY) < 0x10)

	)

127 #define 
	#IS_NVIC_OFFSET
(
OFFSET
) ((OFFSET) < 0x000FFFFF)

	)

137 #define 
	#SysTick_CLKSource_HCLK_Div8
 ((
uint32_t
)0xFFFFFFFB)

	)

138 #define 
	#SysTick_CLKSource_HCLK
 ((
uint32_t
)0x00000004)

	)

139 #define 
	#IS_SYSTICK_CLK_SOURCE
(
SOURCE
) (((SOURCE) == 
SysTick_CLKSource_HCLK
) || \

	)

140 ((
SOURCE
) == 
SysTick_CLKSource_HCLK_Div8
))

152 void 
NVIC_PriorityGroupConfig
(
uint32_t
 
NVIC_PriorityGroup
);

153 void 
NVIC_Init
(
NVIC_InitTypeDef
* 
NVIC_InitStruct
);

154 void 
NVIC_SetVectorTable
(
uint32_t
 
NVIC_VectTab
, uint32_t 
Offset
);

155 void 
NVIC_SystemLPConfig
(
uint8_t
 
LowPowerMode
, 
FunctionalState
 
NewState
);

156 void 
SysTick_CLKSourceConfig
(
uint32_t
 
SysTick_CLKSource
);

158 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_adc.h

24 #ifndef 
__STM32F4xx_ADC_H


25 #define 
	#__STM32F4xx_ADC_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

49 
uint32_t
 
ADC_Resolution
;

51 
FunctionalState
 
ADC_ScanConvMode
;

55 
FunctionalState
 
ADC_ContinuousConvMode
;

58 
uint32_t
 
ADC_ExternalTrigConvEdge
;

62 
uint32_t
 
ADC_ExternalTrigConv
;

66 
uint32_t
 
ADC_DataAlign
;

69 
uint8_t
 
ADC_NbrOfConversion
;

73 }
	tADC_InitTypeDef
;

80 
uint32_t
 
ADC_Mode
;

83 
uint32_t
 
ADC_Prescaler
;

86 
uint32_t
 
ADC_DMAAccessMode
;

90 
uint32_t
 
ADC_TwoSamplingDelay
;

94 }
	tADC_CommonInitTypeDef
;

102 #define 
	#IS_ADC_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
ADC1
) || \

	)

103 ((
PERIPH
) == 
ADC2
) || \

104 ((
PERIPH
) == 
ADC3
))

109 #define 
	#ADC_Mode_Independent
 ((
uint32_t
)0x00000000)

	)

110 #define 
	#ADC_DualMode_RegSimult_InjecSimult
 ((
uint32_t
)0x00000001)

	)

111 #define 
	#ADC_DualMode_RegSimult_AlterTrig
 ((
uint32_t
)0x00000002)

	)

112 #define 
	#ADC_DualMode_InjecSimult
 ((
uint32_t
)0x00000005)

	)

113 #define 
	#ADC_DualMode_RegSimult
 ((
uint32_t
)0x00000006)

	)

114 #define 
	#ADC_DualMode_Interl
 ((
uint32_t
)0x00000007)

	)

115 #define 
	#ADC_DualMode_AlterTrig
 ((
uint32_t
)0x00000009)

	)

116 #define 
	#ADC_TripleMode_RegSimult_InjecSimult
 ((
uint32_t
)0x00000011)

	)

117 #define 
	#ADC_TripleMode_RegSimult_AlterTrig
 ((
uint32_t
)0x00000012)

	)

118 #define 
	#ADC_TripleMode_InjecSimult
 ((
uint32_t
)0x00000015)

	)

119 #define 
	#ADC_TripleMode_RegSimult
 ((
uint32_t
)0x00000016)

	)

120 #define 
	#ADC_TripleMode_Interl
 ((
uint32_t
)0x00000017)

	)

121 #define 
	#ADC_TripleMode_AlterTrig
 ((
uint32_t
)0x00000019)

	)

122 #define 
	#IS_ADC_MODE
(
MODE
) (((MODE) == 
ADC_Mode_Independent
) || \

	)

123 ((
MODE
) == 
ADC_DualMode_RegSimult_InjecSimult
) || \

124 ((
MODE
) == 
ADC_DualMode_RegSimult_AlterTrig
) || \

125 ((
MODE
) == 
ADC_DualMode_InjecSimult
) || \

126 ((
MODE
) == 
ADC_DualMode_RegSimult
) || \

127 ((
MODE
) == 
ADC_DualMode_Interl
) || \

128 ((
MODE
) == 
ADC_DualMode_AlterTrig
) || \

129 ((
MODE
) == 
ADC_TripleMode_RegSimult_InjecSimult
) || \

130 ((
MODE
) == 
ADC_TripleMode_RegSimult_AlterTrig
) || \

131 ((
MODE
) == 
ADC_TripleMode_InjecSimult
) || \

132 ((
MODE
) == 
ADC_TripleMode_RegSimult
) || \

133 ((
MODE
) == 
ADC_TripleMode_Interl
) || \

134 ((
MODE
) == 
ADC_TripleMode_AlterTrig
))

143 #define 
	#ADC_Prescaler_Div2
 ((
uint32_t
)0x00000000)

	)

144 #define 
	#ADC_Prescaler_Div4
 ((
uint32_t
)0x00010000)

	)

145 #define 
	#ADC_Prescaler_Div6
 ((
uint32_t
)0x00020000)

	)

146 #define 
	#ADC_Prescaler_Div8
 ((
uint32_t
)0x00030000)

	)

147 #define 
	#IS_ADC_PRESCALER
(
PRESCALER
) (((PRESCALER) == 
ADC_Prescaler_Div2
) || \

	)

148 ((
PRESCALER
) == 
ADC_Prescaler_Div4
) || \

149 ((
PRESCALER
) == 
ADC_Prescaler_Div6
) || \

150 ((
PRESCALER
) == 
ADC_Prescaler_Div8
))

159 #define 
	#ADC_DMAAccessMode_Disabled
 ((
uint32_t
)0x00000000)

	)

160 #define 
	#ADC_DMAAccessMode_1
 ((
uint32_t
)0x00004000)

	)

161 #define 
	#ADC_DMAAccessMode_2
 ((
uint32_t
)0x00008000)

	)

162 #define 
	#ADC_DMAAccessMode_3
 ((
uint32_t
)0x0000C000)

	)

163 #define 
	#IS_ADC_DMA_ACCESS_MODE
(
MODE
) (((MODE) == 
ADC_DMAAccessMode_Disabled
) || \

	)

164 ((
MODE
) == 
ADC_DMAAccessMode_1
) || \

165 ((
MODE
) == 
ADC_DMAAccessMode_2
) || \

166 ((
MODE
) == 
ADC_DMAAccessMode_3
))

176 #define 
	#ADC_TwoSamplingDelay_5Cycles
 ((
uint32_t
)0x00000000)

	)

177 #define 
	#ADC_TwoSamplingDelay_6Cycles
 ((
uint32_t
)0x00000100)

	)

178 #define 
	#ADC_TwoSamplingDelay_7Cycles
 ((
uint32_t
)0x00000200)

	)

179 #define 
	#ADC_TwoSamplingDelay_8Cycles
 ((
uint32_t
)0x00000300)

	)

180 #define 
	#ADC_TwoSamplingDelay_9Cycles
 ((
uint32_t
)0x00000400)

	)

181 #define 
	#ADC_TwoSamplingDelay_10Cycles
 ((
uint32_t
)0x00000500)

	)

182 #define 
	#ADC_TwoSamplingDelay_11Cycles
 ((
uint32_t
)0x00000600)

	)

183 #define 
	#ADC_TwoSamplingDelay_12Cycles
 ((
uint32_t
)0x00000700)

	)

184 #define 
	#ADC_TwoSamplingDelay_13Cycles
 ((
uint32_t
)0x00000800)

	)

185 #define 
	#ADC_TwoSamplingDelay_14Cycles
 ((
uint32_t
)0x00000900)

	)

186 #define 
	#ADC_TwoSamplingDelay_15Cycles
 ((
uint32_t
)0x00000A00)

	)

187 #define 
	#ADC_TwoSamplingDelay_16Cycles
 ((
uint32_t
)0x00000B00)

	)

188 #define 
	#ADC_TwoSamplingDelay_17Cycles
 ((
uint32_t
)0x00000C00)

	)

189 #define 
	#ADC_TwoSamplingDelay_18Cycles
 ((
uint32_t
)0x00000D00)

	)

190 #define 
	#ADC_TwoSamplingDelay_19Cycles
 ((
uint32_t
)0x00000E00)

	)

191 #define 
	#ADC_TwoSamplingDelay_20Cycles
 ((
uint32_t
)0x00000F00)

	)

192 #define 
	#IS_ADC_SAMPLING_DELAY
(
DELAY
) (((DELAY) == 
ADC_TwoSamplingDelay_5Cycles
) || \

	)

193 ((
DELAY
) == 
ADC_TwoSamplingDelay_6Cycles
) || \

194 ((
DELAY
) == 
ADC_TwoSamplingDelay_7Cycles
) || \

195 ((
DELAY
) == 
ADC_TwoSamplingDelay_8Cycles
) || \

196 ((
DELAY
) == 
ADC_TwoSamplingDelay_9Cycles
) || \

197 ((
DELAY
) == 
ADC_TwoSamplingDelay_10Cycles
) || \

198 ((
DELAY
) == 
ADC_TwoSamplingDelay_11Cycles
) || \

199 ((
DELAY
) == 
ADC_TwoSamplingDelay_12Cycles
) || \

200 ((
DELAY
) == 
ADC_TwoSamplingDelay_13Cycles
) || \

201 ((
DELAY
) == 
ADC_TwoSamplingDelay_14Cycles
) || \

202 ((
DELAY
) == 
ADC_TwoSamplingDelay_15Cycles
) || \

203 ((
DELAY
) == 
ADC_TwoSamplingDelay_16Cycles
) || \

204 ((
DELAY
) == 
ADC_TwoSamplingDelay_17Cycles
) || \

205 ((
DELAY
) == 
ADC_TwoSamplingDelay_18Cycles
) || \

206 ((
DELAY
) == 
ADC_TwoSamplingDelay_19Cycles
) || \

207 ((
DELAY
) == 
ADC_TwoSamplingDelay_20Cycles
))

217 #define 
	#ADC_Resolution_12b
 ((
uint32_t
)0x00000000)

	)

218 #define 
	#ADC_Resolution_10b
 ((
uint32_t
)0x01000000)

	)

219 #define 
	#ADC_Resolution_8b
 ((
uint32_t
)0x02000000)

	)

220 #define 
	#ADC_Resolution_6b
 ((
uint32_t
)0x03000000)

	)

221 #define 
	#IS_ADC_RESOLUTION
(
RESOLUTION
) (((RESOLUTION) == 
ADC_Resolution_12b
) || \

	)

222 ((
RESOLUTION
) == 
ADC_Resolution_10b
) || \

223 ((
RESOLUTION
) == 
ADC_Resolution_8b
) || \

224 ((
RESOLUTION
) == 
ADC_Resolution_6b
))

234 #define 
	#ADC_ExternalTrigConvEdge_None
 ((
uint32_t
)0x00000000)

	)

235 #define 
	#ADC_ExternalTrigConvEdge_Rising
 ((
uint32_t
)0x10000000)

	)

236 #define 
	#ADC_ExternalTrigConvEdge_Falling
 ((
uint32_t
)0x20000000)

	)

237 #define 
	#ADC_ExternalTrigConvEdge_RisingFalling
 ((
uint32_t
)0x30000000)

	)

238 #define 
	#IS_ADC_EXT_TRIG_EDGE
(
EDGE
) (((EDGE) == 
ADC_ExternalTrigConvEdge_None
) || \

	)

239 ((
EDGE
) == 
ADC_ExternalTrigConvEdge_Rising
) || \

240 ((
EDGE
) == 
ADC_ExternalTrigConvEdge_Falling
) || \

241 ((
EDGE
) == 
ADC_ExternalTrigConvEdge_RisingFalling
))

250 #define 
	#ADC_ExternalTrigConv_T1_CC1
 ((
uint32_t
)0x00000000)

	)

251 #define 
	#ADC_ExternalTrigConv_T1_CC2
 ((
uint32_t
)0x01000000)

	)

252 #define 
	#ADC_ExternalTrigConv_T1_CC3
 ((
uint32_t
)0x02000000)

	)

253 #define 
	#ADC_ExternalTrigConv_T2_CC2
 ((
uint32_t
)0x03000000)

	)

254 #define 
	#ADC_ExternalTrigConv_T2_CC3
 ((
uint32_t
)0x04000000)

	)

255 #define 
	#ADC_ExternalTrigConv_T2_CC4
 ((
uint32_t
)0x05000000)

	)

256 #define 
	#ADC_ExternalTrigConv_T2_TRGO
 ((
uint32_t
)0x06000000)

	)

257 #define 
	#ADC_ExternalTrigConv_T3_CC1
 ((
uint32_t
)0x07000000)

	)

258 #define 
	#ADC_ExternalTrigConv_T3_TRGO
 ((
uint32_t
)0x08000000)

	)

259 #define 
	#ADC_ExternalTrigConv_T4_CC4
 ((
uint32_t
)0x09000000)

	)

260 #define 
	#ADC_ExternalTrigConv_T5_CC1
 ((
uint32_t
)0x0A000000)

	)

261 #define 
	#ADC_ExternalTrigConv_T5_CC2
 ((
uint32_t
)0x0B000000)

	)

262 #define 
	#ADC_ExternalTrigConv_T5_CC3
 ((
uint32_t
)0x0C000000)

	)

263 #define 
	#ADC_ExternalTrigConv_T8_CC1
 ((
uint32_t
)0x0D000000)

	)

264 #define 
	#ADC_ExternalTrigConv_T8_TRGO
 ((
uint32_t
)0x0E000000)

	)

265 #define 
	#ADC_ExternalTrigConv_Ext_IT11
 ((
uint32_t
)0x0F000000)

	)

266 #define 
	#IS_ADC_EXT_TRIG
(
REGTRIG
) (((REGTRIG) == 
ADC_ExternalTrigConv_T1_CC1
) || \

	)

267 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T1_CC2
) || \

268 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T1_CC3
) || \

269 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T2_CC2
) || \

270 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T2_CC3
) || \

271 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T2_CC4
) || \

272 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T2_TRGO
) || \

273 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T3_CC1
) || \

274 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T3_TRGO
) || \

275 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T4_CC4
) || \

276 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T5_CC1
) || \

277 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T5_CC2
) || \

278 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T5_CC3
) || \

279 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T8_CC1
) || \

280 ((
REGTRIG
) == 
ADC_ExternalTrigConv_T8_TRGO
) || \

281 ((
REGTRIG
) == 
ADC_ExternalTrigConv_Ext_IT11
))

290 #define 
	#ADC_DataAlign_Right
 ((
uint32_t
)0x00000000)

	)

291 #define 
	#ADC_DataAlign_Left
 ((
uint32_t
)0x00000800)

	)

292 #define 
	#IS_ADC_DATA_ALIGN
(
ALIGN
) (((ALIGN) == 
ADC_DataAlign_Right
) || \

	)

293 ((
ALIGN
) == 
ADC_DataAlign_Left
))

302 #define 
	#ADC_Channel_0
 ((
uint8_t
)0x00)

	)

303 #define 
	#ADC_Channel_1
 ((
uint8_t
)0x01)

	)

304 #define 
	#ADC_Channel_2
 ((
uint8_t
)0x02)

	)

305 #define 
	#ADC_Channel_3
 ((
uint8_t
)0x03)

	)

306 #define 
	#ADC_Channel_4
 ((
uint8_t
)0x04)

	)

307 #define 
	#ADC_Channel_5
 ((
uint8_t
)0x05)

	)

308 #define 
	#ADC_Channel_6
 ((
uint8_t
)0x06)

	)

309 #define 
	#ADC_Channel_7
 ((
uint8_t
)0x07)

	)

310 #define 
	#ADC_Channel_8
 ((
uint8_t
)0x08)

	)

311 #define 
	#ADC_Channel_9
 ((
uint8_t
)0x09)

	)

312 #define 
	#ADC_Channel_10
 ((
uint8_t
)0x0A)

	)

313 #define 
	#ADC_Channel_11
 ((
uint8_t
)0x0B)

	)

314 #define 
	#ADC_Channel_12
 ((
uint8_t
)0x0C)

	)

315 #define 
	#ADC_Channel_13
 ((
uint8_t
)0x0D)

	)

316 #define 
	#ADC_Channel_14
 ((
uint8_t
)0x0E)

	)

317 #define 
	#ADC_Channel_15
 ((
uint8_t
)0x0F)

	)

318 #define 
	#ADC_Channel_16
 ((
uint8_t
)0x10)

	)

319 #define 
	#ADC_Channel_17
 ((
uint8_t
)0x11)

	)

320 #define 
	#ADC_Channel_18
 ((
uint8_t
)0x12)

	)

322 #define 
	#ADC_Channel_TempSensor
 ((
uint8_t
)
ADC_Channel_16
)

	)

323 #define 
	#ADC_Channel_Vrefint
 ((
uint8_t
)
ADC_Channel_17
)

	)

324 #define 
	#ADC_Channel_Vbat
 ((
uint8_t
)
ADC_Channel_18
)

	)

326 #define 
	#IS_ADC_CHANNEL
(
CHANNEL
) (((CHANNEL) == 
ADC_Channel_0
) || \

	)

327 ((
CHANNEL
) == 
ADC_Channel_1
) || \

328 ((
CHANNEL
) == 
ADC_Channel_2
) || \

329 ((
CHANNEL
) == 
ADC_Channel_3
) || \

330 ((
CHANNEL
) == 
ADC_Channel_4
) || \

331 ((
CHANNEL
) == 
ADC_Channel_5
) || \

332 ((
CHANNEL
) == 
ADC_Channel_6
) || \

333 ((
CHANNEL
) == 
ADC_Channel_7
) || \

334 ((
CHANNEL
) == 
ADC_Channel_8
) || \

335 ((
CHANNEL
) == 
ADC_Channel_9
) || \

336 ((
CHANNEL
) == 
ADC_Channel_10
) || \

337 ((
CHANNEL
) == 
ADC_Channel_11
) || \

338 ((
CHANNEL
) == 
ADC_Channel_12
) || \

339 ((
CHANNEL
) == 
ADC_Channel_13
) || \

340 ((
CHANNEL
) == 
ADC_Channel_14
) || \

341 ((
CHANNEL
) == 
ADC_Channel_15
) || \

342 ((
CHANNEL
) == 
ADC_Channel_16
) || \

343 ((
CHANNEL
) == 
ADC_Channel_17
) || \

344 ((
CHANNEL
) == 
ADC_Channel_18
))

353 #define 
	#ADC_SampleTime_3Cycles
 ((
uint8_t
)0x00)

	)

354 #define 
	#ADC_SampleTime_15Cycles
 ((
uint8_t
)0x01)

	)

355 #define 
	#ADC_SampleTime_28Cycles
 ((
uint8_t
)0x02)

	)

356 #define 
	#ADC_SampleTime_56Cycles
 ((
uint8_t
)0x03)

	)

357 #define 
	#ADC_SampleTime_84Cycles
 ((
uint8_t
)0x04)

	)

358 #define 
	#ADC_SampleTime_112Cycles
 ((
uint8_t
)0x05)

	)

359 #define 
	#ADC_SampleTime_144Cycles
 ((
uint8_t
)0x06)

	)

360 #define 
	#ADC_SampleTime_480Cycles
 ((
uint8_t
)0x07)

	)

361 #define 
	#IS_ADC_SAMPLE_TIME
(
TIME
) (((TIME) == 
ADC_SampleTime_3Cycles
) || \

	)

362 ((
TIME
) == 
ADC_SampleTime_15Cycles
) || \

363 ((
TIME
) == 
ADC_SampleTime_28Cycles
) || \

364 ((
TIME
) == 
ADC_SampleTime_56Cycles
) || \

365 ((
TIME
) == 
ADC_SampleTime_84Cycles
) || \

366 ((
TIME
) == 
ADC_SampleTime_112Cycles
) || \

367 ((
TIME
) == 
ADC_SampleTime_144Cycles
) || \

368 ((
TIME
) == 
ADC_SampleTime_480Cycles
))

377 #define 
	#ADC_ExternalTrigInjecConvEdge_None
 ((
uint32_t
)0x00000000)

	)

378 #define 
	#ADC_ExternalTrigInjecConvEdge_Rising
 ((
uint32_t
)0x00100000)

	)

379 #define 
	#ADC_ExternalTrigInjecConvEdge_Falling
 ((
uint32_t
)0x00200000)

	)

380 #define 
	#ADC_ExternalTrigInjecConvEdge_RisingFalling
 ((
uint32_t
)0x00300000)

	)

381 #define 
	#IS_ADC_EXT_INJEC_TRIG_EDGE
(
EDGE
) (((EDGE) == 
ADC_ExternalTrigInjecConvEdge_None
) || \

	)

382 ((
EDGE
) == 
ADC_ExternalTrigInjecConvEdge_Rising
) || \

383 ((
EDGE
) == 
ADC_ExternalTrigInjecConvEdge_Falling
) || \

384 ((
EDGE
) == 
ADC_ExternalTrigInjecConvEdge_RisingFalling
))

394 #define 
	#ADC_ExternalTrigInjecConv_T1_CC4
 ((
uint32_t
)0x00000000)

	)

395 #define 
	#ADC_ExternalTrigInjecConv_T1_TRGO
 ((
uint32_t
)0x00010000)

	)

396 #define 
	#ADC_ExternalTrigInjecConv_T2_CC1
 ((
uint32_t
)0x00020000)

	)

397 #define 
	#ADC_ExternalTrigInjecConv_T2_TRGO
 ((
uint32_t
)0x00030000)

	)

398 #define 
	#ADC_ExternalTrigInjecConv_T3_CC2
 ((
uint32_t
)0x00040000)

	)

399 #define 
	#ADC_ExternalTrigInjecConv_T3_CC4
 ((
uint32_t
)0x00050000)

	)

400 #define 
	#ADC_ExternalTrigInjecConv_T4_CC1
 ((
uint32_t
)0x00060000)

	)

401 #define 
	#ADC_ExternalTrigInjecConv_T4_CC2
 ((
uint32_t
)0x00070000)

	)

402 #define 
	#ADC_ExternalTrigInjecConv_T4_CC3
 ((
uint32_t
)0x00080000)

	)

403 #define 
	#ADC_ExternalTrigInjecConv_T4_TRGO
 ((
uint32_t
)0x00090000)

	)

404 #define 
	#ADC_ExternalTrigInjecConv_T5_CC4
 ((
uint32_t
)0x000A0000)

	)

405 #define 
	#ADC_ExternalTrigInjecConv_T5_TRGO
 ((
uint32_t
)0x000B0000)

	)

406 #define 
	#ADC_ExternalTrigInjecConv_T8_CC2
 ((
uint32_t
)0x000C0000)

	)

407 #define 
	#ADC_ExternalTrigInjecConv_T8_CC3
 ((
uint32_t
)0x000D0000)

	)

408 #define 
	#ADC_ExternalTrigInjecConv_T8_CC4
 ((
uint32_t
)0x000E0000)

	)

409 #define 
	#ADC_ExternalTrigInjecConv_Ext_IT15
 ((
uint32_t
)0x000F0000)

	)

410 #define 
	#IS_ADC_EXT_INJEC_TRIG
(
INJTRIG
) (((INJTRIG) == 
ADC_ExternalTrigInjecConv_T1_CC4
) || \

	)

411 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T1_TRGO
) || \

412 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T2_CC1
) || \

413 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T2_TRGO
) || \

414 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T3_CC2
) || \

415 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T3_CC4
) || \

416 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T4_CC1
) || \

417 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T4_CC2
) || \

418 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T4_CC3
) || \

419 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T4_TRGO
) || \

420 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T5_CC4
) || \

421 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T5_TRGO
) || \

422 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T8_CC2
) || \

423 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T8_CC3
) || \

424 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_T8_CC4
) || \

425 ((
INJTRIG
) == 
ADC_ExternalTrigInjecConv_Ext_IT15
))

434 #define 
	#ADC_InjectedChannel_1
 ((
uint8_t
)0x14)

	)

435 #define 
	#ADC_InjectedChannel_2
 ((
uint8_t
)0x18)

	)

436 #define 
	#ADC_InjectedChannel_3
 ((
uint8_t
)0x1C)

	)

437 #define 
	#ADC_InjectedChannel_4
 ((
uint8_t
)0x20)

	)

438 #define 
	#IS_ADC_INJECTED_CHANNEL
(
CHANNEL
) (((CHANNEL) == 
ADC_InjectedChannel_1
) || \

	)

439 ((
CHANNEL
) == 
ADC_InjectedChannel_2
) || \

440 ((
CHANNEL
) == 
ADC_InjectedChannel_3
) || \

441 ((
CHANNEL
) == 
ADC_InjectedChannel_4
))

450 #define 
	#ADC_AnalogWatchdog_SingleRegEnable
 ((
uint32_t
)0x00800200)

	)

451 #define 
	#ADC_AnalogWatchdog_SingleInjecEnable
 ((
uint32_t
)0x00400200)

	)

452 #define 
	#ADC_AnalogWatchdog_SingleRegOrInjecEnable
 ((
uint32_t
)0x00C00200)

	)

453 #define 
	#ADC_AnalogWatchdog_AllRegEnable
 ((
uint32_t
)0x00800000)

	)

454 #define 
	#ADC_AnalogWatchdog_AllInjecEnable
 ((
uint32_t
)0x00400000)

	)

455 #define 
	#ADC_AnalogWatchdog_AllRegAllInjecEnable
 ((
uint32_t
)0x00C00000)

	)

456 #define 
	#ADC_AnalogWatchdog_None
 ((
uint32_t
)0x00000000)

	)

457 #define 
	#IS_ADC_ANALOG_WATCHDOG
(
WATCHDOG
) (((WATCHDOG) == 
ADC_AnalogWatchdog_SingleRegEnable
) || \

	)

458 ((
WATCHDOG
) == 
ADC_AnalogWatchdog_SingleInjecEnable
) || \

459 ((
WATCHDOG
) == 
ADC_AnalogWatchdog_SingleRegOrInjecEnable
) || \

460 ((
WATCHDOG
) == 
ADC_AnalogWatchdog_AllRegEnable
) || \

461 ((
WATCHDOG
) == 
ADC_AnalogWatchdog_AllInjecEnable
) || \

462 ((
WATCHDOG
) == 
ADC_AnalogWatchdog_AllRegAllInjecEnable
) || \

463 ((
WATCHDOG
) == 
ADC_AnalogWatchdog_None
))

472 #define 
	#ADC_IT_EOC
 ((
uint16_t
)0x0205)

	)

473 #define 
	#ADC_IT_AWD
 ((
uint16_t
)0x0106)

	)

474 #define 
	#ADC_IT_JEOC
 ((
uint16_t
)0x0407)

	)

475 #define 
	#ADC_IT_OVR
 ((
uint16_t
)0x201A)

	)

476 #define 
	#IS_ADC_IT
(
IT
) (((IT) == 
ADC_IT_EOC
) || ((IT) == 
ADC_IT_AWD
) || \

	)

477 ((
IT
) == 
ADC_IT_JEOC
)|| ((IT) == 
ADC_IT_OVR
))

486 #define 
	#ADC_FLAG_AWD
 ((
uint8_t
)0x01)

	)

487 #define 
	#ADC_FLAG_EOC
 ((
uint8_t
)0x02)

	)

488 #define 
	#ADC_FLAG_JEOC
 ((
uint8_t
)0x04)

	)

489 #define 
	#ADC_FLAG_JSTRT
 ((
uint8_t
)0x08)

	)

490 #define 
	#ADC_FLAG_STRT
 ((
uint8_t
)0x10)

	)

491 #define 
	#ADC_FLAG_OVR
 ((
uint8_t
)0x20)

	)

493 #define 
	#IS_ADC_CLEAR_FLAG
(
FLAG
) ((((FLAG) & (
uint8_t
)0xC0) == 0x00) && ((FLAG) != 0x00))

	)

494 #define 
	#IS_ADC_GET_FLAG
(
FLAG
) (((FLAG) == 
ADC_FLAG_AWD
) || \

	)

495 ((
FLAG
) == 
ADC_FLAG_EOC
) || \

496 ((
FLAG
) == 
ADC_FLAG_JEOC
) || \

497 ((
FLAG
)== 
ADC_FLAG_JSTRT
) || \

498 ((
FLAG
) == 
ADC_FLAG_STRT
) || \

499 ((
FLAG
)== 
ADC_FLAG_OVR
))

508 #define 
	#IS_ADC_THRESHOLD
(
THRESHOLD
) ((THRESHOLD) <= 0xFFF)

	)

517 #define 
	#IS_ADC_OFFSET
(
OFFSET
) ((OFFSET) <= 0xFFF)

	)

526 #define 
	#IS_ADC_INJECTED_LENGTH
(
LENGTH
) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x4))

	)

535 #define 
	#IS_ADC_INJECTED_RANK
(
RANK
) (((RANK) >= 0x1) && ((RANK) <= 0x4))

	)

544 #define 
	#IS_ADC_REGULAR_LENGTH
(
LENGTH
) (((LENGTH) >= 0x1) && ((LENGTH) <= 0x10))

	)

553 #define 
	#IS_ADC_REGULAR_RANK
(
RANK
) (((RANK) >= 0x1) && ((RANK) <= 0x10))

	)

562 #define 
	#IS_ADC_REGULAR_DISC_NUMBER
(
NUMBER
) (((NUMBER) >= 0x1) && ((NUMBER) <= 0x8))

	)

576 void 
ADC_DeInit
(void);

579 void 
ADC_Init
(
ADC_TypeDef
* 
ADCx
, 
ADC_InitTypeDef
* 
ADC_InitStruct
);

580 void 
ADC_StructInit
(
ADC_InitTypeDef
* 
ADC_InitStruct
);

581 void 
ADC_CommonInit
(
ADC_CommonInitTypeDef
* 
ADC_CommonInitStruct
);

582 void 
ADC_CommonStructInit
(
ADC_CommonInitTypeDef
* 
ADC_CommonInitStruct
);

583 void 
ADC_Cmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

586 void 
ADC_AnalogWatchdogCmd
(
ADC_TypeDef
* 
ADCx
, 
uint32_t
 
ADC_AnalogWatchdog
);

587 void 
ADC_AnalogWatchdogThresholdsConfig
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
HighThreshold
,uint16_t 
LowThreshold
);

588 void 
ADC_AnalogWatchdogSingleChannelConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_Channel
);

591 void 
ADC_TempSensorVrefintCmd
(
FunctionalState
 
NewState
);

592 void 
ADC_VBATCmd
(
FunctionalState
 
NewState
);

595 void 
ADC_RegularChannelConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_Channel
, uint8_t 
Rank
, uint8_t 
ADC_SampleTime
);

596 void 
ADC_SoftwareStartConv
(
ADC_TypeDef
* 
ADCx
);

597 
FlagStatus
 
ADC_GetSoftwareStartConvStatus
(
ADC_TypeDef
* 
ADCx
);

598 void 
ADC_EOCOnEachRegularChannelCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

599 void 
ADC_ContinuousModeCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

600 void 
ADC_DiscModeChannelCountConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
Number
);

601 void 
ADC_DiscModeCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

602 
uint16_t
 
ADC_GetConversionValue
(
ADC_TypeDef
* 
ADCx
);

603 
uint32_t
 
ADC_GetMultiModeConversionValue
(void);

606 void 
ADC_DMACmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

607 void 
ADC_DMARequestAfterLastTransferCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

608 void 
ADC_MultiModeDMARequestAfterLastTransferCmd
(
FunctionalState
 
NewState
);

611 void 
ADC_InjectedChannelConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_Channel
, uint8_t 
Rank
, uint8_t 
ADC_SampleTime
);

612 void 
ADC_InjectedSequencerLengthConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
Length
);

613 void 
ADC_SetInjectedOffset
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_InjectedChannel
, 
uint16_t
 
Offset
);

614 void 
ADC_ExternalTrigInjectedConvConfig
(
ADC_TypeDef
* 
ADCx
, 
uint32_t
 
ADC_ExternalTrigInjecConv
);

615 void 
ADC_ExternalTrigInjectedConvEdgeConfig
(
ADC_TypeDef
* 
ADCx
, 
uint32_t
 
ADC_ExternalTrigInjecConvEdge
);

616 void 
ADC_SoftwareStartInjectedConv
(
ADC_TypeDef
* 
ADCx
);

617 
FlagStatus
 
ADC_GetSoftwareStartInjectedConvCmdStatus
(
ADC_TypeDef
* 
ADCx
);

618 void 
ADC_AutoInjectedConvCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

619 void 
ADC_InjectedDiscModeCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
);

620 
uint16_t
 
ADC_GetInjectedConversionValue
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_InjectedChannel
);

623 void 
ADC_ITConfig
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
ADC_IT
, 
FunctionalState
 
NewState
);

624 
FlagStatus
 
ADC_GetFlagStatus
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_FLAG
);

625 void 
ADC_ClearFlag
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_FLAG
);

626 
ITStatus
 
ADC_GetITStatus
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
ADC_IT
);

627 void 
ADC_ClearITPendingBit
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
ADC_IT
);

629 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_can.h

24 #ifndef 
__STM32F4xx_CAN_H


25 #define 
	#__STM32F4xx_CAN_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

44 #define 
	#IS_CAN_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
CAN1
) || \

	)

45 ((
PERIPH
) == 
CAN2
))

52 
uint16_t
 
CAN_Prescaler
;

55 
uint8_t
 
CAN_Mode
;

58 
uint8_t
 
CAN_SJW
;

63 
uint8_t
 
CAN_BS1
;

67 
uint8_t
 
CAN_BS2
;

70 
FunctionalState
 
CAN_TTCM
;

73 
FunctionalState
 
CAN_ABOM
;

76 
FunctionalState
 
CAN_AWUM
;

79 
FunctionalState
 
CAN_NART
;

82 
FunctionalState
 
CAN_RFLM
;

85 
FunctionalState
 
CAN_TXFP
;

87 } 
	tCAN_InitTypeDef
;

94 
uint16_t
 
CAN_FilterIdHigh
;

98 
uint16_t
 
CAN_FilterIdLow
;

102 
uint16_t
 
CAN_FilterMaskIdHigh
;

107 
uint16_t
 
CAN_FilterMaskIdLow
;

112 
uint16_t
 
CAN_FilterFIFOAssignment
;

115 
uint8_t
 
CAN_FilterNumber
;

117 
uint8_t
 
CAN_FilterMode
;

120 
uint8_t
 
CAN_FilterScale
;

123 
FunctionalState
 
CAN_FilterActivation
;

125 } 
	tCAN_FilterInitTypeDef
;

132 
uint32_t
 
StdId
;

135 
uint32_t
 
ExtId
;

138 
uint8_t
 
IDE
;

142 
uint8_t
 
RTR
;

146 
uint8_t
 
DLC
;

150 
uint8_t
 
Data
[8];

152 } 
	tCanTxMsg
;

159 
uint32_t
 
StdId
;

162 
uint32_t
 
ExtId
;

165 
uint8_t
 
IDE
;

169 
uint8_t
 
RTR
;

173 
uint8_t
 
DLC
;

176 
uint8_t
 
Data
[8];

179 
uint8_t
 
FMI
;

182 } 
	tCanRxMsg
;

194 #define 
	#CAN_InitStatus_Failed
 ((
uint8_t
)0x00)

	)

195 #define 
	#CAN_InitStatus_Success
 ((
uint8_t
)0x01)

	)

199 #define 
	#CANINITFAILED
 
CAN_InitStatus_Failed


	)

200 #define 
	#CANINITOK
 
CAN_InitStatus_Success


	)

209 #define 
	#CAN_Mode_Normal
 ((
uint8_t
)0x00)

	)

210 #define 
	#CAN_Mode_LoopBack
 ((
uint8_t
)0x01)

	)

211 #define 
	#CAN_Mode_Silent
 ((
uint8_t
)0x02)

	)

212 #define 
	#CAN_Mode_Silent_LoopBack
 ((
uint8_t
)0x03)

	)

214 #define 
	#IS_CAN_MODE
(
MODE
) (((MODE) == 
CAN_Mode_Normal
) || \

	)

215 ((
MODE
) == 
CAN_Mode_LoopBack
)|| \

216 ((
MODE
) == 
CAN_Mode_Silent
) || \

217 ((
MODE
) == 
CAN_Mode_Silent_LoopBack
))

227 #define 
	#CAN_OperatingMode_Initialization
 ((
uint8_t
)0x00)

	)

228 #define 
	#CAN_OperatingMode_Normal
 ((
uint8_t
)0x01)

	)

229 #define 
	#CAN_OperatingMode_Sleep
 ((
uint8_t
)0x02)

	)

232 #define 
	#IS_CAN_OPERATING_MODE
(
MODE
) (((MODE) == 
CAN_OperatingMode_Initialization
) ||\

	)

233 ((
MODE
) == 
CAN_OperatingMode_Normal
)|| \

234 ((
MODE
) == 
CAN_OperatingMode_Sleep
))

244 #define 
	#CAN_ModeStatus_Failed
 ((
uint8_t
)0x00)

	)

245 #define 
	#CAN_ModeStatus_Success
 ((
uint8_t
)!
CAN_ModeStatus_Failed
)

	)

253 #define 
	#CAN_SJW_1tq
 ((
uint8_t
)0x00)

	)

254 #define 
	#CAN_SJW_2tq
 ((
uint8_t
)0x01)

	)

255 #define 
	#CAN_SJW_3tq
 ((
uint8_t
)0x02)

	)

256 #define 
	#CAN_SJW_4tq
 ((
uint8_t
)0x03)

	)

258 #define 
	#IS_CAN_SJW
(
SJW
) (((SJW) == 
CAN_SJW_1tq
) || ((SJW) == 
CAN_SJW_2tq
)|| \

	)

259 ((
SJW
) == 
CAN_SJW_3tq
) || ((SJW) == 
CAN_SJW_4tq
))

267 #define 
	#CAN_BS1_1tq
 ((
uint8_t
)0x00)

	)

268 #define 
	#CAN_BS1_2tq
 ((
uint8_t
)0x01)

	)

269 #define 
	#CAN_BS1_3tq
 ((
uint8_t
)0x02)

	)

270 #define 
	#CAN_BS1_4tq
 ((
uint8_t
)0x03)

	)

271 #define 
	#CAN_BS1_5tq
 ((
uint8_t
)0x04)

	)

272 #define 
	#CAN_BS1_6tq
 ((
uint8_t
)0x05)

	)

273 #define 
	#CAN_BS1_7tq
 ((
uint8_t
)0x06)

	)

274 #define 
	#CAN_BS1_8tq
 ((
uint8_t
)0x07)

	)

275 #define 
	#CAN_BS1_9tq
 ((
uint8_t
)0x08)

	)

276 #define 
	#CAN_BS1_10tq
 ((
uint8_t
)0x09)

	)

277 #define 
	#CAN_BS1_11tq
 ((
uint8_t
)0x0A)

	)

278 #define 
	#CAN_BS1_12tq
 ((
uint8_t
)0x0B)

	)

279 #define 
	#CAN_BS1_13tq
 ((
uint8_t
)0x0C)

	)

280 #define 
	#CAN_BS1_14tq
 ((
uint8_t
)0x0D)

	)

281 #define 
	#CAN_BS1_15tq
 ((
uint8_t
)0x0E)

	)

282 #define 
	#CAN_BS1_16tq
 ((
uint8_t
)0x0F)

	)

284 #define 
	#IS_CAN_BS1
(
BS1
) ((BS1) <= 
CAN_BS1_16tq
)

	)

292 #define 
	#CAN_BS2_1tq
 ((
uint8_t
)0x00)

	)

293 #define 
	#CAN_BS2_2tq
 ((
uint8_t
)0x01)

	)

294 #define 
	#CAN_BS2_3tq
 ((
uint8_t
)0x02)

	)

295 #define 
	#CAN_BS2_4tq
 ((
uint8_t
)0x03)

	)

296 #define 
	#CAN_BS2_5tq
 ((
uint8_t
)0x04)

	)

297 #define 
	#CAN_BS2_6tq
 ((
uint8_t
)0x05)

	)

298 #define 
	#CAN_BS2_7tq
 ((
uint8_t
)0x06)

	)

299 #define 
	#CAN_BS2_8tq
 ((
uint8_t
)0x07)

	)

301 #define 
	#IS_CAN_BS2
(
BS2
) ((BS2) <= 
CAN_BS2_8tq
)

	)

309 #define 
	#IS_CAN_PRESCALER
(
PRESCALER
) (((PRESCALER) >= 1) && ((PRESCALER) <= 1024))

	)

317 #define 
	#IS_CAN_FILTER_NUMBER
(
NUMBER
) ((NUMBER) <= 27)

	)

325 #define 
	#CAN_FilterMode_IdMask
 ((
uint8_t
)0x00)

	)

326 #define 
	#CAN_FilterMode_IdList
 ((
uint8_t
)0x01)

	)

328 #define 
	#IS_CAN_FILTER_MODE
(
MODE
) (((MODE) == 
CAN_FilterMode_IdMask
) || \

	)

329 ((
MODE
) == 
CAN_FilterMode_IdList
))

337 #define 
	#CAN_FilterScale_16bit
 ((
uint8_t
)0x00)

	)

338 #define 
	#CAN_FilterScale_32bit
 ((
uint8_t
)0x01)

	)

340 #define 
	#IS_CAN_FILTER_SCALE
(
SCALE
) (((SCALE) == 
CAN_FilterScale_16bit
) || \

	)

341 ((
SCALE
) == 
CAN_FilterScale_32bit
))

349 #define 
	#CAN_Filter_FIFO0
 ((
uint8_t
)0x00)

	)

350 #define 
	#CAN_Filter_FIFO1
 ((
uint8_t
)0x01)

	)

351 #define 
	#IS_CAN_FILTER_FIFO
(
FIFO
) (((FIFO) == 
CAN_FilterFIFO0
) || \

	)

352 ((
FIFO
) == 
CAN_FilterFIFO1
))

355 #define 
	#CAN_FilterFIFO0
 
CAN_Filter_FIFO0


	)

356 #define 
	#CAN_FilterFIFO1
 
CAN_Filter_FIFO1


	)

364 #define 
	#IS_CAN_BANKNUMBER
(
BANKNUMBER
) (((BANKNUMBER) >= 1) && ((BANKNUMBER) <= 27))

	)

372 #define 
	#IS_CAN_TRANSMITMAILBOX
(
TRANSMITMAILBOX
) ((TRANSMITMAILBOX) <= ((
uint8_t
)0x02))

	)

373 #define 
	#IS_CAN_STDID
(
STDID
) ((STDID) <= ((
uint32_t
)0x7FF))

	)

374 #define 
	#IS_CAN_EXTID
(
EXTID
) ((EXTID) <= ((
uint32_t
)0x1FFFFFFF))

	)

375 #define 
	#IS_CAN_DLC
(
DLC
) ((DLC) <= ((
uint8_t
)0x08))

	)

383 #define 
	#CAN_Id_Standard
 ((
uint32_t
)0x00000000)

	)

384 #define 
	#CAN_Id_Extended
 ((
uint32_t
)0x00000004)

	)

385 #define 
	#IS_CAN_IDTYPE
(
IDTYPE
) (((IDTYPE) == 
CAN_Id_Standard
) || \

	)

386 ((
IDTYPE
) == 
CAN_Id_Extended
))

389 #define 
	#CAN_ID_STD
 
CAN_Id_Standard


	)

390 #define 
	#CAN_ID_EXT
 
CAN_Id_Extended


	)

398 #define 
	#CAN_RTR_Data
 ((
uint32_t
)0x00000000)

	)

399 #define 
	#CAN_RTR_Remote
 ((
uint32_t
)0x00000002)

	)

400 #define 
	#IS_CAN_RTR
(
RTR
) (((RTR) == 
CAN_RTR_Data
) || ((RTR) == 
CAN_RTR_Remote
))

	)

403 #define 
	#CAN_RTR_DATA
 
CAN_RTR_Data


	)

404 #define 
	#CAN_RTR_REMOTE
 
CAN_RTR_Remote


	)

412 #define 
	#CAN_TxStatus_Failed
 ((
uint8_t
)0x00)

	)

413 #define 
	#CAN_TxStatus_Ok
 ((
uint8_t
)0x01)

	)

414 #define 
	#CAN_TxStatus_Pending
 ((
uint8_t
)0x02)

	)

415 #define 
	#CAN_TxStatus_NoMailBox
 ((
uint8_t
)0x04)

	)

418 #define 
	#CANTXFAILED
 
CAN_TxStatus_Failed


	)

419 #define 
	#CANTXOK
 
CAN_TxStatus_Ok


	)

420 #define 
	#CANTXPENDING
 
CAN_TxStatus_Pending


	)

421 #define 
	#CAN_NO_MB
 
CAN_TxStatus_NoMailBox


	)

429 #define 
	#CAN_FIFO0
 ((
uint8_t
)0x00)

	)

430 #define 
	#CAN_FIFO1
 ((
uint8_t
)0x01)

	)

432 #define 
	#IS_CAN_FIFO
(
FIFO
) (((FIFO) == 
CAN_FIFO0
) || ((FIFO) == 
CAN_FIFO1
))

	)

440 #define 
	#CAN_Sleep_Failed
 ((
uint8_t
)0x00)

	)

441 #define 
	#CAN_Sleep_Ok
 ((
uint8_t
)0x01)

	)

444 #define 
	#CANSLEEPFAILED
 
CAN_Sleep_Failed


	)

445 #define 
	#CANSLEEPOK
 
CAN_Sleep_Ok


	)

453 #define 
	#CAN_WakeUp_Failed
 ((
uint8_t
)0x00)

	)

454 #define 
	#CAN_WakeUp_Ok
 ((
uint8_t
)0x01)

	)

457 #define 
	#CANWAKEUPFAILED
 
CAN_WakeUp_Failed


	)

458 #define 
	#CANWAKEUPOK
 
CAN_WakeUp_Ok


	)

467 #define 
	#CAN_ErrorCode_NoErr
 ((
uint8_t
)0x00)

	)

468 #define 
	#CAN_ErrorCode_StuffErr
 ((
uint8_t
)0x10)

	)

469 #define 
	#CAN_ErrorCode_FormErr
 ((
uint8_t
)0x20)

	)

470 #define 
	#CAN_ErrorCode_ACKErr
 ((
uint8_t
)0x30)

	)

471 #define 
	#CAN_ErrorCode_BitRecessiveErr
 ((
uint8_t
)0x40)

	)

472 #define 
	#CAN_ErrorCode_BitDominantErr
 ((
uint8_t
)0x50)

	)

473 #define 
	#CAN_ErrorCode_CRCErr
 ((
uint8_t
)0x60)

	)

474 #define 
	#CAN_ErrorCode_SoftwareSetErr
 ((
uint8_t
)0x70)

	)

488 #define 
	#CAN_FLAG_RQCP0
 ((
uint32_t
)0x38000001)

	)

489 #define 
	#CAN_FLAG_RQCP1
 ((
uint32_t
)0x38000100)

	)

490 #define 
	#CAN_FLAG_RQCP2
 ((
uint32_t
)0x38010000)

	)

493 #define 
	#CAN_FLAG_FMP0
 ((
uint32_t
)0x12000003)

	)

494 #define 
	#CAN_FLAG_FF0
 ((
uint32_t
)0x32000008)

	)

495 #define 
	#CAN_FLAG_FOV0
 ((
uint32_t
)0x32000010)

	)

496 #define 
	#CAN_FLAG_FMP1
 ((
uint32_t
)0x14000003)

	)

497 #define 
	#CAN_FLAG_FF1
 ((
uint32_t
)0x34000008)

	)

498 #define 
	#CAN_FLAG_FOV1
 ((
uint32_t
)0x34000010)

	)

501 #define 
	#CAN_FLAG_WKU
 ((
uint32_t
)0x31000008)

	)

502 #define 
	#CAN_FLAG_SLAK
 ((
uint32_t
)0x31000012)

	)

507 #define 
	#CAN_FLAG_EWG
 ((
uint32_t
)0x10F00001)

	)

508 #define 
	#CAN_FLAG_EPV
 ((
uint32_t
)0x10F00002)

	)

509 #define 
	#CAN_FLAG_BOF
 ((
uint32_t
)0x10F00004)

	)

510 #define 
	#CAN_FLAG_LEC
 ((
uint32_t
)0x30F00070)

	)

512 #define 
	#IS_CAN_GET_FLAG
(
FLAG
) (((FLAG) == 
CAN_FLAG_LEC
) || ((FLAG) == 
CAN_FLAG_BOF
) || \

	)

513 ((
FLAG
) == 
CAN_FLAG_EPV
) || ((FLAG) == 
CAN_FLAG_EWG
) || \

514 ((
FLAG
) == 
CAN_FLAG_WKU
) || ((FLAG) == 
CAN_FLAG_FOV0
) || \

515 ((
FLAG
) == 
CAN_FLAG_FF0
) || ((FLAG) == 
CAN_FLAG_FMP0
) || \

516 ((
FLAG
) == 
CAN_FLAG_FOV1
) || ((FLAG) == 
CAN_FLAG_FF1
) || \

517 ((
FLAG
) == 
CAN_FLAG_FMP1
) || ((FLAG) == 
CAN_FLAG_RQCP2
) || \

518 ((
FLAG
) == 
CAN_FLAG_RQCP1
)|| ((FLAG) == 
CAN_FLAG_RQCP0
) || \

519 ((
FLAG
) == 
CAN_FLAG_SLAK
 ))

521 #define 
	#IS_CAN_CLEAR_FLAG
(
FLAG
)(((FLAG) == 
CAN_FLAG_LEC
) || ((FLAG) == 
CAN_FLAG_RQCP2
) || \

	)

522 ((
FLAG
) == 
CAN_FLAG_RQCP1
) || ((FLAG) == 
CAN_FLAG_RQCP0
) || \

523 ((
FLAG
) == 
CAN_FLAG_FF0
) || ((FLAG) == 
CAN_FLAG_FOV0
) ||\

524 ((
FLAG
) == 
CAN_FLAG_FF1
) || ((FLAG) == 
CAN_FLAG_FOV1
) || \

525 ((
FLAG
) == 
CAN_FLAG_WKU
) || ((FLAG) == 
CAN_FLAG_SLAK
))

534 #define 
	#CAN_IT_TME
 ((
uint32_t
)0x00000001)

	)

537 #define 
	#CAN_IT_FMP0
 ((
uint32_t
)0x00000002)

	)

538 #define 
	#CAN_IT_FF0
 ((
uint32_t
)0x00000004)

	)

539 #define 
	#CAN_IT_FOV0
 ((
uint32_t
)0x00000008)

	)

540 #define 
	#CAN_IT_FMP1
 ((
uint32_t
)0x00000010)

	)

541 #define 
	#CAN_IT_FF1
 ((
uint32_t
)0x00000020)

	)

542 #define 
	#CAN_IT_FOV1
 ((
uint32_t
)0x00000040)

	)

545 #define 
	#CAN_IT_WKU
 ((
uint32_t
)0x00010000)

	)

546 #define 
	#CAN_IT_SLK
 ((
uint32_t
)0x00020000)

	)

549 #define 
	#CAN_IT_EWG
 ((
uint32_t
)0x00000100)

	)

550 #define 
	#CAN_IT_EPV
 ((
uint32_t
)0x00000200)

	)

551 #define 
	#CAN_IT_BOF
 ((
uint32_t
)0x00000400)

	)

552 #define 
	#CAN_IT_LEC
 ((
uint32_t
)0x00000800)

	)

553 #define 
	#CAN_IT_ERR
 ((
uint32_t
)0x00008000)

	)

556 #define 
	#CAN_IT_RQCP0
 
CAN_IT_TME


	)

557 #define 
	#CAN_IT_RQCP1
 
CAN_IT_TME


	)

558 #define 
	#CAN_IT_RQCP2
 
CAN_IT_TME


	)

561 #define 
	#IS_CAN_IT
(
IT
) (((IT) == 
CAN_IT_TME
) || ((IT) == 
CAN_IT_FMP0
) ||\

	)

562 ((
IT
) == 
CAN_IT_FF0
) || ((IT) == 
CAN_IT_FOV0
) ||\

563 ((
IT
) == 
CAN_IT_FMP1
) || ((IT) == 
CAN_IT_FF1
) ||\

564 ((
IT
) == 
CAN_IT_FOV1
) || ((IT) == 
CAN_IT_EWG
) ||\

565 ((
IT
) == 
CAN_IT_EPV
) || ((IT) == 
CAN_IT_BOF
) ||\

566 ((
IT
) == 
CAN_IT_LEC
) || ((IT) == 
CAN_IT_ERR
) ||\

567 ((
IT
) == 
CAN_IT_WKU
) || ((IT) == 
CAN_IT_SLK
))

569 #define 
	#IS_CAN_CLEAR_IT
(
IT
) (((IT) == 
CAN_IT_TME
) || ((IT) == 
CAN_IT_FF0
) ||\

	)

570 ((
IT
) == 
CAN_IT_FOV0
)|| ((IT) == 
CAN_IT_FF1
) ||\

571 ((
IT
) == 
CAN_IT_FOV1
)|| ((IT) == 
CAN_IT_EWG
) ||\

572 ((
IT
) == 
CAN_IT_EPV
) || ((IT) == 
CAN_IT_BOF
) ||\

573 ((
IT
) == 
CAN_IT_LEC
) || ((IT) == 
CAN_IT_ERR
) ||\

574 ((
IT
) == 
CAN_IT_WKU
) || ((IT) == 
CAN_IT_SLK
))

587 void 
CAN_DeInit
(
CAN_TypeDef
* 
CANx
);

590 
uint8_t
 
CAN_Init
(
CAN_TypeDef
* 
CANx
, 
CAN_InitTypeDef
* 
CAN_InitStruct
);

591 void 
CAN_FilterInit
(
CAN_FilterInitTypeDef
* 
CAN_FilterInitStruct
);

592 void 
CAN_StructInit
(
CAN_InitTypeDef
* 
CAN_InitStruct
);

593 void 
CAN_SlaveStartBank
(
uint8_t
 
CAN_BankNumber
);

594 void 
CAN_DBGFreeze
(
CAN_TypeDef
* 
CANx
, 
FunctionalState
 
NewState
);

595 void 
CAN_TTComModeCmd
(
CAN_TypeDef
* 
CANx
, 
FunctionalState
 
NewState
);

598 
uint8_t
 
CAN_Transmit
(
CAN_TypeDef
* 
CANx
, 
CanTxMsg
* 
TxMessage
);

599 
uint8_t
 
CAN_TransmitStatus
(
CAN_TypeDef
* 
CANx
, uint8_t 
TransmitMailbox
);

600 void 
CAN_CancelTransmit
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
Mailbox
);

603 void 
CAN_Receive
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
FIFONumber
, 
CanRxMsg
* 
RxMessage
);

604 void 
CAN_FIFORelease
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
FIFONumber
);

605 
uint8_t
 
CAN_MessagePending
(
CAN_TypeDef
* 
CANx
, uint8_t 
FIFONumber
);

608 
uint8_t
 
CAN_OperatingModeRequest
(
CAN_TypeDef
* 
CANx
, uint8_t 
CAN_OperatingMode
);

609 
uint8_t
 
CAN_Sleep
(
CAN_TypeDef
* 
CANx
);

610 
uint8_t
 
CAN_WakeUp
(
CAN_TypeDef
* 
CANx
);

613 
uint8_t
 
CAN_GetLastErrorCode
(
CAN_TypeDef
* 
CANx
);

614 
uint8_t
 
CAN_GetReceiveErrorCounter
(
CAN_TypeDef
* 
CANx
);

615 
uint8_t
 
CAN_GetLSBTransmitErrorCounter
(
CAN_TypeDef
* 
CANx
);

618 void 
CAN_ITConfig
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_IT
, 
FunctionalState
 
NewState
);

619 
FlagStatus
 
CAN_GetFlagStatus
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_FLAG
);

620 void 
CAN_ClearFlag
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_FLAG
);

621 
ITStatus
 
CAN_GetITStatus
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_IT
);

622 void 
CAN_ClearITPendingBit
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_IT
);

624 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_crc.h

24 #ifndef 
__STM32F4xx_CRC_H


25 #define 
	#__STM32F4xx_CRC_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

56 void 
CRC_ResetDR
(void);

57 
uint32_t
 
CRC_CalcCRC
(uint32_t 
Data
);

58 
uint32_t
 
CRC_CalcBlockCRC
(uint32_t 
pBuffer
[], uint32_t 
BufferLength
);

59 
uint32_t
 
CRC_GetCRC
(void);

60 void 
CRC_SetIDRegister
(
uint8_t
 
IDValue
);

61 
uint8_t
 
CRC_GetIDRegister
(void);

63 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_cryp.h

24 #ifndef 
__STM32F4xx_CRYP_H


25 #define 
	#__STM32F4xx_CRYP_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

49 
uint16_t
 
CRYP_AlgoDir
;

51 
uint16_t
 
CRYP_AlgoMode
;

54 
uint16_t
 
CRYP_DataType
;

56 
uint16_t
 
CRYP_KeySize
;

59 }
	tCRYP_InitTypeDef
;

66 
uint32_t
 
CRYP_Key0Left
;

67 
uint32_t
 
CRYP_Key0Right
;

68 
uint32_t
 
CRYP_Key1Left
;

69 
uint32_t
 
CRYP_Key1Right
;

70 
uint32_t
 
CRYP_Key2Left
;

71 
uint32_t
 
CRYP_Key2Right
;

72 
uint32_t
 
CRYP_Key3Left
;

73 
uint32_t
 
CRYP_Key3Right
;

74 }
	tCRYP_KeyInitTypeDef
;

80 
uint32_t
 
CRYP_IV0Left
;

81 
uint32_t
 
CRYP_IV0Right
;

82 
uint32_t
 
CRYP_IV1Left
;

83 
uint32_t
 
CRYP_IV1Right
;

84 }
	tCRYP_IVInitTypeDef
;

92 
uint32_t
 
CR_bits9to2
;

94 
uint32_t
 
CRYP_IV0LR
;

95 
uint32_t
 
CRYP_IV0RR
;

96 
uint32_t
 
CRYP_IV1LR
;

97 
uint32_t
 
CRYP_IV1RR
;

99 
uint32_t
 
CRYP_K0LR
;

100 
uint32_t
 
CRYP_K0RR
;

101 
uint32_t
 
CRYP_K1LR
;

102 
uint32_t
 
CRYP_K1RR
;

103 
uint32_t
 
CRYP_K2LR
;

104 
uint32_t
 
CRYP_K2RR
;

105 
uint32_t
 
CRYP_K3LR
;

106 
uint32_t
 
CRYP_K3RR
;

107 }
	tCRYP_Context
;

119 #define 
	#CRYP_AlgoDir_Encrypt
 ((
uint16_t
)0x0000)

	)

120 #define 
	#CRYP_AlgoDir_Decrypt
 ((
uint16_t
)0x0004)

	)

121 #define 
	#IS_CRYP_ALGODIR
(
ALGODIR
) (((ALGODIR) == 
CRYP_AlgoDir_Encrypt
) || \

	)

122 ((
ALGODIR
) == 
CRYP_AlgoDir_Decrypt
))

133 #define 
	#CRYP_AlgoMode_TDES_ECB
 ((
uint16_t
)0x0000)

	)

134 #define 
	#CRYP_AlgoMode_TDES_CBC
 ((
uint16_t
)0x0008)

	)

137 #define 
	#CRYP_AlgoMode_DES_ECB
 ((
uint16_t
)0x0010)

	)

138 #define 
	#CRYP_AlgoMode_DES_CBC
 ((
uint16_t
)0x0018)

	)

141 #define 
	#CRYP_AlgoMode_AES_ECB
 ((
uint16_t
)0x0020)

	)

142 #define 
	#CRYP_AlgoMode_AES_CBC
 ((
uint16_t
)0x0028)

	)

143 #define 
	#CRYP_AlgoMode_AES_CTR
 ((
uint16_t
)0x0030)

	)

144 #define 
	#CRYP_AlgoMode_AES_Key
 ((
uint16_t
)0x0038)

	)

146 #define 
	#IS_CRYP_ALGOMODE
(
ALGOMODE
) (((ALGOMODE) == 
CRYP_AlgoMode_TDES_ECB
) || \

	)

147 ((
ALGOMODE
) == 
CRYP_AlgoMode_TDES_CBC
)|| \

148 ((
ALGOMODE
) == 
CRYP_AlgoMode_DES_ECB
)|| \

149 ((
ALGOMODE
) == 
CRYP_AlgoMode_DES_CBC
) || \

150 ((
ALGOMODE
) == 
CRYP_AlgoMode_AES_ECB
) || \

151 ((
ALGOMODE
) == 
CRYP_AlgoMode_AES_CBC
) || \

152 ((
ALGOMODE
) == 
CRYP_AlgoMode_AES_CTR
) || \

153 ((
ALGOMODE
) == 
CRYP_AlgoMode_AES_Key
))

161 #define 
	#CRYP_DataType_32b
 ((
uint16_t
)0x0000)

	)

162 #define 
	#CRYP_DataType_16b
 ((
uint16_t
)0x0040)

	)

163 #define 
	#CRYP_DataType_8b
 ((
uint16_t
)0x0080)

	)

164 #define 
	#CRYP_DataType_1b
 ((
uint16_t
)0x00C0)

	)

165 #define 
	#IS_CRYP_DATATYPE
(
DATATYPE
) (((DATATYPE) == 
CRYP_DataType_32b
) || \

	)

166 ((
DATATYPE
) == 
CRYP_DataType_16b
)|| \

167 ((
DATATYPE
) == 
CRYP_DataType_8b
)|| \

168 ((
DATATYPE
) == 
CRYP_DataType_1b
))

176 #define 
	#CRYP_KeySize_128b
 ((
uint16_t
)0x0000)

	)

177 #define 
	#CRYP_KeySize_192b
 ((
uint16_t
)0x0100)

	)

178 #define 
	#CRYP_KeySize_256b
 ((
uint16_t
)0x0200)

	)

179 #define 
	#IS_CRYP_KEYSIZE
(
KEYSIZE
) (((KEYSIZE) == 
CRYP_KeySize_128b
)|| \

	)

180 ((
KEYSIZE
) == 
CRYP_KeySize_192b
)|| \

181 ((
KEYSIZE
) == 
CRYP_KeySize_256b
))

189 #define 
	#CRYP_FLAG_BUSY
 ((
uint8_t
)0x10)

	)

193 #define 
	#CRYP_FLAG_IFEM
 ((
uint8_t
)0x01)

	)

194 #define 
	#CRYP_FLAG_IFNF
 ((
uint8_t
)0x02)

	)

195 #define 
	#CRYP_FLAG_INRIS
 ((
uint8_t
)0x22)

	)

196 #define 
	#CRYP_FLAG_OFNE
 ((
uint8_t
)0x04)

	)

198 #define 
	#CRYP_FLAG_OFFU
 ((
uint8_t
)0x08)

	)

199 #define 
	#CRYP_FLAG_OUTRIS
 ((
uint8_t
)0x21)

	)

202 #define 
	#IS_CRYP_GET_FLAG
(
FLAG
) (((FLAG) == 
CRYP_FLAG_IFEM
) || \

	)

203 ((
FLAG
) == 
CRYP_FLAG_IFNF
) || \

204 ((
FLAG
) == 
CRYP_FLAG_OFNE
) || \

205 ((
FLAG
) == 
CRYP_FLAG_OFFU
) || \

206 ((
FLAG
) == 
CRYP_FLAG_BUSY
) || \

207 ((
FLAG
) == 
CRYP_FLAG_OUTRIS
)|| \

208 ((
FLAG
) == 
CRYP_FLAG_INRIS
))

216 #define 
	#CRYP_IT_INI
 ((
uint8_t
)0x01)

	)

217 #define 
	#CRYP_IT_OUTI
 ((
uint8_t
)0x02)

	)

218 #define 
	#IS_CRYP_CONFIG_IT
(
IT
) ((((IT) & (
uint8_t
)0xFC) == 0x00) && ((IT) != 0x00))

	)

219 #define 
	#IS_CRYP_GET_IT
(
IT
) (((IT) == 
CRYP_IT_INI
) || ((IT) == 
CRYP_IT_OUTI
))

	)

228 #define 
	#MODE_ENCRYPT
 ((
uint8_t
)0x01)

	)

229 #define 
	#MODE_DECRYPT
 ((
uint8_t
)0x00)

	)

238 #define 
	#CRYP_DMAReq_DataIN
 ((
uint8_t
)0x01)

	)

239 #define 
	#CRYP_DMAReq_DataOUT
 ((
uint8_t
)0x02)

	)

240 #define 
	#IS_CRYP_DMAREQ
(
DMAREQ
) ((((DMAREQ) & (
uint8_t
)0xFC) == 0x00) && ((DMAREQ) != 0x00))

	)

253 void 
CRYP_DeInit
(void);

256 void 
CRYP_Init
(
CRYP_InitTypeDef
* 
CRYP_InitStruct
);

257 void 
CRYP_StructInit
(
CRYP_InitTypeDef
* 
CRYP_InitStruct
);

258 void 
CRYP_KeyInit
(
CRYP_KeyInitTypeDef
* 
CRYP_KeyInitStruct
);

259 void 
CRYP_KeyStructInit
(
CRYP_KeyInitTypeDef
* 
CRYP_KeyInitStruct
);

260 void 
CRYP_IVInit
(
CRYP_IVInitTypeDef
* 
CRYP_IVInitStruct
);

261 void 
CRYP_IVStructInit
(
CRYP_IVInitTypeDef
* 
CRYP_IVInitStruct
);

262 void 
CRYP_Cmd
(
FunctionalState
 
NewState
);

265 void 
CRYP_DataIn
(
uint32_t
 
Data
);

266 
uint32_t
 
CRYP_DataOut
(void);

267 void 
CRYP_FIFOFlush
(void);

270 
ErrorStatus
 
CRYP_SaveContext
(
CRYP_Context
* 
CRYP_ContextSave
,

271 
CRYP_KeyInitTypeDef
* 
CRYP_KeyInitStruct
);

272 void 
CRYP_RestoreContext
(
CRYP_Context
* 
CRYP_ContextRestore
);

275 void 
CRYP_DMACmd
(
uint8_t
 
CRYP_DMAReq
, 
FunctionalState
 
NewState
);

278 void 
CRYP_ITConfig
(
uint8_t
 
CRYP_IT
, 
FunctionalState
 
NewState
);

279 
ITStatus
 
CRYP_GetITStatus
(
uint8_t
 
CRYP_IT
);

280 
FlagStatus
 
CRYP_GetFlagStatus
(
uint8_t
 
CRYP_FLAG
);

283 
ErrorStatus
 
CRYP_AES_ECB
(
uint8_t
 
Mode
,

284 
uint8_t
 *
Key
, 
uint16_t
 
Keysize
,

285 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

286 
uint8_t
 *
Output
);

288 
ErrorStatus
 
CRYP_AES_CBC
(
uint8_t
 
Mode
,

289 
uint8_t
 
InitVectors
[16],

290 
uint8_t
 *
Key
, 
uint16_t
 
Keysize
,

291 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

292 
uint8_t
 *
Output
);

294 
ErrorStatus
 
CRYP_AES_CTR
(
uint8_t
 
Mode
,

295 
uint8_t
 
InitVectors
[16],

296 
uint8_t
 *
Key
, 
uint16_t
 
Keysize
,

297 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

298 
uint8_t
 *
Output
);

301 
ErrorStatus
 
CRYP_TDES_ECB
(
uint8_t
 
Mode
,

302 
uint8_t
 
Key
[24],

303 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

304 
uint8_t
 *
Output
);

306 
ErrorStatus
 
CRYP_TDES_CBC
(
uint8_t
 
Mode
,

307 
uint8_t
 
Key
[24],

308 
uint8_t
 
InitVectors
[8],

309 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

310 
uint8_t
 *
Output
);

313 
ErrorStatus
 
CRYP_DES_ECB
(
uint8_t
 
Mode
,

314 
uint8_t
 
Key
[8],

315 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

316 
uint8_t
 *
Output
);

318 
ErrorStatus
 
CRYP_DES_CBC
(
uint8_t
 
Mode
,

319 
uint8_t
 
Key
[8],

320 
uint8_t
 
InitVectors
[8],

321 
uint8_t
 *
Input
,
uint32_t
 
Ilength
,

322 
uint8_t
 *
Output
);

324 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dac.h

24 #ifndef 
__STM32F4xx_DAC_H


25 #define 
	#__STM32F4xx_DAC_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

50 
uint32_t
 
DAC_Trigger
;

53 
uint32_t
 
DAC_WaveGeneration
;

57 
uint32_t
 
DAC_LFSRUnmask_TriangleAmplitude
;

61 
uint32_t
 
DAC_OutputBuffer
;

63 }
	tDAC_InitTypeDef
;

75 #define 
	#DAC_Trigger_None
 ((
uint32_t
)0x00000000)

	)

77 #define 
	#DAC_Trigger_T2_TRGO
 ((
uint32_t
)0x00000024)

	)

78 #define 
	#DAC_Trigger_T4_TRGO
 ((
uint32_t
)0x0000002C)

	)

79 #define 
	#DAC_Trigger_T5_TRGO
 ((
uint32_t
)0x0000001C)

	)

80 #define 
	#DAC_Trigger_T6_TRGO
 ((
uint32_t
)0x00000004)

	)

81 #define 
	#DAC_Trigger_T7_TRGO
 ((
uint32_t
)0x00000014)

	)

82 #define 
	#DAC_Trigger_T8_TRGO
 ((
uint32_t
)0x0000000C)

	)

84 #define 
	#DAC_Trigger_Ext_IT9
 ((
uint32_t
)0x00000034)

	)

85 #define 
	#DAC_Trigger_Software
 ((
uint32_t
)0x0000003C)

	)

87 #define 
	#IS_DAC_TRIGGER
(
TRIGGER
) (((TRIGGER) == 
DAC_Trigger_None
) || \

	)

88 ((
TRIGGER
) == 
DAC_Trigger_T6_TRGO
) || \

89 ((
TRIGGER
) == 
DAC_Trigger_T8_TRGO
) || \

90 ((
TRIGGER
) == 
DAC_Trigger_T7_TRGO
) || \

91 ((
TRIGGER
) == 
DAC_Trigger_T5_TRGO
) || \

92 ((
TRIGGER
) == 
DAC_Trigger_T2_TRGO
) || \

93 ((
TRIGGER
) == 
DAC_Trigger_T4_TRGO
) || \

94 ((
TRIGGER
) == 
DAC_Trigger_Ext_IT9
) || \

95 ((
TRIGGER
) == 
DAC_Trigger_Software
))

105 #define 
	#DAC_WaveGeneration_None
 ((
uint32_t
)0x00000000)

	)

106 #define 
	#DAC_WaveGeneration_Noise
 ((
uint32_t
)0x00000040)

	)

107 #define 
	#DAC_WaveGeneration_Triangle
 ((
uint32_t
)0x00000080)

	)

108 #define 
	#IS_DAC_GENERATE_WAVE
(
WAVE
) (((WAVE) == 
DAC_WaveGeneration_None
) || \

	)

109 ((
WAVE
) == 
DAC_WaveGeneration_Noise
) || \

110 ((
WAVE
) == 
DAC_WaveGeneration_Triangle
))

119 #define 
	#DAC_LFSRUnmask_Bit0
 ((
uint32_t
)0x00000000)

	)

120 #define 
	#DAC_LFSRUnmask_Bits1_0
 ((
uint32_t
)0x00000100)

	)

121 #define 
	#DAC_LFSRUnmask_Bits2_0
 ((
uint32_t
)0x00000200)

	)

122 #define 
	#DAC_LFSRUnmask_Bits3_0
 ((
uint32_t
)0x00000300)

	)

123 #define 
	#DAC_LFSRUnmask_Bits4_0
 ((
uint32_t
)0x00000400)

	)

124 #define 
	#DAC_LFSRUnmask_Bits5_0
 ((
uint32_t
)0x00000500)

	)

125 #define 
	#DAC_LFSRUnmask_Bits6_0
 ((
uint32_t
)0x00000600)

	)

126 #define 
	#DAC_LFSRUnmask_Bits7_0
 ((
uint32_t
)0x00000700)

	)

127 #define 
	#DAC_LFSRUnmask_Bits8_0
 ((
uint32_t
)0x00000800)

	)

128 #define 
	#DAC_LFSRUnmask_Bits9_0
 ((
uint32_t
)0x00000900)

	)

129 #define 
	#DAC_LFSRUnmask_Bits10_0
 ((
uint32_t
)0x00000A00)

	)

130 #define 
	#DAC_LFSRUnmask_Bits11_0
 ((
uint32_t
)0x00000B00)

	)

131 #define 
	#DAC_TriangleAmplitude_1
 ((
uint32_t
)0x00000000)

	)

132 #define 
	#DAC_TriangleAmplitude_3
 ((
uint32_t
)0x00000100)

	)

133 #define 
	#DAC_TriangleAmplitude_7
 ((
uint32_t
)0x00000200)

	)

134 #define 
	#DAC_TriangleAmplitude_15
 ((
uint32_t
)0x00000300)

	)

135 #define 
	#DAC_TriangleAmplitude_31
 ((
uint32_t
)0x00000400)

	)

136 #define 
	#DAC_TriangleAmplitude_63
 ((
uint32_t
)0x00000500)

	)

137 #define 
	#DAC_TriangleAmplitude_127
 ((
uint32_t
)0x00000600)

	)

138 #define 
	#DAC_TriangleAmplitude_255
 ((
uint32_t
)0x00000700)

	)

139 #define 
	#DAC_TriangleAmplitude_511
 ((
uint32_t
)0x00000800)

	)

140 #define 
	#DAC_TriangleAmplitude_1023
 ((
uint32_t
)0x00000900)

	)

141 #define 
	#DAC_TriangleAmplitude_2047
 ((
uint32_t
)0x00000A00)

	)

142 #define 
	#DAC_TriangleAmplitude_4095
 ((
uint32_t
)0x00000B00)

	)

144 #define 
	#IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE
(
VALUE
) (((VALUE) == 
DAC_LFSRUnmask_Bit0
) || \

	)

145 ((
VALUE
) == 
DAC_LFSRUnmask_Bits1_0
) || \

146 ((
VALUE
) == 
DAC_LFSRUnmask_Bits2_0
) || \

147 ((
VALUE
) == 
DAC_LFSRUnmask_Bits3_0
) || \

148 ((
VALUE
) == 
DAC_LFSRUnmask_Bits4_0
) || \

149 ((
VALUE
) == 
DAC_LFSRUnmask_Bits5_0
) || \

150 ((
VALUE
) == 
DAC_LFSRUnmask_Bits6_0
) || \

151 ((
VALUE
) == 
DAC_LFSRUnmask_Bits7_0
) || \

152 ((
VALUE
) == 
DAC_LFSRUnmask_Bits8_0
) || \

153 ((
VALUE
) == 
DAC_LFSRUnmask_Bits9_0
) || \

154 ((
VALUE
) == 
DAC_LFSRUnmask_Bits10_0
) || \

155 ((
VALUE
) == 
DAC_LFSRUnmask_Bits11_0
) || \

156 ((
VALUE
) == 
DAC_TriangleAmplitude_1
) || \

157 ((
VALUE
) == 
DAC_TriangleAmplitude_3
) || \

158 ((
VALUE
) == 
DAC_TriangleAmplitude_7
) || \

159 ((
VALUE
) == 
DAC_TriangleAmplitude_15
) || \

160 ((
VALUE
) == 
DAC_TriangleAmplitude_31
) || \

161 ((
VALUE
) == 
DAC_TriangleAmplitude_63
) || \

162 ((
VALUE
) == 
DAC_TriangleAmplitude_127
) || \

163 ((
VALUE
) == 
DAC_TriangleAmplitude_255
) || \

164 ((
VALUE
) == 
DAC_TriangleAmplitude_511
) || \

165 ((
VALUE
) == 
DAC_TriangleAmplitude_1023
) || \

166 ((
VALUE
) == 
DAC_TriangleAmplitude_2047
) || \

167 ((
VALUE
) == 
DAC_TriangleAmplitude_4095
))

176 #define 
	#DAC_OutputBuffer_Enable
 ((
uint32_t
)0x00000000)

	)

177 #define 
	#DAC_OutputBuffer_Disable
 ((
uint32_t
)0x00000002)

	)

178 #define 
	#IS_DAC_OUTPUT_BUFFER_STATE
(
STATE
) (((STATE) == 
DAC_OutputBuffer_Enable
) || \

	)

179 ((
STATE
) == 
DAC_OutputBuffer_Disable
))

188 #define 
	#DAC_Channel_1
 ((
uint32_t
)0x00000000)

	)

189 #define 
	#DAC_Channel_2
 ((
uint32_t
)0x00000010)

	)

190 #define 
	#IS_DAC_CHANNEL
(
CHANNEL
) (((CHANNEL) == 
DAC_Channel_1
) || \

	)

191 ((
CHANNEL
) == 
DAC_Channel_2
))

200 #define 
	#DAC_Align_12b_R
 ((
uint32_t
)0x00000000)

	)

201 #define 
	#DAC_Align_12b_L
 ((
uint32_t
)0x00000004)

	)

202 #define 
	#DAC_Align_8b_R
 ((
uint32_t
)0x00000008)

	)

203 #define 
	#IS_DAC_ALIGN
(
ALIGN
) (((ALIGN) == 
DAC_Align_12b_R
) || \

	)

204 ((
ALIGN
) == 
DAC_Align_12b_L
) || \

205 ((
ALIGN
) == 
DAC_Align_8b_R
))

214 #define 
	#DAC_Wave_Noise
 ((
uint32_t
)0x00000040)

	)

215 #define 
	#DAC_Wave_Triangle
 ((
uint32_t
)0x00000080)

	)

216 #define 
	#IS_DAC_WAVE
(
WAVE
) (((WAVE) == 
DAC_Wave_Noise
) || \

	)

217 ((
WAVE
) == 
DAC_Wave_Triangle
))

226 #define 
	#IS_DAC_DATA
(
DATA
) ((DATA) <= 0xFFF0)

	)

234 #define 
	#DAC_IT_DMAUDR
 ((
uint32_t
)0x00002000)

	)

235 #define 
	#IS_DAC_IT
(
IT
) (((IT) == 
DAC_IT_DMAUDR
))

	)

245 #define 
	#DAC_FLAG_DMAUDR
 ((
uint32_t
)0x00002000)

	)

246 #define 
	#IS_DAC_FLAG
(
FLAG
) (((FLAG) == 
DAC_FLAG_DMAUDR
))

	)

260 void 
DAC_DeInit
(void);

263 void 
DAC_Init
(
uint32_t
 
DAC_Channel
, 
DAC_InitTypeDef
* 
DAC_InitStruct
);

264 void 
DAC_StructInit
(
DAC_InitTypeDef
* 
DAC_InitStruct
);

265 void 
DAC_Cmd
(
uint32_t
 
DAC_Channel
, 
FunctionalState
 
NewState
);

266 void 
DAC_SoftwareTriggerCmd
(
uint32_t
 
DAC_Channel
, 
FunctionalState
 
NewState
);

267 void 
DAC_DualSoftwareTriggerCmd
(
FunctionalState
 
NewState
);

268 void 
DAC_WaveGenerationCmd
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_Wave
, 
FunctionalState
 
NewState
);

269 void 
DAC_SetChannel1Data
(
uint32_t
 
DAC_Align
, 
uint16_t
 
Data
);

270 void 
DAC_SetChannel2Data
(
uint32_t
 
DAC_Align
, 
uint16_t
 
Data
);

271 void 
DAC_SetDualChannelData
(
uint32_t
 
DAC_Align
, 
uint16_t
 
Data2
, uint16_t 
Data1
);

272 
uint16_t
 
DAC_GetDataOutputValue
(
uint32_t
 
DAC_Channel
);

275 void 
DAC_DMACmd
(
uint32_t
 
DAC_Channel
, 
FunctionalState
 
NewState
);

278 void 
DAC_ITConfig
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_IT
, 
FunctionalState
 
NewState
);

279 
FlagStatus
 
DAC_GetFlagStatus
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_FLAG
);

280 void 
DAC_ClearFlag
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_FLAG
);

281 
ITStatus
 
DAC_GetITStatus
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_IT
);

282 void 
DAC_ClearITPendingBit
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_IT
);

284 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dbgmcu.h

23 #ifndef 
__STM32F4xx_DBGMCU_H


24 #define 
	#__STM32F4xx_DBGMCU_H


	)

26 #ifdef 
__cplusplus


31 #include 
	~"stm32f4xx.h
"

47 #define 
	#DBGMCU_SLEEP
 ((
uint32_t
)0x00000001)

	)

48 #define 
	#DBGMCU_STOP
 ((
uint32_t
)0x00000002)

	)

49 #define 
	#DBGMCU_STANDBY
 ((
uint32_t
)0x00000004)

	)

50 #define 
	#IS_DBGMCU_PERIPH
(
PERIPH
) ((((PERIPH) & 0xFFFFFFF8) == 0x00) && ((PERIPH) != 0x00))

	)

52 #define 
	#DBGMCU_TIM2_STOP
 ((
uint32_t
)0x00000001)

	)

53 #define 
	#DBGMCU_TIM3_STOP
 ((
uint32_t
)0x00000002)

	)

54 #define 
	#DBGMCU_TIM4_STOP
 ((
uint32_t
)0x00000004)

	)

55 #define 
	#DBGMCU_TIM5_STOP
 ((
uint32_t
)0x00000008)

	)

56 #define 
	#DBGMCU_TIM6_STOP
 ((
uint32_t
)0x00000010)

	)

57 #define 
	#DBGMCU_TIM7_STOP
 ((
uint32_t
)0x00000020)

	)

58 #define 
	#DBGMCU_TIM12_STOP
 ((
uint32_t
)0x00000040)

	)

59 #define 
	#DBGMCU_TIM13_STOP
 ((
uint32_t
)0x00000080)

	)

60 #define 
	#DBGMCU_TIM14_STOP
 ((
uint32_t
)0x00000100)

	)

61 #define 
	#DBGMCU_RTC_STOP
 ((
uint32_t
)0x00000400)

	)

62 #define 
	#DBGMCU_WWDG_STOP
 ((
uint32_t
)0x00000800)

	)

63 #define 
	#DBGMCU_IWDG_STOP
 ((
uint32_t
)0x00001000)

	)

64 #define 
	#DBGMCU_I2C1_SMBUS_TIMEOUT
 ((
uint32_t
)0x00200000)

	)

65 #define 
	#DBGMCU_I2C2_SMBUS_TIMEOUT
 ((
uint32_t
)0x00400000)

	)

66 #define 
	#DBGMCU_I2C3_SMBUS_TIMEOUT
 ((
uint32_t
)0x00800000)

	)

67 #define 
	#DBGMCU_CAN1_STOP
 ((
uint32_t
)0x02000000)

	)

68 #define 
	#DBGMCU_CAN2_STOP
 ((
uint32_t
)0x04000000)

	)

69 #define 
	#IS_DBGMCU_APB1PERIPH
(
PERIPH
) ((((PERIPH) & 0xF91FE200) == 0x00) && ((PERIPH) != 0x00))

	)

71 #define 
	#DBGMCU_TIM1_STOP
 ((
uint32_t
)0x00000001)

	)

72 #define 
	#DBGMCU_TIM8_STOP
 ((
uint32_t
)0x00000002)

	)

73 #define 
	#DBGMCU_TIM9_STOP
 ((
uint32_t
)0x00010000)

	)

74 #define 
	#DBGMCU_TIM10_STOP
 ((
uint32_t
)0x00020000)

	)

75 #define 
	#DBGMCU_TIM11_STOP
 ((
uint32_t
)0x00040000)

	)

76 #define 
	#IS_DBGMCU_APB2PERIPH
(
PERIPH
) ((((PERIPH) & 0xFFF8FFFC) == 0x00) && ((PERIPH) != 0x00))

	)

83 
uint32_t
 
DBGMCU_GetREVID
(void);

84 
uint32_t
 
DBGMCU_GetDEVID
(void);

85 void 
DBGMCU_Config
(
uint32_t
 
DBGMCU_Periph
, 
FunctionalState
 
NewState
);

86 void 
DBGMCU_APB1PeriphConfig
(
uint32_t
 
DBGMCU_Periph
, 
FunctionalState
 
NewState
);

87 void 
DBGMCU_APB2PeriphConfig
(
uint32_t
 
DBGMCU_Periph
, 
FunctionalState
 
NewState
);

89 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dcmi.h

23 #ifndef 
__STM32F4xx_DCMI_H


24 #define 
	#__STM32F4xx_DCMI_H


	)

26 #ifdef 
__cplusplus


31 #include 
	~"stm32f4xx.h
"

47 
uint16_t
 
DCMI_CaptureMode
;

50 
uint16_t
 
DCMI_SynchroMode
;

53 
uint16_t
 
DCMI_PCKPolarity
;

56 
uint16_t
 
DCMI_VSPolarity
;

59 
uint16_t
 
DCMI_HSPolarity
;

62 
uint16_t
 
DCMI_CaptureRate
;

65 
uint16_t
 
DCMI_ExtendedDataMode
;

67 } 
	tDCMI_InitTypeDef
;

74 
uint16_t
 
DCMI_VerticalStartLine
;

77 
uint16_t
 
DCMI_HorizontalOffsetCount
;

80 
uint16_t
 
DCMI_VerticalLineCount
;

83 
uint16_t
 
DCMI_CaptureCount
;

86 } 
	tDCMI_CROPInitTypeDef
;

93 
uint8_t
 
DCMI_FrameStartCode
;

94 
uint8_t
 
DCMI_LineStartCode
;

95 
uint8_t
 
DCMI_LineEndCode
;

96 
uint8_t
 
DCMI_FrameEndCode
;

97 } 
	tDCMI_CodesInitTypeDef
;

108 #define 
	#DCMI_CaptureMode_Continuous
 ((
uint16_t
)0x0000)

	)

110 #define 
	#DCMI_CaptureMode_SnapShot
 ((
uint16_t
)0x0002)

	)

112 #define 
	#IS_DCMI_CAPTURE_MODE
(
MODE
)(((MODE) == 
DCMI_CaptureMode_Continuous
) || \

	)

113 ((
MODE
) == 
DCMI_CaptureMode_SnapShot
))

122 #define 
	#DCMI_SynchroMode_Hardware
 ((
uint16_t
)0x0000)

	)

124 #define 
	#DCMI_SynchroMode_Embedded
 ((
uint16_t
)0x0010)

	)

126 #define 
	#IS_DCMI_SYNCHRO
(
MODE
)(((MODE) == 
DCMI_SynchroMode_Hardware
) || \

	)

127 ((
MODE
) == 
DCMI_SynchroMode_Embedded
))

136 #define 
	#DCMI_PCKPolarity_Falling
 ((
uint16_t
)0x0000)

	)

137 #define 
	#DCMI_PCKPolarity_Rising
 ((
uint16_t
)0x0020)

	)

138 #define 
	#IS_DCMI_PCKPOLARITY
(
POLARITY
)(((POLARITY) == 
DCMI_PCKPolarity_Falling
) || \

	)

139 ((
POLARITY
) == 
DCMI_PCKPolarity_Rising
))

148 #define 
	#DCMI_VSPolarity_Low
 ((
uint16_t
)0x0000)

	)

149 #define 
	#DCMI_VSPolarity_High
 ((
uint16_t
)0x0080)

	)

150 #define 
	#IS_DCMI_VSPOLARITY
(
POLARITY
)(((POLARITY) == 
DCMI_VSPolarity_Low
) || \

	)

151 ((
POLARITY
) == 
DCMI_VSPolarity_High
))

160 #define 
	#DCMI_HSPolarity_Low
 ((
uint16_t
)0x0000)

	)

161 #define 
	#DCMI_HSPolarity_High
 ((
uint16_t
)0x0040)

	)

162 #define 
	#IS_DCMI_HSPOLARITY
(
POLARITY
)(((POLARITY) == 
DCMI_HSPolarity_Low
) || \

	)

163 ((
POLARITY
) == 
DCMI_HSPolarity_High
))

172 #define 
	#DCMI_CaptureRate_All_Frame
 ((
uint16_t
)0x0000)

	)

173 #define 
	#DCMI_CaptureRate_1of2_Frame
 ((
uint16_t
)0x0100)

	)

174 #define 
	#DCMI_CaptureRate_1of4_Frame
 ((
uint16_t
)0x0200)

	)

175 #define 
	#IS_DCMI_CAPTURE_RATE
(
RATE
) (((RATE) == 
DCMI_CaptureRate_All_Frame
) || \

	)

176 ((
RATE
) == 
DCMI_CaptureRate_1of2_Frame
) ||\

177 ((
RATE
) == 
DCMI_CaptureRate_1of4_Frame
))

186 #define 
	#DCMI_ExtendedDataMode_8b
 ((
uint16_t
)0x0000)

	)

187 #define 
	#DCMI_ExtendedDataMode_10b
 ((
uint16_t
)0x0400)

	)

188 #define 
	#DCMI_ExtendedDataMode_12b
 ((
uint16_t
)0x0800)

	)

189 #define 
	#DCMI_ExtendedDataMode_14b
 ((
uint16_t
)0x0C00)

	)

190 #define 
	#IS_DCMI_EXTENDED_DATA
(
DATA
)(((DATA) == 
DCMI_ExtendedDataMode_8b
) || \

	)

191 ((
DATA
) == 
DCMI_ExtendedDataMode_10b
) ||\

192 ((
DATA
) == 
DCMI_ExtendedDataMode_12b
) ||\

193 ((
DATA
) == 
DCMI_ExtendedDataMode_14b
))

202 #define 
	#DCMI_IT_FRAME
 ((
uint16_t
)0x0001)

	)

203 #define 
	#DCMI_IT_OVF
 ((
uint16_t
)0x0002)

	)

204 #define 
	#DCMI_IT_ERR
 ((
uint16_t
)0x0004)

	)

205 #define 
	#DCMI_IT_VSYNC
 ((
uint16_t
)0x0008)

	)

206 #define 
	#DCMI_IT_LINE
 ((
uint16_t
)0x0010)

	)

207 #define 
	#IS_DCMI_CONFIG_IT
(
IT
) ((((IT) & (
uint16_t
)0xFFE0) == 0x0000) && ((IT) != 0x0000))

	)

208 #define 
	#IS_DCMI_GET_IT
(
IT
) (((IT) == 
DCMI_IT_FRAME
) || \

	)

209 ((
IT
) == 
DCMI_IT_OVF
) || \

210 ((
IT
) == 
DCMI_IT_ERR
) || \

211 ((
IT
) == 
DCMI_IT_VSYNC
) || \

212 ((
IT
) == 
DCMI_IT_LINE
))

224 #define 
	#DCMI_FLAG_HSYNC
 ((
uint16_t
)0x2001)

	)

225 #define 
	#DCMI_FLAG_VSYNC
 ((
uint16_t
)0x2002)

	)

226 #define 
	#DCMI_FLAG_FNE
 ((
uint16_t
)0x2004)

	)

230 #define 
	#DCMI_FLAG_FRAMERI
 ((
uint16_t
)0x0001)

	)

231 #define 
	#DCMI_FLAG_OVFRI
 ((
uint16_t
)0x0002)

	)

232 #define 
	#DCMI_FLAG_ERRRI
 ((
uint16_t
)0x0004)

	)

233 #define 
	#DCMI_FLAG_VSYNCRI
 ((
uint16_t
)0x0008)

	)

234 #define 
	#DCMI_FLAG_LINERI
 ((
uint16_t
)0x0010)

	)

238 #define 
	#DCMI_FLAG_FRAMEMI
 ((
uint16_t
)0x1001)

	)

239 #define 
	#DCMI_FLAG_OVFMI
 ((
uint16_t
)0x1002)

	)

240 #define 
	#DCMI_FLAG_ERRMI
 ((
uint16_t
)0x1004)

	)

241 #define 
	#DCMI_FLAG_VSYNCMI
 ((
uint16_t
)0x1008)

	)

242 #define 
	#DCMI_FLAG_LINEMI
 ((
uint16_t
)0x1010)

	)

243 #define 
	#IS_DCMI_GET_FLAG
(
FLAG
) (((FLAG) == 
DCMI_FLAG_HSYNC
) || \

	)

244 ((
FLAG
) == 
DCMI_FLAG_VSYNC
) || \

245 ((
FLAG
) == 
DCMI_FLAG_FNE
) || \

246 ((
FLAG
) == 
DCMI_FLAG_FRAMERI
) || \

247 ((
FLAG
) == 
DCMI_FLAG_OVFRI
) || \

248 ((
FLAG
) == 
DCMI_FLAG_ERRRI
) || \

249 ((
FLAG
) == 
DCMI_FLAG_VSYNCRI
) || \

250 ((
FLAG
) == 
DCMI_FLAG_LINERI
) || \

251 ((
FLAG
) == 
DCMI_FLAG_FRAMEMI
) || \

252 ((
FLAG
) == 
DCMI_FLAG_OVFMI
) || \

253 ((
FLAG
) == 
DCMI_FLAG_ERRMI
) || \

254 ((
FLAG
) == 
DCMI_FLAG_VSYNCMI
) || \

255 ((
FLAG
) == 
DCMI_FLAG_LINEMI
))

257 #define 
	#IS_DCMI_CLEAR_FLAG
(
FLAG
) ((((FLAG) & (
uint16_t
)0xFFE0) == 0x0000) && ((FLAG) != 0x0000))

	)

270 void 
DCMI_DeInit
(void);

273 void 
DCMI_Init
(
DCMI_InitTypeDef
* 
DCMI_InitStruct
);

274 void 
DCMI_StructInit
(
DCMI_InitTypeDef
* 
DCMI_InitStruct
);

275 void 
DCMI_CROPConfig
(
DCMI_CROPInitTypeDef
* 
DCMI_CROPInitStruct
);

276 void 
DCMI_CROPCmd
(
FunctionalState
 
NewState
);

277 void 
DCMI_SetEmbeddedSynchroCodes
(
DCMI_CodesInitTypeDef
* 
DCMI_CodesInitStruct
);

278 void 
DCMI_JPEGCmd
(
FunctionalState
 
NewState
);

281 void 
DCMI_Cmd
(
FunctionalState
 
NewState
);

282 void 
DCMI_CaptureCmd
(
FunctionalState
 
NewState
);

283 
uint32_t
 
DCMI_ReadData
(void);

286 void 
DCMI_ITConfig
(
uint16_t
 
DCMI_IT
, 
FunctionalState
 
NewState
);

287 
FlagStatus
 
DCMI_GetFlagStatus
(
uint16_t
 
DCMI_FLAG
);

288 void 
DCMI_ClearFlag
(
uint16_t
 
DCMI_FLAG
);

289 
ITStatus
 
DCMI_GetITStatus
(
uint16_t
 
DCMI_IT
);

290 void 
DCMI_ClearITPendingBit
(
uint16_t
 
DCMI_IT
);

292 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h

24 #ifndef 
__STM32F4xx_DMA_H


25 #define 
	#__STM32F4xx_DMA_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

50 
uint32_t
 
DMA_Channel
;

53 
uint32_t
 
DMA_PeripheralBaseAddr
;

55 
uint32_t
 
DMA_Memory0BaseAddr
;

59 
uint32_t
 
DMA_DIR
;

63 
uint32_t
 
DMA_BufferSize
;

67 
uint32_t
 
DMA_PeripheralInc
;

70 
uint32_t
 
DMA_MemoryInc
;

73 
uint32_t
 
DMA_PeripheralDataSize
;

76 
uint32_t
 
DMA_MemoryDataSize
;

79 
uint32_t
 
DMA_Mode
;

84 
uint32_t
 
DMA_Priority
;

87 
uint32_t
 
DMA_FIFOMode
;

92 
uint32_t
 
DMA_FIFOThreshold
;

95 
uint32_t
 
DMA_MemoryBurst
;

100 
uint32_t
 
DMA_PeripheralBurst
;

104 }
	tDMA_InitTypeDef
;

112 #define 
	#IS_DMA_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
DMA1_Stream0
) || \

	)

113 ((
PERIPH
) == 
DMA1_Stream1
) || \

114 ((
PERIPH
) == 
DMA1_Stream2
) || \

115 ((
PERIPH
) == 
DMA1_Stream3
) || \

116 ((
PERIPH
) == 
DMA1_Stream4
) || \

117 ((
PERIPH
) == 
DMA1_Stream5
) || \

118 ((
PERIPH
) == 
DMA1_Stream6
) || \

119 ((
PERIPH
) == 
DMA1_Stream7
) || \

120 ((
PERIPH
) == 
DMA2_Stream0
) || \

121 ((
PERIPH
) == 
DMA2_Stream1
) || \

122 ((
PERIPH
) == 
DMA2_Stream2
) || \

123 ((
PERIPH
) == 
DMA2_Stream3
) || \

124 ((
PERIPH
) == 
DMA2_Stream4
) || \

125 ((
PERIPH
) == 
DMA2_Stream5
) || \

126 ((
PERIPH
) == 
DMA2_Stream6
) || \

127 ((
PERIPH
) == 
DMA2_Stream7
))

129 #define 
	#IS_DMA_ALL_CONTROLLER
(
CONTROLLER
) (((CONTROLLER) == 
DMA1
) || \

	)

130 ((
CONTROLLER
) == 
DMA2
))

135 #define 
	#DMA_Channel_0
 ((
uint32_t
)0x00000000)

	)

136 #define 
	#DMA_Channel_1
 ((
uint32_t
)0x02000000)

	)

137 #define 
	#DMA_Channel_2
 ((
uint32_t
)0x04000000)

	)

138 #define 
	#DMA_Channel_3
 ((
uint32_t
)0x06000000)

	)

139 #define 
	#DMA_Channel_4
 ((
uint32_t
)0x08000000)

	)

140 #define 
	#DMA_Channel_5
 ((
uint32_t
)0x0A000000)

	)

141 #define 
	#DMA_Channel_6
 ((
uint32_t
)0x0C000000)

	)

142 #define 
	#DMA_Channel_7
 ((
uint32_t
)0x0E000000)

	)

144 #define 
	#IS_DMA_CHANNEL
(
CHANNEL
) (((CHANNEL) == 
DMA_Channel_0
) || \

	)

145 ((
CHANNEL
) == 
DMA_Channel_1
) || \

146 ((
CHANNEL
) == 
DMA_Channel_2
) || \

147 ((
CHANNEL
) == 
DMA_Channel_3
) || \

148 ((
CHANNEL
) == 
DMA_Channel_4
) || \

149 ((
CHANNEL
) == 
DMA_Channel_5
) || \

150 ((
CHANNEL
) == 
DMA_Channel_6
) || \

151 ((
CHANNEL
) == 
DMA_Channel_7
))

160 #define 
	#DMA_DIR_PeripheralToMemory
 ((
uint32_t
)0x00000000)

	)

161 #define 
	#DMA_DIR_MemoryToPeripheral
 ((
uint32_t
)0x00000040)

	)

162 #define 
	#DMA_DIR_MemoryToMemory
 ((
uint32_t
)0x00000080)

	)

164 #define 
	#IS_DMA_DIRECTION
(
DIRECTION
) (((DIRECTION) == 
DMA_DIR_PeripheralToMemory
 ) || \

	)

165 ((
DIRECTION
) == 
DMA_DIR_MemoryToPeripheral
) || \

166 ((
DIRECTION
) == 
DMA_DIR_MemoryToMemory
))

175 #define 
	#IS_DMA_BUFFER_SIZE
(
SIZE
) (((SIZE) >= 0x1) && ((SIZE) < 0x10000))

	)

184 #define 
	#DMA_PeripheralInc_Enable
 ((
uint32_t
)0x00000200)

	)

185 #define 
	#DMA_PeripheralInc_Disable
 ((
uint32_t
)0x00000000)

	)

187 #define 
	#IS_DMA_PERIPHERAL_INC_STATE
(
STATE
) (((STATE) == 
DMA_PeripheralInc_Enable
) || \

	)

188 ((
STATE
) == 
DMA_PeripheralInc_Disable
))

197 #define 
	#DMA_MemoryInc_Enable
 ((
uint32_t
)0x00000400)

	)

198 #define 
	#DMA_MemoryInc_Disable
 ((
uint32_t
)0x00000000)

	)

200 #define 
	#IS_DMA_MEMORY_INC_STATE
(
STATE
) (((STATE) == 
DMA_MemoryInc_Enable
) || \

	)

201 ((
STATE
) == 
DMA_MemoryInc_Disable
))

210 #define 
	#DMA_PeripheralDataSize_Byte
 ((
uint32_t
)0x00000000)

	)

211 #define 
	#DMA_PeripheralDataSize_HalfWord
 ((
uint32_t
)0x00000800)

	)

212 #define 
	#DMA_PeripheralDataSize_Word
 ((
uint32_t
)0x00001000)

	)

214 #define 
	#IS_DMA_PERIPHERAL_DATA_SIZE
(
SIZE
) (((SIZE) == 
DMA_PeripheralDataSize_Byte
) || \

	)

215 ((
SIZE
) == 
DMA_PeripheralDataSize_HalfWord
) || \

216 ((
SIZE
) == 
DMA_PeripheralDataSize_Word
))

225 #define 
	#DMA_MemoryDataSize_Byte
 ((
uint32_t
)0x00000000)

	)

226 #define 
	#DMA_MemoryDataSize_HalfWord
 ((
uint32_t
)0x00002000)

	)

227 #define 
	#DMA_MemoryDataSize_Word
 ((
uint32_t
)0x00004000)

	)

229 #define 
	#IS_DMA_MEMORY_DATA_SIZE
(
SIZE
) (((SIZE) == 
DMA_MemoryDataSize_Byte
) || \

	)

230 ((
SIZE
) == 
DMA_MemoryDataSize_HalfWord
) || \

231 ((
SIZE
) == 
DMA_MemoryDataSize_Word
 ))

240 #define 
	#DMA_Mode_Normal
 ((
uint32_t
)0x00000000)

	)

241 #define 
	#DMA_Mode_Circular
 ((
uint32_t
)0x00000100)

	)

243 #define 
	#IS_DMA_MODE
(
MODE
) (((MODE) == 
DMA_Mode_Normal
 ) || \

	)

244 ((
MODE
) == 
DMA_Mode_Circular
))

253 #define 
	#DMA_Priority_Low
 ((
uint32_t
)0x00000000)

	)

254 #define 
	#DMA_Priority_Medium
 ((
uint32_t
)0x00010000)

	)

255 #define 
	#DMA_Priority_High
 ((
uint32_t
)0x00020000)

	)

256 #define 
	#DMA_Priority_VeryHigh
 ((
uint32_t
)0x00030000)

	)

258 #define 
	#IS_DMA_PRIORITY
(
PRIORITY
) (((PRIORITY) == 
DMA_Priority_Low
 ) || \

	)

259 ((
PRIORITY
) == 
DMA_Priority_Medium
) || \

260 ((
PRIORITY
) == 
DMA_Priority_High
) || \

261 ((
PRIORITY
) == 
DMA_Priority_VeryHigh
))

270 #define 
	#DMA_FIFOMode_Disable
 ((
uint32_t
)0x00000000)

	)

271 #define 
	#DMA_FIFOMode_Enable
 ((
uint32_t
)0x00000004)

	)

273 #define 
	#IS_DMA_FIFO_MODE_STATE
(
STATE
) (((STATE) == 
DMA_FIFOMode_Disable
 ) || \

	)

274 ((
STATE
) == 
DMA_FIFOMode_Enable
))

283 #define 
	#DMA_FIFOThreshold_1QuarterFull
 ((
uint32_t
)0x00000000)

	)

284 #define 
	#DMA_FIFOThreshold_HalfFull
 ((
uint32_t
)0x00000001)

	)

285 #define 
	#DMA_FIFOThreshold_3QuartersFull
 ((
uint32_t
)0x00000002)

	)

286 #define 
	#DMA_FIFOThreshold_Full
 ((
uint32_t
)0x00000003)

	)

288 #define 
	#IS_DMA_FIFO_THRESHOLD
(
THRESHOLD
) (((THRESHOLD) == 
DMA_FIFOThreshold_1QuarterFull
 ) || \

	)

289 ((
THRESHOLD
) == 
DMA_FIFOThreshold_HalfFull
) || \

290 ((
THRESHOLD
) == 
DMA_FIFOThreshold_3QuartersFull
) || \

291 ((
THRESHOLD
) == 
DMA_FIFOThreshold_Full
))

300 #define 
	#DMA_MemoryBurst_Single
 ((
uint32_t
)0x00000000)

	)

301 #define 
	#DMA_MemoryBurst_INC4
 ((
uint32_t
)0x00800000)

	)

302 #define 
	#DMA_MemoryBurst_INC8
 ((
uint32_t
)0x01000000)

	)

303 #define 
	#DMA_MemoryBurst_INC16
 ((
uint32_t
)0x01800000)

	)

305 #define 
	#IS_DMA_MEMORY_BURST
(
BURST
) (((BURST) == 
DMA_MemoryBurst_Single
) || \

	)

306 ((
BURST
) == 
DMA_MemoryBurst_INC4
) || \

307 ((
BURST
) == 
DMA_MemoryBurst_INC8
) || \

308 ((
BURST
) == 
DMA_MemoryBurst_INC16
))

317 #define 
	#DMA_PeripheralBurst_Single
 ((
uint32_t
)0x00000000)

	)

318 #define 
	#DMA_PeripheralBurst_INC4
 ((
uint32_t
)0x00200000)

	)

319 #define 
	#DMA_PeripheralBurst_INC8
 ((
uint32_t
)0x00400000)

	)

320 #define 
	#DMA_PeripheralBurst_INC16
 ((
uint32_t
)0x00600000)

	)

322 #define 
	#IS_DMA_PERIPHERAL_BURST
(
BURST
) (((BURST) == 
DMA_PeripheralBurst_Single
) || \

	)

323 ((
BURST
) == 
DMA_PeripheralBurst_INC4
) || \

324 ((
BURST
) == 
DMA_PeripheralBurst_INC8
) || \

325 ((
BURST
) == 
DMA_PeripheralBurst_INC16
))

334 #define 
	#DMA_FIFOStatus_Less1QuarterFull
 ((
uint32_t
)0x00000000 << 3)

	)

335 #define 
	#DMA_FIFOStatus_1QuarterFull
 ((
uint32_t
)0x00000001 << 3)

	)

336 #define 
	#DMA_FIFOStatus_HalfFull
 ((
uint32_t
)0x00000002 << 3)

	)

337 #define 
	#DMA_FIFOStatus_3QuartersFull
 ((
uint32_t
)0x00000003 << 3)

	)

338 #define 
	#DMA_FIFOStatus_Empty
 ((
uint32_t
)0x00000004 << 3)

	)

339 #define 
	#DMA_FIFOStatus_Full
 ((
uint32_t
)0x00000005 << 3)

	)

341 #define 
	#IS_DMA_FIFO_STATUS
(
STATUS
) (((STATUS) == 
DMA_FIFOStatus_Less1QuarterFull
 ) || \

	)

342 ((
STATUS
) == 
DMA_FIFOStatus_HalfFull
) || \

343 ((
STATUS
) == 
DMA_FIFOStatus_1QuarterFull
) || \

344 ((
STATUS
) == 
DMA_FIFOStatus_3QuartersFull
) || \

345 ((
STATUS
) == 
DMA_FIFOStatus_Full
) || \

346 ((
STATUS
) == 
DMA_FIFOStatus_Empty
))

354 #define 
	#DMA_FLAG_FEIF0
 ((
uint32_t
)0x10800001)

	)

355 #define 
	#DMA_FLAG_DMEIF0
 ((
uint32_t
)0x10800004)

	)

356 #define 
	#DMA_FLAG_TEIF0
 ((
uint32_t
)0x10000008)

	)

357 #define 
	#DMA_FLAG_HTIF0
 ((
uint32_t
)0x10000010)

	)

358 #define 
	#DMA_FLAG_TCIF0
 ((
uint32_t
)0x10000020)

	)

359 #define 
	#DMA_FLAG_FEIF1
 ((
uint32_t
)0x10000040)

	)

360 #define 
	#DMA_FLAG_DMEIF1
 ((
uint32_t
)0x10000100)

	)

361 #define 
	#DMA_FLAG_TEIF1
 ((
uint32_t
)0x10000200)

	)

362 #define 
	#DMA_FLAG_HTIF1
 ((
uint32_t
)0x10000400)

	)

363 #define 
	#DMA_FLAG_TCIF1
 ((
uint32_t
)0x10000800)

	)

364 #define 
	#DMA_FLAG_FEIF2
 ((
uint32_t
)0x10010000)

	)

365 #define 
	#DMA_FLAG_DMEIF2
 ((
uint32_t
)0x10040000)

	)

366 #define 
	#DMA_FLAG_TEIF2
 ((
uint32_t
)0x10080000)

	)

367 #define 
	#DMA_FLAG_HTIF2
 ((
uint32_t
)0x10100000)

	)

368 #define 
	#DMA_FLAG_TCIF2
 ((
uint32_t
)0x10200000)

	)

369 #define 
	#DMA_FLAG_FEIF3
 ((
uint32_t
)0x10400000)

	)

370 #define 
	#DMA_FLAG_DMEIF3
 ((
uint32_t
)0x11000000)

	)

371 #define 
	#DMA_FLAG_TEIF3
 ((
uint32_t
)0x12000000)

	)

372 #define 
	#DMA_FLAG_HTIF3
 ((
uint32_t
)0x14000000)

	)

373 #define 
	#DMA_FLAG_TCIF3
 ((
uint32_t
)0x18000000)

	)

374 #define 
	#DMA_FLAG_FEIF4
 ((
uint32_t
)0x20000001)

	)

375 #define 
	#DMA_FLAG_DMEIF4
 ((
uint32_t
)0x20000004)

	)

376 #define 
	#DMA_FLAG_TEIF4
 ((
uint32_t
)0x20000008)

	)

377 #define 
	#DMA_FLAG_HTIF4
 ((
uint32_t
)0x20000010)

	)

378 #define 
	#DMA_FLAG_TCIF4
 ((
uint32_t
)0x20000020)

	)

379 #define 
	#DMA_FLAG_FEIF5
 ((
uint32_t
)0x20000040)

	)

380 #define 
	#DMA_FLAG_DMEIF5
 ((
uint32_t
)0x20000100)

	)

381 #define 
	#DMA_FLAG_TEIF5
 ((
uint32_t
)0x20000200)

	)

382 #define 
	#DMA_FLAG_HTIF5
 ((
uint32_t
)0x20000400)

	)

383 #define 
	#DMA_FLAG_TCIF5
 ((
uint32_t
)0x20000800)

	)

384 #define 
	#DMA_FLAG_FEIF6
 ((
uint32_t
)0x20010000)

	)

385 #define 
	#DMA_FLAG_DMEIF6
 ((
uint32_t
)0x20040000)

	)

386 #define 
	#DMA_FLAG_TEIF6
 ((
uint32_t
)0x20080000)

	)

387 #define 
	#DMA_FLAG_HTIF6
 ((
uint32_t
)0x20100000)

	)

388 #define 
	#DMA_FLAG_TCIF6
 ((
uint32_t
)0x20200000)

	)

389 #define 
	#DMA_FLAG_FEIF7
 ((
uint32_t
)0x20400000)

	)

390 #define 
	#DMA_FLAG_DMEIF7
 ((
uint32_t
)0x21000000)

	)

391 #define 
	#DMA_FLAG_TEIF7
 ((
uint32_t
)0x22000000)

	)

392 #define 
	#DMA_FLAG_HTIF7
 ((
uint32_t
)0x24000000)

	)

393 #define 
	#DMA_FLAG_TCIF7
 ((
uint32_t
)0x28000000)

	)

395 #define 
	#IS_DMA_CLEAR_FLAG
(
FLAG
) ((((FLAG) & 0x30000000) != 0x30000000) && (((FLAG) & 0x30000000) != 0) && \

	)

396 (((
FLAG
) & 0xC082F082) == 0x00) && ((FLAG) != 0x00))

398 #define 
	#IS_DMA_GET_FLAG
(
FLAG
) (((FLAG) == 
DMA_FLAG_TCIF0
) || ((FLAG) == 
DMA_FLAG_HTIF0
) || \

	)

399 ((
FLAG
) == 
DMA_FLAG_TEIF0
) || ((FLAG) == 
DMA_FLAG_DMEIF0
) || \

400 ((
FLAG
) == 
DMA_FLAG_FEIF0
) || ((FLAG) == 
DMA_FLAG_TCIF1
) || \

401 ((
FLAG
) == 
DMA_FLAG_HTIF1
) || ((FLAG) == 
DMA_FLAG_TEIF1
) || \

402 ((
FLAG
) == 
DMA_FLAG_DMEIF1
) || ((FLAG) == 
DMA_FLAG_FEIF1
) || \

403 ((
FLAG
) == 
DMA_FLAG_TCIF2
) || ((FLAG) == 
DMA_FLAG_HTIF2
) || \

404 ((
FLAG
) == 
DMA_FLAG_TEIF2
) || ((FLAG) == 
DMA_FLAG_DMEIF2
) || \

405 ((
FLAG
) == 
DMA_FLAG_FEIF2
) || ((FLAG) == 
DMA_FLAG_TCIF3
) || \

406 ((
FLAG
) == 
DMA_FLAG_HTIF3
) || ((FLAG) == 
DMA_FLAG_TEIF3
) || \

407 ((
FLAG
) == 
DMA_FLAG_DMEIF3
) || ((FLAG) == 
DMA_FLAG_FEIF3
) || \

408 ((
FLAG
) == 
DMA_FLAG_TCIF4
) || ((FLAG) == 
DMA_FLAG_HTIF4
) || \

409 ((
FLAG
) == 
DMA_FLAG_TEIF4
) || ((FLAG) == 
DMA_FLAG_DMEIF4
) || \

410 ((
FLAG
) == 
DMA_FLAG_FEIF4
) || ((FLAG) == 
DMA_FLAG_TCIF5
) || \

411 ((
FLAG
) == 
DMA_FLAG_HTIF5
) || ((FLAG) == 
DMA_FLAG_TEIF5
) || \

412 ((
FLAG
) == 
DMA_FLAG_DMEIF5
) || ((FLAG) == 
DMA_FLAG_FEIF5
) || \

413 ((
FLAG
) == 
DMA_FLAG_TCIF6
) || ((FLAG) == 
DMA_FLAG_HTIF6
) || \

414 ((
FLAG
) == 
DMA_FLAG_TEIF6
) || ((FLAG) == 
DMA_FLAG_DMEIF6
) || \

415 ((
FLAG
) == 
DMA_FLAG_FEIF6
) || ((FLAG) == 
DMA_FLAG_TCIF7
) || \

416 ((
FLAG
) == 
DMA_FLAG_HTIF7
) || ((FLAG) == 
DMA_FLAG_TEIF7
) || \

417 ((
FLAG
) == 
DMA_FLAG_DMEIF7
) || ((FLAG) == 
DMA_FLAG_FEIF7
))

426 #define 
	#DMA_IT_TC
 ((
uint32_t
)0x00000010)

	)

427 #define 
	#DMA_IT_HT
 ((
uint32_t
)0x00000008)

	)

428 #define 
	#DMA_IT_TE
 ((
uint32_t
)0x00000004)

	)

429 #define 
	#DMA_IT_DME
 ((
uint32_t
)0x00000002)

	)

430 #define 
	#DMA_IT_FE
 ((
uint32_t
)0x00000080)

	)

432 #define 
	#IS_DMA_CONFIG_IT
(
IT
) ((((IT) & 0xFFFFFF61) == 0x00) && ((IT) != 0x00))

	)

441 #define 
	#DMA_IT_FEIF0
 ((
uint32_t
)0x90000001)

	)

442 #define 
	#DMA_IT_DMEIF0
 ((
uint32_t
)0x10001004)

	)

443 #define 
	#DMA_IT_TEIF0
 ((
uint32_t
)0x10002008)

	)

444 #define 
	#DMA_IT_HTIF0
 ((
uint32_t
)0x10004010)

	)

445 #define 
	#DMA_IT_TCIF0
 ((
uint32_t
)0x10008020)

	)

446 #define 
	#DMA_IT_FEIF1
 ((
uint32_t
)0x90000040)

	)

447 #define 
	#DMA_IT_DMEIF1
 ((
uint32_t
)0x10001100)

	)

448 #define 
	#DMA_IT_TEIF1
 ((
uint32_t
)0x10002200)

	)

449 #define 
	#DMA_IT_HTIF1
 ((
uint32_t
)0x10004400)

	)

450 #define 
	#DMA_IT_TCIF1
 ((
uint32_t
)0x10008800)

	)

451 #define 
	#DMA_IT_FEIF2
 ((
uint32_t
)0x90010000)

	)

452 #define 
	#DMA_IT_DMEIF2
 ((
uint32_t
)0x10041000)

	)

453 #define 
	#DMA_IT_TEIF2
 ((
uint32_t
)0x10082000)

	)

454 #define 
	#DMA_IT_HTIF2
 ((
uint32_t
)0x10104000)

	)

455 #define 
	#DMA_IT_TCIF2
 ((
uint32_t
)0x10208000)

	)

456 #define 
	#DMA_IT_FEIF3
 ((
uint32_t
)0x90400000)

	)

457 #define 
	#DMA_IT_DMEIF3
 ((
uint32_t
)0x11001000)

	)

458 #define 
	#DMA_IT_TEIF3
 ((
uint32_t
)0x12002000)

	)

459 #define 
	#DMA_IT_HTIF3
 ((
uint32_t
)0x14004000)

	)

460 #define 
	#DMA_IT_TCIF3
 ((
uint32_t
)0x18008000)

	)

461 #define 
	#DMA_IT_FEIF4
 ((
uint32_t
)0xA0000001)

	)

462 #define 
	#DMA_IT_DMEIF4
 ((
uint32_t
)0x20001004)

	)

463 #define 
	#DMA_IT_TEIF4
 ((
uint32_t
)0x20002008)

	)

464 #define 
	#DMA_IT_HTIF4
 ((
uint32_t
)0x20004010)

	)

465 #define 
	#DMA_IT_TCIF4
 ((
uint32_t
)0x20008020)

	)

466 #define 
	#DMA_IT_FEIF5
 ((
uint32_t
)0xA0000040)

	)

467 #define 
	#DMA_IT_DMEIF5
 ((
uint32_t
)0x20001100)

	)

468 #define 
	#DMA_IT_TEIF5
 ((
uint32_t
)0x20002200)

	)

469 #define 
	#DMA_IT_HTIF5
 ((
uint32_t
)0x20004400)

	)

470 #define 
	#DMA_IT_TCIF5
 ((
uint32_t
)0x20008800)

	)

471 #define 
	#DMA_IT_FEIF6
 ((
uint32_t
)0xA0010000)

	)

472 #define 
	#DMA_IT_DMEIF6
 ((
uint32_t
)0x20041000)

	)

473 #define 
	#DMA_IT_TEIF6
 ((
uint32_t
)0x20082000)

	)

474 #define 
	#DMA_IT_HTIF6
 ((
uint32_t
)0x20104000)

	)

475 #define 
	#DMA_IT_TCIF6
 ((
uint32_t
)0x20208000)

	)

476 #define 
	#DMA_IT_FEIF7
 ((
uint32_t
)0xA0400000)

	)

477 #define 
	#DMA_IT_DMEIF7
 ((
uint32_t
)0x21001000)

	)

478 #define 
	#DMA_IT_TEIF7
 ((
uint32_t
)0x22002000)

	)

479 #define 
	#DMA_IT_HTIF7
 ((
uint32_t
)0x24004000)

	)

480 #define 
	#DMA_IT_TCIF7
 ((
uint32_t
)0x28008000)

	)

482 #define 
	#IS_DMA_CLEAR_IT
(
IT
) ((((IT) & 0x30000000) != 0x30000000) && \

	)

483 (((
IT
) & 0x30000000) != 0) && ((IT) != 0x00) && \

484 (((
IT
) & 0x40820082) == 0x00))

486 #define 
	#IS_DMA_GET_IT
(
IT
) (((IT) == 
DMA_IT_TCIF0
) || ((IT) == 
DMA_IT_HTIF0
) || \

	)

487 ((
IT
) == 
DMA_IT_TEIF0
) || ((IT) == 
DMA_IT_DMEIF0
) || \

488 ((
IT
) == 
DMA_IT_FEIF0
) || ((IT) == 
DMA_IT_TCIF1
) || \

489 ((
IT
) == 
DMA_IT_HTIF1
) || ((IT) == 
DMA_IT_TEIF1
) || \

490 ((
IT
) == 
DMA_IT_DMEIF1
)|| ((IT) == 
DMA_IT_FEIF1
) || \

491 ((
IT
) == 
DMA_IT_TCIF2
) || ((IT) == 
DMA_IT_HTIF2
) || \

492 ((
IT
) == 
DMA_IT_TEIF2
) || ((IT) == 
DMA_IT_DMEIF2
) || \

493 ((
IT
) == 
DMA_IT_FEIF2
) || ((IT) == 
DMA_IT_TCIF3
) || \

494 ((
IT
) == 
DMA_IT_HTIF3
) || ((IT) == 
DMA_IT_TEIF3
) || \

495 ((
IT
) == 
DMA_IT_DMEIF3
)|| ((IT) == 
DMA_IT_FEIF3
) || \

496 ((
IT
) == 
DMA_IT_TCIF4
) || ((IT) == 
DMA_IT_HTIF4
) || \

497 ((
IT
) == 
DMA_IT_TEIF4
) || ((IT) == 
DMA_IT_DMEIF4
) || \

498 ((
IT
) == 
DMA_IT_FEIF4
) || ((IT) == 
DMA_IT_TCIF5
) || \

499 ((
IT
) == 
DMA_IT_HTIF5
) || ((IT) == 
DMA_IT_TEIF5
) || \

500 ((
IT
) == 
DMA_IT_DMEIF5
)|| ((IT) == 
DMA_IT_FEIF5
) || \

501 ((
IT
) == 
DMA_IT_TCIF6
) || ((IT) == 
DMA_IT_HTIF6
) || \

502 ((
IT
) == 
DMA_IT_TEIF6
) || ((IT) == 
DMA_IT_DMEIF6
) || \

503 ((
IT
) == 
DMA_IT_FEIF6
) || ((IT) == 
DMA_IT_TCIF7
) || \

504 ((
IT
) == 
DMA_IT_HTIF7
) || ((IT) == 
DMA_IT_TEIF7
) || \

505 ((
IT
) == 
DMA_IT_DMEIF7
)|| ((IT) == 
DMA_IT_FEIF7
))

514 #define 
	#DMA_PINCOS_Psize
 ((
uint32_t
)0x00000000)

	)

515 #define 
	#DMA_PINCOS_WordAligned
 ((
uint32_t
)0x00008000)

	)

517 #define 
	#IS_DMA_PINCOS_SIZE
(
SIZE
) (((SIZE) == 
DMA_PINCOS_Psize
) || \

	)

518 ((
SIZE
) == 
DMA_PINCOS_WordAligned
))

527 #define 
	#DMA_FlowCtrl_Memory
 ((
uint32_t
)0x00000000)

	)

528 #define 
	#DMA_FlowCtrl_Peripheral
 ((
uint32_t
)0x00000020)

	)

530 #define 
	#IS_DMA_FLOW_CTRL
(
CTRL
) (((CTRL) == 
DMA_FlowCtrl_Memory
) || \

	)

531 ((
CTRL
) == 
DMA_FlowCtrl_Peripheral
))

540 #define 
	#DMA_Memory_0
 ((
uint32_t
)0x00000000)

	)

541 #define 
	#DMA_Memory_1
 ((
uint32_t
)0x00080000)

	)

543 #define 
	#IS_DMA_CURRENT_MEM
(
MEM
) (((MEM) == 
DMA_Memory_0
) || ((MEM) == 
DMA_Memory_1
))

	)

556 void 
DMA_DeInit
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
);

559 void 
DMA_Init
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
DMA_InitTypeDef
* 
DMA_InitStruct
);

560 void 
DMA_StructInit
(
DMA_InitTypeDef
* 
DMA_InitStruct
);

561 void 
DMA_Cmd
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
FunctionalState
 
NewState
);

564 void 
DMA_PeriphIncOffsetSizeConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_Pincos
);

565 void 
DMA_FlowControllerConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_FlowCtrl
);

568 void 
DMA_SetCurrDataCounter
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint16_t
 
Counter
);

569 
uint16_t
 
DMA_GetCurrDataCounter
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
);

572 void 
DMA_DoubleBufferModeConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
Memory1BaseAddr
,

573 
uint32_t
 
DMA_CurrentMemory
);

574 void 
DMA_DoubleBufferModeCmd
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
FunctionalState
 
NewState
);

575 void 
DMA_MemoryTargetConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
MemoryBaseAddr
,

576 
uint32_t
 
DMA_MemoryTarget
);

577 
uint32_t
 
DMA_GetCurrentMemoryTarget
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
);

580 
FunctionalState
 
DMA_GetCmdStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
);

581 
uint32_t
 
DMA_GetFIFOStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
);

582 
FlagStatus
 
DMA_GetFlagStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_FLAG
);

583 void 
DMA_ClearFlag
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_FLAG
);

584 void 
DMA_ITConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_IT
, 
FunctionalState
 
NewState
);

585 
ITStatus
 
DMA_GetITStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_IT
);

586 void 
DMA_ClearITPendingBit
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_IT
);

588 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_exti.h

24 #ifndef 
__STM32F4xx_EXTI_H


25 #define 
	#__STM32F4xx_EXTI_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

50 
EXTI_Mode_Interrupt
 = 0x00,

51 
EXTI_Mode_Event
 = 0x04

52 }
	tEXTIMode_TypeDef
;

54 #define 
	#IS_EXTI_MODE
(
MODE
) (((MODE) == 
EXTI_Mode_Interrupt
) || ((MODE) == 
EXTI_Mode_Event
))

	)

62 
EXTI_Trigger_Rising
 = 0x08,

63 
EXTI_Trigger_Falling
 = 0x0C,

64 
EXTI_Trigger_Rising_Falling
 = 0x10

65 }
	tEXTITrigger_TypeDef
;

67 #define 
	#IS_EXTI_TRIGGER
(
TRIGGER
) (((TRIGGER) == 
EXTI_Trigger_Rising
) || \

	)

68 ((
TRIGGER
) == 
EXTI_Trigger_Falling
) || \

69 ((
TRIGGER
) == 
EXTI_Trigger_Rising_Falling
))

76 
uint32_t
 
EXTI_Line
;

79 
EXTIMode_TypeDef
 
EXTI_Mode
;

82 
EXTITrigger_TypeDef
 
EXTI_Trigger
;

85 
FunctionalState
 
EXTI_LineCmd
;

87 }
	tEXTI_InitTypeDef
;

99 #define 
	#EXTI_Line0
 ((
uint32_t
)0x00001)

	)

100 #define 
	#EXTI_Line1
 ((
uint32_t
)0x00002)

	)

101 #define 
	#EXTI_Line2
 ((
uint32_t
)0x00004)

	)

102 #define 
	#EXTI_Line3
 ((
uint32_t
)0x00008)

	)

103 #define 
	#EXTI_Line4
 ((
uint32_t
)0x00010)

	)

104 #define 
	#EXTI_Line5
 ((
uint32_t
)0x00020)

	)

105 #define 
	#EXTI_Line6
 ((
uint32_t
)0x00040)

	)

106 #define 
	#EXTI_Line7
 ((
uint32_t
)0x00080)

	)

107 #define 
	#EXTI_Line8
 ((
uint32_t
)0x00100)

	)

108 #define 
	#EXTI_Line9
 ((
uint32_t
)0x00200)

	)

109 #define 
	#EXTI_Line10
 ((
uint32_t
)0x00400)

	)

110 #define 
	#EXTI_Line11
 ((
uint32_t
)0x00800)

	)

111 #define 
	#EXTI_Line12
 ((
uint32_t
)0x01000)

	)

112 #define 
	#EXTI_Line13
 ((
uint32_t
)0x02000)

	)

113 #define 
	#EXTI_Line14
 ((
uint32_t
)0x04000)

	)

114 #define 
	#EXTI_Line15
 ((
uint32_t
)0x08000)

	)

115 #define 
	#EXTI_Line16
 ((
uint32_t
)0x10000)

	)

116 #define 
	#EXTI_Line17
 ((
uint32_t
)0x20000)

	)

117 #define 
	#EXTI_Line18
 ((
uint32_t
)0x40000)

	)

118 #define 
	#EXTI_Line19
 ((
uint32_t
)0x80000)

	)

119 #define 
	#EXTI_Line20
 ((
uint32_t
)0x00100000)

	)

120 #define 
	#EXTI_Line21
 ((
uint32_t
)0x00200000)

	)

121 #define 
	#EXTI_Line22
 ((
uint32_t
)0x00400000)

	)

123 #define 
	#IS_EXTI_LINE
(
LINE
) ((((LINE) & (
uint32_t
)0xFF800000) == 0x00) && ((LINE) != (
uint16_t
)0x00))

	)

125 #define 
	#IS_GET_EXTI_LINE
(
LINE
) (((LINE) == 
EXTI_Line0
) || ((LINE) == 
EXTI_Line1
) || \

	)

126 ((
LINE
) == 
EXTI_Line2
) || ((LINE) == 
EXTI_Line3
) || \

127 ((
LINE
) == 
EXTI_Line4
) || ((LINE) == 
EXTI_Line5
) || \

128 ((
LINE
) == 
EXTI_Line6
) || ((LINE) == 
EXTI_Line7
) || \

129 ((
LINE
) == 
EXTI_Line8
) || ((LINE) == 
EXTI_Line9
) || \

130 ((
LINE
) == 
EXTI_Line10
) || ((LINE) == 
EXTI_Line11
) || \

131 ((
LINE
) == 
EXTI_Line12
) || ((LINE) == 
EXTI_Line13
) || \

132 ((
LINE
) == 
EXTI_Line14
) || ((LINE) == 
EXTI_Line15
) || \

133 ((
LINE
) == 
EXTI_Line16
) || ((LINE) == 
EXTI_Line17
) || \

134 ((
LINE
) == 
EXTI_Line18
) || ((LINE) == 
EXTI_Line19
) || \

135 ((
LINE
) == 
EXTI_Line20
) || ((LINE) == 
EXTI_Line21
) ||\

136 ((
LINE
) == 
EXTI_Line22
))

150 void 
EXTI_DeInit
(void);

153 void 
EXTI_Init
(
EXTI_InitTypeDef
* 
EXTI_InitStruct
);

154 void 
EXTI_StructInit
(
EXTI_InitTypeDef
* 
EXTI_InitStruct
);

155 void 
EXTI_GenerateSWInterrupt
(
uint32_t
 
EXTI_Line
);

158 
FlagStatus
 
EXTI_GetFlagStatus
(
uint32_t
 
EXTI_Line
);

159 void 
EXTI_ClearFlag
(
uint32_t
 
EXTI_Line
);

160 
ITStatus
 
EXTI_GetITStatus
(
uint32_t
 
EXTI_Line
);

161 void 
EXTI_ClearITPendingBit
(
uint32_t
 
EXTI_Line
);

163 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash.h

24 #ifndef 
__STM32F4xx_FLASH_H


25 #define 
	#__STM32F4xx_FLASH_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

48 
FLASH_BUSY
 = 1,

49 
FLASH_ERROR_PGS
,

50 
FLASH_ERROR_PGP
,

51 
FLASH_ERROR_PGA
,

52 
FLASH_ERROR_WRP
,

53 
FLASH_ERROR_PROGRAM
,

54 
FLASH_ERROR_OPERATION
,

55 
FLASH_COMPLETE


56 }
	tFLASH_Status
;

67 #define 
	#FLASH_Latency_0
 ((
uint8_t
)0x0000)

	)

68 #define 
	#FLASH_Latency_1
 ((
uint8_t
)0x0001)

	)

69 #define 
	#FLASH_Latency_2
 ((
uint8_t
)0x0002)

	)

70 #define 
	#FLASH_Latency_3
 ((
uint8_t
)0x0003)

	)

71 #define 
	#FLASH_Latency_4
 ((
uint8_t
)0x0004)

	)

72 #define 
	#FLASH_Latency_5
 ((
uint8_t
)0x0005)

	)

73 #define 
	#FLASH_Latency_6
 ((
uint8_t
)0x0006)

	)

74 #define 
	#FLASH_Latency_7
 ((
uint8_t
)0x0007)

	)

76 #define 
	#IS_FLASH_LATENCY
(
LATENCY
) (((LATENCY) == 
FLASH_Latency_0
) || \

	)

77 ((
LATENCY
) == 
FLASH_Latency_1
) || \

78 ((
LATENCY
) == 
FLASH_Latency_2
) || \

79 ((
LATENCY
) == 
FLASH_Latency_3
) || \

80 ((
LATENCY
) == 
FLASH_Latency_4
) || \

81 ((
LATENCY
) == 
FLASH_Latency_5
) || \

82 ((
LATENCY
) == 
FLASH_Latency_6
) || \

83 ((
LATENCY
) == 
FLASH_Latency_7
))

91 #define 
	#VoltageRange_1
 ((
uint8_t
)0x00)

	)

92 #define 
	#VoltageRange_2
 ((
uint8_t
)0x01)

	)

93 #define 
	#VoltageRange_3
 ((
uint8_t
)0x02)

	)

94 #define 
	#VoltageRange_4
 ((
uint8_t
)0x03)

	)

96 #define 
	#IS_VOLTAGERANGE
(
RANGE
)(((RANGE) == 
VoltageRange_1
) || \

	)

97 ((
RANGE
) == 
VoltageRange_2
) || \

98 ((
RANGE
) == 
VoltageRange_3
) || \

99 ((
RANGE
) == 
VoltageRange_4
))

107 #define 
	#FLASH_Sector_0
 ((
uint16_t
)0x0000)

	)

108 #define 
	#FLASH_Sector_1
 ((
uint16_t
)0x0008)

	)

109 #define 
	#FLASH_Sector_2
 ((
uint16_t
)0x0010)

	)

110 #define 
	#FLASH_Sector_3
 ((
uint16_t
)0x0018)

	)

111 #define 
	#FLASH_Sector_4
 ((
uint16_t
)0x0020)

	)

112 #define 
	#FLASH_Sector_5
 ((
uint16_t
)0x0028)

	)

113 #define 
	#FLASH_Sector_6
 ((
uint16_t
)0x0030)

	)

114 #define 
	#FLASH_Sector_7
 ((
uint16_t
)0x0038)

	)

115 #define 
	#FLASH_Sector_8
 ((
uint16_t
)0x0040)

	)

116 #define 
	#FLASH_Sector_9
 ((
uint16_t
)0x0048)

	)

117 #define 
	#FLASH_Sector_10
 ((
uint16_t
)0x0050)

	)

118 #define 
	#FLASH_Sector_11
 ((
uint16_t
)0x0058)

	)

119 #define 
	#IS_FLASH_SECTOR
(
SECTOR
) (((SECTOR) == 
FLASH_Sector_0
) || ((SECTOR) == 
FLASH_Sector_1
) ||\

	)

120 ((
SECTOR
) == 
FLASH_Sector_2
) || ((SECTOR) == 
FLASH_Sector_3
) ||\

121 ((
SECTOR
) == 
FLASH_Sector_4
) || ((SECTOR) == 
FLASH_Sector_5
) ||\

122 ((
SECTOR
) == 
FLASH_Sector_6
) || ((SECTOR) == 
FLASH_Sector_7
) ||\

123 ((
SECTOR
) == 
FLASH_Sector_8
) || ((SECTOR) == 
FLASH_Sector_9
) ||\

124 ((
SECTOR
) == 
FLASH_Sector_10
) || ((SECTOR) == 
FLASH_Sector_11
))

125 #define 
	#IS_FLASH_ADDRESS
(
ADDRESS
) ((((ADDRESS) >= 0x08000000) && ((ADDRESS) < 0x080FFFFF)) ||\

	)

126 (((
ADDRESS
) >= 0x1FFF7800) && ((ADDRESS) < 0x1FFF7A0F)))

134 #define 
	#OB_WRP_Sector_0
 ((
uint32_t
)0x00000001)

	)

135 #define 
	#OB_WRP_Sector_1
 ((
uint32_t
)0x00000002)

	)

136 #define 
	#OB_WRP_Sector_2
 ((
uint32_t
)0x00000004)

	)

137 #define 
	#OB_WRP_Sector_3
 ((
uint32_t
)0x00000008)

	)

138 #define 
	#OB_WRP_Sector_4
 ((
uint32_t
)0x00000010)

	)

139 #define 
	#OB_WRP_Sector_5
 ((
uint32_t
)0x00000020)

	)

140 #define 
	#OB_WRP_Sector_6
 ((
uint32_t
)0x00000040)

	)

141 #define 
	#OB_WRP_Sector_7
 ((
uint32_t
)0x00000080)

	)

142 #define 
	#OB_WRP_Sector_8
 ((
uint32_t
)0x00000100)

	)

143 #define 
	#OB_WRP_Sector_9
 ((
uint32_t
)0x00000200)

	)

144 #define 
	#OB_WRP_Sector_10
 ((
uint32_t
)0x00000400)

	)

145 #define 
	#OB_WRP_Sector_11
 ((
uint32_t
)0x00000800)

	)

146 #define 
	#OB_WRP_Sector_All
 ((
uint32_t
)0x00000FFF)

	)

148 #define 
	#IS_OB_WRP
(
SECTOR
)((((SECTOR) & (
uint32_t
)0xFFFFF000) == 0x00000000) && ((SECTOR) != 0x00000000))

	)

156 #define 
	#OB_RDP_Level_0
 ((
uint8_t
)0xAA)

	)

157 #define 
	#OB_RDP_Level_1
 ((
uint8_t
)0x55)

	)

160 #define 
	#IS_OB_RDP
(
LEVEL
) (((LEVEL) == 
OB_RDP_Level_0
)||\

	)

161 ((
LEVEL
) == 
OB_RDP_Level_1
))

170 #define 
	#OB_IWDG_SW
 ((
uint8_t
)0x20)

	)

171 #define 
	#OB_IWDG_HW
 ((
uint8_t
)0x00)

	)

172 #define 
	#IS_OB_IWDG_SOURCE
(
SOURCE
) (((SOURCE) == 
OB_IWDG_SW
) || ((SOURCE) == 
OB_IWDG_HW
))

	)

180 #define 
	#OB_STOP_NoRST
 ((
uint8_t
)0x40)

	)

181 #define 
	#OB_STOP_RST
 ((
uint8_t
)0x00)

	)

182 #define 
	#IS_OB_STOP_SOURCE
(
SOURCE
) (((SOURCE) == 
OB_STOP_NoRST
) || ((SOURCE) == 
OB_STOP_RST
))

	)

191 #define 
	#OB_STDBY_NoRST
 ((
uint8_t
)0x80)

	)

192 #define 
	#OB_STDBY_RST
 ((
uint8_t
)0x00)

	)

193 #define 
	#IS_OB_STDBY_SOURCE
(
SOURCE
) (((SOURCE) == 
OB_STDBY_NoRST
) || ((SOURCE) == 
OB_STDBY_RST
))

	)

201 #define 
	#OB_BOR_LEVEL3
 ((
uint8_t
)0x00)

	)

202 #define 
	#OB_BOR_LEVEL2
 ((
uint8_t
)0x04)

	)

203 #define 
	#OB_BOR_LEVEL1
 ((
uint8_t
)0x08)

	)

204 #define 
	#OB_BOR_OFF
 ((
uint8_t
)0x0C)

	)

205 #define 
	#IS_OB_BOR
(
LEVEL
) (((LEVEL) == 
OB_BOR_LEVEL1
) || ((LEVEL) == 
OB_BOR_LEVEL2
) ||\

	)

206 ((
LEVEL
) == 
OB_BOR_LEVEL3
) || ((LEVEL) == 
OB_BOR_OFF
))

214 #define 
	#FLASH_IT_EOP
 ((
uint32_t
)0x01000000)

	)

215 #define 
	#FLASH_IT_ERR
 ((
uint32_t
)0x02000000)

	)

216 #define 
	#IS_FLASH_IT
(
IT
) ((((IT) & (
uint32_t
)0xFCFFFFFF) == 0x00000000) && ((IT) != 0x00000000))

	)

224 #define 
	#FLASH_FLAG_EOP
 ((
uint32_t
)0x00000001)

	)

225 #define 
	#FLASH_FLAG_OPERR
 ((
uint32_t
)0x00000002)

	)

226 #define 
	#FLASH_FLAG_WRPERR
 ((
uint32_t
)0x00000010)

	)

227 #define 
	#FLASH_FLAG_PGAERR
 ((
uint32_t
)0x00000020)

	)

228 #define 
	#FLASH_FLAG_PGPERR
 ((
uint32_t
)0x00000040)

	)

229 #define 
	#FLASH_FLAG_PGSERR
 ((
uint32_t
)0x00000080)

	)

230 #define 
	#FLASH_FLAG_BSY
 ((
uint32_t
)0x00010000)

	)

231 #define 
	#IS_FLASH_CLEAR_FLAG
(
FLAG
) ((((FLAG) & (
uint32_t
)0xFFFFFF0C) == 0x00000000) && ((FLAG) != 0x00000000))

	)

232 #define 
	#IS_FLASH_GET_FLAG
(
FLAG
) (((FLAG) == 
FLASH_FLAG_EOP
) || ((FLAG) == 
FLASH_FLAG_OPERR
) || \

	)

233 ((
FLAG
) == 
FLASH_FLAG_WRPERR
) || ((FLAG) == 
FLASH_FLAG_PGAERR
) || \

234 ((
FLAG
) == 
FLASH_FLAG_PGPERR
) || ((FLAG) == 
FLASH_FLAG_PGSERR
) || \

235 ((
FLAG
) == 
FLASH_FLAG_BSY
))

243 #define 
	#FLASH_PSIZE_BYTE
 ((
uint32_t
)0x00000000)

	)

244 #define 
	#FLASH_PSIZE_HALF_WORD
 ((
uint32_t
)0x00000100)

	)

245 #define 
	#FLASH_PSIZE_WORD
 ((
uint32_t
)0x00000200)

	)

246 #define 
	#FLASH_PSIZE_DOUBLE_WORD
 ((
uint32_t
)0x00000300)

	)

247 #define 
	#CR_PSIZE_MASK
 ((
uint32_t
)0xFFFFFCFF)

	)

255 #define 
	#RDP_KEY
 ((
uint16_t
)0x00A5)

	)

256 #define 
	#FLASH_KEY1
 ((
uint32_t
)0x45670123)

	)

257 #define 
	#FLASH_KEY2
 ((
uint32_t
)0xCDEF89AB)

	)

258 #define 
	#FLASH_OPT_KEY1
 ((
uint32_t
)0x08192A3B)

	)

259 #define 
	#FLASH_OPT_KEY2
 ((
uint32_t
)0x4C5D6E7F)

	)

267 #define 
	#ACR_BYTE0_ADDRESS
 ((
uint32_t
)0x40023C00)

	)

271 #define 
	#OPTCR_BYTE0_ADDRESS
 ((
uint32_t
)0x40023C14)

	)

272 #define 
	#OPTCR_BYTE1_ADDRESS
 ((
uint32_t
)0x40023C15)

	)

273 #define 
	#OPTCR_BYTE2_ADDRESS
 ((
uint32_t
)0x40023C16)

	)

283 void 
FLASH_SetLatency
(
uint32_t
 
FLASH_Latency
);

284 void 
FLASH_PrefetchBufferCmd
(
FunctionalState
 
NewState
);

285 void 
FLASH_InstructionCacheCmd
(
FunctionalState
 
NewState
);

286 void 
FLASH_DataCacheCmd
(
FunctionalState
 
NewState
);

287 void 
FLASH_InstructionCacheReset
(void);

288 void 
FLASH_DataCacheReset
(void);

291 void 
FLASH_Unlock
(void);

292 void 
FLASH_Lock
(void);

293 
FLASH_Status
 
FLASH_EraseSector
(
uint32_t
 
FLASH_Sector
, 
uint8_t
 
VoltageRange
);

294 
FLASH_Status
 
FLASH_EraseAllSectors
(
uint8_t
 
VoltageRange
);

295 
FLASH_Status
 
FLASH_ProgramDoubleWord
(
uint32_t
 
Address
, 
uint64_t
 
Data
);

296 
FLASH_Status
 
FLASH_ProgramWord
(
uint32_t
 
Address
, uint32_t 
Data
);

297 
FLASH_Status
 
FLASH_ProgramHalfWord
(
uint32_t
 
Address
, 
uint16_t
 
Data
);

298 
FLASH_Status
 
FLASH_ProgramByte
(
uint32_t
 
Address
, 
uint8_t
 
Data
);

301 void 
FLASH_OB_Unlock
(void);

302 void 
FLASH_OB_Lock
(void);

303 void 
FLASH_OB_WRPConfig
(
uint32_t
 
OB_WRP
, 
FunctionalState
 
NewState
);

304 void 
FLASH_OB_RDPConfig
(
uint8_t
 
OB_RDP
);

305 void 
FLASH_OB_UserConfig
(
uint8_t
 
OB_IWDG
, uint8_t 
OB_STOP
, uint8_t 
OB_STDBY
);

306 void 
FLASH_OB_BORConfig
(
uint8_t
 
OB_BOR
);

307 
FLASH_Status
 
FLASH_OB_Launch
(void);

308 
uint8_t
 
FLASH_OB_GetUser
(void);

309 
uint16_t
 
FLASH_OB_GetWRP
(void);

310 
FlagStatus
 
FLASH_OB_GetRDP
(void);

311 
uint8_t
 
FLASH_OB_GetBOR
(void);

314 void 
FLASH_ITConfig
(
uint32_t
 
FLASH_IT
, 
FunctionalState
 
NewState
);

315 
FlagStatus
 
FLASH_GetFlagStatus
(
uint32_t
 
FLASH_FLAG
);

316 void 
FLASH_ClearFlag
(
uint32_t
 
FLASH_FLAG
);

317 
FLASH_Status
 
FLASH_GetStatus
(void);

318 
FLASH_Status
 
FLASH_WaitForLastOperation
(void);

320 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fsmc.h

24 #ifndef 
__STM32F4xx_FSMC_H


25 #define 
	#__STM32F4xx_FSMC_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

49 
uint32_t
 
FSMC_AddressSetupTime
;

54 
uint32_t
 
FSMC_AddressHoldTime
;

59 
uint32_t
 
FSMC_DataSetupTime
;

64 
uint32_t
 
FSMC_BusTurnAroundDuration
;

69 
uint32_t
 
FSMC_CLKDivision
;

73 
uint32_t
 
FSMC_DataLatency
;

81 
uint32_t
 
FSMC_AccessMode
;

83 }
	tFSMC_NORSRAMTimingInitTypeDef
;

90 
uint32_t
 
FSMC_Bank
;

93 
uint32_t
 
FSMC_DataAddressMux
;

97 
uint32_t
 
FSMC_MemoryType
;

101 
uint32_t
 
FSMC_MemoryDataWidth
;

104 
uint32_t
 
FSMC_BurstAccessMode
;

108 
uint32_t
 
FSMC_AsynchronousWait
;

112 
uint32_t
 
FSMC_WaitSignalPolarity
;

116 
uint32_t
 
FSMC_WrapMode
;

120 
uint32_t
 
FSMC_WaitSignalActive
;

125 
uint32_t
 
FSMC_WriteOperation
;

128 
uint32_t
 
FSMC_WaitSignal
;

132 
uint32_t
 
FSMC_ExtendedMode
;

135 
uint32_t
 
FSMC_WriteBurst
;

138 
FSMC_NORSRAMTimingInitTypeDef
* 
FSMC_ReadWriteTimingStruct
;

140 
FSMC_NORSRAMTimingInitTypeDef
* 
FSMC_WriteTimingStruct
;

141 }
	tFSMC_NORSRAMInitTypeDef
;

148 
uint32_t
 
FSMC_SetupTime
;

154 
uint32_t
 
FSMC_WaitSetupTime
;

160 
uint32_t
 
FSMC_HoldSetupTime
;

167 
uint32_t
 
FSMC_HiZSetupTime
;

172 }
	tFSMC_NAND_PCCARDTimingInitTypeDef
;

179 
uint32_t
 
FSMC_Bank
;

182 
uint32_t
 
FSMC_Waitfeature
;

185 
uint32_t
 
FSMC_MemoryDataWidth
;

188 
uint32_t
 
FSMC_ECC
;

191 
uint32_t
 
FSMC_ECCPageSize
;

194 
uint32_t
 
FSMC_TCLRSetupTime
;

198 
uint32_t
 
FSMC_TARSetupTime
;

202 
FSMC_NAND_PCCARDTimingInitTypeDef
* 
FSMC_CommonSpaceTimingStruct
;

204 
FSMC_NAND_PCCARDTimingInitTypeDef
* 
FSMC_AttributeSpaceTimingStruct
;

205 }
	tFSMC_NANDInitTypeDef
;

213 
uint32_t
 
FSMC_Waitfeature
;

216 
uint32_t
 
FSMC_TCLRSetupTime
;

220 
uint32_t
 
FSMC_TARSetupTime
;

225 
FSMC_NAND_PCCARDTimingInitTypeDef
* 
FSMC_CommonSpaceTimingStruct
;

227 
FSMC_NAND_PCCARDTimingInitTypeDef
* 
FSMC_AttributeSpaceTimingStruct
;

229 
FSMC_NAND_PCCARDTimingInitTypeDef
* 
FSMC_IOSpaceTimingStruct
;

230 }
	tFSMC_PCCARDInitTypeDef
;

241 #define 
	#FSMC_Bank1_NORSRAM1
 ((
uint32_t
)0x00000000)

	)

242 #define 
	#FSMC_Bank1_NORSRAM2
 ((
uint32_t
)0x00000002)

	)

243 #define 
	#FSMC_Bank1_NORSRAM3
 ((
uint32_t
)0x00000004)

	)

244 #define 
	#FSMC_Bank1_NORSRAM4
 ((
uint32_t
)0x00000006)

	)

252 #define 
	#FSMC_Bank2_NAND
 ((
uint32_t
)0x00000010)

	)

253 #define 
	#FSMC_Bank3_NAND
 ((
uint32_t
)0x00000100)

	)

261 #define 
	#FSMC_Bank4_PCCARD
 ((
uint32_t
)0x00001000)

	)

266 #define 
	#IS_FSMC_NORSRAM_BANK
(
BANK
) (((BANK) == 
FSMC_Bank1_NORSRAM1
) || \

	)

267 ((
BANK
) == 
FSMC_Bank1_NORSRAM2
) || \

268 ((
BANK
) == 
FSMC_Bank1_NORSRAM3
) || \

269 ((
BANK
) == 
FSMC_Bank1_NORSRAM4
))

271 #define 
	#IS_FSMC_NAND_BANK
(
BANK
) (((BANK) == 
FSMC_Bank2_NAND
) || \

	)

272 ((
BANK
) == 
FSMC_Bank3_NAND
))

274 #define 
	#IS_FSMC_GETFLAG_BANK
(
BANK
) (((BANK) == 
FSMC_Bank2_NAND
) || \

	)

275 ((
BANK
) == 
FSMC_Bank3_NAND
) || \

276 ((
BANK
) == 
FSMC_Bank4_PCCARD
))

278 #define 
	#IS_FSMC_IT_BANK
(
BANK
) (((BANK) == 
FSMC_Bank2_NAND
) || \

	)

279 ((
BANK
) == 
FSMC_Bank3_NAND
) || \

280 ((
BANK
) == 
FSMC_Bank4_PCCARD
))

290 #define 
	#FSMC_DataAddressMux_Disable
 ((
uint32_t
)0x00000000)

	)

291 #define 
	#FSMC_DataAddressMux_Enable
 ((
uint32_t
)0x00000002)

	)

292 #define 
	#IS_FSMC_MUX
(
MUX
) (((MUX) == 
FSMC_DataAddressMux_Disable
) || \

	)

293 ((
MUX
) == 
FSMC_DataAddressMux_Enable
))

302 #define 
	#FSMC_MemoryType_SRAM
 ((
uint32_t
)0x00000000)

	)

303 #define 
	#FSMC_MemoryType_PSRAM
 ((
uint32_t
)0x00000004)

	)

304 #define 
	#FSMC_MemoryType_NOR
 ((
uint32_t
)0x00000008)

	)

305 #define 
	#IS_FSMC_MEMORY
(
MEMORY
) (((MEMORY) == 
FSMC_MemoryType_SRAM
) || \

	)

306 ((
MEMORY
) == 
FSMC_MemoryType_PSRAM
)|| \

307 ((
MEMORY
) == 
FSMC_MemoryType_NOR
))

316 #define 
	#FSMC_MemoryDataWidth_8b
 ((
uint32_t
)0x00000000)

	)

317 #define 
	#FSMC_MemoryDataWidth_16b
 ((
uint32_t
)0x00000010)

	)

318 #define 
	#IS_FSMC_MEMORY_WIDTH
(
WIDTH
) (((WIDTH) == 
FSMC_MemoryDataWidth_8b
) || \

	)

319 ((
WIDTH
) == 
FSMC_MemoryDataWidth_16b
))

328 #define 
	#FSMC_BurstAccessMode_Disable
 ((
uint32_t
)0x00000000)

	)

329 #define 
	#FSMC_BurstAccessMode_Enable
 ((
uint32_t
)0x00000100)

	)

330 #define 
	#IS_FSMC_BURSTMODE
(
STATE
) (((STATE) == 
FSMC_BurstAccessMode_Disable
) || \

	)

331 ((
STATE
) == 
FSMC_BurstAccessMode_Enable
))

339 #define 
	#FSMC_AsynchronousWait_Disable
 ((
uint32_t
)0x00000000)

	)

340 #define 
	#FSMC_AsynchronousWait_Enable
 ((
uint32_t
)0x00008000)

	)

341 #define 
	#IS_FSMC_ASYNWAIT
(
STATE
) (((STATE) == 
FSMC_AsynchronousWait_Disable
) || \

	)

342 ((
STATE
) == 
FSMC_AsynchronousWait_Enable
))

350 #define 
	#FSMC_WaitSignalPolarity_Low
 ((
uint32_t
)0x00000000)

	)

351 #define 
	#FSMC_WaitSignalPolarity_High
 ((
uint32_t
)0x00000200)

	)

352 #define 
	#IS_FSMC_WAIT_POLARITY
(
POLARITY
) (((POLARITY) == 
FSMC_WaitSignalPolarity_Low
) || \

	)

353 ((
POLARITY
) == 
FSMC_WaitSignalPolarity_High
))

361 #define 
	#FSMC_WrapMode_Disable
 ((
uint32_t
)0x00000000)

	)

362 #define 
	#FSMC_WrapMode_Enable
 ((
uint32_t
)0x00000400)

	)

363 #define 
	#IS_FSMC_WRAP_MODE
(
MODE
) (((MODE) == 
FSMC_WrapMode_Disable
) || \

	)

364 ((
MODE
) == 
FSMC_WrapMode_Enable
))

372 #define 
	#FSMC_WaitSignalActive_BeforeWaitState
 ((
uint32_t
)0x00000000)

	)

373 #define 
	#FSMC_WaitSignalActive_DuringWaitState
 ((
uint32_t
)0x00000800)

	)

374 #define 
	#IS_FSMC_WAIT_SIGNAL_ACTIVE
(
ACTIVE
) (((ACTIVE) == 
FSMC_WaitSignalActive_BeforeWaitState
) || \

	)

375 ((
ACTIVE
) == 
FSMC_WaitSignalActive_DuringWaitState
))

383 #define 
	#FSMC_WriteOperation_Disable
 ((
uint32_t
)0x00000000)

	)

384 #define 
	#FSMC_WriteOperation_Enable
 ((
uint32_t
)0x00001000)

	)

385 #define 
	#IS_FSMC_WRITE_OPERATION
(
OPERATION
) (((OPERATION) == 
FSMC_WriteOperation_Disable
) || \

	)

386 ((
OPERATION
) == 
FSMC_WriteOperation_Enable
))

394 #define 
	#FSMC_WaitSignal_Disable
 ((
uint32_t
)0x00000000)

	)

395 #define 
	#FSMC_WaitSignal_Enable
 ((
uint32_t
)0x00002000)

	)

396 #define 
	#IS_FSMC_WAITE_SIGNAL
(
SIGNAL
) (((SIGNAL) == 
FSMC_WaitSignal_Disable
) || \

	)

397 ((
SIGNAL
) == 
FSMC_WaitSignal_Enable
))

405 #define 
	#FSMC_ExtendedMode_Disable
 ((
uint32_t
)0x00000000)

	)

406 #define 
	#FSMC_ExtendedMode_Enable
 ((
uint32_t
)0x00004000)

	)

408 #define 
	#IS_FSMC_EXTENDED_MODE
(
MODE
) (((MODE) == 
FSMC_ExtendedMode_Disable
) || \

	)

409 ((
MODE
) == 
FSMC_ExtendedMode_Enable
))

418 #define 
	#FSMC_WriteBurst_Disable
 ((
uint32_t
)0x00000000)

	)

419 #define 
	#FSMC_WriteBurst_Enable
 ((
uint32_t
)0x00080000)

	)

420 #define 
	#IS_FSMC_WRITE_BURST
(
BURST
) (((BURST) == 
FSMC_WriteBurst_Disable
) || \

	)

421 ((
BURST
) == 
FSMC_WriteBurst_Enable
))

429 #define 
	#IS_FSMC_ADDRESS_SETUP_TIME
(
TIME
) ((TIME) <= 0xF)

	)

437 #define 
	#IS_FSMC_ADDRESS_HOLD_TIME
(
TIME
) ((TIME) <= 0xF)

	)

445 #define 
	#IS_FSMC_DATASETUP_TIME
(
TIME
) (((TIME) > 0) && ((TIME) <= 0xFF))

	)

453 #define 
	#IS_FSMC_TURNAROUND_TIME
(
TIME
) ((TIME) <= 0xF)

	)

461 #define 
	#IS_FSMC_CLK_DIV
(
DIV
) ((DIV) <= 0xF)

	)

469 #define 
	#IS_FSMC_DATA_LATENCY
(
LATENCY
) ((LATENCY) <= 0xF)

	)

477 #define 
	#FSMC_AccessMode_A
 ((
uint32_t
)0x00000000)

	)

478 #define 
	#FSMC_AccessMode_B
 ((
uint32_t
)0x10000000)

	)

479 #define 
	#FSMC_AccessMode_C
 ((
uint32_t
)0x20000000)

	)

480 #define 
	#FSMC_AccessMode_D
 ((
uint32_t
)0x30000000)

	)

481 #define 
	#IS_FSMC_ACCESS_MODE
(
MODE
) (((MODE) == 
FSMC_AccessMode_A
) || \

	)

482 ((
MODE
) == 
FSMC_AccessMode_B
) || \

483 ((
MODE
) == 
FSMC_AccessMode_C
) || \

484 ((
MODE
) == 
FSMC_AccessMode_D
))

500 #define 
	#FSMC_Waitfeature_Disable
 ((
uint32_t
)0x00000000)

	)

501 #define 
	#FSMC_Waitfeature_Enable
 ((
uint32_t
)0x00000002)

	)

502 #define 
	#IS_FSMC_WAIT_FEATURE
(
FEATURE
) (((FEATURE) == 
FSMC_Waitfeature_Disable
) || \

	)

503 ((
FEATURE
) == 
FSMC_Waitfeature_Enable
))

512 #define 
	#FSMC_ECC_Disable
 ((
uint32_t
)0x00000000)

	)

513 #define 
	#FSMC_ECC_Enable
 ((
uint32_t
)0x00000040)

	)

514 #define 
	#IS_FSMC_ECC_STATE
(
STATE
) (((STATE) == 
FSMC_ECC_Disable
) || \

	)

515 ((
STATE
) == 
FSMC_ECC_Enable
))

523 #define 
	#FSMC_ECCPageSize_256Bytes
 ((
uint32_t
)0x00000000)

	)

524 #define 
	#FSMC_ECCPageSize_512Bytes
 ((
uint32_t
)0x00020000)

	)

525 #define 
	#FSMC_ECCPageSize_1024Bytes
 ((
uint32_t
)0x00040000)

	)

526 #define 
	#FSMC_ECCPageSize_2048Bytes
 ((
uint32_t
)0x00060000)

	)

527 #define 
	#FSMC_ECCPageSize_4096Bytes
 ((
uint32_t
)0x00080000)

	)

528 #define 
	#FSMC_ECCPageSize_8192Bytes
 ((
uint32_t
)0x000A0000)

	)

529 #define 
	#IS_FSMC_ECCPAGE_SIZE
(
SIZE
) (((SIZE) == 
FSMC_ECCPageSize_256Bytes
) || \

	)

530 ((
SIZE
) == 
FSMC_ECCPageSize_512Bytes
) || \

531 ((
SIZE
) == 
FSMC_ECCPageSize_1024Bytes
) || \

532 ((
SIZE
) == 
FSMC_ECCPageSize_2048Bytes
) || \

533 ((
SIZE
) == 
FSMC_ECCPageSize_4096Bytes
) || \

534 ((
SIZE
) == 
FSMC_ECCPageSize_8192Bytes
))

542 #define 
	#IS_FSMC_TCLR_TIME
(
TIME
) ((TIME) <= 0xFF)

	)

550 #define 
	#IS_FSMC_TAR_TIME
(
TIME
) ((TIME) <= 0xFF)

	)

558 #define 
	#IS_FSMC_SETUP_TIME
(
TIME
) ((TIME) <= 0xFF)

	)

566 #define 
	#IS_FSMC_WAIT_TIME
(
TIME
) ((TIME) <= 0xFF)

	)

574 #define 
	#IS_FSMC_HOLD_TIME
(
TIME
) ((TIME) <= 0xFF)

	)

582 #define 
	#IS_FSMC_HIZ_TIME
(
TIME
) ((TIME) <= 0xFF)

	)

590 #define 
	#FSMC_IT_RisingEdge
 ((
uint32_t
)0x00000008)

	)

591 #define 
	#FSMC_IT_Level
 ((
uint32_t
)0x00000010)

	)

592 #define 
	#FSMC_IT_FallingEdge
 ((
uint32_t
)0x00000020)

	)

593 #define 
	#IS_FSMC_IT
(
IT
) ((((IT) & (
uint32_t
)0xFFFFFFC7) == 0x00000000) && ((IT) != 0x00000000))

	)

594 #define 
	#IS_FSMC_GET_IT
(
IT
) (((IT) == 
FSMC_IT_RisingEdge
) || \

	)

595 ((
IT
) == 
FSMC_IT_Level
) || \

596 ((
IT
) == 
FSMC_IT_FallingEdge
))

604 #define 
	#FSMC_FLAG_RisingEdge
 ((
uint32_t
)0x00000001)

	)

605 #define 
	#FSMC_FLAG_Level
 ((
uint32_t
)0x00000002)

	)

606 #define 
	#FSMC_FLAG_FallingEdge
 ((
uint32_t
)0x00000004)

	)

607 #define 
	#FSMC_FLAG_FEMPT
 ((
uint32_t
)0x00000040)

	)

608 #define 
	#IS_FSMC_GET_FLAG
(
FLAG
) (((FLAG) == 
FSMC_FLAG_RisingEdge
) || \

	)

609 ((
FLAG
) == 
FSMC_FLAG_Level
) || \

610 ((
FLAG
) == 
FSMC_FLAG_FallingEdge
) || \

611 ((
FLAG
) == 
FSMC_FLAG_FEMPT
))

613 #define 
	#IS_FSMC_CLEAR_FLAG
(
FLAG
) ((((FLAG) & (
uint32_t
)0xFFFFFFF8) == 0x00000000) && ((FLAG) != 0x00000000))

	)

630 void 
FSMC_NORSRAMDeInit
(
uint32_t
 
FSMC_Bank
);

631 void 
FSMC_NORSRAMInit
(
FSMC_NORSRAMInitTypeDef
* 
FSMC_NORSRAMInitStruct
);

632 void 
FSMC_NORSRAMStructInit
(
FSMC_NORSRAMInitTypeDef
* 
FSMC_NORSRAMInitStruct
);

633 void 
FSMC_NORSRAMCmd
(
uint32_t
 
FSMC_Bank
, 
FunctionalState
 
NewState
);

636 void 
FSMC_NANDDeInit
(
uint32_t
 
FSMC_Bank
);

637 void 
FSMC_NANDInit
(
FSMC_NANDInitTypeDef
* 
FSMC_NANDInitStruct
);

638 void 
FSMC_NANDStructInit
(
FSMC_NANDInitTypeDef
* 
FSMC_NANDInitStruct
);

639 void 
FSMC_NANDCmd
(
uint32_t
 
FSMC_Bank
, 
FunctionalState
 
NewState
);

640 void 
FSMC_NANDECCCmd
(
uint32_t
 
FSMC_Bank
, 
FunctionalState
 
NewState
);

641 
uint32_t
 
FSMC_GetECC
(uint32_t 
FSMC_Bank
);

644 void 
FSMC_PCCARDDeInit
(void);

645 void 
FSMC_PCCARDInit
(
FSMC_PCCARDInitTypeDef
* 
FSMC_PCCARDInitStruct
);

646 void 
FSMC_PCCARDStructInit
(
FSMC_PCCARDInitTypeDef
* 
FSMC_PCCARDInitStruct
);

647 void 
FSMC_PCCARDCmd
(
FunctionalState
 
NewState
);

650 void 
FSMC_ITConfig
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_IT
, 
FunctionalState
 
NewState
);

651 
FlagStatus
 
FSMC_GetFlagStatus
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_FLAG
);

652 void 
FSMC_ClearFlag
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_FLAG
);

653 
ITStatus
 
FSMC_GetITStatus
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_IT
);

654 void 
FSMC_ClearITPendingBit
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_IT
);

656 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h

24 #ifndef 
__STM32F4xx_GPIO_H


25 #define 
	#__STM32F4xx_GPIO_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

44 #define 
	#IS_GPIO_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
GPIOA
) || \

	)

45 ((
PERIPH
) == 
GPIOB
) || \

46 ((
PERIPH
) == 
GPIOC
) || \

47 ((
PERIPH
) == 
GPIOD
) || \

48 ((
PERIPH
) == 
GPIOE
) || \

49 ((
PERIPH
) == 
GPIOF
) || \

50 ((
PERIPH
) == 
GPIOG
) || \

51 ((
PERIPH
) == 
GPIOH
) || \

52 ((
PERIPH
) == 
GPIOI
))

59 
GPIO_Mode_IN
 = 0x00,

60 
GPIO_Mode_OUT
 = 0x01,

61 
GPIO_Mode_AF
 = 0x02,

62 
GPIO_Mode_AN
 = 0x03

63 }
	tGPIOMode_TypeDef
;

64 #define 
	#IS_GPIO_MODE
(
MODE
) (((MODE) == 
GPIO_Mode_IN
) || ((MODE) == 
GPIO_Mode_OUT
) || \

	)

65 ((
MODE
) == 
GPIO_Mode_AF
)|| ((MODE) == 
GPIO_Mode_AN
))

72 
GPIO_OType_PP
 = 0x00,

73 
GPIO_OType_OD
 = 0x01

74 }
	tGPIOOType_TypeDef
;

75 #define 
	#IS_GPIO_OTYPE
(
OTYPE
) (((OTYPE) == 
GPIO_OType_PP
) || ((OTYPE) == 
GPIO_OType_OD
))

	)

83 
GPIO_Speed_2MHz
 = 0x00,

84 
GPIO_Speed_25MHz
 = 0x01,

85 
GPIO_Speed_50MHz
 = 0x02,

86 
GPIO_Speed_100MHz
 = 0x03

87 }
	tGPIOSpeed_TypeDef
;

88 #define 
	#IS_GPIO_SPEED
(
SPEED
) (((SPEED) == 
GPIO_Speed_2MHz
) || ((SPEED) == 
GPIO_Speed_25MHz
) || \

	)

89 ((
SPEED
) == 
GPIO_Speed_50MHz
)|| ((SPEED) == 
GPIO_Speed_100MHz
))

96 
GPIO_PuPd_NOPULL
 = 0x00,

97 
GPIO_PuPd_UP
 = 0x01,

98 
GPIO_PuPd_DOWN
 = 0x02

99 }
	tGPIOPuPd_TypeDef
;

100 #define 
	#IS_GPIO_PUPD
(
PUPD
) (((PUPD) == 
GPIO_PuPd_NOPULL
) || ((PUPD) == 
GPIO_PuPd_UP
) || \

	)

101 ((
PUPD
) == 
GPIO_PuPd_DOWN
))

108 
Bit_RESET
 = 0,

109 
Bit_SET


110 }
	tBitAction
;

111 #define 
	#IS_GPIO_BIT_ACTION
(
ACTION
) (((ACTION) == 
Bit_RESET
) || ((ACTION) == 
Bit_SET
))

	)

119 
uint32_t
 
GPIO_Pin
;

122 
GPIOMode_TypeDef
 
GPIO_Mode
;

125 
GPIOSpeed_TypeDef
 
GPIO_Speed
;

128 
GPIOOType_TypeDef
 
GPIO_OType
;

131 
GPIOPuPd_TypeDef
 
GPIO_PuPd
;

133 }
	tGPIO_InitTypeDef
;

144 #define 
	#GPIO_Pin_0
 ((
uint16_t
)0x0001)

	)

145 #define 
	#GPIO_Pin_1
 ((
uint16_t
)0x0002)

	)

146 #define 
	#GPIO_Pin_2
 ((
uint16_t
)0x0004)

	)

147 #define 
	#GPIO_Pin_3
 ((
uint16_t
)0x0008)

	)

148 #define 
	#GPIO_Pin_4
 ((
uint16_t
)0x0010)

	)

149 #define 
	#GPIO_Pin_5
 ((
uint16_t
)0x0020)

	)

150 #define 
	#GPIO_Pin_6
 ((
uint16_t
)0x0040)

	)

151 #define 
	#GPIO_Pin_7
 ((
uint16_t
)0x0080)

	)

152 #define 
	#GPIO_Pin_8
 ((
uint16_t
)0x0100)

	)

153 #define 
	#GPIO_Pin_9
 ((
uint16_t
)0x0200)

	)

154 #define 
	#GPIO_Pin_10
 ((
uint16_t
)0x0400)

	)

155 #define 
	#GPIO_Pin_11
 ((
uint16_t
)0x0800)

	)

156 #define 
	#GPIO_Pin_12
 ((
uint16_t
)0x1000)

	)

157 #define 
	#GPIO_Pin_13
 ((
uint16_t
)0x2000)

	)

158 #define 
	#GPIO_Pin_14
 ((
uint16_t
)0x4000)

	)

159 #define 
	#GPIO_Pin_15
 ((
uint16_t
)0x8000)

	)

160 #define 
	#GPIO_Pin_All
 ((
uint16_t
)0xFFFF)

	)

162 #define 
	#IS_GPIO_PIN
(
PIN
) ((((PIN) & (
uint16_t
)0x00) == 0x00) && ((PIN) != (uint16_t)0x00))

	)

163 #define 
	#IS_GET_GPIO_PIN
(
PIN
) (((PIN) == 
GPIO_Pin_0
) || \

	)

164 ((
PIN
) == 
GPIO_Pin_1
) || \

165 ((
PIN
) == 
GPIO_Pin_2
) || \

166 ((
PIN
) == 
GPIO_Pin_3
) || \

167 ((
PIN
) == 
GPIO_Pin_4
) || \

168 ((
PIN
) == 
GPIO_Pin_5
) || \

169 ((
PIN
) == 
GPIO_Pin_6
) || \

170 ((
PIN
) == 
GPIO_Pin_7
) || \

171 ((
PIN
) == 
GPIO_Pin_8
) || \

172 ((
PIN
) == 
GPIO_Pin_9
) || \

173 ((
PIN
) == 
GPIO_Pin_10
) || \

174 ((
PIN
) == 
GPIO_Pin_11
) || \

175 ((
PIN
) == 
GPIO_Pin_12
) || \

176 ((
PIN
) == 
GPIO_Pin_13
) || \

177 ((
PIN
) == 
GPIO_Pin_14
) || \

178 ((
PIN
) == 
GPIO_Pin_15
))

187 #define 
	#GPIO_PinSource0
 ((
uint8_t
)0x00)

	)

188 #define 
	#GPIO_PinSource1
 ((
uint8_t
)0x01)

	)

189 #define 
	#GPIO_PinSource2
 ((
uint8_t
)0x02)

	)

190 #define 
	#GPIO_PinSource3
 ((
uint8_t
)0x03)

	)

191 #define 
	#GPIO_PinSource4
 ((
uint8_t
)0x04)

	)

192 #define 
	#GPIO_PinSource5
 ((
uint8_t
)0x05)

	)

193 #define 
	#GPIO_PinSource6
 ((
uint8_t
)0x06)

	)

194 #define 
	#GPIO_PinSource7
 ((
uint8_t
)0x07)

	)

195 #define 
	#GPIO_PinSource8
 ((
uint8_t
)0x08)

	)

196 #define 
	#GPIO_PinSource9
 ((
uint8_t
)0x09)

	)

197 #define 
	#GPIO_PinSource10
 ((
uint8_t
)0x0A)

	)

198 #define 
	#GPIO_PinSource11
 ((
uint8_t
)0x0B)

	)

199 #define 
	#GPIO_PinSource12
 ((
uint8_t
)0x0C)

	)

200 #define 
	#GPIO_PinSource13
 ((
uint8_t
)0x0D)

	)

201 #define 
	#GPIO_PinSource14
 ((
uint8_t
)0x0E)

	)

202 #define 
	#GPIO_PinSource15
 ((
uint8_t
)0x0F)

	)

204 #define 
	#IS_GPIO_PIN_SOURCE
(
PINSOURCE
) (((PINSOURCE) == 
GPIO_PinSource0
) || \

	)

205 ((
PINSOURCE
) == 
GPIO_PinSource1
) || \

206 ((
PINSOURCE
) == 
GPIO_PinSource2
) || \

207 ((
PINSOURCE
) == 
GPIO_PinSource3
) || \

208 ((
PINSOURCE
) == 
GPIO_PinSource4
) || \

209 ((
PINSOURCE
) == 
GPIO_PinSource5
) || \

210 ((
PINSOURCE
) == 
GPIO_PinSource6
) || \

211 ((
PINSOURCE
) == 
GPIO_PinSource7
) || \

212 ((
PINSOURCE
) == 
GPIO_PinSource8
) || \

213 ((
PINSOURCE
) == 
GPIO_PinSource9
) || \

214 ((
PINSOURCE
) == 
GPIO_PinSource10
) || \

215 ((
PINSOURCE
) == 
GPIO_PinSource11
) || \

216 ((
PINSOURCE
) == 
GPIO_PinSource12
) || \

217 ((
PINSOURCE
) == 
GPIO_PinSource13
) || \

218 ((
PINSOURCE
) == 
GPIO_PinSource14
) || \

219 ((
PINSOURCE
) == 
GPIO_PinSource15
))

230 #define 
	#GPIO_AF_RTC_50Hz
 ((
uint8_t
)0x00)

	)

231 #define 
	#GPIO_AF_MCO
 ((
uint8_t
)0x00)

	)

232 #define 
	#GPIO_AF_TAMPER
 ((
uint8_t
)0x00)

	)

233 #define 
	#GPIO_AF_SWJ
 ((
uint8_t
)0x00)

	)

234 #define 
	#GPIO_AF_TRACE
 ((
uint8_t
)0x00)

	)

239 #define 
	#GPIO_AF_TIM1
 ((
uint8_t
)0x01)

	)

240 #define 
	#GPIO_AF_TIM2
 ((
uint8_t
)0x01)

	)

245 #define 
	#GPIO_AF_TIM3
 ((
uint8_t
)0x02)

	)

246 #define 
	#GPIO_AF_TIM4
 ((
uint8_t
)0x02)

	)

247 #define 
	#GPIO_AF_TIM5
 ((
uint8_t
)0x02)

	)

252 #define 
	#GPIO_AF_TIM8
 ((
uint8_t
)0x03)

	)

253 #define 
	#GPIO_AF_TIM9
 ((
uint8_t
)0x03)

	)

254 #define 
	#GPIO_AF_TIM10
 ((
uint8_t
)0x03)

	)

255 #define 
	#GPIO_AF_TIM11
 ((
uint8_t
)0x03)

	)

260 #define 
	#GPIO_AF_I2C1
 ((
uint8_t
)0x04)

	)

261 #define 
	#GPIO_AF_I2C2
 ((
uint8_t
)0x04)

	)

262 #define 
	#GPIO_AF_I2C3
 ((
uint8_t
)0x04)

	)

267 #define 
	#GPIO_AF_SPI1
 ((
uint8_t
)0x05)

	)

268 #define 
	#GPIO_AF_SPI2
 ((
uint8_t
)0x05)

	)

273 #define 
	#GPIO_AF_SPI3
 ((
uint8_t
)0x06)

	)

278 #define 
	#GPIO_AF_USART1
 ((
uint8_t
)0x07)

	)

279 #define 
	#GPIO_AF_USART2
 ((
uint8_t
)0x07)

	)

280 #define 
	#GPIO_AF_USART3
 ((
uint8_t
)0x07)

	)

281 #define 
	#GPIO_AF_I2S3ext
 ((
uint8_t
)0x07)

	)

286 #define 
	#GPIO_AF_UART4
 ((
uint8_t
)0x08)

	)

287 #define 
	#GPIO_AF_UART5
 ((
uint8_t
)0x08)

	)

288 #define 
	#GPIO_AF_USART6
 ((
uint8_t
)0x08)

	)

293 #define 
	#GPIO_AF_CAN1
 ((
uint8_t
)0x09)

	)

294 #define 
	#GPIO_AF_CAN2
 ((
uint8_t
)0x09)

	)

295 #define 
	#GPIO_AF_TIM12
 ((
uint8_t
)0x09)

	)

296 #define 
	#GPIO_AF_TIM13
 ((
uint8_t
)0x09)

	)

297 #define 
	#GPIO_AF_TIM14
 ((
uint8_t
)0x09)

	)

302 #define 
	#GPIO_AF_OTG_FS
 ((
uint8_t
)0xA)

	)

303 #define 
	#GPIO_AF_OTG_HS
 ((
uint8_t
)0xA)

	)

308 #define 
	#GPIO_AF_ETH
 ((
uint8_t
)0x0B)

	)

313 #define 
	#GPIO_AF_FSMC
 ((
uint8_t
)0xC)

	)

314 #define 
	#GPIO_AF_OTG_HS_FS
 ((
uint8_t
)0xC)

	)

315 #define 
	#GPIO_AF_SDIO
 ((
uint8_t
)0xC)

	)

320 #define 
	#GPIO_AF_DCMI
 ((
uint8_t
)0x0D)

	)

325 #define 
	#GPIO_AF_EVENTOUT
 ((
uint8_t
)0x0F)

	)

327 #define 
	#IS_GPIO_AF
(
AF
) (((AF) == 
GPIO_AF_RTC_50Hz
) || ((AF) == 
GPIO_AF_TIM14
) || \

	)

328 ((
AF
) == 
GPIO_AF_MCO
) || ((AF) == 
GPIO_AF_TAMPER
) || \

329 ((
AF
) == 
GPIO_AF_SWJ
) || ((AF) == 
GPIO_AF_TRACE
) || \

330 ((
AF
) == 
GPIO_AF_TIM1
) || ((AF) == 
GPIO_AF_TIM2
) || \

331 ((
AF
) == 
GPIO_AF_TIM3
) || ((AF) == 
GPIO_AF_TIM4
) || \

332 ((
AF
) == 
GPIO_AF_TIM5
) || ((AF) == 
GPIO_AF_TIM8
) || \

333 ((
AF
) == 
GPIO_AF_I2C1
) || ((AF) == 
GPIO_AF_I2C2
) || \

334 ((
AF
) == 
GPIO_AF_I2C3
) || ((AF) == 
GPIO_AF_SPI1
) || \

335 ((
AF
) == 
GPIO_AF_SPI2
) || ((AF) == 
GPIO_AF_TIM13
) || \

336 ((
AF
) == 
GPIO_AF_SPI3
) || ((AF) == 
GPIO_AF_TIM14
) || \

337 ((
AF
) == 
GPIO_AF_USART1
) || ((AF) == 
GPIO_AF_USART2
) || \

338 ((
AF
) == 
GPIO_AF_USART3
) || ((AF) == 
GPIO_AF_UART4
) || \

339 ((
AF
) == 
GPIO_AF_UART5
) || ((AF) == 
GPIO_AF_USART6
) || \

340 ((
AF
) == 
GPIO_AF_CAN1
) || ((AF) == 
GPIO_AF_CAN2
) || \

341 ((
AF
) == 
GPIO_AF_OTG_FS
) || ((AF) == 
GPIO_AF_OTG_HS
) || \

342 ((
AF
) == 
GPIO_AF_ETH
) || ((AF) == 
GPIO_AF_FSMC
) || \

343 ((
AF
) == 
GPIO_AF_OTG_HS_FS
) || ((AF) == 
GPIO_AF_SDIO
) || \

344 ((
AF
) == 
GPIO_AF_DCMI
) || ((AF) == 
GPIO_AF_EVENTOUT
))

353 #define 
	#GPIO_Mode_AIN
 
GPIO_Mode_AN


	)

355 #define 
	#GPIO_AF_OTG1_FS
 
GPIO_AF_OTG_FS


	)

356 #define 
	#GPIO_AF_OTG2_HS
 
GPIO_AF_OTG_HS


	)

357 #define 
	#GPIO_AF_OTG2_FS
 
GPIO_AF_OTG_HS_FS


	)

371 void 
GPIO_DeInit
(
GPIO_TypeDef
* 
GPIOx
);

374 void 
GPIO_Init
(
GPIO_TypeDef
* 
GPIOx
, 
GPIO_InitTypeDef
* 
GPIO_InitStruct
);

375 void 
GPIO_StructInit
(
GPIO_InitTypeDef
* 
GPIO_InitStruct
);

376 void 
GPIO_PinLockConfig
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
);

379 
uint8_t
 
GPIO_ReadInputDataBit
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
);

380 
uint16_t
 
GPIO_ReadInputData
(
GPIO_TypeDef
* 
GPIOx
);

381 
uint8_t
 
GPIO_ReadOutputDataBit
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
);

382 
uint16_t
 
GPIO_ReadOutputData
(
GPIO_TypeDef
* 
GPIOx
);

383 void 
GPIO_SetBits
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
);

384 void 
GPIO_ResetBits
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
);

385 void 
GPIO_WriteBit
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
, 
BitAction
 
BitVal
);

386 void 
GPIO_Write
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
PortVal
);

387 void 
GPIO_ToggleBits
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
);

390 void 
GPIO_PinAFConfig
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_PinSource
, 
uint8_t
 
GPIO_AF
);

392 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_hash.h

24 #ifndef 
__STM32F4xx_HASH_H


25 #define 
	#__STM32F4xx_HASH_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

49 
uint32_t
 
HASH_AlgoSelection
;

51 
uint32_t
 
HASH_AlgoMode
;

53 
uint32_t
 
HASH_DataType
;

56 
uint32_t
 
HASH_HMACKeyType
;

58 }
	tHASH_InitTypeDef
;

65 
uint32_t
 
Data
[5];

67 } 
	tHASH_MsgDigest
;

74 
uint32_t
 
HASH_IMR
;

75 
uint32_t
 
HASH_STR
;

76 
uint32_t
 
HASH_CR
;

77 
uint32_t
 
HASH_CSR
[51];

78 }
	tHASH_Context
;

89 #define 
	#HASH_AlgoSelection_SHA1
 ((
uint16_t
)0x0000)

	)

90 #define 
	#HASH_AlgoSelection_MD5
 ((
uint16_t
)0x0080)

	)

92 #define 
	#IS_HASH_ALGOSELECTION
(
ALGOSELECTION
) (((ALGOSELECTION) == 
HASH_AlgoSelection_SHA1
) || \

	)

93 ((
ALGOSELECTION
) == 
HASH_AlgoSelection_MD5
))

101 #define 
	#HASH_AlgoMode_HASH
 ((
uint16_t
)0x0000)

	)

102 #define 
	#HASH_AlgoMode_HMAC
 ((
uint16_t
)0x0040)

	)

104 #define 
	#IS_HASH_ALGOMODE
(
ALGOMODE
) (((ALGOMODE) == 
HASH_AlgoMode_HASH
) || \

	)

105 ((
ALGOMODE
) == 
HASH_AlgoMode_HMAC
))

113 #define 
	#HASH_DataType_32b
 ((
uint16_t
)0x0000)

	)

114 #define 
	#HASH_DataType_16b
 ((
uint16_t
)0x0010)

	)

115 #define 
	#HASH_DataType_8b
 ((
uint16_t
)0x0020)

	)

116 #define 
	#HASH_DataType_1b
 ((
uint16_t
)0x0030)

	)

118 #define 
	#IS_HASH_DATATYPE
(
DATATYPE
) (((DATATYPE) == 
HASH_DataType_32b
)|| \

	)

119 ((
DATATYPE
) == 
HASH_DataType_16b
)|| \

120 ((
DATATYPE
) == 
HASH_DataType_8b
)|| \

121 ((
DATATYPE
) == 
HASH_DataType_1b
))

129 #define 
	#HASH_HMACKeyType_ShortKey
 ((
uint32_t
)0x00000000)

	)

130 #define 
	#HASH_HMACKeyType_LongKey
 ((
uint32_t
)0x00010000)

	)

132 #define 
	#IS_HASH_HMAC_KEYTYPE
(
KEYTYPE
) (((KEYTYPE) == 
HASH_HMACKeyType_ShortKey
) || \

	)

133 ((
KEYTYPE
) == 
HASH_HMACKeyType_LongKey
))

141 #define 
	#IS_HASH_VALIDBITSNUMBER
(
VALIDBITS
) ((VALIDBITS) <= 0x1F)

	)

150 #define 
	#HASH_IT_DINI
 ((
uint8_t
)0x01)

	)

151 #define 
	#HASH_IT_DCI
 ((
uint8_t
)0x02)

	)

153 #define 
	#IS_HASH_IT
(
IT
) ((((IT) & (
uint8_t
)0xFC) == 0x00) && ((IT) != 0x00))

	)

154 #define 
	#IS_HASH_GET_IT
(
IT
) (((IT) == 
HASH_IT_DINI
) || ((IT) == 
HASH_IT_DCI
))

	)

163 #define 
	#HASH_FLAG_DINIS
 ((
uint16_t
)0x0001)

	)

164 #define 
	#HASH_FLAG_DCIS
 ((
uint16_t
)0x0002)

	)

165 #define 
	#HASH_FLAG_DMAS
 ((
uint16_t
)0x0004)

	)

166 #define 
	#HASH_FLAG_BUSY
 ((
uint16_t
)0x0008)

	)

167 #define 
	#HASH_FLAG_DINNE
 ((
uint16_t
)0x1000)

	)

169 #define 
	#IS_HASH_GET_FLAG
(
FLAG
) (((FLAG) == 
HASH_FLAG_DINIS
) || \

	)

170 ((
FLAG
) == 
HASH_FLAG_DCIS
) || \

171 ((
FLAG
) == 
HASH_FLAG_DMAS
) || \

172 ((
FLAG
) == 
HASH_FLAG_BUSY
) || \

173 ((
FLAG
) == 
HASH_FLAG_DINNE
))

175 #define 
	#IS_HASH_CLEAR_FLAG
(
FLAG
)(((FLAG) == 
HASH_FLAG_DINIS
) || \

	)

176 ((
FLAG
) == 
HASH_FLAG_DCIS
))

190 void 
HASH_DeInit
(void);

193 void 
HASH_Init
(
HASH_InitTypeDef
* 
HASH_InitStruct
);

194 void 
HASH_StructInit
(
HASH_InitTypeDef
* 
HASH_InitStruct
);

195 void 
HASH_Reset
(void);

198 void 
HASH_DataIn
(
uint32_t
 
Data
);

199 
uint8_t
 
HASH_GetInFIFOWordsNbr
(void);

200 void 
HASH_SetLastWordValidBitsNbr
(
uint16_t
 
ValidNumber
);

201 void 
HASH_StartDigest
(void);

202 void 
HASH_GetDigest
(
HASH_MsgDigest
* 
HASH_MessageDigest
);

205 void 
HASH_SaveContext
(
HASH_Context
* 
HASH_ContextSave
);

206 void 
HASH_RestoreContext
(
HASH_Context
* 
HASH_ContextRestore
);

209 void 
HASH_DMACmd
(
FunctionalState
 
NewState
);

212 void 
HASH_ITConfig
(
uint8_t
 
HASH_IT
, 
FunctionalState
 
NewState
);

213 
FlagStatus
 
HASH_GetFlagStatus
(
uint16_t
 
HASH_FLAG
);

214 void 
HASH_ClearFlag
(
uint16_t
 
HASH_FLAG
);

215 
ITStatus
 
HASH_GetITStatus
(
uint8_t
 
HASH_IT
);

216 void 
HASH_ClearITPendingBit
(
uint8_t
 
HASH_IT
);

219 
ErrorStatus
 
HASH_SHA1
(
uint8_t
 *
Input
, 
uint32_t
 
Ilen
, uint8_t 
Output
[20]);

220 
ErrorStatus
 
HMAC_SHA1
(
uint8_t
 *
Key
, 
uint32_t
 
Keylen
,

221 
uint8_t
 *
Input
, 
uint32_t
 
Ilen
,

222 
uint8_t
 
Output
[20]);

225 
ErrorStatus
 
HASH_MD5
(
uint8_t
 *
Input
, 
uint32_t
 
Ilen
, uint8_t 
Output
[16]);

226 
ErrorStatus
 
HMAC_MD5
(
uint8_t
 *
Key
, 
uint32_t
 
Keylen
,

227 
uint8_t
 *
Input
, 
uint32_t
 
Ilen
,

228 
uint8_t
 
Output
[16]);

230 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_i2c.h

24 #ifndef 
__STM32F4xx_I2C_H


25 #define 
	#__STM32F4xx_I2C_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

50 
uint32_t
 
I2C_ClockSpeed
;

53 
uint16_t
 
I2C_Mode
;

56 
uint16_t
 
I2C_DutyCycle
;

59 
uint16_t
 
I2C_OwnAddress1
;

62 
uint16_t
 
I2C_Ack
;

65 
uint16_t
 
I2C_AcknowledgedAddress
;

67 }
	tI2C_InitTypeDef
;

76 #define 
	#IS_I2C_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
I2C1
) || \

	)

77 ((
PERIPH
) == 
I2C2
) || \

78 ((
PERIPH
) == 
I2C3
))

83 #define 
	#I2C_Mode_I2C
 ((
uint16_t
)0x0000)

	)

84 #define 
	#I2C_Mode_SMBusDevice
 ((
uint16_t
)0x0002)

	)

85 #define 
	#I2C_Mode_SMBusHost
 ((
uint16_t
)0x000A)

	)

86 #define 
	#IS_I2C_MODE
(
MODE
) (((MODE) == 
I2C_Mode_I2C
) || \

	)

87 ((
MODE
) == 
I2C_Mode_SMBusDevice
) || \

88 ((
MODE
) == 
I2C_Mode_SMBusHost
))

97 #define 
	#I2C_DutyCycle_16_9
 ((
uint16_t
)0x4000)

	)

98 #define 
	#I2C_DutyCycle_2
 ((
uint16_t
)0xBFFF)

	)

99 #define 
	#IS_I2C_DUTY_CYCLE
(
CYCLE
) (((CYCLE) == 
I2C_DutyCycle_16_9
) || \

	)

100 ((
CYCLE
) == 
I2C_DutyCycle_2
))

109 #define 
	#I2C_Ack_Enable
 ((
uint16_t
)0x0400)

	)

110 #define 
	#I2C_Ack_Disable
 ((
uint16_t
)0x0000)

	)

111 #define 
	#IS_I2C_ACK_STATE
(
STATE
) (((STATE) == 
I2C_Ack_Enable
) || \

	)

112 ((
STATE
) == 
I2C_Ack_Disable
))

121 #define 
	#I2C_Direction_Transmitter
 ((
uint8_t
)0x00)

	)

122 #define 
	#I2C_Direction_Receiver
 ((
uint8_t
)0x01)

	)

123 #define 
	#IS_I2C_DIRECTION
(
DIRECTION
) (((DIRECTION) == 
I2C_Direction_Transmitter
) || \

	)

124 ((
DIRECTION
) == 
I2C_Direction_Receiver
))

133 #define 
	#I2C_AcknowledgedAddress_7bit
 ((
uint16_t
)0x4000)

	)

134 #define 
	#I2C_AcknowledgedAddress_10bit
 ((
uint16_t
)0xC000)

	)

135 #define 
	#IS_I2C_ACKNOWLEDGE_ADDRESS
(
ADDRESS
) (((ADDRESS) == 
I2C_AcknowledgedAddress_7bit
) || \

	)

136 ((
ADDRESS
) == 
I2C_AcknowledgedAddress_10bit
))

145 #define 
	#I2C_Register_CR1
 ((
uint8_t
)0x00)

	)

146 #define 
	#I2C_Register_CR2
 ((
uint8_t
)0x04)

	)

147 #define 
	#I2C_Register_OAR1
 ((
uint8_t
)0x08)

	)

148 #define 
	#I2C_Register_OAR2
 ((
uint8_t
)0x0C)

	)

149 #define 
	#I2C_Register_DR
 ((
uint8_t
)0x10)

	)

150 #define 
	#I2C_Register_SR1
 ((
uint8_t
)0x14)

	)

151 #define 
	#I2C_Register_SR2
 ((
uint8_t
)0x18)

	)

152 #define 
	#I2C_Register_CCR
 ((
uint8_t
)0x1C)

	)

153 #define 
	#I2C_Register_TRISE
 ((
uint8_t
)0x20)

	)

154 #define 
	#IS_I2C_REGISTER
(
REGISTER
) (((REGISTER) == 
I2C_Register_CR1
) || \

	)

155 ((
REGISTER
) == 
I2C_Register_CR2
) || \

156 ((
REGISTER
) == 
I2C_Register_OAR1
) || \

157 ((
REGISTER
) == 
I2C_Register_OAR2
) || \

158 ((
REGISTER
) == 
I2C_Register_DR
) || \

159 ((
REGISTER
) == 
I2C_Register_SR1
) || \

160 ((
REGISTER
) == 
I2C_Register_SR2
) || \

161 ((
REGISTER
) == 
I2C_Register_CCR
) || \

162 ((
REGISTER
) == 
I2C_Register_TRISE
))

171 #define 
	#I2C_NACKPosition_Next
 ((
uint16_t
)0x0800)

	)

172 #define 
	#I2C_NACKPosition_Current
 ((
uint16_t
)0xF7FF)

	)

173 #define 
	#IS_I2C_NACK_POSITION
(
POSITION
) (((POSITION) == 
I2C_NACKPosition_Next
) || \

	)

174 ((
POSITION
) == 
I2C_NACKPosition_Current
))

183 #define 
	#I2C_SMBusAlert_Low
 ((
uint16_t
)0x2000)

	)

184 #define 
	#I2C_SMBusAlert_High
 ((
uint16_t
)0xDFFF)

	)

185 #define 
	#IS_I2C_SMBUS_ALERT
(
ALERT
) (((ALERT) == 
I2C_SMBusAlert_Low
) || \

	)

186 ((
ALERT
) == 
I2C_SMBusAlert_High
))

195 #define 
	#I2C_PECPosition_Next
 ((
uint16_t
)0x0800)

	)

196 #define 
	#I2C_PECPosition_Current
 ((
uint16_t
)0xF7FF)

	)

197 #define 
	#IS_I2C_PEC_POSITION
(
POSITION
) (((POSITION) == 
I2C_PECPosition_Next
) || \

	)

198 ((
POSITION
) == 
I2C_PECPosition_Current
))

207 #define 
	#I2C_IT_BUF
 ((
uint16_t
)0x0400)

	)

208 #define 
	#I2C_IT_EVT
 ((
uint16_t
)0x0200)

	)

209 #define 
	#I2C_IT_ERR
 ((
uint16_t
)0x0100)

	)

210 #define 
	#IS_I2C_CONFIG_IT
(
IT
) ((((IT) & (
uint16_t
)0xF8FF) == 0x00) && ((IT) != 0x00))

	)

219 #define 
	#I2C_IT_SMBALERT
 ((
uint32_t
)0x01008000)

	)

220 #define 
	#I2C_IT_TIMEOUT
 ((
uint32_t
)0x01004000)

	)

221 #define 
	#I2C_IT_PECERR
 ((
uint32_t
)0x01001000)

	)

222 #define 
	#I2C_IT_OVR
 ((
uint32_t
)0x01000800)

	)

223 #define 
	#I2C_IT_AF
 ((
uint32_t
)0x01000400)

	)

224 #define 
	#I2C_IT_ARLO
 ((
uint32_t
)0x01000200)

	)

225 #define 
	#I2C_IT_BERR
 ((
uint32_t
)0x01000100)

	)

226 #define 
	#I2C_IT_TXE
 ((
uint32_t
)0x06000080)

	)

227 #define 
	#I2C_IT_RXNE
 ((
uint32_t
)0x06000040)

	)

228 #define 
	#I2C_IT_STOPF
 ((
uint32_t
)0x02000010)

	)

229 #define 
	#I2C_IT_ADD10
 ((
uint32_t
)0x02000008)

	)

230 #define 
	#I2C_IT_BTF
 ((
uint32_t
)0x02000004)

	)

231 #define 
	#I2C_IT_ADDR
 ((
uint32_t
)0x02000002)

	)

232 #define 
	#I2C_IT_SB
 ((
uint32_t
)0x02000001)

	)

234 #define 
	#IS_I2C_CLEAR_IT
(
IT
) ((((IT) & (
uint16_t
)0x20FF) == 0x00) && ((IT) != (uint16_t)0x00))

	)

236 #define 
	#IS_I2C_GET_IT
(
IT
) (((IT) == 
I2C_IT_SMBALERT
) || ((IT) == 
I2C_IT_TIMEOUT
) || \

	)

237 ((
IT
) == 
I2C_IT_PECERR
) || ((IT) == 
I2C_IT_OVR
) || \

238 ((
IT
) == 
I2C_IT_AF
) || ((IT) == 
I2C_IT_ARLO
) || \

239 ((
IT
) == 
I2C_IT_BERR
) || ((IT) == 
I2C_IT_TXE
) || \

240 ((
IT
) == 
I2C_IT_RXNE
) || ((IT) == 
I2C_IT_STOPF
) || \

241 ((
IT
) == 
I2C_IT_ADD10
) || ((IT) == 
I2C_IT_BTF
) || \

242 ((
IT
) == 
I2C_IT_ADDR
) || ((IT) == 
I2C_IT_SB
))

255 #define 
	#I2C_FLAG_DUALF
 ((
uint32_t
)0x00800000)

	)

256 #define 
	#I2C_FLAG_SMBHOST
 ((
uint32_t
)0x00400000)

	)

257 #define 
	#I2C_FLAG_SMBDEFAULT
 ((
uint32_t
)0x00200000)

	)

258 #define 
	#I2C_FLAG_GENCALL
 ((
uint32_t
)0x00100000)

	)

259 #define 
	#I2C_FLAG_TRA
 ((
uint32_t
)0x00040000)

	)

260 #define 
	#I2C_FLAG_BUSY
 ((
uint32_t
)0x00020000)

	)

261 #define 
	#I2C_FLAG_MSL
 ((
uint32_t
)0x00010000)

	)

267 #define 
	#I2C_FLAG_SMBALERT
 ((
uint32_t
)0x10008000)

	)

268 #define 
	#I2C_FLAG_TIMEOUT
 ((
uint32_t
)0x10004000)

	)

269 #define 
	#I2C_FLAG_PECERR
 ((
uint32_t
)0x10001000)

	)

270 #define 
	#I2C_FLAG_OVR
 ((
uint32_t
)0x10000800)

	)

271 #define 
	#I2C_FLAG_AF
 ((
uint32_t
)0x10000400)

	)

272 #define 
	#I2C_FLAG_ARLO
 ((
uint32_t
)0x10000200)

	)

273 #define 
	#I2C_FLAG_BERR
 ((
uint32_t
)0x10000100)

	)

274 #define 
	#I2C_FLAG_TXE
 ((
uint32_t
)0x10000080)

	)

275 #define 
	#I2C_FLAG_RXNE
 ((
uint32_t
)0x10000040)

	)

276 #define 
	#I2C_FLAG_STOPF
 ((
uint32_t
)0x10000010)

	)

277 #define 
	#I2C_FLAG_ADD10
 ((
uint32_t
)0x10000008)

	)

278 #define 
	#I2C_FLAG_BTF
 ((
uint32_t
)0x10000004)

	)

279 #define 
	#I2C_FLAG_ADDR
 ((
uint32_t
)0x10000002)

	)

280 #define 
	#I2C_FLAG_SB
 ((
uint32_t
)0x10000001)

	)

282 #define 
	#IS_I2C_CLEAR_FLAG
(
FLAG
) ((((FLAG) & (
uint16_t
)0x20FF) == 0x00) && ((FLAG) != (uint16_t)0x00))

	)

284 #define 
	#IS_I2C_GET_FLAG
(
FLAG
) (((FLAG) == 
I2C_FLAG_DUALF
) || ((FLAG) == 
I2C_FLAG_SMBHOST
) || \

	)

285 ((
FLAG
) == 
I2C_FLAG_SMBDEFAULT
) || ((FLAG) == 
I2C_FLAG_GENCALL
) || \

286 ((
FLAG
) == 
I2C_FLAG_TRA
) || ((FLAG) == 
I2C_FLAG_BUSY
) || \

287 ((
FLAG
) == 
I2C_FLAG_MSL
) || ((FLAG) == 
I2C_FLAG_SMBALERT
) || \

288 ((
FLAG
) == 
I2C_FLAG_TIMEOUT
) || ((FLAG) == 
I2C_FLAG_PECERR
) || \

289 ((
FLAG
) == 
I2C_FLAG_OVR
) || ((FLAG) == 
I2C_FLAG_AF
) || \

290 ((
FLAG
) == 
I2C_FLAG_ARLO
) || ((FLAG) == 
I2C_FLAG_BERR
) || \

291 ((
FLAG
) == 
I2C_FLAG_TXE
) || ((FLAG) == 
I2C_FLAG_RXNE
) || \

292 ((
FLAG
) == 
I2C_FLAG_STOPF
) || ((FLAG) == 
I2C_FLAG_ADD10
) || \

293 ((
FLAG
) == 
I2C_FLAG_BTF
) || ((FLAG) == 
I2C_FLAG_ADDR
) || \

294 ((
FLAG
) == 
I2C_FLAG_SB
))

318 #define 
	#I2C_EVENT_MASTER_MODE_SELECT
 ((
uint32_t
)0x00030001)

	)

346 #define 
	#I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED
 ((
uint32_t
)0x00070082)

	)

347 #define 
	#I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED
 ((
uint32_t
)0x00030002)

	)

349 #define 
	#I2C_EVENT_MASTER_MODE_ADDRESS10
 ((
uint32_t
)0x00030008)

	)

382 #define 
	#I2C_EVENT_MASTER_BYTE_RECEIVED
 ((
uint32_t
)0x00030040)

	)

386 #define 
	#I2C_EVENT_MASTER_BYTE_TRANSMITTING
 ((
uint32_t
)0x00070080)

	)

388 #define 
	#I2C_EVENT_MASTER_BYTE_TRANSMITTED
 ((
uint32_t
)0x00070084)

	)

425 #define 
	#I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED
 ((
uint32_t
)0x00020002)

	)

426 #define 
	#I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED
 ((
uint32_t
)0x00060082)

	)

429 #define 
	#I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED
 ((
uint32_t
)0x00820000)

	)

430 #define 
	#I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED
 ((
uint32_t
)0x00860080)

	)

433 #define 
	#I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED
 ((
uint32_t
)0x00120000)

	)

464 #define 
	#I2C_EVENT_SLAVE_BYTE_RECEIVED
 ((
uint32_t
)0x00020040)

	)

466 #define 
	#I2C_EVENT_SLAVE_STOP_DETECTED
 ((
uint32_t
)0x00000010)

	)

470 #define 
	#I2C_EVENT_SLAVE_BYTE_TRANSMITTED
 ((
uint32_t
)0x00060084)

	)

471 #define 
	#I2C_EVENT_SLAVE_BYTE_TRANSMITTING
 ((
uint32_t
)0x00060080)

	)

473 #define 
	#I2C_EVENT_SLAVE_ACK_FAILURE
 ((
uint32_t
)0x00000400)

	)

481 #define 
	#IS_I2C_EVENT
(
EVENT
) (((EVENT) == 
I2C_EVENT_SLAVE_TRANSMITTER_ADDRESS_MATCHED
) || \

	)

482 ((
EVENT
) == 
I2C_EVENT_SLAVE_RECEIVER_ADDRESS_MATCHED
) || \

483 ((
EVENT
) == 
I2C_EVENT_SLAVE_TRANSMITTER_SECONDADDRESS_MATCHED
) || \

484 ((
EVENT
) == 
I2C_EVENT_SLAVE_RECEIVER_SECONDADDRESS_MATCHED
) || \

485 ((
EVENT
) == 
I2C_EVENT_SLAVE_GENERALCALLADDRESS_MATCHED
) || \

486 ((
EVENT
) == 
I2C_EVENT_SLAVE_BYTE_RECEIVED
) || \

487 ((
EVENT
) == (
I2C_EVENT_SLAVE_BYTE_RECEIVED
 | 
I2C_FLAG_DUALF
)) || \

488 ((
EVENT
) == (
I2C_EVENT_SLAVE_BYTE_RECEIVED
 | 
I2C_FLAG_GENCALL
)) || \

489 ((
EVENT
) == 
I2C_EVENT_SLAVE_BYTE_TRANSMITTED
) || \

490 ((
EVENT
) == (
I2C_EVENT_SLAVE_BYTE_TRANSMITTED
 | 
I2C_FLAG_DUALF
)) || \

491 ((
EVENT
) == (
I2C_EVENT_SLAVE_BYTE_TRANSMITTED
 | 
I2C_FLAG_GENCALL
)) || \

492 ((
EVENT
) == 
I2C_EVENT_SLAVE_STOP_DETECTED
) || \

493 ((
EVENT
) == 
I2C_EVENT_MASTER_MODE_SELECT
) || \

494 ((
EVENT
) == 
I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED
) || \

495 ((
EVENT
) == 
I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED
) || \

496 ((
EVENT
) == 
I2C_EVENT_MASTER_BYTE_RECEIVED
) || \

497 ((
EVENT
) == 
I2C_EVENT_MASTER_BYTE_TRANSMITTED
) || \

498 ((
EVENT
) == 
I2C_EVENT_MASTER_BYTE_TRANSMITTING
) || \

499 ((
EVENT
) == 
I2C_EVENT_MASTER_MODE_ADDRESS10
) || \

500 ((
EVENT
) == 
I2C_EVENT_SLAVE_ACK_FAILURE
))

509 #define 
	#IS_I2C_OWN_ADDRESS1
(
ADDRESS1
) ((ADDRESS1) <= 0x3FF)

	)

518 #define 
	#IS_I2C_CLOCK_SPEED
(
SPEED
) (((SPEED) >= 0x1) && ((SPEED) <= 400000))

	)

531 void 
I2C_DeInit
(
I2C_TypeDef
* 
I2Cx
);

534 void 
I2C_Init
(
I2C_TypeDef
* 
I2Cx
, 
I2C_InitTypeDef
* 
I2C_InitStruct
);

535 void 
I2C_StructInit
(
I2C_InitTypeDef
* 
I2C_InitStruct
);

536 void 
I2C_Cmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

537 void 
I2C_GenerateSTART
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

538 void 
I2C_GenerateSTOP
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

539 void 
I2C_Send7bitAddress
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
Address
, uint8_t 
I2C_Direction
);

540 void 
I2C_AcknowledgeConfig
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

541 void 
I2C_OwnAddress2Config
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
Address
);

542 void 
I2C_DualAddressCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

543 void 
I2C_GeneralCallCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

544 void 
I2C_SoftwareResetCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

545 void 
I2C_StretchClockCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

546 void 
I2C_FastModeDutyCycleConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_DutyCycle
);

547 void 
I2C_NACKPositionConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_NACKPosition
);

548 void 
I2C_SMBusAlertConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_SMBusAlert
);

549 void 
I2C_ARPCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

552 void 
I2C_SendData
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
Data
);

553 
uint8_t
 
I2C_ReceiveData
(
I2C_TypeDef
* 
I2Cx
);

556 void 
I2C_TransmitPEC
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

557 void 
I2C_PECPositionConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_PECPosition
);

558 void 
I2C_CalculatePEC
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

559 
uint8_t
 
I2C_GetPEC
(
I2C_TypeDef
* 
I2Cx
);

562 void 
I2C_DMACmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

563 void 
I2C_DMALastTransferCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
);

566 
uint16_t
 
I2C_ReadRegister
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
I2C_Register
);

567 void 
I2C_ITConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_IT
, 
FunctionalState
 
NewState
);

659 
ErrorStatus
 
I2C_CheckEvent
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_EVENT
);

665 
uint32_t
 
I2C_GetLastEvent
(
I2C_TypeDef
* 
I2Cx
);

671 
FlagStatus
 
I2C_GetFlagStatus
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_FLAG
);

674 void 
I2C_ClearFlag
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_FLAG
);

675 
ITStatus
 
I2C_GetITStatus
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_IT
);

676 void 
I2C_ClearITPendingBit
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_IT
);

678 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_iwdg.h

24 #ifndef 
__STM32F4xx_IWDG_H


25 #define 
	#__STM32F4xx_IWDG_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

52 #define 
	#IWDG_WriteAccess_Enable
 ((
uint16_t
)0x5555)

	)

53 #define 
	#IWDG_WriteAccess_Disable
 ((
uint16_t
)0x0000)

	)

54 #define 
	#IS_IWDG_WRITE_ACCESS
(
ACCESS
) (((ACCESS) == 
IWDG_WriteAccess_Enable
) || \

	)

55 ((
ACCESS
) == 
IWDG_WriteAccess_Disable
))

63 #define 
	#IWDG_Prescaler_4
 ((
uint8_t
)0x00)

	)

64 #define 
	#IWDG_Prescaler_8
 ((
uint8_t
)0x01)

	)

65 #define 
	#IWDG_Prescaler_16
 ((
uint8_t
)0x02)

	)

66 #define 
	#IWDG_Prescaler_32
 ((
uint8_t
)0x03)

	)

67 #define 
	#IWDG_Prescaler_64
 ((
uint8_t
)0x04)

	)

68 #define 
	#IWDG_Prescaler_128
 ((
uint8_t
)0x05)

	)

69 #define 
	#IWDG_Prescaler_256
 ((
uint8_t
)0x06)

	)

70 #define 
	#IS_IWDG_PRESCALER
(
PRESCALER
) (((PRESCALER) == 
IWDG_Prescaler_4
) || \

	)

71 ((
PRESCALER
) == 
IWDG_Prescaler_8
) || \

72 ((
PRESCALER
) == 
IWDG_Prescaler_16
) || \

73 ((
PRESCALER
) == 
IWDG_Prescaler_32
) || \

74 ((
PRESCALER
) == 
IWDG_Prescaler_64
) || \

75 ((
PRESCALER
) == 
IWDG_Prescaler_128
)|| \

76 ((
PRESCALER
) == 
IWDG_Prescaler_256
))

84 #define 
	#IWDG_FLAG_PVU
 ((
uint16_t
)0x0001)

	)

85 #define 
	#IWDG_FLAG_RVU
 ((
uint16_t
)0x0002)

	)

86 #define 
	#IS_IWDG_FLAG
(
FLAG
) (((FLAG) == 
IWDG_FLAG_PVU
) || ((FLAG) == 
IWDG_FLAG_RVU
))

	)

87 #define 
	#IS_IWDG_RELOAD
(
RELOAD
) ((RELOAD) <= 0xFFF)

	)

100 void 
IWDG_WriteAccessCmd
(
uint16_t
 
IWDG_WriteAccess
);

101 void 
IWDG_SetPrescaler
(
uint8_t
 
IWDG_Prescaler
);

102 void 
IWDG_SetReload
(
uint16_t
 
Reload
);

103 void 
IWDG_ReloadCounter
(void);

106 void 
IWDG_Enable
(void);

109 
FlagStatus
 
IWDG_GetFlagStatus
(
uint16_t
 
IWDG_FLAG
);

111 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_pwr.h

24 #ifndef 
__STM32F4xx_PWR_H


25 #define 
	#__STM32F4xx_PWR_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

53 #define 
	#PWR_PVDLevel_0
 
PWR_CR_PLS_LEV0


	)

54 #define 
	#PWR_PVDLevel_1
 
PWR_CR_PLS_LEV1


	)

55 #define 
	#PWR_PVDLevel_2
 
PWR_CR_PLS_LEV2


	)

56 #define 
	#PWR_PVDLevel_3
 
PWR_CR_PLS_LEV3


	)

57 #define 
	#PWR_PVDLevel_4
 
PWR_CR_PLS_LEV4


	)

58 #define 
	#PWR_PVDLevel_5
 
PWR_CR_PLS_LEV5


	)

59 #define 
	#PWR_PVDLevel_6
 
PWR_CR_PLS_LEV6


	)

60 #define 
	#PWR_PVDLevel_7
 
PWR_CR_PLS_LEV7


	)

62 #define 
	#IS_PWR_PVD_LEVEL
(
LEVEL
) (((LEVEL) == 
PWR_PVDLevel_0
) || ((LEVEL) == 
PWR_PVDLevel_1
)|| \

	)

63 ((
LEVEL
) == 
PWR_PVDLevel_2
) || ((LEVEL) == 
PWR_PVDLevel_3
)|| \

64 ((
LEVEL
) == 
PWR_PVDLevel_4
) || ((LEVEL) == 
PWR_PVDLevel_5
)|| \

65 ((
LEVEL
) == 
PWR_PVDLevel_6
) || ((LEVEL) == 
PWR_PVDLevel_7
))

75 #define 
	#PWR_Regulator_ON
 ((
uint32_t
)0x00000000)

	)

76 #define 
	#PWR_Regulator_LowPower
 
PWR_CR_LPDS


	)

77 #define 
	#IS_PWR_REGULATOR
(
REGULATOR
) (((REGULATOR) == 
PWR_Regulator_ON
) || \

	)

78 ((
REGULATOR
) == 
PWR_Regulator_LowPower
))

87 #define 
	#PWR_STOPEntry_WFI
 ((
uint8_t
)0x01)

	)

88 #define 
	#PWR_STOPEntry_WFE
 ((
uint8_t
)0x02)

	)

89 #define 
	#IS_PWR_STOP_ENTRY
(
ENTRY
) (((ENTRY) == 
PWR_STOPEntry_WFI
) || ((ENTRY) == 
PWR_STOPEntry_WFE
))

	)

99 #define 
	#PWR_FLAG_WU
 
PWR_CSR_WUF


	)

100 #define 
	#PWR_FLAG_SB
 
PWR_CSR_SBF


	)

101 #define 
	#PWR_FLAG_PVDO
 
PWR_CSR_PVDO


	)

102 #define 
	#PWR_FLAG_BRR
 
PWR_CSR_BRR


	)

103 #define 
	#PWR_FLAG_REGRDY
 
PWR_CSR_REGRDY


	)

105 #define 
	#IS_PWR_GET_FLAG
(
FLAG
) (((FLAG) == 
PWR_FLAG_WU
) || ((FLAG) == 
PWR_FLAG_SB
) || \

	)

106 ((
FLAG
) == 
PWR_FLAG_PVDO
) || ((FLAG) == 
PWR_FLAG_BRR
) || \

107 ((
FLAG
) == 
PWR_FLAG_REGRDY
))

109 #define 
	#IS_PWR_CLEAR_FLAG
(
FLAG
) (((FLAG) == 
PWR_FLAG_WU
) || ((FLAG) == 
PWR_FLAG_SB
))

	)

122 void 
PWR_DeInit
(void);

125 void 
PWR_BackupAccessCmd
(
FunctionalState
 
NewState
);

128 void 
PWR_PVDLevelConfig
(
uint32_t
 
PWR_PVDLevel
);

129 void 
PWR_PVDCmd
(
FunctionalState
 
NewState
);

132 void 
PWR_WakeUpPinCmd
(
FunctionalState
 
NewState
);

135 void 
PWR_BackupRegulatorCmd
(
FunctionalState
 
NewState
);

138 void 
PWR_HighPerformanceModeCmd
(
FunctionalState
 
NewState
);

139 void 
PWR_FlashPowerDownCmd
(
FunctionalState
 
NewState
);

142 void 
PWR_EnterSTOPMode
(
uint32_t
 
PWR_Regulator
, 
uint8_t
 
PWR_STOPEntry
);

143 void 
PWR_EnterSTANDBYMode
(void);

146 
FlagStatus
 
PWR_GetFlagStatus
(
uint32_t
 
PWR_FLAG
);

147 void 
PWR_ClearFlag
(
uint32_t
 
PWR_FLAG
);

149 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h

23 #ifndef 
__STM32F4xx_RCC_H


24 #define 
	#__STM32F4xx_RCC_H


	)

26 #ifdef 
__cplusplus


31 #include 
	~"stm32f4xx.h
"

44 
uint32_t
 
SYSCLK_Frequency
;

45 
uint32_t
 
HCLK_Frequency
;

46 
uint32_t
 
PCLK1_Frequency
;

47 
uint32_t
 
PCLK2_Frequency
;

48 }
	tRCC_ClocksTypeDef
;

59 #define 
	#RCC_HSE_OFF
 ((
uint8_t
)0x00)

	)

60 #define 
	#RCC_HSE_ON
 ((
uint8_t
)0x01)

	)

61 #define 
	#RCC_HSE_Bypass
 ((
uint8_t
)0x05)

	)

62 #define 
	#IS_RCC_HSE
(
HSE
) (((HSE) == 
RCC_HSE_OFF
) || ((HSE) == 
RCC_HSE_ON
) || \

	)

63 ((
HSE
) == 
RCC_HSE_Bypass
))

71 #define 
	#RCC_PLLSource_HSI
 ((
uint32_t
)0x00000000)

	)

72 #define 
	#RCC_PLLSource_HSE
 ((
uint32_t
)0x00400000)

	)

73 #define 
	#IS_RCC_PLL_SOURCE
(
SOURCE
) (((SOURCE) == 
RCC_PLLSource_HSI
) || \

	)

74 ((
SOURCE
) == 
RCC_PLLSource_HSE
))

75 #define 
	#IS_RCC_PLLM_VALUE
(
VALUE
) ((VALUE) <= 63)

	)

76 #define 
	#IS_RCC_PLLN_VALUE
(
VALUE
) ((192 <= (VALUE)) && ((VALUE) <= 432))

	)

77 #define 
	#IS_RCC_PLLP_VALUE
(
VALUE
) (((VALUE) == 2) || ((VALUE) == 4) || ((VALUE) == 6) || ((VALUE) == 8))

	)

78 #define 
	#IS_RCC_PLLQ_VALUE
(
VALUE
) ((4 <= (VALUE)) && ((VALUE) <= 15))

	)

80 #define 
	#IS_RCC_PLLI2SN_VALUE
(
VALUE
) ((192 <= (VALUE)) && ((VALUE) <= 432))

	)

81 #define 
	#IS_RCC_PLLI2SR_VALUE
(
VALUE
) ((2 <= (VALUE)) && ((VALUE) <= 7))

	)

89 #define 
	#RCC_SYSCLKSource_HSI
 ((
uint32_t
)0x00000000)

	)

90 #define 
	#RCC_SYSCLKSource_HSE
 ((
uint32_t
)0x00000001)

	)

91 #define 
	#RCC_SYSCLKSource_PLLCLK
 ((
uint32_t
)0x00000002)

	)

92 #define 
	#IS_RCC_SYSCLK_SOURCE
(
SOURCE
) (((SOURCE) == 
RCC_SYSCLKSource_HSI
) || \

	)

93 ((
SOURCE
) == 
RCC_SYSCLKSource_HSE
) || \

94 ((
SOURCE
) == 
RCC_SYSCLKSource_PLLCLK
))

102 #define 
	#RCC_SYSCLK_Div1
 ((
uint32_t
)0x00000000)

	)

103 #define 
	#RCC_SYSCLK_Div2
 ((
uint32_t
)0x00000080)

	)

104 #define 
	#RCC_SYSCLK_Div4
 ((
uint32_t
)0x00000090)

	)

105 #define 
	#RCC_SYSCLK_Div8
 ((
uint32_t
)0x000000A0)

	)

106 #define 
	#RCC_SYSCLK_Div16
 ((
uint32_t
)0x000000B0)

	)

107 #define 
	#RCC_SYSCLK_Div64
 ((
uint32_t
)0x000000C0)

	)

108 #define 
	#RCC_SYSCLK_Div128
 ((
uint32_t
)0x000000D0)

	)

109 #define 
	#RCC_SYSCLK_Div256
 ((
uint32_t
)0x000000E0)

	)

110 #define 
	#RCC_SYSCLK_Div512
 ((
uint32_t
)0x000000F0)

	)

111 #define 
	#IS_RCC_HCLK
(
HCLK
) (((HCLK) == 
RCC_SYSCLK_Div1
) || ((HCLK) == 
RCC_SYSCLK_Div2
) || \

	)

112 ((
HCLK
) == 
RCC_SYSCLK_Div4
) || ((HCLK) == 
RCC_SYSCLK_Div8
) || \

113 ((
HCLK
) == 
RCC_SYSCLK_Div16
) || ((HCLK) == 
RCC_SYSCLK_Div64
) || \

114 ((
HCLK
) == 
RCC_SYSCLK_Div128
) || ((HCLK) == 
RCC_SYSCLK_Div256
) || \

115 ((
HCLK
) == 
RCC_SYSCLK_Div512
))

123 #define 
	#RCC_HCLK_Div1
 ((
uint32_t
)0x00000000)

	)

124 #define 
	#RCC_HCLK_Div2
 ((
uint32_t
)0x00001000)

	)

125 #define 
	#RCC_HCLK_Div4
 ((
uint32_t
)0x00001400)

	)

126 #define 
	#RCC_HCLK_Div8
 ((
uint32_t
)0x00001800)

	)

127 #define 
	#RCC_HCLK_Div16
 ((
uint32_t
)0x00001C00)

	)

128 #define 
	#IS_RCC_PCLK
(
PCLK
) (((PCLK) == 
RCC_HCLK_Div1
) || ((PCLK) == 
RCC_HCLK_Div2
) || \

	)

129 ((
PCLK
) == 
RCC_HCLK_Div4
) || ((PCLK) == 
RCC_HCLK_Div8
) || \

130 ((
PCLK
) == 
RCC_HCLK_Div16
))

138 #define 
	#RCC_IT_LSIRDY
 ((
uint8_t
)0x01)

	)

139 #define 
	#RCC_IT_LSERDY
 ((
uint8_t
)0x02)

	)

140 #define 
	#RCC_IT_HSIRDY
 ((
uint8_t
)0x04)

	)

141 #define 
	#RCC_IT_HSERDY
 ((
uint8_t
)0x08)

	)

142 #define 
	#RCC_IT_PLLRDY
 ((
uint8_t
)0x10)

	)

143 #define 
	#RCC_IT_PLLI2SRDY
 ((
uint8_t
)0x20)

	)

144 #define 
	#RCC_IT_CSS
 ((
uint8_t
)0x80)

	)

145 #define 
	#IS_RCC_IT
(
IT
) ((((IT) & (
uint8_t
)0xC0) == 0x00) && ((IT) != 0x00))

	)

146 #define 
	#IS_RCC_GET_IT
(
IT
) (((IT) == 
RCC_IT_LSIRDY
) || ((IT) == 
RCC_IT_LSERDY
) || \

	)

147 ((
IT
) == 
RCC_IT_HSIRDY
) || ((IT) == 
RCC_IT_HSERDY
) || \

148 ((
IT
) == 
RCC_IT_PLLRDY
) || ((IT) == 
RCC_IT_CSS
) || \

149 ((
IT
) == 
RCC_IT_PLLI2SRDY
))

150 #define 
	#IS_RCC_CLEAR_IT
(
IT
) ((((IT) & (
uint8_t
)0x40) == 0x00) && ((IT) != 0x00))

	)

158 #define 
	#RCC_LSE_OFF
 ((
uint8_t
)0x00)

	)

159 #define 
	#RCC_LSE_ON
 ((
uint8_t
)0x01)

	)

160 #define 
	#RCC_LSE_Bypass
 ((
uint8_t
)0x04)

	)

161 #define 
	#IS_RCC_LSE
(
LSE
) (((LSE) == 
RCC_LSE_OFF
) || ((LSE) == 
RCC_LSE_ON
) || \

	)

162 ((
LSE
) == 
RCC_LSE_Bypass
))

170 #define 
	#RCC_RTCCLKSource_LSE
 ((
uint32_t
)0x00000100)

	)

171 #define 
	#RCC_RTCCLKSource_LSI
 ((
uint32_t
)0x00000200)

	)

172 #define 
	#RCC_RTCCLKSource_HSE_Div2
 ((
uint32_t
)0x00020300)

	)

173 #define 
	#RCC_RTCCLKSource_HSE_Div3
 ((
uint32_t
)0x00030300)

	)

174 #define 
	#RCC_RTCCLKSource_HSE_Div4
 ((
uint32_t
)0x00040300)

	)

175 #define 
	#RCC_RTCCLKSource_HSE_Div5
 ((
uint32_t
)0x00050300)

	)

176 #define 
	#RCC_RTCCLKSource_HSE_Div6
 ((
uint32_t
)0x00060300)

	)

177 #define 
	#RCC_RTCCLKSource_HSE_Div7
 ((
uint32_t
)0x00070300)

	)

178 #define 
	#RCC_RTCCLKSource_HSE_Div8
 ((
uint32_t
)0x00080300)

	)

179 #define 
	#RCC_RTCCLKSource_HSE_Div9
 ((
uint32_t
)0x00090300)

	)

180 #define 
	#RCC_RTCCLKSource_HSE_Div10
 ((
uint32_t
)0x000A0300)

	)

181 #define 
	#RCC_RTCCLKSource_HSE_Div11
 ((
uint32_t
)0x000B0300)

	)

182 #define 
	#RCC_RTCCLKSource_HSE_Div12
 ((
uint32_t
)0x000C0300)

	)

183 #define 
	#RCC_RTCCLKSource_HSE_Div13
 ((
uint32_t
)0x000D0300)

	)

184 #define 
	#RCC_RTCCLKSource_HSE_Div14
 ((
uint32_t
)0x000E0300)

	)

185 #define 
	#RCC_RTCCLKSource_HSE_Div15
 ((
uint32_t
)0x000F0300)

	)

186 #define 
	#RCC_RTCCLKSource_HSE_Div16
 ((
uint32_t
)0x00100300)

	)

187 #define 
	#RCC_RTCCLKSource_HSE_Div17
 ((
uint32_t
)0x00110300)

	)

188 #define 
	#RCC_RTCCLKSource_HSE_Div18
 ((
uint32_t
)0x00120300)

	)

189 #define 
	#RCC_RTCCLKSource_HSE_Div19
 ((
uint32_t
)0x00130300)

	)

190 #define 
	#RCC_RTCCLKSource_HSE_Div20
 ((
uint32_t
)0x00140300)

	)

191 #define 
	#RCC_RTCCLKSource_HSE_Div21
 ((
uint32_t
)0x00150300)

	)

192 #define 
	#RCC_RTCCLKSource_HSE_Div22
 ((
uint32_t
)0x00160300)

	)

193 #define 
	#RCC_RTCCLKSource_HSE_Div23
 ((
uint32_t
)0x00170300)

	)

194 #define 
	#RCC_RTCCLKSource_HSE_Div24
 ((
uint32_t
)0x00180300)

	)

195 #define 
	#RCC_RTCCLKSource_HSE_Div25
 ((
uint32_t
)0x00190300)

	)

196 #define 
	#RCC_RTCCLKSource_HSE_Div26
 ((
uint32_t
)0x001A0300)

	)

197 #define 
	#RCC_RTCCLKSource_HSE_Div27
 ((
uint32_t
)0x001B0300)

	)

198 #define 
	#RCC_RTCCLKSource_HSE_Div28
 ((
uint32_t
)0x001C0300)

	)

199 #define 
	#RCC_RTCCLKSource_HSE_Div29
 ((
uint32_t
)0x001D0300)

	)

200 #define 
	#RCC_RTCCLKSource_HSE_Div30
 ((
uint32_t
)0x001E0300)

	)

201 #define 
	#RCC_RTCCLKSource_HSE_Div31
 ((
uint32_t
)0x001F0300)

	)

202 #define 
	#IS_RCC_RTCCLK_SOURCE
(
SOURCE
) (((SOURCE) == 
RCC_RTCCLKSource_LSE
) || \

	)

203 ((
SOURCE
) == 
RCC_RTCCLKSource_LSI
) || \

204 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div2
) || \

205 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div3
) || \

206 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div4
) || \

207 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div5
) || \

208 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div6
) || \

209 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div7
) || \

210 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div8
) || \

211 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div9
) || \

212 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div10
) || \

213 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div11
) || \

214 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div12
) || \

215 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div13
) || \

216 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div14
) || \

217 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div15
) || \

218 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div16
) || \

219 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div17
) || \

220 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div18
) || \

221 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div19
) || \

222 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div20
) || \

223 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div21
) || \

224 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div22
) || \

225 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div23
) || \

226 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div24
) || \

227 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div25
) || \

228 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div26
) || \

229 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div27
) || \

230 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div28
) || \

231 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div29
) || \

232 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div30
) || \

233 ((
SOURCE
) == 
RCC_RTCCLKSource_HSE_Div31
))

241 #define 
	#RCC_I2S2CLKSource_PLLI2S
 ((
uint8_t
)0x00)

	)

242 #define 
	#RCC_I2S2CLKSource_Ext
 ((
uint8_t
)0x01)

	)

244 #define 
	#IS_RCC_I2SCLK_SOURCE
(
SOURCE
) (((SOURCE) == 
RCC_I2S2CLKSource_PLLI2S
) || ((SOURCE) == 
RCC_I2S2CLKSource_Ext
))

	)

252 #define 
	#RCC_AHB1Periph_GPIOA
 ((
uint32_t
)0x00000001)

	)

253 #define 
	#RCC_AHB1Periph_GPIOB
 ((
uint32_t
)0x00000002)

	)

254 #define 
	#RCC_AHB1Periph_GPIOC
 ((
uint32_t
)0x00000004)

	)

255 #define 
	#RCC_AHB1Periph_GPIOD
 ((
uint32_t
)0x00000008)

	)

256 #define 
	#RCC_AHB1Periph_GPIOE
 ((
uint32_t
)0x00000010)

	)

257 #define 
	#RCC_AHB1Periph_GPIOF
 ((
uint32_t
)0x00000020)

	)

258 #define 
	#RCC_AHB1Periph_GPIOG
 ((
uint32_t
)0x00000040)

	)

259 #define 
	#RCC_AHB1Periph_GPIOH
 ((
uint32_t
)0x00000080)

	)

260 #define 
	#RCC_AHB1Periph_GPIOI
 ((
uint32_t
)0x00000100)

	)

261 #define 
	#RCC_AHB1Periph_CRC
 ((
uint32_t
)0x00001000)

	)

262 #define 
	#RCC_AHB1Periph_FLITF
 ((
uint32_t
)0x00008000)

	)

263 #define 
	#RCC_AHB1Periph_SRAM1
 ((
uint32_t
)0x00010000)

	)

264 #define 
	#RCC_AHB1Periph_SRAM2
 ((
uint32_t
)0x00020000)

	)

265 #define 
	#RCC_AHB1Periph_BKPSRAM
 ((
uint32_t
)0x00040000)

	)

266 #define 
	#RCC_AHB1Periph_DMA1
 ((
uint32_t
)0x00200000)

	)

267 #define 
	#RCC_AHB1Periph_DMA2
 ((
uint32_t
)0x00400000)

	)

268 #define 
	#RCC_AHB1Periph_ETH_MAC
 ((
uint32_t
)0x02000000)

	)

269 #define 
	#RCC_AHB1Periph_ETH_MAC_Tx
 ((
uint32_t
)0x04000000)

	)

270 #define 
	#RCC_AHB1Periph_ETH_MAC_Rx
 ((
uint32_t
)0x08000000)

	)

271 #define 
	#RCC_AHB1Periph_ETH_MAC_PTP
 ((
uint32_t
)0x10000000)

	)

272 #define 
	#RCC_AHB1Periph_OTG_HS
 ((
uint32_t
)0x20000000)

	)

273 #define 
	#RCC_AHB1Periph_OTG_HS_ULPI
 ((
uint32_t
)0x40000000)

	)

274 #define 
	#IS_RCC_AHB1_CLOCK_PERIPH
(
PERIPH
) ((((PERIPH) & 0x819BEE00) == 0x00) && ((PERIPH) != 0x00))

	)

275 #define 
	#IS_RCC_AHB1_RESET_PERIPH
(
PERIPH
) ((((PERIPH) & 0xDD9FEE00) == 0x00) && ((PERIPH) != 0x00))

	)

276 #define 
	#IS_RCC_AHB1_LPMODE_PERIPH
(
PERIPH
) ((((PERIPH) & 0x81986E00) == 0x00) && ((PERIPH) != 0x00))

	)

284 #define 
	#RCC_AHB2Periph_DCMI
 ((
uint32_t
)0x00000001)

	)

285 #define 
	#RCC_AHB2Periph_CRYP
 ((
uint32_t
)0x00000010)

	)

286 #define 
	#RCC_AHB2Periph_HASH
 ((
uint32_t
)0x00000020)

	)

287 #define 
	#RCC_AHB2Periph_RNG
 ((
uint32_t
)0x00000040)

	)

288 #define 
	#RCC_AHB2Periph_OTG_FS
 ((
uint32_t
)0x00000080)

	)

289 #define 
	#IS_RCC_AHB2_PERIPH
(
PERIPH
) ((((PERIPH) & 0xFFFFFF0E) == 0x00) && ((PERIPH) != 0x00))

	)

297 #define 
	#RCC_AHB3Periph_FSMC
 ((
uint32_t
)0x00000001)

	)

298 #define 
	#IS_RCC_AHB3_PERIPH
(
PERIPH
) ((((PERIPH) & 0xFFFFFFFE) == 0x00) && ((PERIPH) != 0x00))

	)

306 #define 
	#RCC_APB1Periph_TIM2
 ((
uint32_t
)0x00000001)

	)

307 #define 
	#RCC_APB1Periph_TIM3
 ((
uint32_t
)0x00000002)

	)

308 #define 
	#RCC_APB1Periph_TIM4
 ((
uint32_t
)0x00000004)

	)

309 #define 
	#RCC_APB1Periph_TIM5
 ((
uint32_t
)0x00000008)

	)

310 #define 
	#RCC_APB1Periph_TIM6
 ((
uint32_t
)0x00000010)

	)

311 #define 
	#RCC_APB1Periph_TIM7
 ((
uint32_t
)0x00000020)

	)

312 #define 
	#RCC_APB1Periph_TIM12
 ((
uint32_t
)0x00000040)

	)

313 #define 
	#RCC_APB1Periph_TIM13
 ((
uint32_t
)0x00000080)

	)

314 #define 
	#RCC_APB1Periph_TIM14
 ((
uint32_t
)0x00000100)

	)

315 #define 
	#RCC_APB1Periph_WWDG
 ((
uint32_t
)0x00000800)

	)

316 #define 
	#RCC_APB1Periph_SPI2
 ((
uint32_t
)0x00004000)

	)

317 #define 
	#RCC_APB1Periph_SPI3
 ((
uint32_t
)0x00008000)

	)

318 #define 
	#RCC_APB1Periph_USART2
 ((
uint32_t
)0x00020000)

	)

319 #define 
	#RCC_APB1Periph_USART3
 ((
uint32_t
)0x00040000)

	)

320 #define 
	#RCC_APB1Periph_UART4
 ((
uint32_t
)0x00080000)

	)

321 #define 
	#RCC_APB1Periph_UART5
 ((
uint32_t
)0x00100000)

	)

322 #define 
	#RCC_APB1Periph_I2C1
 ((
uint32_t
)0x00200000)

	)

323 #define 
	#RCC_APB1Periph_I2C2
 ((
uint32_t
)0x00400000)

	)

324 #define 
	#RCC_APB1Periph_I2C3
 ((
uint32_t
)0x00800000)

	)

325 #define 
	#RCC_APB1Periph_CAN1
 ((
uint32_t
)0x02000000)

	)

326 #define 
	#RCC_APB1Periph_CAN2
 ((
uint32_t
)0x04000000)

	)

327 #define 
	#RCC_APB1Periph_PWR
 ((
uint32_t
)0x10000000)

	)

328 #define 
	#RCC_APB1Periph_DAC
 ((
uint32_t
)0x20000000)

	)

329 #define 
	#IS_RCC_APB1_PERIPH
(
PERIPH
) ((((PERIPH) & 0xC9013600) == 0x00) && ((PERIPH) != 0x00))

	)

337 #define 
	#RCC_APB2Periph_TIM1
 ((
uint32_t
)0x00000001)

	)

338 #define 
	#RCC_APB2Periph_TIM8
 ((
uint32_t
)0x00000002)

	)

339 #define 
	#RCC_APB2Periph_USART1
 ((
uint32_t
)0x00000010)

	)

340 #define 
	#RCC_APB2Periph_USART6
 ((
uint32_t
)0x00000020)

	)

341 #define 
	#RCC_APB2Periph_ADC
 ((
uint32_t
)0x00000100)

	)

342 #define 
	#RCC_APB2Periph_ADC1
 ((
uint32_t
)0x00000100)

	)

343 #define 
	#RCC_APB2Periph_ADC2
 ((
uint32_t
)0x00000200)

	)

344 #define 
	#RCC_APB2Periph_ADC3
 ((
uint32_t
)0x00000400)

	)

345 #define 
	#RCC_APB2Periph_SDIO
 ((
uint32_t
)0x00000800)

	)

346 #define 
	#RCC_APB2Periph_SPI1
 ((
uint32_t
)0x00001000)

	)

347 #define 
	#RCC_APB2Periph_SYSCFG
 ((
uint32_t
)0x00004000)

	)

348 #define 
	#RCC_APB2Periph_TIM9
 ((
uint32_t
)0x00010000)

	)

349 #define 
	#RCC_APB2Periph_TIM10
 ((
uint32_t
)0x00020000)

	)

350 #define 
	#RCC_APB2Periph_TIM11
 ((
uint32_t
)0x00040000)

	)

351 #define 
	#IS_RCC_APB2_PERIPH
(
PERIPH
) ((((PERIPH) & 0xFFF8A0CC) == 0x00) && ((PERIPH) != 0x00))

	)

352 #define 
	#IS_RCC_APB2_RESET_PERIPH
(
PERIPH
) ((((PERIPH) & 0xFFF8A6CC) == 0x00) && ((PERIPH) != 0x00))

	)

360 #define 
	#RCC_MCO1Source_HSI
 ((
uint32_t
)0x00000000)

	)

361 #define 
	#RCC_MCO1Source_LSE
 ((
uint32_t
)0x00200000)

	)

362 #define 
	#RCC_MCO1Source_HSE
 ((
uint32_t
)0x00400000)

	)

363 #define 
	#RCC_MCO1Source_PLLCLK
 ((
uint32_t
)0x00600000)

	)

364 #define 
	#RCC_MCO1Div_1
 ((
uint32_t
)0x00000000)

	)

365 #define 
	#RCC_MCO1Div_2
 ((
uint32_t
)0x04000000)

	)

366 #define 
	#RCC_MCO1Div_3
 ((
uint32_t
)0x05000000)

	)

367 #define 
	#RCC_MCO1Div_4
 ((
uint32_t
)0x06000000)

	)

368 #define 
	#RCC_MCO1Div_5
 ((
uint32_t
)0x07000000)

	)

369 #define 
	#IS_RCC_MCO1SOURCE
(
SOURCE
) (((SOURCE) == 
RCC_MCO1Source_HSI
) || ((SOURCE) == 
RCC_MCO1Source_LSE
) || \

	)

370 ((
SOURCE
) == 
RCC_MCO1Source_HSE
) || ((SOURCE) == 
RCC_MCO1Source_PLLCLK
))

372 #define 
	#IS_RCC_MCO1DIV
(
DIV
) (((DIV) == 
RCC_MCO1Div_1
) || ((DIV) == 
RCC_MCO1Div_2
) || \

	)

373 ((
DIV
) == 
RCC_MCO1Div_3
) || ((DIV) == 
RCC_MCO1Div_4
) || \

374 ((
DIV
) == 
RCC_MCO1Div_5
))

382 #define 
	#RCC_MCO2Source_SYSCLK
 ((
uint32_t
)0x00000000)

	)

383 #define 
	#RCC_MCO2Source_PLLI2SCLK
 ((
uint32_t
)0x40000000)

	)

384 #define 
	#RCC_MCO2Source_HSE
 ((
uint32_t
)0x80000000)

	)

385 #define 
	#RCC_MCO2Source_PLLCLK
 ((
uint32_t
)0xC0000000)

	)

386 #define 
	#RCC_MCO2Div_1
 ((
uint32_t
)0x00000000)

	)

387 #define 
	#RCC_MCO2Div_2
 ((
uint32_t
)0x20000000)

	)

388 #define 
	#RCC_MCO2Div_3
 ((
uint32_t
)0x28000000)

	)

389 #define 
	#RCC_MCO2Div_4
 ((
uint32_t
)0x30000000)

	)

390 #define 
	#RCC_MCO2Div_5
 ((
uint32_t
)0x38000000)

	)

391 #define 
	#IS_RCC_MCO2SOURCE
(
SOURCE
) (((SOURCE) == 
RCC_MCO2Source_SYSCLK
) || ((SOURCE) == 
RCC_MCO2Source_PLLI2SCLK
)|| \

	)

392 ((
SOURCE
) == 
RCC_MCO2Source_HSE
) || ((SOURCE) == 
RCC_MCO2Source_PLLCLK
))

394 #define 
	#IS_RCC_MCO2DIV
(
DIV
) (((DIV) == 
RCC_MCO2Div_1
) || ((DIV) == 
RCC_MCO2Div_2
) || \

	)

395 ((
DIV
) == 
RCC_MCO2Div_3
) || ((DIV) == 
RCC_MCO2Div_4
) || \

396 ((
DIV
) == 
RCC_MCO2Div_5
))

404 #define 
	#RCC_FLAG_HSIRDY
 ((
uint8_t
)0x21)

	)

405 #define 
	#RCC_FLAG_HSERDY
 ((
uint8_t
)0x31)

	)

406 #define 
	#RCC_FLAG_PLLRDY
 ((
uint8_t
)0x39)

	)

407 #define 
	#RCC_FLAG_PLLI2SRDY
 ((
uint8_t
)0x3B)

	)

408 #define 
	#RCC_FLAG_LSERDY
 ((
uint8_t
)0x41)

	)

409 #define 
	#RCC_FLAG_LSIRDY
 ((
uint8_t
)0x61)

	)

410 #define 
	#RCC_FLAG_BORRST
 ((
uint8_t
)0x79)

	)

411 #define 
	#RCC_FLAG_PINRST
 ((
uint8_t
)0x7A)

	)

412 #define 
	#RCC_FLAG_PORRST
 ((
uint8_t
)0x7B)

	)

413 #define 
	#RCC_FLAG_SFTRST
 ((
uint8_t
)0x7C)

	)

414 #define 
	#RCC_FLAG_IWDGRST
 ((
uint8_t
)0x7D)

	)

415 #define 
	#RCC_FLAG_WWDGRST
 ((
uint8_t
)0x7E)

	)

416 #define 
	#RCC_FLAG_LPWRRST
 ((
uint8_t
)0x7F)

	)

417 #define 
	#IS_RCC_FLAG
(
FLAG
) (((FLAG) == 
RCC_FLAG_HSIRDY
) || ((FLAG) == 
RCC_FLAG_HSERDY
) || \

	)

418 ((
FLAG
) == 
RCC_FLAG_PLLRDY
) || ((FLAG) == 
RCC_FLAG_LSERDY
) || \

419 ((
FLAG
) == 
RCC_FLAG_LSIRDY
) || ((FLAG) == 
RCC_FLAG_BORRST
) || \

420 ((
FLAG
) == 
RCC_FLAG_PINRST
) || ((FLAG) == 
RCC_FLAG_PORRST
) || \

421 ((
FLAG
) == 
RCC_FLAG_SFTRST
) || ((FLAG) == 
RCC_FLAG_IWDGRST
)|| \

422 ((
FLAG
) == 
RCC_FLAG_WWDGRST
)|| ((FLAG) == 
RCC_FLAG_LPWRRST
)|| \

423 ((
FLAG
) == 
RCC_FLAG_PLLI2SRDY
))

424 #define 
	#IS_RCC_CALIBRATION_VALUE
(
VALUE
) ((VALUE) <= 0x1F)

	)

437 void 
RCC_DeInit
(void);

440 void 
RCC_HSEConfig
(
uint8_t
 
RCC_HSE
);

441 
ErrorStatus
 
RCC_WaitForHSEStartUp
(void);

442 void 
RCC_AdjustHSICalibrationValue
(
uint8_t
 
HSICalibrationValue
);

443 void 
RCC_HSICmd
(
FunctionalState
 
NewState
);

444 void 
RCC_LSEConfig
(
uint8_t
 
RCC_LSE
);

445 void 
RCC_LSICmd
(
FunctionalState
 
NewState
);

447 void 
RCC_PLLConfig
(
uint32_t
 
RCC_PLLSource
, uint32_t 
PLLM
, uint32_t 
PLLN
, uint32_t 
PLLP
, uint32_t 
PLLQ
);

448 void 
RCC_PLLCmd
(
FunctionalState
 
NewState
);

449 void 
RCC_PLLI2SConfig
(
uint32_t
 
PLLI2SN
, uint32_t 
PLLI2SR
);

450 void 
RCC_PLLI2SCmd
(
FunctionalState
 
NewState
);

452 void 
RCC_ClockSecuritySystemCmd
(
FunctionalState
 
NewState
);

453 void 
RCC_MCO1Config
(
uint32_t
 
RCC_MCO1Source
, uint32_t 
RCC_MCO1Div
);

454 void 
RCC_MCO2Config
(
uint32_t
 
RCC_MCO2Source
, uint32_t 
RCC_MCO2Div
);

457 void 
RCC_SYSCLKConfig
(
uint32_t
 
RCC_SYSCLKSource
);

458 
uint8_t
 
RCC_GetSYSCLKSource
(void);

459 void 
RCC_HCLKConfig
(
uint32_t
 
RCC_SYSCLK
);

460 void 
RCC_PCLK1Config
(
uint32_t
 
RCC_HCLK
);

461 void 
RCC_PCLK2Config
(
uint32_t
 
RCC_HCLK
);

462 void 
RCC_GetClocksFreq
(
RCC_ClocksTypeDef
* 
RCC_Clocks
);

465 void 
RCC_RTCCLKConfig
(
uint32_t
 
RCC_RTCCLKSource
);

466 void 
RCC_RTCCLKCmd
(
FunctionalState
 
NewState
);

467 void 
RCC_BackupResetCmd
(
FunctionalState
 
NewState
);

468 void 
RCC_I2SCLKConfig
(
uint32_t
 
RCC_I2SCLKSource
);

470 void 
RCC_AHB1PeriphClockCmd
(
uint32_t
 
RCC_AHB1Periph
, 
FunctionalState
 
NewState
);

471 void 
RCC_AHB2PeriphClockCmd
(
uint32_t
 
RCC_AHB2Periph
, 
FunctionalState
 
NewState
);

472 void 
RCC_AHB3PeriphClockCmd
(
uint32_t
 
RCC_AHB3Periph
, 
FunctionalState
 
NewState
);

473 void 
RCC_APB1PeriphClockCmd
(
uint32_t
 
RCC_APB1Periph
, 
FunctionalState
 
NewState
);

474 void 
RCC_APB2PeriphClockCmd
(
uint32_t
 
RCC_APB2Periph
, 
FunctionalState
 
NewState
);

476 void 
RCC_AHB1PeriphResetCmd
(
uint32_t
 
RCC_AHB1Periph
, 
FunctionalState
 
NewState
);

477 void 
RCC_AHB2PeriphResetCmd
(
uint32_t
 
RCC_AHB2Periph
, 
FunctionalState
 
NewState
);

478 void 
RCC_AHB3PeriphResetCmd
(
uint32_t
 
RCC_AHB3Periph
, 
FunctionalState
 
NewState
);

479 void 
RCC_APB1PeriphResetCmd
(
uint32_t
 
RCC_APB1Periph
, 
FunctionalState
 
NewState
);

480 void 
RCC_APB2PeriphResetCmd
(
uint32_t
 
RCC_APB2Periph
, 
FunctionalState
 
NewState
);

482 void 
RCC_AHB1PeriphClockLPModeCmd
(
uint32_t
 
RCC_AHB1Periph
, 
FunctionalState
 
NewState
);

483 void 
RCC_AHB2PeriphClockLPModeCmd
(
uint32_t
 
RCC_AHB2Periph
, 
FunctionalState
 
NewState
);

484 void 
RCC_AHB3PeriphClockLPModeCmd
(
uint32_t
 
RCC_AHB3Periph
, 
FunctionalState
 
NewState
);

485 void 
RCC_APB1PeriphClockLPModeCmd
(
uint32_t
 
RCC_APB1Periph
, 
FunctionalState
 
NewState
);

486 void 
RCC_APB2PeriphClockLPModeCmd
(
uint32_t
 
RCC_APB2Periph
, 
FunctionalState
 
NewState
);

489 void 
RCC_ITConfig
(
uint8_t
 
RCC_IT
, 
FunctionalState
 
NewState
);

490 
FlagStatus
 
RCC_GetFlagStatus
(
uint8_t
 
RCC_FLAG
);

491 void 
RCC_ClearFlag
(void);

492 
ITStatus
 
RCC_GetITStatus
(
uint8_t
 
RCC_IT
);

493 void 
RCC_ClearITPendingBit
(
uint8_t
 
RCC_IT
);

495 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rng.h

24 #ifndef 
__STM32F4xx_RNG_H


25 #define 
	#__STM32F4xx_RNG_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

52 #define 
	#RNG_FLAG_DRDY
 ((
uint8_t
)0x0001)

	)

53 #define 
	#RNG_FLAG_CECS
 ((
uint8_t
)0x0002)

	)

54 #define 
	#RNG_FLAG_SECS
 ((
uint8_t
)0x0004)

	)

56 #define 
	#IS_RNG_GET_FLAG
(
RNG_FLAG
) (((RNG_FLAG) == 
RNG_FLAG_DRDY
) || \

	)

57 ((
RNG_FLAG
) == 
RNG_FLAG_CECS
) || \

58 ((
RNG_FLAG
) == 
RNG_FLAG_SECS
))

59 #define 
	#IS_RNG_CLEAR_FLAG
(
RNG_FLAG
) (((RNG_FLAG) == 
RNG_FLAG_CECS
) || \

	)

60 ((
RNG_FLAG
) == 
RNG_FLAG_SECS
))

68 #define 
	#RNG_IT_CEI
 ((
uint8_t
)0x20)

	)

69 #define 
	#RNG_IT_SEI
 ((
uint8_t
)0x40)

	)

71 #define 
	#IS_RNG_IT
(
IT
) ((((IT) & (
uint8_t
)0x9F) == 0x00) && ((IT) != 0x00))

	)

72 #define 
	#IS_RNG_GET_IT
(
RNG_IT
) (((RNG_IT) == 
RNG_IT_CEI
) || ((RNG_IT) == 
RNG_IT_SEI
))

	)

85 void 
RNG_DeInit
(void);

88 void 
RNG_Cmd
(
FunctionalState
 
NewState
);

91 
uint32_t
 
RNG_GetRandomNumber
(void);

94 void 
RNG_ITConfig
(
FunctionalState
 
NewState
);

95 
FlagStatus
 
RNG_GetFlagStatus
(
uint8_t
 
RNG_FLAG
);

96 void 
RNG_ClearFlag
(
uint8_t
 
RNG_FLAG
);

97 
ITStatus
 
RNG_GetITStatus
(
uint8_t
 
RNG_IT
);

98 void 
RNG_ClearITPendingBit
(
uint8_t
 
RNG_IT
);

100 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rtc.h

24 #ifndef 
__STM32F4xx_RTC_H


25 #define 
	#__STM32F4xx_RTC_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

49 
uint32_t
 
RTC_HourFormat
;

52 
uint32_t
 
RTC_AsynchPrediv
;

55 
uint32_t
 
RTC_SynchPrediv
;

57 }
	tRTC_InitTypeDef
;

64 
uint8_t
 
RTC_Hours
;

69 
uint8_t
 
RTC_Minutes
;

72 
uint8_t
 
RTC_Seconds
;

75 
uint8_t
 
RTC_H12
;

77 }
	tRTC_TimeTypeDef
;

84 
uint8_t
 
RTC_WeekDay
;

87 
uint8_t
 
RTC_Month
;

90 
uint8_t
 
RTC_Date
;

93 
uint8_t
 
RTC_Year
;

95 }
	tRTC_DateTypeDef
;

102 
RTC_TimeTypeDef
 
RTC_AlarmTime
;

104 
uint32_t
 
RTC_AlarmMask
;

107 
uint32_t
 
RTC_AlarmDateWeekDaySel
;

110 
uint8_t
 
RTC_AlarmDateWeekDay
;

115 }
	tRTC_AlarmTypeDef
;

127 #define 
	#RTC_HourFormat_24
 ((
uint32_t
)0x00000000)

	)

128 #define 
	#RTC_HourFormat_12
 ((
uint32_t
)0x00000040)

	)

129 #define 
	#IS_RTC_HOUR_FORMAT
(
FORMAT
) (((FORMAT) == 
RTC_HourFormat_12
) || \

	)

130 ((
FORMAT
) == 
RTC_HourFormat_24
))

138 #define 
	#IS_RTC_ASYNCH_PREDIV
(
PREDIV
) ((PREDIV) <= 0x7F)

	)

148 #define 
	#IS_RTC_SYNCH_PREDIV
(
PREDIV
) ((PREDIV) <= 0x7FFF)

	)

157 #define 
	#IS_RTC_HOUR12
(
HOUR
) (((HOUR) > 0) && ((HOUR) <= 12))

	)

158 #define 
	#IS_RTC_HOUR24
(
HOUR
) ((HOUR) <= 23)

	)

159 #define 
	#IS_RTC_MINUTES
(
MINUTES
) ((MINUTES) <= 59)

	)

160 #define 
	#IS_RTC_SECONDS
(
SECONDS
) ((SECONDS) <= 59)

	)

169 #define 
	#RTC_H12_AM
 ((
uint8_t
)0x00)

	)

170 #define 
	#RTC_H12_PM
 ((
uint8_t
)0x40)

	)

171 #define 
	#IS_RTC_H12
(
PM
) (((PM) == 
RTC_H12_AM
) || ((PM) == 
RTC_H12_PM
))

	)

180 #define 
	#IS_RTC_YEAR
(
YEAR
) ((YEAR) <= 99)

	)

191 #define 
	#RTC_Month_January
 ((
uint8_t
)0x01)

	)

192 #define 
	#RTC_Month_February
 ((
uint8_t
)0x02)

	)

193 #define 
	#RTC_Month_March
 ((
uint8_t
)0x03)

	)

194 #define 
	#RTC_Month_April
 ((
uint8_t
)0x04)

	)

195 #define 
	#RTC_Month_May
 ((
uint8_t
)0x05)

	)

196 #define 
	#RTC_Month_June
 ((
uint8_t
)0x06)

	)

197 #define 
	#RTC_Month_July
 ((
uint8_t
)0x07)

	)

198 #define 
	#RTC_Month_August
 ((
uint8_t
)0x08)

	)

199 #define 
	#RTC_Month_September
 ((
uint8_t
)0x09)

	)

200 #define 
	#RTC_Month_October
 ((
uint8_t
)0x10)

	)

201 #define 
	#RTC_Month_November
 ((
uint8_t
)0x11)

	)

202 #define 
	#RTC_Month_December
 ((
uint8_t
)0x12)

	)

203 #define 
	#IS_RTC_MONTH
(
MONTH
) (((MONTH) >= 1) && ((MONTH) <= 12))

	)

204 #define 
	#IS_RTC_DATE
(
DATE
) (((DATE) >= 1) && ((DATE) <= 31))

	)

214 #define 
	#RTC_Weekday_Monday
 ((
uint8_t
)0x01)

	)

215 #define 
	#RTC_Weekday_Tuesday
 ((
uint8_t
)0x02)

	)

216 #define 
	#RTC_Weekday_Wednesday
 ((
uint8_t
)0x03)

	)

217 #define 
	#RTC_Weekday_Thursday
 ((
uint8_t
)0x04)

	)

218 #define 
	#RTC_Weekday_Friday
 ((
uint8_t
)0x05)

	)

219 #define 
	#RTC_Weekday_Saturday
 ((
uint8_t
)0x06)

	)

220 #define 
	#RTC_Weekday_Sunday
 ((
uint8_t
)0x07)

	)

221 #define 
	#IS_RTC_WEEKDAY
(
WEEKDAY
) (((WEEKDAY) == 
RTC_Weekday_Monday
) || \

	)

222 ((
WEEKDAY
) == 
RTC_Weekday_Tuesday
) || \

223 ((
WEEKDAY
) == 
RTC_Weekday_Wednesday
) || \

224 ((
WEEKDAY
) == 
RTC_Weekday_Thursday
) || \

225 ((
WEEKDAY
) == 
RTC_Weekday_Friday
) || \

226 ((
WEEKDAY
) == 
RTC_Weekday_Saturday
) || \

227 ((
WEEKDAY
) == 
RTC_Weekday_Sunday
))

236 #define 
	#IS_RTC_ALARM_DATE_WEEKDAY_DATE
(
DATE
) (((DATE) > 0) && ((DATE) <= 31))

	)

237 #define 
	#IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY
(
WEEKDAY
) (((WEEKDAY) == 
RTC_Weekday_Monday
) || \

	)

238 ((
WEEKDAY
) == 
RTC_Weekday_Tuesday
) || \

239 ((
WEEKDAY
) == 
RTC_Weekday_Wednesday
) || \

240 ((
WEEKDAY
) == 
RTC_Weekday_Thursday
) || \

241 ((
WEEKDAY
) == 
RTC_Weekday_Friday
) || \

242 ((
WEEKDAY
) == 
RTC_Weekday_Saturday
) || \

243 ((
WEEKDAY
) == 
RTC_Weekday_Sunday
))

253 #define 
	#RTC_AlarmDateWeekDaySel_Date
 ((
uint32_t
)0x00000000)

	)

254 #define 
	#RTC_AlarmDateWeekDaySel_WeekDay
 ((
uint32_t
)0x40000000)

	)

256 #define 
	#IS_RTC_ALARM_DATE_WEEKDAY_SEL
(
SEL
) (((SEL) == 
RTC_AlarmDateWeekDaySel_Date
) || \

	)

257 ((
SEL
) == 
RTC_AlarmDateWeekDaySel_WeekDay
))

267 #define 
	#RTC_AlarmMask_None
 ((
uint32_t
)0x00000000)

	)

268 #define 
	#RTC_AlarmMask_DateWeekDay
 ((
uint32_t
)0x80000000)

	)

269 #define 
	#RTC_AlarmMask_Hours
 ((
uint32_t
)0x00800000)

	)

270 #define 
	#RTC_AlarmMask_Minutes
 ((
uint32_t
)0x00008000)

	)

271 #define 
	#RTC_AlarmMask_Seconds
 ((
uint32_t
)0x00000080)

	)

272 #define 
	#RTC_AlarmMask_All
 ((
uint32_t
)0x80808080)

	)

273 #define 
	#IS_ALARM_MASK
(
MASK
) (((MASK) & 0x7F7F7F7F) == (
uint32_t
)
RESET
)

	)

282 #define 
	#RTC_Alarm_A
 ((
uint32_t
)0x00000100)

	)

283 #define 
	#RTC_Alarm_B
 ((
uint32_t
)0x00000200)

	)

284 #define 
	#IS_RTC_ALARM
(
ALARM
) (((ALARM) == 
RTC_Alarm_A
) || ((ALARM) == 
RTC_Alarm_B
))

	)

285 #define 
	#IS_RTC_CMD_ALARM
(
ALARM
) (((ALARM) & (
RTC_Alarm_A
 | 
RTC_Alarm_B
)) != (
uint32_t
)
RESET
)

	)

294 #define 
	#RTC_AlarmSubSecondMask_All
 ((
uint32_t
)0x00000000)

	)

297 #define 
	#RTC_AlarmSubSecondMask_SS14_1
 ((
uint32_t
)0x01000000)

	)

299 #define 
	#RTC_AlarmSubSecondMask_SS14_2
 ((
uint32_t
)0x02000000)

	)

301 #define 
	#RTC_AlarmSubSecondMask_SS14_3
 ((
uint32_t
)0x03000000)

	)

303 #define 
	#RTC_AlarmSubSecondMask_SS14_4
 ((
uint32_t
)0x04000000)

	)

305 #define 
	#RTC_AlarmSubSecondMask_SS14_5
 ((
uint32_t
)0x05000000)

	)

307 #define 
	#RTC_AlarmSubSecondMask_SS14_6
 ((
uint32_t
)0x06000000)

	)

309 #define 
	#RTC_AlarmSubSecondMask_SS14_7
 ((
uint32_t
)0x07000000)

	)

311 #define 
	#RTC_AlarmSubSecondMask_SS14_8
 ((
uint32_t
)0x08000000)

	)

313 #define 
	#RTC_AlarmSubSecondMask_SS14_9
 ((
uint32_t
)0x09000000)

	)

315 #define 
	#RTC_AlarmSubSecondMask_SS14_10
 ((
uint32_t
)0x0A000000)

	)

317 #define 
	#RTC_AlarmSubSecondMask_SS14_11
 ((
uint32_t
)0x0B000000)

	)

319 #define 
	#RTC_AlarmSubSecondMask_SS14_12
 ((
uint32_t
)0x0C000000)

	)

321 #define 
	#RTC_AlarmSubSecondMask_SS14_13
 ((
uint32_t
)0x0D000000)

	)

323 #define 
	#RTC_AlarmSubSecondMask_SS14
 ((
uint32_t
)0x0E000000)

	)

325 #define 
	#RTC_AlarmSubSecondMask_None
 ((
uint32_t
)0x0F000000)

	)

327 #define 
	#IS_RTC_ALARM_SUB_SECOND_MASK
(
MASK
) (((MASK) == 
RTC_AlarmSubSecondMask_All
) || \

	)

328 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_1
) || \

329 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_2
) || \

330 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_3
) || \

331 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_4
) || \

332 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_5
) || \

333 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_6
) || \

334 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_7
) || \

335 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_8
) || \

336 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_9
) || \

337 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_10
) || \

338 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_11
) || \

339 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_12
) || \

340 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14_13
) || \

341 ((
MASK
) == 
RTC_AlarmSubSecondMask_SS14
) || \

342 ((
MASK
) == 
RTC_AlarmSubSecondMask_None
))

351 #define 
	#IS_RTC_ALARM_SUB_SECOND_VALUE
(
VALUE
) ((VALUE) <= 0x00007FFF)

	)

360 #define 
	#RTC_WakeUpClock_RTCCLK_Div16
 ((
uint32_t
)0x00000000)

	)

361 #define 
	#RTC_WakeUpClock_RTCCLK_Div8
 ((
uint32_t
)0x00000001)

	)

362 #define 
	#RTC_WakeUpClock_RTCCLK_Div4
 ((
uint32_t
)0x00000002)

	)

363 #define 
	#RTC_WakeUpClock_RTCCLK_Div2
 ((
uint32_t
)0x00000003)

	)

364 #define 
	#RTC_WakeUpClock_CK_SPRE_16bits
 ((
uint32_t
)0x00000004)

	)

365 #define 
	#RTC_WakeUpClock_CK_SPRE_17bits
 ((
uint32_t
)0x00000006)

	)

366 #define 
	#IS_RTC_WAKEUP_CLOCK
(
CLOCK
) (((CLOCK) == 
RTC_WakeUpClock_RTCCLK_Div16
) || \

	)

367 ((
CLOCK
) == 
RTC_WakeUpClock_RTCCLK_Div8
) || \

368 ((
CLOCK
) == 
RTC_WakeUpClock_RTCCLK_Div4
) || \

369 ((
CLOCK
) == 
RTC_WakeUpClock_RTCCLK_Div2
) || \

370 ((
CLOCK
) == 
RTC_WakeUpClock_CK_SPRE_16bits
) || \

371 ((
CLOCK
) == 
RTC_WakeUpClock_CK_SPRE_17bits
))

372 #define 
	#IS_RTC_WAKEUP_COUNTER
(
COUNTER
) ((COUNTER) <= 0xFFFF)

	)

380 #define 
	#RTC_TimeStampEdge_Rising
 ((
uint32_t
)0x00000000)

	)

381 #define 
	#RTC_TimeStampEdge_Falling
 ((
uint32_t
)0x00000008)

	)

382 #define 
	#IS_RTC_TIMESTAMP_EDGE
(
EDGE
) (((EDGE) == 
RTC_TimeStampEdge_Rising
) || \

	)

383 ((
EDGE
) == 
RTC_TimeStampEdge_Falling
))

391 #define 
	#RTC_Output_Disable
 ((
uint32_t
)0x00000000)

	)

392 #define 
	#RTC_Output_AlarmA
 ((
uint32_t
)0x00200000)

	)

393 #define 
	#RTC_Output_AlarmB
 ((
uint32_t
)0x00400000)

	)

394 #define 
	#RTC_Output_WakeUp
 ((
uint32_t
)0x00600000)

	)

396 #define 
	#IS_RTC_OUTPUT
(
OUTPUT
) (((OUTPUT) == 
RTC_Output_Disable
) || \

	)

397 ((
OUTPUT
) == 
RTC_Output_AlarmA
) || \

398 ((
OUTPUT
) == 
RTC_Output_AlarmB
) || \

399 ((
OUTPUT
) == 
RTC_Output_WakeUp
))

408 #define 
	#RTC_OutputPolarity_High
 ((
uint32_t
)0x00000000)

	)

409 #define 
	#RTC_OutputPolarity_Low
 ((
uint32_t
)0x00100000)

	)

410 #define 
	#IS_RTC_OUTPUT_POL
(
POL
) (((POL) == 
RTC_OutputPolarity_High
) || \

	)

411 ((
POL
) == 
RTC_OutputPolarity_Low
))

420 #define 
	#RTC_CalibSign_Positive
 ((
uint32_t
)0x00000000)

	)

421 #define 
	#RTC_CalibSign_Negative
 ((
uint32_t
)0x00000080)

	)

422 #define 
	#IS_RTC_CALIB_SIGN
(
SIGN
) (((SIGN) == 
RTC_CalibSign_Positive
) || \

	)

423 ((
SIGN
) == 
RTC_CalibSign_Negative
))

424 #define 
	#IS_RTC_CALIB_VALUE
(
VALUE
) ((VALUE) < 0x20)

	)

433 #define 
	#RTC_CalibOutput_512Hz
 ((
uint32_t
)0x00000000)

	)

434 #define 
	#RTC_CalibOutput_1Hz
 ((
uint32_t
)0x00080000)

	)

435 #define 
	#IS_RTC_CALIB_OUTPUT
(
OUTPUT
) (((OUTPUT) == 
RTC_CalibOutput_512Hz
) || \

	)

436 ((
OUTPUT
) == 
RTC_CalibOutput_1Hz
))

444 #define 
	#RTC_SmoothCalibPeriod_32sec
 ((
uint32_t
)0x00000000)

	)

446 #define 
	#RTC_SmoothCalibPeriod_16sec
 ((
uint32_t
)0x00002000)

	)

448 #define 
	#RTC_SmoothCalibPeriod_8sec
 ((
uint32_t
)0x00004000)

	)

450 #define 
	#IS_RTC_SMOOTH_CALIB_PERIOD
(
PERIOD
) (((PERIOD) == 
RTC_SmoothCalibPeriod_32sec
) || \

	)

451 ((
PERIOD
) == 
RTC_SmoothCalibPeriod_16sec
) || \

452 ((
PERIOD
) == 
RTC_SmoothCalibPeriod_8sec
))

461 #define 
	#RTC_SmoothCalibPlusPulses_Set
 ((
uint32_t
)0x00008000)

	)

464 #define 
	#RTC_SmoothCalibPlusPulses_Reset
 ((
uint32_t
)0x00000000)

	)

466 #define 
	#IS_RTC_SMOOTH_CALIB_PLUS
(
PLUS
) (((PLUS) == 
RTC_SmoothCalibPlusPulses_Set
) || \

	)

467 ((
PLUS
) == 
RTC_SmoothCalibPlusPulses_Reset
))

476 #define 
	#IS_RTC_SMOOTH_CALIB_MINUS
(
VALUE
) ((VALUE) <= 0x000001FF)

	)

485 #define 
	#RTC_DayLightSaving_SUB1H
 ((
uint32_t
)0x00020000)

	)

486 #define 
	#RTC_DayLightSaving_ADD1H
 ((
uint32_t
)0x00010000)

	)

487 #define 
	#IS_RTC_DAYLIGHT_SAVING
(
SAVE
) (((SAVE) == 
RTC_DayLightSaving_SUB1H
) || \

	)

488 ((
SAVE
) == 
RTC_DayLightSaving_ADD1H
))

490 #define 
	#RTC_StoreOperation_Reset
 ((
uint32_t
)0x00000000)

	)

491 #define 
	#RTC_StoreOperation_Set
 ((
uint32_t
)0x00040000)

	)

492 #define 
	#IS_RTC_STORE_OPERATION
(
OPERATION
) (((OPERATION) == 
RTC_StoreOperation_Reset
) || \

	)

493 ((
OPERATION
) == 
RTC_StoreOperation_Set
))

501 #define 
	#RTC_TamperTrigger_RisingEdge
 ((
uint32_t
)0x00000000)

	)

502 #define 
	#RTC_TamperTrigger_FallingEdge
 ((
uint32_t
)0x00000001)

	)

503 #define 
	#RTC_TamperTrigger_LowLevel
 ((
uint32_t
)0x00000000)

	)

504 #define 
	#RTC_TamperTrigger_HighLevel
 ((
uint32_t
)0x00000001)

	)

505 #define 
	#IS_RTC_TAMPER_TRIGGER
(
TRIGGER
) (((TRIGGER) == 
RTC_TamperTrigger_RisingEdge
) || \

	)

506 ((
TRIGGER
) == 
RTC_TamperTrigger_FallingEdge
) || \

507 ((
TRIGGER
) == 
RTC_TamperTrigger_LowLevel
) || \

508 ((
TRIGGER
) == 
RTC_TamperTrigger_HighLevel
))

517 #define 
	#RTC_TamperFilter_Disable
 ((
uint32_t
)0x00000000)

	)

519 #define 
	#RTC_TamperFilter_2Sample
 ((
uint32_t
)0x00000800)

	)

521 #define 
	#RTC_TamperFilter_4Sample
 ((
uint32_t
)0x00001000)

	)

523 #define 
	#RTC_TamperFilter_8Sample
 ((
uint32_t
)0x00001800)

	)

525 #define 
	#IS_RTC_TAMPER_FILTER
(
FILTER
) (((FILTER) == 
RTC_TamperFilter_Disable
) || \

	)

526 ((
FILTER
) == 
RTC_TamperFilter_2Sample
) || \

527 ((
FILTER
) == 
RTC_TamperFilter_4Sample
) || \

528 ((
FILTER
) == 
RTC_TamperFilter_8Sample
))

536 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div32768
 ((
uint32_t
)0x00000000)

	)

538 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div16384
 ((
uint32_t
)0x000000100)

	)

540 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div8192
 ((
uint32_t
)0x00000200)

	)

542 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div4096
 ((
uint32_t
)0x00000300)

	)

544 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div2048
 ((
uint32_t
)0x00000400)

	)

546 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div1024
 ((
uint32_t
)0x00000500)

	)

548 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div512
 ((
uint32_t
)0x00000600)

	)

550 #define 
	#RTC_TamperSamplingFreq_RTCCLK_Div256
 ((
uint32_t
)0x00000700)

	)

552 #define 
	#IS_RTC_TAMPER_SAMPLING_FREQ
(
FREQ
) (((FREQ) ==
RTC_TamperSamplingFreq_RTCCLK_Div32768
) || \

	)

553 ((
FREQ
) ==
RTC_TamperSamplingFreq_RTCCLK_Div16384
) || \

554 ((
FREQ
) ==
RTC_TamperSamplingFreq_RTCCLK_Div8192
) || \

555 ((
FREQ
) ==
RTC_TamperSamplingFreq_RTCCLK_Div4096
) || \

556 ((
FREQ
) ==
RTC_TamperSamplingFreq_RTCCLK_Div2048
) || \

557 ((
FREQ
) ==
RTC_TamperSamplingFreq_RTCCLK_Div1024
) || \

558 ((
FREQ
) ==
RTC_TamperSamplingFreq_RTCCLK_Div512
) || \

559 ((
FREQ
) ==
RTC_TamperSamplingFreq_RTCCLK_Div256
))

568 #define 
	#RTC_TamperPrechargeDuration_1RTCCLK
 ((
uint32_t
)0x00000000)

	)

570 #define 
	#RTC_TamperPrechargeDuration_2RTCCLK
 ((
uint32_t
)0x00002000)

	)

572 #define 
	#RTC_TamperPrechargeDuration_4RTCCLK
 ((
uint32_t
)0x00004000)

	)

574 #define 
	#RTC_TamperPrechargeDuration_8RTCCLK
 ((
uint32_t
)0x00006000)

	)

577 #define 
	#IS_RTC_TAMPER_PRECHARGE_DURATION
(
DURATION
) (((DURATION) == 
RTC_TamperPrechargeDuration_1RTCCLK
) || \

	)

578 ((
DURATION
) == 
RTC_TamperPrechargeDuration_2RTCCLK
) || \

579 ((
DURATION
) == 
RTC_TamperPrechargeDuration_4RTCCLK
) || \

580 ((
DURATION
) == 
RTC_TamperPrechargeDuration_8RTCCLK
))

588 #define 
	#RTC_Tamper_1
 
RTC_TAFCR_TAMP1E


	)

589 #define 
	#IS_RTC_TAMPER
(
TAMPER
) (((TAMPER) == 
RTC_Tamper_1
))

	)

598 #define 
	#RTC_TamperPin_PC13
 ((
uint32_t
)0x00000000)

	)

599 #define 
	#RTC_TamperPin_PI8
 ((
uint32_t
)0x00010000)

	)

600 #define 
	#IS_RTC_TAMPER_PIN
(
PIN
) (((PIN) == 
RTC_TamperPin_PC13
) || \

	)

601 ((
PIN
) == 
RTC_TamperPin_PI8
))

609 #define 
	#RTC_TimeStampPin_PC13
 ((
uint32_t
)0x00000000)

	)

610 #define 
	#RTC_TimeStampPin_PI8
 ((
uint32_t
)0x00020000)

	)

611 #define 
	#IS_RTC_TIMESTAMP_PIN
(
PIN
) (((PIN) == 
RTC_TimeStampPin_PC13
) || \

	)

612 ((
PIN
) == 
RTC_TimeStampPin_PI8
))

620 #define 
	#RTC_OutputType_OpenDrain
 ((
uint32_t
)0x00000000)

	)

621 #define 
	#RTC_OutputType_PushPull
 ((
uint32_t
)0x00040000)

	)

622 #define 
	#IS_RTC_OUTPUT_TYPE
(
TYPE
) (((TYPE) == 
RTC_OutputType_OpenDrain
) || \

	)

623 ((
TYPE
) == 
RTC_OutputType_PushPull
))

632 #define 
	#RTC_ShiftAdd1S_Reset
 ((
uint32_t
)0x00000000)

	)

633 #define 
	#RTC_ShiftAdd1S_Set
 ((
uint32_t
)0x80000000)

	)

634 #define 
	#IS_RTC_SHIFT_ADD1S
(
SEL
) (((SEL) == 
RTC_ShiftAdd1S_Reset
) || \

	)

635 ((
SEL
) == 
RTC_ShiftAdd1S_Set
))

643 #define 
	#IS_RTC_SHIFT_SUBFS
(
FS
) ((FS) <= 0x00007FFF)

	)

653 #define 
	#RTC_BKP_DR0
 ((
uint32_t
)0x00000000)

	)

654 #define 
	#RTC_BKP_DR1
 ((
uint32_t
)0x00000001)

	)

655 #define 
	#RTC_BKP_DR2
 ((
uint32_t
)0x00000002)

	)

656 #define 
	#RTC_BKP_DR3
 ((
uint32_t
)0x00000003)

	)

657 #define 
	#RTC_BKP_DR4
 ((
uint32_t
)0x00000004)

	)

658 #define 
	#RTC_BKP_DR5
 ((
uint32_t
)0x00000005)

	)

659 #define 
	#RTC_BKP_DR6
 ((
uint32_t
)0x00000006)

	)

660 #define 
	#RTC_BKP_DR7
 ((
uint32_t
)0x00000007)

	)

661 #define 
	#RTC_BKP_DR8
 ((
uint32_t
)0x00000008)

	)

662 #define 
	#RTC_BKP_DR9
 ((
uint32_t
)0x00000009)

	)

663 #define 
	#RTC_BKP_DR10
 ((
uint32_t
)0x0000000A)

	)

664 #define 
	#RTC_BKP_DR11
 ((
uint32_t
)0x0000000B)

	)

665 #define 
	#RTC_BKP_DR12
 ((
uint32_t
)0x0000000C)

	)

666 #define 
	#RTC_BKP_DR13
 ((
uint32_t
)0x0000000D)

	)

667 #define 
	#RTC_BKP_DR14
 ((
uint32_t
)0x0000000E)

	)

668 #define 
	#RTC_BKP_DR15
 ((
uint32_t
)0x0000000F)

	)

669 #define 
	#RTC_BKP_DR16
 ((
uint32_t
)0x00000010)

	)

670 #define 
	#RTC_BKP_DR17
 ((
uint32_t
)0x00000011)

	)

671 #define 
	#RTC_BKP_DR18
 ((
uint32_t
)0x00000012)

	)

672 #define 
	#RTC_BKP_DR19
 ((
uint32_t
)0x00000013)

	)

673 #define 
	#IS_RTC_BKP
(
BKP
) (((BKP) == 
RTC_BKP_DR0
) || \

	)

674 ((
BKP
) == 
RTC_BKP_DR1
) || \

675 ((
BKP
) == 
RTC_BKP_DR2
) || \

676 ((
BKP
) == 
RTC_BKP_DR3
) || \

677 ((
BKP
) == 
RTC_BKP_DR4
) || \

678 ((
BKP
) == 
RTC_BKP_DR5
) || \

679 ((
BKP
) == 
RTC_BKP_DR6
) || \

680 ((
BKP
) == 
RTC_BKP_DR7
) || \

681 ((
BKP
) == 
RTC_BKP_DR8
) || \

682 ((
BKP
) == 
RTC_BKP_DR9
) || \

683 ((
BKP
) == 
RTC_BKP_DR10
) || \

684 ((
BKP
) == 
RTC_BKP_DR11
) || \

685 ((
BKP
) == 
RTC_BKP_DR12
) || \

686 ((
BKP
) == 
RTC_BKP_DR13
) || \

687 ((
BKP
) == 
RTC_BKP_DR14
) || \

688 ((
BKP
) == 
RTC_BKP_DR15
) || \

689 ((
BKP
) == 
RTC_BKP_DR16
) || \

690 ((
BKP
) == 
RTC_BKP_DR17
) || \

691 ((
BKP
) == 
RTC_BKP_DR18
) || \

692 ((
BKP
) == 
RTC_BKP_DR19
))

700 #define 
	#RTC_Format_BIN
 ((
uint32_t
)0x000000000)

	)

701 #define 
	#RTC_Format_BCD
 ((
uint32_t
)0x000000001)

	)

702 #define 
	#IS_RTC_FORMAT
(
FORMAT
) (((FORMAT) == 
RTC_Format_BIN
) || ((FORMAT) == 
RTC_Format_BCD
))

	)

711 #define 
	#RTC_FLAG_RECALPF
 ((
uint32_t
)0x00010000)

	)

712 #define 
	#RTC_FLAG_TAMP1F
 ((
uint32_t
)0x00002000)

	)

713 #define 
	#RTC_FLAG_TSOVF
 ((
uint32_t
)0x00001000)

	)

714 #define 
	#RTC_FLAG_TSF
 ((
uint32_t
)0x00000800)

	)

715 #define 
	#RTC_FLAG_WUTF
 ((
uint32_t
)0x00000400)

	)

716 #define 
	#RTC_FLAG_ALRBF
 ((
uint32_t
)0x00000200)

	)

717 #define 
	#RTC_FLAG_ALRAF
 ((
uint32_t
)0x00000100)

	)

718 #define 
	#RTC_FLAG_INITF
 ((
uint32_t
)0x00000040)

	)

719 #define 
	#RTC_FLAG_RSF
 ((
uint32_t
)0x00000020)

	)

720 #define 
	#RTC_FLAG_INITS
 ((
uint32_t
)0x00000010)

	)

721 #define 
	#RTC_FLAG_SHPF
 ((
uint32_t
)0x00000008)

	)

722 #define 
	#RTC_FLAG_WUTWF
 ((
uint32_t
)0x00000004)

	)

723 #define 
	#RTC_FLAG_ALRBWF
 ((
uint32_t
)0x00000002)

	)

724 #define 
	#RTC_FLAG_ALRAWF
 ((
uint32_t
)0x00000001)

	)

725 #define 
	#IS_RTC_GET_FLAG
(
FLAG
) (((FLAG) == 
RTC_FLAG_TSOVF
) || ((FLAG) == 
RTC_FLAG_TSF
) || \

	)

726 ((
FLAG
) == 
RTC_FLAG_WUTF
) || ((FLAG) == 
RTC_FLAG_ALRBF
) || \

727 ((
FLAG
) == 
RTC_FLAG_ALRAF
) || ((FLAG) == 
RTC_FLAG_INITF
) || \

728 ((
FLAG
) == 
RTC_FLAG_RSF
) || ((FLAG) == 
RTC_FLAG_WUTWF
) || \

729 ((
FLAG
) == 
RTC_FLAG_ALRBWF
) || ((FLAG) == 
RTC_FLAG_ALRAWF
) || \

730 ((
FLAG
) == 
RTC_FLAG_TAMP1F
) || ((FLAG) == 
RTC_FLAG_RECALPF
) || \

731 ((
FLAG
) == 
RTC_FLAG_SHPF
))

732 #define 
	#IS_RTC_CLEAR_FLAG
(
FLAG
) (((FLAG) != (
uint32_t
)
RESET
) && (((FLAG) & 0xFFFF00DF) == (uint32_t)RESET))

	)

740 #define 
	#RTC_IT_TS
 ((
uint32_t
)0x00008000)

	)

741 #define 
	#RTC_IT_WUT
 ((
uint32_t
)0x00004000)

	)

742 #define 
	#RTC_IT_ALRB
 ((
uint32_t
)0x00002000)

	)

743 #define 
	#RTC_IT_ALRA
 ((
uint32_t
)0x00001000)

	)

744 #define 
	#RTC_IT_TAMP
 ((
uint32_t
)0x00000004)

	)

745 #define 
	#RTC_IT_TAMP1
 ((
uint32_t
)0x00020000)

	)

747 #define 
	#IS_RTC_CONFIG_IT
(
IT
) (((IT) != (
uint32_t
)
RESET
) && (((IT) & 0xFFFF0FFB) == (uint32_t)RESET))

	)

748 #define 
	#IS_RTC_GET_IT
(
IT
) (((IT) == 
RTC_IT_TS
) || ((IT) == 
RTC_IT_WUT
) || \

	)

749 ((
IT
) == 
RTC_IT_ALRB
) || ((IT) == 
RTC_IT_ALRA
) || \

750 ((
IT
) == 
RTC_IT_TAMP1
))

751 #define 
	#IS_RTC_CLEAR_IT
(
IT
) (((IT) != (
uint32_t
)
RESET
) && (((IT) & 0xFFFD0FFF) == (uint32_t)RESET))

	)

760 #define 
	#RTC_DigitalCalibConfig
 
RTC_CoarseCalibConfig


	)

761 #define 
	#RTC_DigitalCalibCmd
 
RTC_CoarseCalibCmd


	)

775 
ErrorStatus
 
RTC_DeInit
(void);

778 
ErrorStatus
 
RTC_Init
(
RTC_InitTypeDef
* 
RTC_InitStruct
);

779 void 
RTC_StructInit
(
RTC_InitTypeDef
* 
RTC_InitStruct
);

780 void 
RTC_WriteProtectionCmd
(
FunctionalState
 
NewState
);

781 
ErrorStatus
 
RTC_EnterInitMode
(void);

782 void 
RTC_ExitInitMode
(void);

783 
ErrorStatus
 
RTC_WaitForSynchro
(void);

784 
ErrorStatus
 
RTC_RefClockCmd
(
FunctionalState
 
NewState
);

785 void 
RTC_BypassShadowCmd
(
FunctionalState
 
NewState
);

788 
ErrorStatus
 
RTC_SetTime
(
uint32_t
 
RTC_Format
, 
RTC_TimeTypeDef
* 
RTC_TimeStruct
);

789 void 
RTC_TimeStructInit
(
RTC_TimeTypeDef
* 
RTC_TimeStruct
);

790 void 
RTC_GetTime
(
uint32_t
 
RTC_Format
, 
RTC_TimeTypeDef
* 
RTC_TimeStruct
);

791 
uint32_t
 
RTC_GetSubSecond
(void);

792 
ErrorStatus
 
RTC_SetDate
(
uint32_t
 
RTC_Format
, 
RTC_DateTypeDef
* 
RTC_DateStruct
);

793 void 
RTC_DateStructInit
(
RTC_DateTypeDef
* 
RTC_DateStruct
);

794 void 
RTC_GetDate
(
uint32_t
 
RTC_Format
, 
RTC_DateTypeDef
* 
RTC_DateStruct
);

797 void 
RTC_SetAlarm
(
uint32_t
 
RTC_Format
, uint32_t 
RTC_Alarm
, 
RTC_AlarmTypeDef
* 
RTC_AlarmStruct
);

798 void 
RTC_AlarmStructInit
(
RTC_AlarmTypeDef
* 
RTC_AlarmStruct
);

799 void 
RTC_GetAlarm
(
uint32_t
 
RTC_Format
, uint32_t 
RTC_Alarm
, 
RTC_AlarmTypeDef
* 
RTC_AlarmStruct
);

800 
ErrorStatus
 
RTC_AlarmCmd
(
uint32_t
 
RTC_Alarm
, 
FunctionalState
 
NewState
);

801 void 
RTC_AlarmSubSecondConfig
(
uint32_t
 
RTC_Alarm
, uint32_t 
RTC_AlarmSubSecondValue
, uint32_t 
RTC_AlarmSubSecondMask
);

802 
uint32_t
 
RTC_GetAlarmSubSecond
(uint32_t 
RTC_Alarm
);

805 void 
RTC_WakeUpClockConfig
(
uint32_t
 
RTC_WakeUpClock
);

806 void 
RTC_SetWakeUpCounter
(
uint32_t
 
RTC_WakeUpCounter
);

807 
uint32_t
 
RTC_GetWakeUpCounter
(void);

808 
ErrorStatus
 
RTC_WakeUpCmd
(
FunctionalState
 
NewState
);

811 void 
RTC_DayLightSavingConfig
(
uint32_t
 
RTC_DayLightSaving
, uint32_t 
RTC_StoreOperation
);

812 
uint32_t
 
RTC_GetStoreOperation
(void);

815 void 
RTC_OutputConfig
(
uint32_t
 
RTC_Output
, uint32_t 
RTC_OutputPolarity
);

818 
ErrorStatus
 
RTC_CoarseCalibConfig
(
uint32_t
 
RTC_CalibSign
, uint32_t 
Value
);

819 
ErrorStatus
 
RTC_CoarseCalibCmd
(
FunctionalState
 
NewState
);

820 void 
RTC_CalibOutputCmd
(
FunctionalState
 
NewState
);

821 void 
RTC_CalibOutputConfig
(
uint32_t
 
RTC_CalibOutput
);

822 
ErrorStatus
 
RTC_SmoothCalibConfig
(
uint32_t
 
RTC_SmoothCalibPeriod
,

823 
uint32_t
 
RTC_SmoothCalibPlusPulses
,

824 
uint32_t
 
RTC_SmouthCalibMinusPulsesValue
);

827 void 
RTC_TimeStampCmd
(
uint32_t
 
RTC_TimeStampEdge
, 
FunctionalState
 
NewState
);

828 void 
RTC_GetTimeStamp
(
uint32_t
 
RTC_Format
, 
RTC_TimeTypeDef
* 
RTC_StampTimeStruct
,

829 
RTC_DateTypeDef
* 
RTC_StampDateStruct
);

830 
uint32_t
 
RTC_GetTimeStampSubSecond
(void);

833 void 
RTC_TamperTriggerConfig
(
uint32_t
 
RTC_Tamper
, uint32_t 
RTC_TamperTrigger
);

834 void 
RTC_TamperCmd
(
uint32_t
 
RTC_Tamper
, 
FunctionalState
 
NewState
);

835 void 
RTC_TamperFilterConfig
(
uint32_t
 
RTC_TamperFilter
);

836 void 
RTC_TamperSamplingFreqConfig
(
uint32_t
 
RTC_TamperSamplingFreq
);

837 void 
RTC_TamperPinsPrechargeDuration
(
uint32_t
 
RTC_TamperPrechargeDuration
);

838 void 
RTC_TimeStampOnTamperDetectionCmd
(
FunctionalState
 
NewState
);

839 void 
RTC_TamperPullUpCmd
(
FunctionalState
 
NewState
);

842 void 
RTC_WriteBackupRegister
(
uint32_t
 
RTC_BKP_DR
, uint32_t 
Data
);

843 
uint32_t
 
RTC_ReadBackupRegister
(uint32_t 
RTC_BKP_DR
);

847 void 
RTC_TamperPinSelection
(
uint32_t
 
RTC_TamperPin
);

848 void 
RTC_TimeStampPinSelection
(
uint32_t
 
RTC_TimeStampPin
);

849 void 
RTC_OutputTypeConfig
(
uint32_t
 
RTC_OutputType
);

852 
ErrorStatus
 
RTC_SynchroShiftConfig
(
uint32_t
 
RTC_ShiftAdd1S
, uint32_t 
RTC_ShiftSubFS
);

855 void 
RTC_ITConfig
(
uint32_t
 
RTC_IT
, 
FunctionalState
 
NewState
);

856 
FlagStatus
 
RTC_GetFlagStatus
(
uint32_t
 
RTC_FLAG
);

857 void 
RTC_ClearFlag
(
uint32_t
 
RTC_FLAG
);

858 
ITStatus
 
RTC_GetITStatus
(
uint32_t
 
RTC_IT
);

859 void 
RTC_ClearITPendingBit
(
uint32_t
 
RTC_IT
);

861 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sdio.h

24 #ifndef 
__STM32F4xx_SDIO_H


25 #define 
	#__STM32F4xx_SDIO_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

46 
uint32_t
 
SDIO_ClockEdge
;

49 
uint32_t
 
SDIO_ClockBypass
;

53 
uint32_t
 
SDIO_ClockPowerSave
;

57 
uint32_t
 
SDIO_BusWide
;

60 
uint32_t
 
SDIO_HardwareFlowControl
;

63 
uint8_t
 
SDIO_ClockDiv
;

66 } 
	tSDIO_InitTypeDef
;

70 
uint32_t
 
SDIO_Argument
;

75 
uint32_t
 
SDIO_CmdIndex
;

77 
uint32_t
 
SDIO_Response
;

80 
uint32_t
 
SDIO_Wait
;

83 
uint32_t
 
SDIO_CPSM
;

86 } 
	tSDIO_CmdInitTypeDef
;

90 
uint32_t
 
SDIO_DataTimeOut
;

92 
uint32_t
 
SDIO_DataLength
;

94 
uint32_t
 
SDIO_DataBlockSize
;

97 
uint32_t
 
SDIO_TransferDir
;

101 
uint32_t
 
SDIO_TransferMode
;

104 
uint32_t
 
SDIO_DPSM
;

107 } 
	tSDIO_DataInitTypeDef
;

120 #define 
	#SDIO_ClockEdge_Rising
 ((
uint32_t
)0x00000000)

	)

121 #define 
	#SDIO_ClockEdge_Falling
 ((
uint32_t
)0x00002000)

	)

122 #define 
	#IS_SDIO_CLOCK_EDGE
(
EDGE
) (((EDGE) == 
SDIO_ClockEdge_Rising
) || \

	)

123 ((
EDGE
) == 
SDIO_ClockEdge_Falling
))

132 #define 
	#SDIO_ClockBypass_Disable
 ((
uint32_t
)0x00000000)

	)

133 #define 
	#SDIO_ClockBypass_Enable
 ((
uint32_t
)0x00000400)

	)

134 #define 
	#IS_SDIO_CLOCK_BYPASS
(
BYPASS
) (((BYPASS) == 
SDIO_ClockBypass_Disable
) || \

	)

135 ((
BYPASS
) == 
SDIO_ClockBypass_Enable
))

144 #define 
	#SDIO_ClockPowerSave_Disable
 ((
uint32_t
)0x00000000)

	)

145 #define 
	#SDIO_ClockPowerSave_Enable
 ((
uint32_t
)0x00000200)

	)

146 #define 
	#IS_SDIO_CLOCK_POWER_SAVE
(
SAVE
) (((SAVE) == 
SDIO_ClockPowerSave_Disable
) || \

	)

147 ((
SAVE
) == 
SDIO_ClockPowerSave_Enable
))

156 #define 
	#SDIO_BusWide_1b
 ((
uint32_t
)0x00000000)

	)

157 #define 
	#SDIO_BusWide_4b
 ((
uint32_t
)0x00000800)

	)

158 #define 
	#SDIO_BusWide_8b
 ((
uint32_t
)0x00001000)

	)

159 #define 
	#IS_SDIO_BUS_WIDE
(
WIDE
) (((WIDE) == 
SDIO_BusWide_1b
) || ((WIDE) == 
SDIO_BusWide_4b
) || \

	)

160 ((
WIDE
) == 
SDIO_BusWide_8b
))

170 #define 
	#SDIO_HardwareFlowControl_Disable
 ((
uint32_t
)0x00000000)

	)

171 #define 
	#SDIO_HardwareFlowControl_Enable
 ((
uint32_t
)0x00004000)

	)

172 #define 
	#IS_SDIO_HARDWARE_FLOW_CONTROL
(
CONTROL
) (((CONTROL) == 
SDIO_HardwareFlowControl_Disable
) || \

	)

173 ((
CONTROL
) == 
SDIO_HardwareFlowControl_Enable
))

182 #define 
	#SDIO_PowerState_OFF
 ((
uint32_t
)0x00000000)

	)

183 #define 
	#SDIO_PowerState_ON
 ((
uint32_t
)0x00000003)

	)

184 #define 
	#IS_SDIO_POWER_STATE
(
STATE
) (((STATE) == 
SDIO_PowerState_OFF
) || ((STATE) == 
SDIO_PowerState_ON
))

	)

194 #define 
	#SDIO_IT_CCRCFAIL
 ((
uint32_t
)0x00000001)

	)

195 #define 
	#SDIO_IT_DCRCFAIL
 ((
uint32_t
)0x00000002)

	)

196 #define 
	#SDIO_IT_CTIMEOUT
 ((
uint32_t
)0x00000004)

	)

197 #define 
	#SDIO_IT_DTIMEOUT
 ((
uint32_t
)0x00000008)

	)

198 #define 
	#SDIO_IT_TXUNDERR
 ((
uint32_t
)0x00000010)

	)

199 #define 
	#SDIO_IT_RXOVERR
 ((
uint32_t
)0x00000020)

	)

200 #define 
	#SDIO_IT_CMDREND
 ((
uint32_t
)0x00000040)

	)

201 #define 
	#SDIO_IT_CMDSENT
 ((
uint32_t
)0x00000080)

	)

202 #define 
	#SDIO_IT_DATAEND
 ((
uint32_t
)0x00000100)

	)

203 #define 
	#SDIO_IT_STBITERR
 ((
uint32_t
)0x00000200)

	)

204 #define 
	#SDIO_IT_DBCKEND
 ((
uint32_t
)0x00000400)

	)

205 #define 
	#SDIO_IT_CMDACT
 ((
uint32_t
)0x00000800)

	)

206 #define 
	#SDIO_IT_TXACT
 ((
uint32_t
)0x00001000)

	)

207 #define 
	#SDIO_IT_RXACT
 ((
uint32_t
)0x00002000)

	)

208 #define 
	#SDIO_IT_TXFIFOHE
 ((
uint32_t
)0x00004000)

	)

209 #define 
	#SDIO_IT_RXFIFOHF
 ((
uint32_t
)0x00008000)

	)

210 #define 
	#SDIO_IT_TXFIFOF
 ((
uint32_t
)0x00010000)

	)

211 #define 
	#SDIO_IT_RXFIFOF
 ((
uint32_t
)0x00020000)

	)

212 #define 
	#SDIO_IT_TXFIFOE
 ((
uint32_t
)0x00040000)

	)

213 #define 
	#SDIO_IT_RXFIFOE
 ((
uint32_t
)0x00080000)

	)

214 #define 
	#SDIO_IT_TXDAVL
 ((
uint32_t
)0x00100000)

	)

215 #define 
	#SDIO_IT_RXDAVL
 ((
uint32_t
)0x00200000)

	)

216 #define 
	#SDIO_IT_SDIOIT
 ((
uint32_t
)0x00400000)

	)

217 #define 
	#SDIO_IT_CEATAEND
 ((
uint32_t
)0x00800000)

	)

218 #define 
	#IS_SDIO_IT
(
IT
) ((((IT) & (
uint32_t
)0xFF000000) == 0x00) && ((IT) != (uint32_t)0x00))

	)

227 #define 
	#IS_SDIO_CMD_INDEX
(
INDEX
) ((INDEX) < 0x40)

	)

236 #define 
	#SDIO_Response_No
 ((
uint32_t
)0x00000000)

	)

237 #define 
	#SDIO_Response_Short
 ((
uint32_t
)0x00000040)

	)

238 #define 
	#SDIO_Response_Long
 ((
uint32_t
)0x000000C0)

	)

239 #define 
	#IS_SDIO_RESPONSE
(
RESPONSE
) (((RESPONSE) == 
SDIO_Response_No
) || \

	)

240 ((
RESPONSE
) == 
SDIO_Response_Short
) || \

241 ((
RESPONSE
) == 
SDIO_Response_Long
))

250 #define 
	#SDIO_Wait_No
 ((
uint32_t
)0x00000000)

	)

251 #define 
	#SDIO_Wait_IT
 ((
uint32_t
)0x00000100)

	)

252 #define 
	#SDIO_Wait_Pend
 ((
uint32_t
)0x00000200)

	)

253 #define 
	#IS_SDIO_WAIT
(
WAIT
) (((WAIT) == 
SDIO_Wait_No
) || ((WAIT) == 
SDIO_Wait_IT
) || \

	)

254 ((
WAIT
) == 
SDIO_Wait_Pend
))

263 #define 
	#SDIO_CPSM_Disable
 ((
uint32_t
)0x00000000)

	)

264 #define 
	#SDIO_CPSM_Enable
 ((
uint32_t
)0x00000400)

	)

265 #define 
	#IS_SDIO_CPSM
(
CPSM
) (((CPSM) == 
SDIO_CPSM_Enable
) || ((CPSM) == 
SDIO_CPSM_Disable
))

	)

274 #define 
	#SDIO_RESP1
 ((
uint32_t
)0x00000000)

	)

275 #define 
	#SDIO_RESP2
 ((
uint32_t
)0x00000004)

	)

276 #define 
	#SDIO_RESP3
 ((
uint32_t
)0x00000008)

	)

277 #define 
	#SDIO_RESP4
 ((
uint32_t
)0x0000000C)

	)

278 #define 
	#IS_SDIO_RESP
(
RESP
) (((RESP) == 
SDIO_RESP1
) || ((RESP) == 
SDIO_RESP2
) || \

	)

279 ((
RESP
) == 
SDIO_RESP3
) || ((RESP) == 
SDIO_RESP4
))

288 #define 
	#IS_SDIO_DATA_LENGTH
(
LENGTH
) ((LENGTH) <= 0x01FFFFFF)

	)

297 #define 
	#SDIO_DataBlockSize_1b
 ((
uint32_t
)0x00000000)

	)

298 #define 
	#SDIO_DataBlockSize_2b
 ((
uint32_t
)0x00000010)

	)

299 #define 
	#SDIO_DataBlockSize_4b
 ((
uint32_t
)0x00000020)

	)

300 #define 
	#SDIO_DataBlockSize_8b
 ((
uint32_t
)0x00000030)

	)

301 #define 
	#SDIO_DataBlockSize_16b
 ((
uint32_t
)0x00000040)

	)

302 #define 
	#SDIO_DataBlockSize_32b
 ((
uint32_t
)0x00000050)

	)

303 #define 
	#SDIO_DataBlockSize_64b
 ((
uint32_t
)0x00000060)

	)

304 #define 
	#SDIO_DataBlockSize_128b
 ((
uint32_t
)0x00000070)

	)

305 #define 
	#SDIO_DataBlockSize_256b
 ((
uint32_t
)0x00000080)

	)

306 #define 
	#SDIO_DataBlockSize_512b
 ((
uint32_t
)0x00000090)

	)

307 #define 
	#SDIO_DataBlockSize_1024b
 ((
uint32_t
)0x000000A0)

	)

308 #define 
	#SDIO_DataBlockSize_2048b
 ((
uint32_t
)0x000000B0)

	)

309 #define 
	#SDIO_DataBlockSize_4096b
 ((
uint32_t
)0x000000C0)

	)

310 #define 
	#SDIO_DataBlockSize_8192b
 ((
uint32_t
)0x000000D0)

	)

311 #define 
	#SDIO_DataBlockSize_16384b
 ((
uint32_t
)0x000000E0)

	)

312 #define 
	#IS_SDIO_BLOCK_SIZE
(
SIZE
) (((SIZE) == 
SDIO_DataBlockSize_1b
) || \

	)

313 ((
SIZE
) == 
SDIO_DataBlockSize_2b
) || \

314 ((
SIZE
) == 
SDIO_DataBlockSize_4b
) || \

315 ((
SIZE
) == 
SDIO_DataBlockSize_8b
) || \

316 ((
SIZE
) == 
SDIO_DataBlockSize_16b
) || \

317 ((
SIZE
) == 
SDIO_DataBlockSize_32b
) || \

318 ((
SIZE
) == 
SDIO_DataBlockSize_64b
) || \

319 ((
SIZE
) == 
SDIO_DataBlockSize_128b
) || \

320 ((
SIZE
) == 
SDIO_DataBlockSize_256b
) || \

321 ((
SIZE
) == 
SDIO_DataBlockSize_512b
) || \

322 ((
SIZE
) == 
SDIO_DataBlockSize_1024b
) || \

323 ((
SIZE
) == 
SDIO_DataBlockSize_2048b
) || \

324 ((
SIZE
) == 
SDIO_DataBlockSize_4096b
) || \

325 ((
SIZE
) == 
SDIO_DataBlockSize_8192b
) || \

326 ((
SIZE
) == 
SDIO_DataBlockSize_16384b
))

335 #define 
	#SDIO_TransferDir_ToCard
 ((
uint32_t
)0x00000000)

	)

336 #define 
	#SDIO_TransferDir_ToSDIO
 ((
uint32_t
)0x00000002)

	)

337 #define 
	#IS_SDIO_TRANSFER_DIR
(
DIR
) (((DIR) == 
SDIO_TransferDir_ToCard
) || \

	)

338 ((
DIR
) == 
SDIO_TransferDir_ToSDIO
))

347 #define 
	#SDIO_TransferMode_Block
 ((
uint32_t
)0x00000000)

	)

348 #define 
	#SDIO_TransferMode_Stream
 ((
uint32_t
)0x00000004)

	)

349 #define 
	#IS_SDIO_TRANSFER_MODE
(
MODE
) (((MODE) == 
SDIO_TransferMode_Stream
) || \

	)

350 ((
MODE
) == 
SDIO_TransferMode_Block
))

359 #define 
	#SDIO_DPSM_Disable
 ((
uint32_t
)0x00000000)

	)

360 #define 
	#SDIO_DPSM_Enable
 ((
uint32_t
)0x00000001)

	)

361 #define 
	#IS_SDIO_DPSM
(
DPSM
) (((DPSM) == 
SDIO_DPSM_Enable
) || ((DPSM) == 
SDIO_DPSM_Disable
))

	)

370 #define 
	#SDIO_FLAG_CCRCFAIL
 ((
uint32_t
)0x00000001)

	)

371 #define 
	#SDIO_FLAG_DCRCFAIL
 ((
uint32_t
)0x00000002)

	)

372 #define 
	#SDIO_FLAG_CTIMEOUT
 ((
uint32_t
)0x00000004)

	)

373 #define 
	#SDIO_FLAG_DTIMEOUT
 ((
uint32_t
)0x00000008)

	)

374 #define 
	#SDIO_FLAG_TXUNDERR
 ((
uint32_t
)0x00000010)

	)

375 #define 
	#SDIO_FLAG_RXOVERR
 ((
uint32_t
)0x00000020)

	)

376 #define 
	#SDIO_FLAG_CMDREND
 ((
uint32_t
)0x00000040)

	)

377 #define 
	#SDIO_FLAG_CMDSENT
 ((
uint32_t
)0x00000080)

	)

378 #define 
	#SDIO_FLAG_DATAEND
 ((
uint32_t
)0x00000100)

	)

379 #define 
	#SDIO_FLAG_STBITERR
 ((
uint32_t
)0x00000200)

	)

380 #define 
	#SDIO_FLAG_DBCKEND
 ((
uint32_t
)0x00000400)

	)

381 #define 
	#SDIO_FLAG_CMDACT
 ((
uint32_t
)0x00000800)

	)

382 #define 
	#SDIO_FLAG_TXACT
 ((
uint32_t
)0x00001000)

	)

383 #define 
	#SDIO_FLAG_RXACT
 ((
uint32_t
)0x00002000)

	)

384 #define 
	#SDIO_FLAG_TXFIFOHE
 ((
uint32_t
)0x00004000)

	)

385 #define 
	#SDIO_FLAG_RXFIFOHF
 ((
uint32_t
)0x00008000)

	)

386 #define 
	#SDIO_FLAG_TXFIFOF
 ((
uint32_t
)0x00010000)

	)

387 #define 
	#SDIO_FLAG_RXFIFOF
 ((
uint32_t
)0x00020000)

	)

388 #define 
	#SDIO_FLAG_TXFIFOE
 ((
uint32_t
)0x00040000)

	)

389 #define 
	#SDIO_FLAG_RXFIFOE
 ((
uint32_t
)0x00080000)

	)

390 #define 
	#SDIO_FLAG_TXDAVL
 ((
uint32_t
)0x00100000)

	)

391 #define 
	#SDIO_FLAG_RXDAVL
 ((
uint32_t
)0x00200000)

	)

392 #define 
	#SDIO_FLAG_SDIOIT
 ((
uint32_t
)0x00400000)

	)

393 #define 
	#SDIO_FLAG_CEATAEND
 ((
uint32_t
)0x00800000)

	)

394 #define 
	#IS_SDIO_FLAG
(
FLAG
) (((FLAG) == 
SDIO_FLAG_CCRCFAIL
) || \

	)

395 ((
FLAG
) == 
SDIO_FLAG_DCRCFAIL
) || \

396 ((
FLAG
) == 
SDIO_FLAG_CTIMEOUT
) || \

397 ((
FLAG
) == 
SDIO_FLAG_DTIMEOUT
) || \

398 ((
FLAG
) == 
SDIO_FLAG_TXUNDERR
) || \

399 ((
FLAG
) == 
SDIO_FLAG_RXOVERR
) || \

400 ((
FLAG
) == 
SDIO_FLAG_CMDREND
) || \

401 ((
FLAG
) == 
SDIO_FLAG_CMDSENT
) || \

402 ((
FLAG
) == 
SDIO_FLAG_DATAEND
) || \

403 ((
FLAG
) == 
SDIO_FLAG_STBITERR
) || \

404 ((
FLAG
) == 
SDIO_FLAG_DBCKEND
) || \

405 ((
FLAG
) == 
SDIO_FLAG_CMDACT
) || \

406 ((
FLAG
) == 
SDIO_FLAG_TXACT
) || \

407 ((
FLAG
) == 
SDIO_FLAG_RXACT
) || \

408 ((
FLAG
) == 
SDIO_FLAG_TXFIFOHE
) || \

409 ((
FLAG
) == 
SDIO_FLAG_RXFIFOHF
) || \

410 ((
FLAG
) == 
SDIO_FLAG_TXFIFOF
) || \

411 ((
FLAG
) == 
SDIO_FLAG_RXFIFOF
) || \

412 ((
FLAG
) == 
SDIO_FLAG_TXFIFOE
) || \

413 ((
FLAG
) == 
SDIO_FLAG_RXFIFOE
) || \

414 ((
FLAG
) == 
SDIO_FLAG_TXDAVL
) || \

415 ((
FLAG
) == 
SDIO_FLAG_RXDAVL
) || \

416 ((
FLAG
) == 
SDIO_FLAG_SDIOIT
) || \

417 ((
FLAG
) == 
SDIO_FLAG_CEATAEND
))

419 #define 
	#IS_SDIO_CLEAR_FLAG
(
FLAG
) ((((FLAG) & (
uint32_t
)0xFF3FF800) == 0x00) && ((FLAG) != (uint32_t)0x00))

	)

421 #define 
	#IS_SDIO_GET_IT
(
IT
) (((IT) == 
SDIO_IT_CCRCFAIL
) || \

	)

422 ((
IT
) == 
SDIO_IT_DCRCFAIL
) || \

423 ((
IT
) == 
SDIO_IT_CTIMEOUT
) || \

424 ((
IT
) == 
SDIO_IT_DTIMEOUT
) || \

425 ((
IT
) == 
SDIO_IT_TXUNDERR
) || \

426 ((
IT
) == 
SDIO_IT_RXOVERR
) || \

427 ((
IT
) == 
SDIO_IT_CMDREND
) || \

428 ((
IT
) == 
SDIO_IT_CMDSENT
) || \

429 ((
IT
) == 
SDIO_IT_DATAEND
) || \

430 ((
IT
) == 
SDIO_IT_STBITERR
) || \

431 ((
IT
) == 
SDIO_IT_DBCKEND
) || \

432 ((
IT
) == 
SDIO_IT_CMDACT
) || \

433 ((
IT
) == 
SDIO_IT_TXACT
) || \

434 ((
IT
) == 
SDIO_IT_RXACT
) || \

435 ((
IT
) == 
SDIO_IT_TXFIFOHE
) || \

436 ((
IT
) == 
SDIO_IT_RXFIFOHF
) || \

437 ((
IT
) == 
SDIO_IT_TXFIFOF
) || \

438 ((
IT
) == 
SDIO_IT_RXFIFOF
) || \

439 ((
IT
) == 
SDIO_IT_TXFIFOE
) || \

440 ((
IT
) == 
SDIO_IT_RXFIFOE
) || \

441 ((
IT
) == 
SDIO_IT_TXDAVL
) || \

442 ((
IT
) == 
SDIO_IT_RXDAVL
) || \

443 ((
IT
) == 
SDIO_IT_SDIOIT
) || \

444 ((
IT
) == 
SDIO_IT_CEATAEND
))

446 #define 
	#IS_SDIO_CLEAR_IT
(
IT
) ((((IT) & (
uint32_t
)0xFF3FF800) == 0x00) && ((IT) != (uint32_t)0x00))

	)

456 #define 
	#SDIO_ReadWaitMode_CLK
 ((
uint32_t
)0x00000000)

	)

457 #define 
	#SDIO_ReadWaitMode_DATA2
 ((
uint32_t
)0x00000001)

	)

458 #define 
	#IS_SDIO_READWAIT_MODE
(
MODE
) (((MODE) == 
SDIO_ReadWaitMode_CLK
) || \

	)

459 ((
MODE
) == 
SDIO_ReadWaitMode_DATA2
))

471 void 
SDIO_DeInit
(void);

474 void 
SDIO_Init
(
SDIO_InitTypeDef
* 
SDIO_InitStruct
);

475 void 
SDIO_StructInit
(
SDIO_InitTypeDef
* 
SDIO_InitStruct
);

476 void 
SDIO_ClockCmd
(
FunctionalState
 
NewState
);

477 void 
SDIO_SetPowerState
(
uint32_t
 
SDIO_PowerState
);

478 
uint32_t
 
SDIO_GetPowerState
(void);

481 void 
SDIO_SendCommand
(
SDIO_CmdInitTypeDef
 *
SDIO_CmdInitStruct
);

482 void 
SDIO_CmdStructInit
(
SDIO_CmdInitTypeDef
* 
SDIO_CmdInitStruct
);

483 
uint8_t
 
SDIO_GetCommandResponse
(void);

484 
uint32_t
 
SDIO_GetResponse
(uint32_t 
SDIO_RESP
);

487 void 
SDIO_DataConfig
(
SDIO_DataInitTypeDef
* 
SDIO_DataInitStruct
);

488 void 
SDIO_DataStructInit
(
SDIO_DataInitTypeDef
* 
SDIO_DataInitStruct
);

489 
uint32_t
 
SDIO_GetDataCounter
(void);

490 
uint32_t
 
SDIO_ReadData
(void);

491 void 
SDIO_WriteData
(
uint32_t
 
Data
);

492 
uint32_t
 
SDIO_GetFIFOCount
(void);

495 void 
SDIO_StartSDIOReadWait
(
FunctionalState
 
NewState
);

496 void 
SDIO_StopSDIOReadWait
(
FunctionalState
 
NewState
);

497 void 
SDIO_SetSDIOReadWaitMode
(
uint32_t
 
SDIO_ReadWaitMode
);

498 void 
SDIO_SetSDIOOperation
(
FunctionalState
 
NewState
);

499 void 
SDIO_SendSDIOSuspendCmd
(
FunctionalState
 
NewState
);

502 void 
SDIO_CommandCompletionCmd
(
FunctionalState
 
NewState
);

503 void 
SDIO_CEATAITCmd
(
FunctionalState
 
NewState
);

504 void 
SDIO_SendCEATACmd
(
FunctionalState
 
NewState
);

507 void 
SDIO_DMACmd
(
FunctionalState
 
NewState
);

510 void 
SDIO_ITConfig
(
uint32_t
 
SDIO_IT
, 
FunctionalState
 
NewState
);

511 
FlagStatus
 
SDIO_GetFlagStatus
(
uint32_t
 
SDIO_FLAG
);

512 void 
SDIO_ClearFlag
(
uint32_t
 
SDIO_FLAG
);

513 
ITStatus
 
SDIO_GetITStatus
(
uint32_t
 
SDIO_IT
);

514 void 
SDIO_ClearITPendingBit
(
uint32_t
 
SDIO_IT
);

516 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_spi.h

24 #ifndef 
__STM32F4xx_SPI_H


25 #define 
	#__STM32F4xx_SPI_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

50 
uint16_t
 
SPI_Direction
;

53 
uint16_t
 
SPI_Mode
;

56 
uint16_t
 
SPI_DataSize
;

59 
uint16_t
 
SPI_CPOL
;

62 
uint16_t
 
SPI_CPHA
;

65 
uint16_t
 
SPI_NSS
;

69 
uint16_t
 
SPI_BaudRatePrescaler
;

75 
uint16_t
 
SPI_FirstBit
;

78 
uint16_t
 
SPI_CRCPolynomial
;

79 }
	tSPI_InitTypeDef
;

88 
uint16_t
 
I2S_Mode
;

91 
uint16_t
 
I2S_Standard
;

94 
uint16_t
 
I2S_DataFormat
;

97 
uint16_t
 
I2S_MCLKOutput
;

100 
uint32_t
 
I2S_AudioFreq
;

103 
uint16_t
 
I2S_CPOL
;

105 }
	tI2S_InitTypeDef
;

113 #define 
	#IS_SPI_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
SPI1
) || \

	)

114 ((
PERIPH
) == 
SPI2
) || \

115 ((
PERIPH
) == 
SPI3
))

117 #define 
	#IS_SPI_ALL_PERIPH_EXT
(
PERIPH
) (((PERIPH) == 
SPI1
) || \

	)

118 ((
PERIPH
) == 
SPI2
) || \

119 ((
PERIPH
) == 
SPI3
) || \

120 ((
PERIPH
) == 
I2S2ext
) || \

121 ((
PERIPH
) == 
I2S3ext
))

123 #define 
	#IS_SPI_23_PERIPH
(
PERIPH
) (((PERIPH) == 
SPI2
) || \

	)

124 ((
PERIPH
) == 
SPI3
))

126 #define 
	#IS_SPI_23_PERIPH_EXT
(
PERIPH
) (((PERIPH) == 
SPI2
) || \

	)

127 ((
PERIPH
) == 
SPI3
) || \

128 ((
PERIPH
) == 
I2S2ext
) || \

129 ((
PERIPH
) == 
I2S3ext
))

131 #define 
	#IS_I2S_EXT_PERIPH
(
PERIPH
) (((PERIPH) == 
I2S2ext
) || \

	)

132 ((
PERIPH
) == 
I2S2ext
))

139 #define 
	#SPI_Direction_2Lines_FullDuplex
 ((
uint16_t
)0x0000)

	)

140 #define 
	#SPI_Direction_2Lines_RxOnly
 ((
uint16_t
)0x0400)

	)

141 #define 
	#SPI_Direction_1Line_Rx
 ((
uint16_t
)0x8000)

	)

142 #define 
	#SPI_Direction_1Line_Tx
 ((
uint16_t
)0xC000)

	)

143 #define 
	#IS_SPI_DIRECTION_MODE
(
MODE
) (((MODE) == 
SPI_Direction_2Lines_FullDuplex
) || \

	)

144 ((
MODE
) == 
SPI_Direction_2Lines_RxOnly
) || \

145 ((
MODE
) == 
SPI_Direction_1Line_Rx
) || \

146 ((
MODE
) == 
SPI_Direction_1Line_Tx
))

155 #define 
	#SPI_Mode_Master
 ((
uint16_t
)0x0104)

	)

156 #define 
	#SPI_Mode_Slave
 ((
uint16_t
)0x0000)

	)

157 #define 
	#IS_SPI_MODE
(
MODE
) (((MODE) == 
SPI_Mode_Master
) || \

	)

158 ((
MODE
) == 
SPI_Mode_Slave
))

167 #define 
	#SPI_DataSize_16b
 ((
uint16_t
)0x0800)

	)

168 #define 
	#SPI_DataSize_8b
 ((
uint16_t
)0x0000)

	)

169 #define 
	#IS_SPI_DATASIZE
(
DATASIZE
) (((DATASIZE) == 
SPI_DataSize_16b
) || \

	)

170 ((
DATASIZE
) == 
SPI_DataSize_8b
))

179 #define 
	#SPI_CPOL_Low
 ((
uint16_t
)0x0000)

	)

180 #define 
	#SPI_CPOL_High
 ((
uint16_t
)0x0002)

	)

181 #define 
	#IS_SPI_CPOL
(
CPOL
) (((CPOL) == 
SPI_CPOL_Low
) || \

	)

182 ((
CPOL
) == 
SPI_CPOL_High
))

191 #define 
	#SPI_CPHA_1Edge
 ((
uint16_t
)0x0000)

	)

192 #define 
	#SPI_CPHA_2Edge
 ((
uint16_t
)0x0001)

	)

193 #define 
	#IS_SPI_CPHA
(
CPHA
) (((CPHA) == 
SPI_CPHA_1Edge
) || \

	)

194 ((
CPHA
) == 
SPI_CPHA_2Edge
))

203 #define 
	#SPI_NSS_Soft
 ((
uint16_t
)0x0200)

	)

204 #define 
	#SPI_NSS_Hard
 ((
uint16_t
)0x0000)

	)

205 #define 
	#IS_SPI_NSS
(
NSS
) (((NSS) == 
SPI_NSS_Soft
) || \

	)

206 ((
NSS
) == 
SPI_NSS_Hard
))

215 #define 
	#SPI_BaudRatePrescaler_2
 ((
uint16_t
)0x0000)

	)

216 #define 
	#SPI_BaudRatePrescaler_4
 ((
uint16_t
)0x0008)

	)

217 #define 
	#SPI_BaudRatePrescaler_8
 ((
uint16_t
)0x0010)

	)

218 #define 
	#SPI_BaudRatePrescaler_16
 ((
uint16_t
)0x0018)

	)

219 #define 
	#SPI_BaudRatePrescaler_32
 ((
uint16_t
)0x0020)

	)

220 #define 
	#SPI_BaudRatePrescaler_64
 ((
uint16_t
)0x0028)

	)

221 #define 
	#SPI_BaudRatePrescaler_128
 ((
uint16_t
)0x0030)

	)

222 #define 
	#SPI_BaudRatePrescaler_256
 ((
uint16_t
)0x0038)

	)

223 #define 
	#IS_SPI_BAUDRATE_PRESCALER
(
PRESCALER
) (((PRESCALER) == 
SPI_BaudRatePrescaler_2
) || \

	)

224 ((
PRESCALER
) == 
SPI_BaudRatePrescaler_4
) || \

225 ((
PRESCALER
) == 
SPI_BaudRatePrescaler_8
) || \

226 ((
PRESCALER
) == 
SPI_BaudRatePrescaler_16
) || \

227 ((
PRESCALER
) == 
SPI_BaudRatePrescaler_32
) || \

228 ((
PRESCALER
) == 
SPI_BaudRatePrescaler_64
) || \

229 ((
PRESCALER
) == 
SPI_BaudRatePrescaler_128
) || \

230 ((
PRESCALER
) == 
SPI_BaudRatePrescaler_256
))

239 #define 
	#SPI_FirstBit_MSB
 ((
uint16_t
)0x0000)

	)

240 #define 
	#SPI_FirstBit_LSB
 ((
uint16_t
)0x0080)

	)

241 #define 
	#IS_SPI_FIRST_BIT
(
BIT
) (((BIT) == 
SPI_FirstBit_MSB
) || \

	)

242 ((
BIT
) == 
SPI_FirstBit_LSB
))

251 #define 
	#I2S_Mode_SlaveTx
 ((
uint16_t
)0x0000)

	)

252 #define 
	#I2S_Mode_SlaveRx
 ((
uint16_t
)0x0100)

	)

253 #define 
	#I2S_Mode_MasterTx
 ((
uint16_t
)0x0200)

	)

254 #define 
	#I2S_Mode_MasterRx
 ((
uint16_t
)0x0300)

	)

255 #define 
	#IS_I2S_MODE
(
MODE
) (((MODE) == 
I2S_Mode_SlaveTx
) || \

	)

256 ((
MODE
) == 
I2S_Mode_SlaveRx
) || \

257 ((
MODE
) == 
I2S_Mode_MasterTx
)|| \

258 ((
MODE
) == 
I2S_Mode_MasterRx
))

268 #define 
	#I2S_Standard_Phillips
 ((
uint16_t
)0x0000)

	)

269 #define 
	#I2S_Standard_MSB
 ((
uint16_t
)0x0010)

	)

270 #define 
	#I2S_Standard_LSB
 ((
uint16_t
)0x0020)

	)

271 #define 
	#I2S_Standard_PCMShort
 ((
uint16_t
)0x0030)

	)

272 #define 
	#I2S_Standard_PCMLong
 ((
uint16_t
)0x00B0)

	)

273 #define 
	#IS_I2S_STANDARD
(
STANDARD
) (((STANDARD) == 
I2S_Standard_Phillips
) || \

	)

274 ((
STANDARD
) == 
I2S_Standard_MSB
) || \

275 ((
STANDARD
) == 
I2S_Standard_LSB
) || \

276 ((
STANDARD
) == 
I2S_Standard_PCMShort
) || \

277 ((
STANDARD
) == 
I2S_Standard_PCMLong
))

286 #define 
	#I2S_DataFormat_16b
 ((
uint16_t
)0x0000)

	)

287 #define 
	#I2S_DataFormat_16bextended
 ((
uint16_t
)0x0001)

	)

288 #define 
	#I2S_DataFormat_24b
 ((
uint16_t
)0x0003)

	)

289 #define 
	#I2S_DataFormat_32b
 ((
uint16_t
)0x0005)

	)

290 #define 
	#IS_I2S_DATA_FORMAT
(
FORMAT
) (((FORMAT) == 
I2S_DataFormat_16b
) || \

	)

291 ((
FORMAT
) == 
I2S_DataFormat_16bextended
) || \

292 ((
FORMAT
) == 
I2S_DataFormat_24b
) || \

293 ((
FORMAT
) == 
I2S_DataFormat_32b
))

302 #define 
	#I2S_MCLKOutput_Enable
 ((
uint16_t
)0x0200)

	)

303 #define 
	#I2S_MCLKOutput_Disable
 ((
uint16_t
)0x0000)

	)

304 #define 
	#IS_I2S_MCLK_OUTPUT
(
OUTPUT
) (((OUTPUT) == 
I2S_MCLKOutput_Enable
) || \

	)

305 ((
OUTPUT
) == 
I2S_MCLKOutput_Disable
))

314 #define 
	#I2S_AudioFreq_192k
 ((
uint32_t
)192000)

	)

315 #define 
	#I2S_AudioFreq_96k
 ((
uint32_t
)96000)

	)

316 #define 
	#I2S_AudioFreq_48k
 ((
uint32_t
)48000)

	)

317 #define 
	#I2S_AudioFreq_44k
 ((
uint32_t
)44100)

	)

318 #define 
	#I2S_AudioFreq_32k
 ((
uint32_t
)32000)

	)

319 #define 
	#I2S_AudioFreq_22k
 ((
uint32_t
)22050)

	)

320 #define 
	#I2S_AudioFreq_16k
 ((
uint32_t
)16000)

	)

321 #define 
	#I2S_AudioFreq_11k
 ((
uint32_t
)11025)

	)

322 #define 
	#I2S_AudioFreq_8k
 ((
uint32_t
)8000)

	)

323 #define 
	#I2S_AudioFreq_Default
 ((
uint32_t
)2)

	)

325 #define 
	#IS_I2S_AUDIO_FREQ
(
FREQ
) ((((FREQ) >= 
I2S_AudioFreq_8k
) && \

	)

326 ((
FREQ
) <= 
I2S_AudioFreq_192k
)) || \

327 ((
FREQ
) == 
I2S_AudioFreq_Default
))

336 #define 
	#I2S_CPOL_Low
 ((
uint16_t
)0x0000)

	)

337 #define 
	#I2S_CPOL_High
 ((
uint16_t
)0x0008)

	)

338 #define 
	#IS_I2S_CPOL
(
CPOL
) (((CPOL) == 
I2S_CPOL_Low
) || \

	)

339 ((
CPOL
) == 
I2S_CPOL_High
))

348 #define 
	#SPI_I2S_DMAReq_Tx
 ((
uint16_t
)0x0002)

	)

349 #define 
	#SPI_I2S_DMAReq_Rx
 ((
uint16_t
)0x0001)

	)

350 #define 
	#IS_SPI_I2S_DMAREQ
(
DMAREQ
) ((((DMAREQ) & (
uint16_t
)0xFFFC) == 0x00) && ((DMAREQ) != 0x00))

	)

359 #define 
	#SPI_NSSInternalSoft_Set
 ((
uint16_t
)0x0100)

	)

360 #define 
	#SPI_NSSInternalSoft_Reset
 ((
uint16_t
)0xFEFF)

	)

361 #define 
	#IS_SPI_NSS_INTERNAL
(
INTERNAL
) (((INTERNAL) == 
SPI_NSSInternalSoft_Set
) || \

	)

362 ((
INTERNAL
) == 
SPI_NSSInternalSoft_Reset
))

371 #define 
	#SPI_CRC_Tx
 ((
uint8_t
)0x00)

	)

372 #define 
	#SPI_CRC_Rx
 ((
uint8_t
)0x01)

	)

373 #define 
	#IS_SPI_CRC
(
CRC
) (((CRC) == 
SPI_CRC_Tx
) || ((CRC) == 
SPI_CRC_Rx
))

	)

382 #define 
	#SPI_Direction_Rx
 ((
uint16_t
)0xBFFF)

	)

383 #define 
	#SPI_Direction_Tx
 ((
uint16_t
)0x4000)

	)

384 #define 
	#IS_SPI_DIRECTION
(
DIRECTION
) (((DIRECTION) == 
SPI_Direction_Rx
) || \

	)

385 ((
DIRECTION
) == 
SPI_Direction_Tx
))

394 #define 
	#SPI_I2S_IT_TXE
 ((
uint8_t
)0x71)

	)

395 #define 
	#SPI_I2S_IT_RXNE
 ((
uint8_t
)0x60)

	)

396 #define 
	#SPI_I2S_IT_ERR
 ((
uint8_t
)0x50)

	)

397 #define 
	#I2S_IT_UDR
 ((
uint8_t
)0x53)

	)

398 #define 
	#SPI_I2S_IT_TIFRFE
 ((
uint8_t
)0x58)

	)

400 #define 
	#IS_SPI_I2S_CONFIG_IT
(
IT
) (((IT) == 
SPI_I2S_IT_TXE
) || \

	)

401 ((
IT
) == 
SPI_I2S_IT_RXNE
) || \

402 ((
IT
) == 
SPI_I2S_IT_ERR
))

404 #define 
	#SPI_I2S_IT_OVR
 ((
uint8_t
)0x56)

	)

405 #define 
	#SPI_IT_MODF
 ((
uint8_t
)0x55)

	)

406 #define 
	#SPI_IT_CRCERR
 ((
uint8_t
)0x54)

	)

408 #define 
	#IS_SPI_I2S_CLEAR_IT
(
IT
) (((IT) == 
SPI_IT_CRCERR
))

	)

410 #define 
	#IS_SPI_I2S_GET_IT
(
IT
) (((IT) == 
SPI_I2S_IT_RXNE
)|| ((IT) == 
SPI_I2S_IT_TXE
) || \

	)

411 ((
IT
) == 
SPI_IT_CRCERR
) || ((IT) == 
SPI_IT_MODF
) || \

412 ((
IT
) == 
SPI_I2S_IT_OVR
) || ((IT) == 
I2S_IT_UDR
) ||\

413 ((
IT
) == 
SPI_I2S_IT_TIFRFE
))

422 #define 
	#SPI_I2S_FLAG_RXNE
 ((
uint16_t
)0x0001)

	)

423 #define 
	#SPI_I2S_FLAG_TXE
 ((
uint16_t
)0x0002)

	)

424 #define 
	#I2S_FLAG_CHSIDE
 ((
uint16_t
)0x0004)

	)

425 #define 
	#I2S_FLAG_UDR
 ((
uint16_t
)0x0008)

	)

426 #define 
	#SPI_FLAG_CRCERR
 ((
uint16_t
)0x0010)

	)

427 #define 
	#SPI_FLAG_MODF
 ((
uint16_t
)0x0020)

	)

428 #define 
	#SPI_I2S_FLAG_OVR
 ((
uint16_t
)0x0040)

	)

429 #define 
	#SPI_I2S_FLAG_BSY
 ((
uint16_t
)0x0080)

	)

430 #define 
	#SPI_I2S_FLAG_TIFRFE
 ((
uint16_t
)0x0100)

	)

432 #define 
	#IS_SPI_I2S_CLEAR_FLAG
(
FLAG
) (((FLAG) == 
SPI_FLAG_CRCERR
))

	)

433 #define 
	#IS_SPI_I2S_GET_FLAG
(
FLAG
) (((FLAG) == 
SPI_I2S_FLAG_BSY
) || ((FLAG) == 
SPI_I2S_FLAG_OVR
) || \

	)

434 ((
FLAG
) == 
SPI_FLAG_MODF
) || ((FLAG) == 
SPI_FLAG_CRCERR
) || \

435 ((
FLAG
) == 
I2S_FLAG_UDR
) || ((FLAG) == 
I2S_FLAG_CHSIDE
) || \

436 ((
FLAG
) == 
SPI_I2S_FLAG_TXE
) || ((FLAG) == 
SPI_I2S_FLAG_RXNE
)|| \

437 ((
FLAG
) == 
SPI_I2S_FLAG_TIFRFE
))

446 #define 
	#IS_SPI_CRC_POLYNOMIAL
(
POLYNOMIAL
) ((POLYNOMIAL) >= 0x1)

	)

455 #define 
	#SPI_DMAReq_Tx
 
SPI_I2S_DMAReq_Tx


	)

456 #define 
	#SPI_DMAReq_Rx
 
SPI_I2S_DMAReq_Rx


	)

457 #define 
	#SPI_IT_TXE
 
SPI_I2S_IT_TXE


	)

458 #define 
	#SPI_IT_RXNE
 
SPI_I2S_IT_RXNE


	)

459 #define 
	#SPI_IT_ERR
 
SPI_I2S_IT_ERR


	)

460 #define 
	#SPI_IT_OVR
 
SPI_I2S_IT_OVR


	)

461 #define 
	#SPI_FLAG_RXNE
 
SPI_I2S_FLAG_RXNE


	)

462 #define 
	#SPI_FLAG_TXE
 
SPI_I2S_FLAG_TXE


	)

463 #define 
	#SPI_FLAG_OVR
 
SPI_I2S_FLAG_OVR


	)

464 #define 
	#SPI_FLAG_BSY
 
SPI_I2S_FLAG_BSY


	)

465 #define 
	#SPI_DeInit
 
SPI_I2S_DeInit


	)

466 #define 
	#SPI_ITConfig
 
SPI_I2S_ITConfig


	)

467 #define 
	#SPI_DMACmd
 
SPI_I2S_DMACmd


	)

468 #define 
	#SPI_SendData
 
SPI_I2S_SendData


	)

469 #define 
	#SPI_ReceiveData
 
SPI_I2S_ReceiveData


	)

470 #define 
	#SPI_GetFlagStatus
 
SPI_I2S_GetFlagStatus


	)

471 #define 
	#SPI_ClearFlag
 
SPI_I2S_ClearFlag


	)

472 #define 
	#SPI_GetITStatus
 
SPI_I2S_GetITStatus


	)

473 #define 
	#SPI_ClearITPendingBit
 
SPI_I2S_ClearITPendingBit


	)

486 void 
SPI_I2S_DeInit
(
SPI_TypeDef
* 
SPIx
);

489 void 
SPI_Init
(
SPI_TypeDef
* 
SPIx
, 
SPI_InitTypeDef
* 
SPI_InitStruct
);

490 void 
I2S_Init
(
SPI_TypeDef
* 
SPIx
, 
I2S_InitTypeDef
* 
I2S_InitStruct
);

491 void 
SPI_StructInit
(
SPI_InitTypeDef
* 
SPI_InitStruct
);

492 void 
I2S_StructInit
(
I2S_InitTypeDef
* 
I2S_InitStruct
);

493 void 
SPI_Cmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
);

494 void 
I2S_Cmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
);

495 void 
SPI_DataSizeConfig
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_DataSize
);

496 void 
SPI_BiDirectionalLineConfig
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_Direction
);

497 void 
SPI_NSSInternalSoftwareConfig
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_NSSInternalSoft
);

498 void 
SPI_SSOutputCmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
);

499 void 
SPI_TIModeCmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
);

501 void 
I2S_FullDuplexConfig
(
SPI_TypeDef
* 
I2Sxext
, 
I2S_InitTypeDef
* 
I2S_InitStruct
);

504 void 
SPI_I2S_SendData
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
Data
);

505 
uint16_t
 
SPI_I2S_ReceiveData
(
SPI_TypeDef
* 
SPIx
);

508 void 
SPI_CalculateCRC
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
);

509 void 
SPI_TransmitCRC
(
SPI_TypeDef
* 
SPIx
);

510 
uint16_t
 
SPI_GetCRC
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_CRC
);

511 
uint16_t
 
SPI_GetCRCPolynomial
(
SPI_TypeDef
* 
SPIx
);

514 void 
SPI_I2S_DMACmd
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_I2S_DMAReq
, 
FunctionalState
 
NewState
);

517 void 
SPI_I2S_ITConfig
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_I2S_IT
, 
FunctionalState
 
NewState
);

518 
FlagStatus
 
SPI_I2S_GetFlagStatus
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_I2S_FLAG
);

519 void 
SPI_I2S_ClearFlag
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_I2S_FLAG
);

520 
ITStatus
 
SPI_I2S_GetITStatus
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_I2S_IT
);

521 void 
SPI_I2S_ClearITPendingBit
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_I2S_IT
);

523 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_syscfg.h

24 #ifndef 
__STM32F4xx_SYSCFG_H


25 #define 
	#__STM32F4xx_SYSCFG_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

52 #define 
	#EXTI_PortSourceGPIOA
 ((
uint8_t
)0x00)

	)

53 #define 
	#EXTI_PortSourceGPIOB
 ((
uint8_t
)0x01)

	)

54 #define 
	#EXTI_PortSourceGPIOC
 ((
uint8_t
)0x02)

	)

55 #define 
	#EXTI_PortSourceGPIOD
 ((
uint8_t
)0x03)

	)

56 #define 
	#EXTI_PortSourceGPIOE
 ((
uint8_t
)0x04)

	)

57 #define 
	#EXTI_PortSourceGPIOF
 ((
uint8_t
)0x05)

	)

58 #define 
	#EXTI_PortSourceGPIOG
 ((
uint8_t
)0x06)

	)

59 #define 
	#EXTI_PortSourceGPIOH
 ((
uint8_t
)0x07)

	)

60 #define 
	#EXTI_PortSourceGPIOI
 ((
uint8_t
)0x08)

	)

62 #define 
	#IS_EXTI_PORT_SOURCE
(
PORTSOURCE
) (((PORTSOURCE) == 
EXTI_PortSourceGPIOA
) || \

	)

63 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOB
) || \

64 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOC
) || \

65 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOD
) || \

66 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOE
) || \

67 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOF
) || \

68 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOG
) || \

69 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOH
) || \

70 ((
PORTSOURCE
) == 
EXTI_PortSourceGPIOI
))

79 #define 
	#EXTI_PinSource0
 ((
uint8_t
)0x00)

	)

80 #define 
	#EXTI_PinSource1
 ((
uint8_t
)0x01)

	)

81 #define 
	#EXTI_PinSource2
 ((
uint8_t
)0x02)

	)

82 #define 
	#EXTI_PinSource3
 ((
uint8_t
)0x03)

	)

83 #define 
	#EXTI_PinSource4
 ((
uint8_t
)0x04)

	)

84 #define 
	#EXTI_PinSource5
 ((
uint8_t
)0x05)

	)

85 #define 
	#EXTI_PinSource6
 ((
uint8_t
)0x06)

	)

86 #define 
	#EXTI_PinSource7
 ((
uint8_t
)0x07)

	)

87 #define 
	#EXTI_PinSource8
 ((
uint8_t
)0x08)

	)

88 #define 
	#EXTI_PinSource9
 ((
uint8_t
)0x09)

	)

89 #define 
	#EXTI_PinSource10
 ((
uint8_t
)0x0A)

	)

90 #define 
	#EXTI_PinSource11
 ((
uint8_t
)0x0B)

	)

91 #define 
	#EXTI_PinSource12
 ((
uint8_t
)0x0C)

	)

92 #define 
	#EXTI_PinSource13
 ((
uint8_t
)0x0D)

	)

93 #define 
	#EXTI_PinSource14
 ((
uint8_t
)0x0E)

	)

94 #define 
	#EXTI_PinSource15
 ((
uint8_t
)0x0F)

	)

95 #define 
	#IS_EXTI_PIN_SOURCE
(
PINSOURCE
) (((PINSOURCE) == 
EXTI_PinSource0
) || \

	)

96 ((
PINSOURCE
) == 
EXTI_PinSource1
) || \

97 ((
PINSOURCE
) == 
EXTI_PinSource2
) || \

98 ((
PINSOURCE
) == 
EXTI_PinSource3
) || \

99 ((
PINSOURCE
) == 
EXTI_PinSource4
) || \

100 ((
PINSOURCE
) == 
EXTI_PinSource5
) || \

101 ((
PINSOURCE
) == 
EXTI_PinSource6
) || \

102 ((
PINSOURCE
) == 
EXTI_PinSource7
) || \

103 ((
PINSOURCE
) == 
EXTI_PinSource8
) || \

104 ((
PINSOURCE
) == 
EXTI_PinSource9
) || \

105 ((
PINSOURCE
) == 
EXTI_PinSource10
) || \

106 ((
PINSOURCE
) == 
EXTI_PinSource11
) || \

107 ((
PINSOURCE
) == 
EXTI_PinSource12
) || \

108 ((
PINSOURCE
) == 
EXTI_PinSource13
) || \

109 ((
PINSOURCE
) == 
EXTI_PinSource14
) || \

110 ((
PINSOURCE
) == 
EXTI_PinSource15
))

119 #define 
	#SYSCFG_MemoryRemap_Flash
 ((
uint8_t
)0x00)

	)

120 #define 
	#SYSCFG_MemoryRemap_SystemFlash
 ((
uint8_t
)0x01)

	)

121 #define 
	#SYSCFG_MemoryRemap_FSMC
 ((
uint8_t
)0x02)

	)

122 #define 
	#SYSCFG_MemoryRemap_SRAM
 ((
uint8_t
)0x03)

	)

124 #define 
	#IS_SYSCFG_MEMORY_REMAP_CONFING
(
REMAP
) (((REMAP) == 
SYSCFG_MemoryRemap_Flash
) || \

	)

125 ((
REMAP
) == 
SYSCFG_MemoryRemap_SystemFlash
) || \

126 ((
REMAP
) == 
SYSCFG_MemoryRemap_SRAM
) || \

127 ((
REMAP
) == 
SYSCFG_MemoryRemap_FSMC
))

136 #define 
	#SYSCFG_ETH_MediaInterface_MII
 ((
uint32_t
)0x00000000)

	)

137 #define 
	#SYSCFG_ETH_MediaInterface_RMII
 ((
uint32_t
)0x00000001)

	)

139 #define 
	#IS_SYSCFG_ETH_MEDIA_INTERFACE
(
INTERFACE
) (((INTERFACE) == 
SYSCFG_ETH_MediaInterface_MII
) || \

	)

140 ((
INTERFACE
) == 
SYSCFG_ETH_MediaInterface_RMII
))

152 void 
SYSCFG_DeInit
(void);

153 void 
SYSCFG_MemoryRemapConfig
(
uint8_t
 
SYSCFG_MemoryRemap
);

154 void 
SYSCFG_EXTILineConfig
(
uint8_t
 
EXTI_PortSourceGPIOx
, uint8_t 
EXTI_PinSourcex
);

155 void 
SYSCFG_ETH_MediaInterfaceConfig
(
uint32_t
 
SYSCFG_ETH_MediaInterface
);

156 void 
SYSCFG_CompensationCellCmd
(
FunctionalState
 
NewState
);

157 
FlagStatus
 
SYSCFG_GetCompensationCellStatus
(void);

159 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h

24 #ifndef 
__STM32F4xx_TIM_H


25 #define 
	#__STM32F4xx_TIM_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

51 
uint16_t
 
TIM_Prescaler
;

54 
uint16_t
 
TIM_CounterMode
;

57 
uint32_t
 
TIM_Period
;

61 
uint16_t
 
TIM_ClockDivision
;

64 
uint8_t
 
TIM_RepetitionCounter
;

72 } 
	tTIM_TimeBaseInitTypeDef
;

80 
uint16_t
 
TIM_OCMode
;

83 
uint16_t
 
TIM_OutputState
;

86 
uint16_t
 
TIM_OutputNState
;

90 
uint32_t
 
TIM_Pulse
;

93 
uint16_t
 
TIM_OCPolarity
;

96 
uint16_t
 
TIM_OCNPolarity
;

100 
uint16_t
 
TIM_OCIdleState
;

104 
uint16_t
 
TIM_OCNIdleState
;

107 } 
	tTIM_OCInitTypeDef
;

116 
uint16_t
 
TIM_Channel
;

119 
uint16_t
 
TIM_ICPolarity
;

122 
uint16_t
 
TIM_ICSelection
;

125 
uint16_t
 
TIM_ICPrescaler
;

128 
uint16_t
 
TIM_ICFilter
;

130 } 
	tTIM_ICInitTypeDef
;

140 
uint16_t
 
TIM_OSSRState
;

143 
uint16_t
 
TIM_OSSIState
;

146 
uint16_t
 
TIM_LOCKLevel
;

149 
uint16_t
 
TIM_DeadTime
;

153 
uint16_t
 
TIM_Break
;

156 
uint16_t
 
TIM_BreakPolarity
;

159 
uint16_t
 
TIM_AutomaticOutput
;

161 } 
	tTIM_BDTRInitTypeDef
;

169 #define 
	#IS_TIM_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
TIM1
) || \

	)

170 ((
PERIPH
) == 
TIM2
) || \

171 ((
PERIPH
) == 
TIM3
) || \

172 ((
PERIPH
) == 
TIM4
) || \

173 ((
PERIPH
) == 
TIM5
) || \

174 ((
PERIPH
) == 
TIM6
) || \

175 ((
PERIPH
) == 
TIM7
) || \

176 ((
PERIPH
) == 
TIM8
) || \

177 ((
PERIPH
) == 
TIM9
) || \

178 ((
PERIPH
) == 
TIM10
) || \

179 ((
PERIPH
) == 
TIM11
) || \

180 ((
PERIPH
) == 
TIM12
) || \

181 (((
PERIPH
) == 
TIM13
) || \

182 ((
PERIPH
) == 
TIM14
)))

184 #define 
	#IS_TIM_LIST1_PERIPH
(
PERIPH
) (((PERIPH) == 
TIM1
) || \

	)

185 ((
PERIPH
) == 
TIM2
) || \

186 ((
PERIPH
) == 
TIM3
) || \

187 ((
PERIPH
) == 
TIM4
) || \

188 ((
PERIPH
) == 
TIM5
) || \

189 ((
PERIPH
) == 
TIM8
) || \

190 ((
PERIPH
) == 
TIM9
) || \

191 ((
PERIPH
) == 
TIM10
) || \

192 ((
PERIPH
) == 
TIM11
) || \

193 ((
PERIPH
) == 
TIM12
) || \

194 ((
PERIPH
) == 
TIM13
) || \

195 ((
PERIPH
) == 
TIM14
))

198 #define 
	#IS_TIM_LIST2_PERIPH
(
PERIPH
) (((PERIPH) == 
TIM1
) || \

	)

199 ((
PERIPH
) == 
TIM2
) || \

200 ((
PERIPH
) == 
TIM3
) || \

201 ((
PERIPH
) == 
TIM4
) || \

202 ((
PERIPH
) == 
TIM5
) || \

203 ((
PERIPH
) == 
TIM8
) || \

204 ((
PERIPH
) == 
TIM9
) || \

205 ((
PERIPH
) == 
TIM12
))

207 #define 
	#IS_TIM_LIST3_PERIPH
(
PERIPH
) (((PERIPH) == 
TIM1
) || \

	)

208 ((
PERIPH
) == 
TIM2
) || \

209 ((
PERIPH
) == 
TIM3
) || \

210 ((
PERIPH
) == 
TIM4
) || \

211 ((
PERIPH
) == 
TIM5
) || \

212 ((
PERIPH
) == 
TIM8
))

214 #define 
	#IS_TIM_LIST4_PERIPH
(
PERIPH
) (((PERIPH) == 
TIM1
) || \

	)

215 ((
PERIPH
) == 
TIM8
))

217 #define 
	#IS_TIM_LIST5_PERIPH
(
PERIPH
) (((PERIPH) == 
TIM1
) || \

	)

218 ((
PERIPH
) == 
TIM2
) || \

219 ((
PERIPH
) == 
TIM3
) || \

220 ((
PERIPH
) == 
TIM4
) || \

221 ((
PERIPH
) == 
TIM5
) || \

222 ((
PERIPH
) == 
TIM6
) || \

223 ((
PERIPH
) == 
TIM7
) || \

224 ((
PERIPH
) == 
TIM8
))

226 #define 
	#IS_TIM_LIST6_PERIPH
(
TIMx
)(((TIMx) == 
TIM2
) || \

	)

227 ((
TIMx
) == 
TIM5
) || \

228 ((
TIMx
) == 
TIM11
))

234 #define 
	#TIM_OCMode_Timing
 ((
uint16_t
)0x0000)

	)

235 #define 
	#TIM_OCMode_Active
 ((
uint16_t
)0x0010)

	)

236 #define 
	#TIM_OCMode_Inactive
 ((
uint16_t
)0x0020)

	)

237 #define 
	#TIM_OCMode_Toggle
 ((
uint16_t
)0x0030)

	)

238 #define 
	#TIM_OCMode_PWM1
 ((
uint16_t
)0x0060)

	)

239 #define 
	#TIM_OCMode_PWM2
 ((
uint16_t
)0x0070)

	)

240 #define 
	#IS_TIM_OC_MODE
(
MODE
) (((MODE) == 
TIM_OCMode_Timing
) || \

	)

241 ((
MODE
) == 
TIM_OCMode_Active
) || \

242 ((
MODE
) == 
TIM_OCMode_Inactive
) || \

243 ((
MODE
) == 
TIM_OCMode_Toggle
)|| \

244 ((
MODE
) == 
TIM_OCMode_PWM1
) || \

245 ((
MODE
) == 
TIM_OCMode_PWM2
))

246 #define 
	#IS_TIM_OCM
(
MODE
) (((MODE) == 
TIM_OCMode_Timing
) || \

	)

247 ((
MODE
) == 
TIM_OCMode_Active
) || \

248 ((
MODE
) == 
TIM_OCMode_Inactive
) || \

249 ((
MODE
) == 
TIM_OCMode_Toggle
)|| \

250 ((
MODE
) == 
TIM_OCMode_PWM1
) || \

251 ((
MODE
) == 
TIM_OCMode_PWM2
) || \

252 ((
MODE
) == 
TIM_ForcedAction_Active
) || \

253 ((
MODE
) == 
TIM_ForcedAction_InActive
))

262 #define 
	#TIM_OPMode_Single
 ((
uint16_t
)0x0008)

	)

263 #define 
	#TIM_OPMode_Repetitive
 ((
uint16_t
)0x0000)

	)

264 #define 
	#IS_TIM_OPM_MODE
(
MODE
) (((MODE) == 
TIM_OPMode_Single
) || \

	)

265 ((
MODE
) == 
TIM_OPMode_Repetitive
))

274 #define 
	#TIM_Channel_1
 ((
uint16_t
)0x0000)

	)

275 #define 
	#TIM_Channel_2
 ((
uint16_t
)0x0004)

	)

276 #define 
	#TIM_Channel_3
 ((
uint16_t
)0x0008)

	)

277 #define 
	#TIM_Channel_4
 ((
uint16_t
)0x000C)

	)

279 #define 
	#IS_TIM_CHANNEL
(
CHANNEL
) (((CHANNEL) == 
TIM_Channel_1
) || \

	)

280 ((
CHANNEL
) == 
TIM_Channel_2
) || \

281 ((
CHANNEL
) == 
TIM_Channel_3
) || \

282 ((
CHANNEL
) == 
TIM_Channel_4
))

284 #define 
	#IS_TIM_PWMI_CHANNEL
(
CHANNEL
) (((CHANNEL) == 
TIM_Channel_1
) || \

	)

285 ((
CHANNEL
) == 
TIM_Channel_2
))

286 #define 
	#IS_TIM_COMPLEMENTARY_CHANNEL
(
CHANNEL
) (((CHANNEL) == 
TIM_Channel_1
) || \

	)

287 ((
CHANNEL
) == 
TIM_Channel_2
) || \

288 ((
CHANNEL
) == 
TIM_Channel_3
))

297 #define 
	#TIM_CKD_DIV1
 ((
uint16_t
)0x0000)

	)

298 #define 
	#TIM_CKD_DIV2
 ((
uint16_t
)0x0100)

	)

299 #define 
	#TIM_CKD_DIV4
 ((
uint16_t
)0x0200)

	)

300 #define 
	#IS_TIM_CKD_DIV
(
DIV
) (((DIV) == 
TIM_CKD_DIV1
) || \

	)

301 ((
DIV
) == 
TIM_CKD_DIV2
) || \

302 ((
DIV
) == 
TIM_CKD_DIV4
))

311 #define 
	#TIM_CounterMode_Up
 ((
uint16_t
)0x0000)

	)

312 #define 
	#TIM_CounterMode_Down
 ((
uint16_t
)0x0010)

	)

313 #define 
	#TIM_CounterMode_CenterAligned1
 ((
uint16_t
)0x0020)

	)

314 #define 
	#TIM_CounterMode_CenterAligned2
 ((
uint16_t
)0x0040)

	)

315 #define 
	#TIM_CounterMode_CenterAligned3
 ((
uint16_t
)0x0060)

	)

316 #define 
	#IS_TIM_COUNTER_MODE
(
MODE
) (((MODE) == 
TIM_CounterMode_Up
) || \

	)

317 ((
MODE
) == 
TIM_CounterMode_Down
) || \

318 ((
MODE
) == 
TIM_CounterMode_CenterAligned1
) || \

319 ((
MODE
) == 
TIM_CounterMode_CenterAligned2
) || \

320 ((
MODE
) == 
TIM_CounterMode_CenterAligned3
))

329 #define 
	#TIM_OCPolarity_High
 ((
uint16_t
)0x0000)

	)

330 #define 
	#TIM_OCPolarity_Low
 ((
uint16_t
)0x0002)

	)

331 #define 
	#IS_TIM_OC_POLARITY
(
POLARITY
) (((POLARITY) == 
TIM_OCPolarity_High
) || \

	)

332 ((
POLARITY
) == 
TIM_OCPolarity_Low
))

341 #define 
	#TIM_OCNPolarity_High
 ((
uint16_t
)0x0000)

	)

342 #define 
	#TIM_OCNPolarity_Low
 ((
uint16_t
)0x0008)

	)

343 #define 
	#IS_TIM_OCN_POLARITY
(
POLARITY
) (((POLARITY) == 
TIM_OCNPolarity_High
) || \

	)

344 ((
POLARITY
) == 
TIM_OCNPolarity_Low
))

353 #define 
	#TIM_OutputState_Disable
 ((
uint16_t
)0x0000)

	)

354 #define 
	#TIM_OutputState_Enable
 ((
uint16_t
)0x0001)

	)

355 #define 
	#IS_TIM_OUTPUT_STATE
(
STATE
) (((STATE) == 
TIM_OutputState_Disable
) || \

	)

356 ((
STATE
) == 
TIM_OutputState_Enable
))

365 #define 
	#TIM_OutputNState_Disable
 ((
uint16_t
)0x0000)

	)

366 #define 
	#TIM_OutputNState_Enable
 ((
uint16_t
)0x0004)

	)

367 #define 
	#IS_TIM_OUTPUTN_STATE
(
STATE
) (((STATE) == 
TIM_OutputNState_Disable
) || \

	)

368 ((
STATE
) == 
TIM_OutputNState_Enable
))

377 #define 
	#TIM_CCx_Enable
 ((
uint16_t
)0x0001)

	)

378 #define 
	#TIM_CCx_Disable
 ((
uint16_t
)0x0000)

	)

379 #define 
	#IS_TIM_CCX
(
CCX
) (((CCX) == 
TIM_CCx_Enable
) || \

	)

380 ((
CCX
) == 
TIM_CCx_Disable
))

389 #define 
	#TIM_CCxN_Enable
 ((
uint16_t
)0x0004)

	)

390 #define 
	#TIM_CCxN_Disable
 ((
uint16_t
)0x0000)

	)

391 #define 
	#IS_TIM_CCXN
(
CCXN
) (((CCXN) == 
TIM_CCxN_Enable
) || \

	)

392 ((
CCXN
) == 
TIM_CCxN_Disable
))

401 #define 
	#TIM_Break_Enable
 ((
uint16_t
)0x1000)

	)

402 #define 
	#TIM_Break_Disable
 ((
uint16_t
)0x0000)

	)

403 #define 
	#IS_TIM_BREAK_STATE
(
STATE
) (((STATE) == 
TIM_Break_Enable
) || \

	)

404 ((
STATE
) == 
TIM_Break_Disable
))

413 #define 
	#TIM_BreakPolarity_Low
 ((
uint16_t
)0x0000)

	)

414 #define 
	#TIM_BreakPolarity_High
 ((
uint16_t
)0x2000)

	)

415 #define 
	#IS_TIM_BREAK_POLARITY
(
POLARITY
) (((POLARITY) == 
TIM_BreakPolarity_Low
) || \

	)

416 ((
POLARITY
) == 
TIM_BreakPolarity_High
))

425 #define 
	#TIM_AutomaticOutput_Enable
 ((
uint16_t
)0x4000)

	)

426 #define 
	#TIM_AutomaticOutput_Disable
 ((
uint16_t
)0x0000)

	)

427 #define 
	#IS_TIM_AUTOMATIC_OUTPUT_STATE
(
STATE
) (((STATE) == 
TIM_AutomaticOutput_Enable
) || \

	)

428 ((
STATE
) == 
TIM_AutomaticOutput_Disable
))

437 #define 
	#TIM_LOCKLevel_OFF
 ((
uint16_t
)0x0000)

	)

438 #define 
	#TIM_LOCKLevel_1
 ((
uint16_t
)0x0100)

	)

439 #define 
	#TIM_LOCKLevel_2
 ((
uint16_t
)0x0200)

	)

440 #define 
	#TIM_LOCKLevel_3
 ((
uint16_t
)0x0300)

	)

441 #define 
	#IS_TIM_LOCK_LEVEL
(
LEVEL
) (((LEVEL) == 
TIM_LOCKLevel_OFF
) || \

	)

442 ((
LEVEL
) == 
TIM_LOCKLevel_1
) || \

443 ((
LEVEL
) == 
TIM_LOCKLevel_2
) || \

444 ((
LEVEL
) == 
TIM_LOCKLevel_3
))

453 #define 
	#TIM_OSSIState_Enable
 ((
uint16_t
)0x0400)

	)

454 #define 
	#TIM_OSSIState_Disable
 ((
uint16_t
)0x0000)

	)

455 #define 
	#IS_TIM_OSSI_STATE
(
STATE
) (((STATE) == 
TIM_OSSIState_Enable
) || \

	)

456 ((
STATE
) == 
TIM_OSSIState_Disable
))

465 #define 
	#TIM_OSSRState_Enable
 ((
uint16_t
)0x0800)

	)

466 #define 
	#TIM_OSSRState_Disable
 ((
uint16_t
)0x0000)

	)

467 #define 
	#IS_TIM_OSSR_STATE
(
STATE
) (((STATE) == 
TIM_OSSRState_Enable
) || \

	)

468 ((
STATE
) == 
TIM_OSSRState_Disable
))

477 #define 
	#TIM_OCIdleState_Set
 ((
uint16_t
)0x0100)

	)

478 #define 
	#TIM_OCIdleState_Reset
 ((
uint16_t
)0x0000)

	)

479 #define 
	#IS_TIM_OCIDLE_STATE
(
STATE
) (((STATE) == 
TIM_OCIdleState_Set
) || \

	)

480 ((
STATE
) == 
TIM_OCIdleState_Reset
))

489 #define 
	#TIM_OCNIdleState_Set
 ((
uint16_t
)0x0200)

	)

490 #define 
	#TIM_OCNIdleState_Reset
 ((
uint16_t
)0x0000)

	)

491 #define 
	#IS_TIM_OCNIDLE_STATE
(
STATE
) (((STATE) == 
TIM_OCNIdleState_Set
) || \

	)

492 ((
STATE
) == 
TIM_OCNIdleState_Reset
))

501 #define 
	#TIM_ICPolarity_Rising
 ((
uint16_t
)0x0000)

	)

502 #define 
	#TIM_ICPolarity_Falling
 ((
uint16_t
)0x0002)

	)

503 #define 
	#TIM_ICPolarity_BothEdge
 ((
uint16_t
)0x000A)

	)

504 #define 
	#IS_TIM_IC_POLARITY
(
POLARITY
) (((POLARITY) == 
TIM_ICPolarity_Rising
) || \

	)

505 ((
POLARITY
) == 
TIM_ICPolarity_Falling
)|| \

506 ((
POLARITY
) == 
TIM_ICPolarity_BothEdge
))

515 #define 
	#TIM_ICSelection_DirectTI
 ((
uint16_t
)0x0001)

	)

517 #define 
	#TIM_ICSelection_IndirectTI
 ((
uint16_t
)0x0002)

	)

519 #define 
	#TIM_ICSelection_TRC
 ((
uint16_t
)0x0003)

	)

520 #define 
	#IS_TIM_IC_SELECTION
(
SELECTION
) (((SELECTION) == 
TIM_ICSelection_DirectTI
) || \

	)

521 ((
SELECTION
) == 
TIM_ICSelection_IndirectTI
) || \

522 ((
SELECTION
) == 
TIM_ICSelection_TRC
))

531 #define 
	#TIM_ICPSC_DIV1
 ((
uint16_t
)0x0000)

	)

532 #define 
	#TIM_ICPSC_DIV2
 ((
uint16_t
)0x0004)

	)

533 #define 
	#TIM_ICPSC_DIV4
 ((
uint16_t
)0x0008)

	)

534 #define 
	#TIM_ICPSC_DIV8
 ((
uint16_t
)0x000C)

	)

535 #define 
	#IS_TIM_IC_PRESCALER
(
PRESCALER
) (((PRESCALER) == 
TIM_ICPSC_DIV1
) || \

	)

536 ((
PRESCALER
) == 
TIM_ICPSC_DIV2
) || \

537 ((
PRESCALER
) == 
TIM_ICPSC_DIV4
) || \

538 ((
PRESCALER
) == 
TIM_ICPSC_DIV8
))

547 #define 
	#TIM_IT_Update
 ((
uint16_t
)0x0001)

	)

548 #define 
	#TIM_IT_CC1
 ((
uint16_t
)0x0002)

	)

549 #define 
	#TIM_IT_CC2
 ((
uint16_t
)0x0004)

	)

550 #define 
	#TIM_IT_CC3
 ((
uint16_t
)0x0008)

	)

551 #define 
	#TIM_IT_CC4
 ((
uint16_t
)0x0010)

	)

552 #define 
	#TIM_IT_COM
 ((
uint16_t
)0x0020)

	)

553 #define 
	#TIM_IT_Trigger
 ((
uint16_t
)0x0040)

	)

554 #define 
	#TIM_IT_Break
 ((
uint16_t
)0x0080)

	)

555 #define 
	#IS_TIM_IT
(
IT
) ((((IT) & (
uint16_t
)0xFF00) == 0x0000) && ((IT) != 0x0000))

	)

557 #define 
	#IS_TIM_GET_IT
(
IT
) (((IT) == 
TIM_IT_Update
) || \

	)

558 ((
IT
) == 
TIM_IT_CC1
) || \

559 ((
IT
) == 
TIM_IT_CC2
) || \

560 ((
IT
) == 
TIM_IT_CC3
) || \

561 ((
IT
) == 
TIM_IT_CC4
) || \

562 ((
IT
) == 
TIM_IT_COM
) || \

563 ((
IT
) == 
TIM_IT_Trigger
) || \

564 ((
IT
) == 
TIM_IT_Break
))

573 #define 
	#TIM_DMABase_CR1
 ((
uint16_t
)0x0000)

	)

574 #define 
	#TIM_DMABase_CR2
 ((
uint16_t
)0x0001)

	)

575 #define 
	#TIM_DMABase_SMCR
 ((
uint16_t
)0x0002)

	)

576 #define 
	#TIM_DMABase_DIER
 ((
uint16_t
)0x0003)

	)

577 #define 
	#TIM_DMABase_SR
 ((
uint16_t
)0x0004)

	)

578 #define 
	#TIM_DMABase_EGR
 ((
uint16_t
)0x0005)

	)

579 #define 
	#TIM_DMABase_CCMR1
 ((
uint16_t
)0x0006)

	)

580 #define 
	#TIM_DMABase_CCMR2
 ((
uint16_t
)0x0007)

	)

581 #define 
	#TIM_DMABase_CCER
 ((
uint16_t
)0x0008)

	)

582 #define 
	#TIM_DMABase_CNT
 ((
uint16_t
)0x0009)

	)

583 #define 
	#TIM_DMABase_PSC
 ((
uint16_t
)0x000A)

	)

584 #define 
	#TIM_DMABase_ARR
 ((
uint16_t
)0x000B)

	)

585 #define 
	#TIM_DMABase_RCR
 ((
uint16_t
)0x000C)

	)

586 #define 
	#TIM_DMABase_CCR1
 ((
uint16_t
)0x000D)

	)

587 #define 
	#TIM_DMABase_CCR2
 ((
uint16_t
)0x000E)

	)

588 #define 
	#TIM_DMABase_CCR3
 ((
uint16_t
)0x000F)

	)

589 #define 
	#TIM_DMABase_CCR4
 ((
uint16_t
)0x0010)

	)

590 #define 
	#TIM_DMABase_BDTR
 ((
uint16_t
)0x0011)

	)

591 #define 
	#TIM_DMABase_DCR
 ((
uint16_t
)0x0012)

	)

592 #define 
	#TIM_DMABase_OR
 ((
uint16_t
)0x0013)

	)

593 #define 
	#IS_TIM_DMA_BASE
(
BASE
) (((BASE) == 
TIM_DMABase_CR1
) || \

	)

594 ((
BASE
) == 
TIM_DMABase_CR2
) || \

595 ((
BASE
) == 
TIM_DMABase_SMCR
) || \

596 ((
BASE
) == 
TIM_DMABase_DIER
) || \

597 ((
BASE
) == 
TIM_DMABase_SR
) || \

598 ((
BASE
) == 
TIM_DMABase_EGR
) || \

599 ((
BASE
) == 
TIM_DMABase_CCMR1
) || \

600 ((
BASE
) == 
TIM_DMABase_CCMR2
) || \

601 ((
BASE
) == 
TIM_DMABase_CCER
) || \

602 ((
BASE
) == 
TIM_DMABase_CNT
) || \

603 ((
BASE
) == 
TIM_DMABase_PSC
) || \

604 ((
BASE
) == 
TIM_DMABase_ARR
) || \

605 ((
BASE
) == 
TIM_DMABase_RCR
) || \

606 ((
BASE
) == 
TIM_DMABase_CCR1
) || \

607 ((
BASE
) == 
TIM_DMABase_CCR2
) || \

608 ((
BASE
) == 
TIM_DMABase_CCR3
) || \

609 ((
BASE
) == 
TIM_DMABase_CCR4
) || \

610 ((
BASE
) == 
TIM_DMABase_BDTR
) || \

611 ((
BASE
) == 
TIM_DMABase_DCR
) || \

612 ((
BASE
) == 
TIM_DMABase_OR
))

621 #define 
	#TIM_DMABurstLength_1Transfer
 ((
uint16_t
)0x0000)

	)

622 #define 
	#TIM_DMABurstLength_2Transfers
 ((
uint16_t
)0x0100)

	)

623 #define 
	#TIM_DMABurstLength_3Transfers
 ((
uint16_t
)0x0200)

	)

624 #define 
	#TIM_DMABurstLength_4Transfers
 ((
uint16_t
)0x0300)

	)

625 #define 
	#TIM_DMABurstLength_5Transfers
 ((
uint16_t
)0x0400)

	)

626 #define 
	#TIM_DMABurstLength_6Transfers
 ((
uint16_t
)0x0500)

	)

627 #define 
	#TIM_DMABurstLength_7Transfers
 ((
uint16_t
)0x0600)

	)

628 #define 
	#TIM_DMABurstLength_8Transfers
 ((
uint16_t
)0x0700)

	)

629 #define 
	#TIM_DMABurstLength_9Transfers
 ((
uint16_t
)0x0800)

	)

630 #define 
	#TIM_DMABurstLength_10Transfers
 ((
uint16_t
)0x0900)

	)

631 #define 
	#TIM_DMABurstLength_11Transfers
 ((
uint16_t
)0x0A00)

	)

632 #define 
	#TIM_DMABurstLength_12Transfers
 ((
uint16_t
)0x0B00)

	)

633 #define 
	#TIM_DMABurstLength_13Transfers
 ((
uint16_t
)0x0C00)

	)

634 #define 
	#TIM_DMABurstLength_14Transfers
 ((
uint16_t
)0x0D00)

	)

635 #define 
	#TIM_DMABurstLength_15Transfers
 ((
uint16_t
)0x0E00)

	)

636 #define 
	#TIM_DMABurstLength_16Transfers
 ((
uint16_t
)0x0F00)

	)

637 #define 
	#TIM_DMABurstLength_17Transfers
 ((
uint16_t
)0x1000)

	)

638 #define 
	#TIM_DMABurstLength_18Transfers
 ((
uint16_t
)0x1100)

	)

639 #define 
	#IS_TIM_DMA_LENGTH
(
LENGTH
) (((LENGTH) == 
TIM_DMABurstLength_1Transfer
) || \

	)

640 ((
LENGTH
) == 
TIM_DMABurstLength_2Transfers
) || \

641 ((
LENGTH
) == 
TIM_DMABurstLength_3Transfers
) || \

642 ((
LENGTH
) == 
TIM_DMABurstLength_4Transfers
) || \

643 ((
LENGTH
) == 
TIM_DMABurstLength_5Transfers
) || \

644 ((
LENGTH
) == 
TIM_DMABurstLength_6Transfers
) || \

645 ((
LENGTH
) == 
TIM_DMABurstLength_7Transfers
) || \

646 ((
LENGTH
) == 
TIM_DMABurstLength_8Transfers
) || \

647 ((
LENGTH
) == 
TIM_DMABurstLength_9Transfers
) || \

648 ((
LENGTH
) == 
TIM_DMABurstLength_10Transfers
) || \

649 ((
LENGTH
) == 
TIM_DMABurstLength_11Transfers
) || \

650 ((
LENGTH
) == 
TIM_DMABurstLength_12Transfers
) || \

651 ((
LENGTH
) == 
TIM_DMABurstLength_13Transfers
) || \

652 ((
LENGTH
) == 
TIM_DMABurstLength_14Transfers
) || \

653 ((
LENGTH
) == 
TIM_DMABurstLength_15Transfers
) || \

654 ((
LENGTH
) == 
TIM_DMABurstLength_16Transfers
) || \

655 ((
LENGTH
) == 
TIM_DMABurstLength_17Transfers
) || \

656 ((
LENGTH
) == 
TIM_DMABurstLength_18Transfers
))

665 #define 
	#TIM_DMA_Update
 ((
uint16_t
)0x0100)

	)

666 #define 
	#TIM_DMA_CC1
 ((
uint16_t
)0x0200)

	)

667 #define 
	#TIM_DMA_CC2
 ((
uint16_t
)0x0400)

	)

668 #define 
	#TIM_DMA_CC3
 ((
uint16_t
)0x0800)

	)

669 #define 
	#TIM_DMA_CC4
 ((
uint16_t
)0x1000)

	)

670 #define 
	#TIM_DMA_COM
 ((
uint16_t
)0x2000)

	)

671 #define 
	#TIM_DMA_Trigger
 ((
uint16_t
)0x4000)

	)

672 #define 
	#IS_TIM_DMA_SOURCE
(
SOURCE
) ((((SOURCE) & (
uint16_t
)0x80FF) == 0x0000) && ((SOURCE) != 0x0000))

	)

682 #define 
	#TIM_ExtTRGPSC_OFF
 ((
uint16_t
)0x0000)

	)

683 #define 
	#TIM_ExtTRGPSC_DIV2
 ((
uint16_t
)0x1000)

	)

684 #define 
	#TIM_ExtTRGPSC_DIV4
 ((
uint16_t
)0x2000)

	)

685 #define 
	#TIM_ExtTRGPSC_DIV8
 ((
uint16_t
)0x3000)

	)

686 #define 
	#IS_TIM_EXT_PRESCALER
(
PRESCALER
) (((PRESCALER) == 
TIM_ExtTRGPSC_OFF
) || \

	)

687 ((
PRESCALER
) == 
TIM_ExtTRGPSC_DIV2
) || \

688 ((
PRESCALER
) == 
TIM_ExtTRGPSC_DIV4
) || \

689 ((
PRESCALER
) == 
TIM_ExtTRGPSC_DIV8
))

698 #define 
	#TIM_TS_ITR0
 ((
uint16_t
)0x0000)

	)

699 #define 
	#TIM_TS_ITR1
 ((
uint16_t
)0x0010)

	)

700 #define 
	#TIM_TS_ITR2
 ((
uint16_t
)0x0020)

	)

701 #define 
	#TIM_TS_ITR3
 ((
uint16_t
)0x0030)

	)

702 #define 
	#TIM_TS_TI1F_ED
 ((
uint16_t
)0x0040)

	)

703 #define 
	#TIM_TS_TI1FP1
 ((
uint16_t
)0x0050)

	)

704 #define 
	#TIM_TS_TI2FP2
 ((
uint16_t
)0x0060)

	)

705 #define 
	#TIM_TS_ETRF
 ((
uint16_t
)0x0070)

	)

706 #define 
	#IS_TIM_TRIGGER_SELECTION
(
SELECTION
) (((SELECTION) == 
TIM_TS_ITR0
) || \

	)

707 ((
SELECTION
) == 
TIM_TS_ITR1
) || \

708 ((
SELECTION
) == 
TIM_TS_ITR2
) || \

709 ((
SELECTION
) == 
TIM_TS_ITR3
) || \

710 ((
SELECTION
) == 
TIM_TS_TI1F_ED
) || \

711 ((
SELECTION
) == 
TIM_TS_TI1FP1
) || \

712 ((
SELECTION
) == 
TIM_TS_TI2FP2
) || \

713 ((
SELECTION
) == 
TIM_TS_ETRF
))

714 #define 
	#IS_TIM_INTERNAL_TRIGGER_SELECTION
(
SELECTION
) (((SELECTION) == 
TIM_TS_ITR0
) || \

	)

715 ((
SELECTION
) == 
TIM_TS_ITR1
) || \

716 ((
SELECTION
) == 
TIM_TS_ITR2
) || \

717 ((
SELECTION
) == 
TIM_TS_ITR3
))

726 #define 
	#TIM_TIxExternalCLK1Source_TI1
 ((
uint16_t
)0x0050)

	)

727 #define 
	#TIM_TIxExternalCLK1Source_TI2
 ((
uint16_t
)0x0060)

	)

728 #define 
	#TIM_TIxExternalCLK1Source_TI1ED
 ((
uint16_t
)0x0040)

	)

737 #define 
	#TIM_ExtTRGPolarity_Inverted
 ((
uint16_t
)0x8000)

	)

738 #define 
	#TIM_ExtTRGPolarity_NonInverted
 ((
uint16_t
)0x0000)

	)

739 #define 
	#IS_TIM_EXT_POLARITY
(
POLARITY
) (((POLARITY) == 
TIM_ExtTRGPolarity_Inverted
) || \

	)

740 ((
POLARITY
) == 
TIM_ExtTRGPolarity_NonInverted
))

749 #define 
	#TIM_PSCReloadMode_Update
 ((
uint16_t
)0x0000)

	)

750 #define 
	#TIM_PSCReloadMode_Immediate
 ((
uint16_t
)0x0001)

	)

751 #define 
	#IS_TIM_PRESCALER_RELOAD
(
RELOAD
) (((RELOAD) == 
TIM_PSCReloadMode_Update
) || \

	)

752 ((
RELOAD
) == 
TIM_PSCReloadMode_Immediate
))

761 #define 
	#TIM_ForcedAction_Active
 ((
uint16_t
)0x0050)

	)

762 #define 
	#TIM_ForcedAction_InActive
 ((
uint16_t
)0x0040)

	)

763 #define 
	#IS_TIM_FORCED_ACTION
(
ACTION
) (((ACTION) == 
TIM_ForcedAction_Active
) || \

	)

764 ((
ACTION
) == 
TIM_ForcedAction_InActive
))

773 #define 
	#TIM_EncoderMode_TI1
 ((
uint16_t
)0x0001)

	)

774 #define 
	#TIM_EncoderMode_TI2
 ((
uint16_t
)0x0002)

	)

775 #define 
	#TIM_EncoderMode_TI12
 ((
uint16_t
)0x0003)

	)

776 #define 
	#IS_TIM_ENCODER_MODE
(
MODE
) (((MODE) == 
TIM_EncoderMode_TI1
) || \

	)

777 ((
MODE
) == 
TIM_EncoderMode_TI2
) || \

778 ((
MODE
) == 
TIM_EncoderMode_TI12
))

788 #define 
	#TIM_EventSource_Update
 ((
uint16_t
)0x0001)

	)

789 #define 
	#TIM_EventSource_CC1
 ((
uint16_t
)0x0002)

	)

790 #define 
	#TIM_EventSource_CC2
 ((
uint16_t
)0x0004)

	)

791 #define 
	#TIM_EventSource_CC3
 ((
uint16_t
)0x0008)

	)

792 #define 
	#TIM_EventSource_CC4
 ((
uint16_t
)0x0010)

	)

793 #define 
	#TIM_EventSource_COM
 ((
uint16_t
)0x0020)

	)

794 #define 
	#TIM_EventSource_Trigger
 ((
uint16_t
)0x0040)

	)

795 #define 
	#TIM_EventSource_Break
 ((
uint16_t
)0x0080)

	)

796 #define 
	#IS_TIM_EVENT_SOURCE
(
SOURCE
) ((((SOURCE) & (
uint16_t
)0xFF00) == 0x0000) && ((SOURCE) != 0x0000))

	)

806 #define 
	#TIM_UpdateSource_Global
 ((
uint16_t
)0x0000)

	)

809 #define 
	#TIM_UpdateSource_Regular
 ((
uint16_t
)0x0001)

	)

810 #define 
	#IS_TIM_UPDATE_SOURCE
(
SOURCE
) (((SOURCE) == 
TIM_UpdateSource_Global
) || \

	)

811 ((
SOURCE
) == 
TIM_UpdateSource_Regular
))

820 #define 
	#TIM_OCPreload_Enable
 ((
uint16_t
)0x0008)

	)

821 #define 
	#TIM_OCPreload_Disable
 ((
uint16_t
)0x0000)

	)

822 #define 
	#IS_TIM_OCPRELOAD_STATE
(
STATE
) (((STATE) == 
TIM_OCPreload_Enable
) || \

	)

823 ((
STATE
) == 
TIM_OCPreload_Disable
))

832 #define 
	#TIM_OCFast_Enable
 ((
uint16_t
)0x0004)

	)

833 #define 
	#TIM_OCFast_Disable
 ((
uint16_t
)0x0000)

	)

834 #define 
	#IS_TIM_OCFAST_STATE
(
STATE
) (((STATE) == 
TIM_OCFast_Enable
) || \

	)

835 ((
STATE
) == 
TIM_OCFast_Disable
))

845 #define 
	#TIM_OCClear_Enable
 ((
uint16_t
)0x0080)

	)

846 #define 
	#TIM_OCClear_Disable
 ((
uint16_t
)0x0000)

	)

847 #define 
	#IS_TIM_OCCLEAR_STATE
(
STATE
) (((STATE) == 
TIM_OCClear_Enable
) || \

	)

848 ((
STATE
) == 
TIM_OCClear_Disable
))

857 #define 
	#TIM_TRGOSource_Reset
 ((
uint16_t
)0x0000)

	)

858 #define 
	#TIM_TRGOSource_Enable
 ((
uint16_t
)0x0010)

	)

859 #define 
	#TIM_TRGOSource_Update
 ((
uint16_t
)0x0020)

	)

860 #define 
	#TIM_TRGOSource_OC1
 ((
uint16_t
)0x0030)

	)

861 #define 
	#TIM_TRGOSource_OC1Ref
 ((
uint16_t
)0x0040)

	)

862 #define 
	#TIM_TRGOSource_OC2Ref
 ((
uint16_t
)0x0050)

	)

863 #define 
	#TIM_TRGOSource_OC3Ref
 ((
uint16_t
)0x0060)

	)

864 #define 
	#TIM_TRGOSource_OC4Ref
 ((
uint16_t
)0x0070)

	)

865 #define 
	#IS_TIM_TRGO_SOURCE
(
SOURCE
) (((SOURCE) == 
TIM_TRGOSource_Reset
) || \

	)

866 ((
SOURCE
) == 
TIM_TRGOSource_Enable
) || \

867 ((
SOURCE
) == 
TIM_TRGOSource_Update
) || \

868 ((
SOURCE
) == 
TIM_TRGOSource_OC1
) || \

869 ((
SOURCE
) == 
TIM_TRGOSource_OC1Ref
) || \

870 ((
SOURCE
) == 
TIM_TRGOSource_OC2Ref
) || \

871 ((
SOURCE
) == 
TIM_TRGOSource_OC3Ref
) || \

872 ((
SOURCE
) == 
TIM_TRGOSource_OC4Ref
))

881 #define 
	#TIM_SlaveMode_Reset
 ((
uint16_t
)0x0004)

	)

882 #define 
	#TIM_SlaveMode_Gated
 ((
uint16_t
)0x0005)

	)

883 #define 
	#TIM_SlaveMode_Trigger
 ((
uint16_t
)0x0006)

	)

884 #define 
	#TIM_SlaveMode_External1
 ((
uint16_t
)0x0007)

	)

885 #define 
	#IS_TIM_SLAVE_MODE
(
MODE
) (((MODE) == 
TIM_SlaveMode_Reset
) || \

	)

886 ((
MODE
) == 
TIM_SlaveMode_Gated
) || \

887 ((
MODE
) == 
TIM_SlaveMode_Trigger
) || \

888 ((
MODE
) == 
TIM_SlaveMode_External1
))

897 #define 
	#TIM_MasterSlaveMode_Enable
 ((
uint16_t
)0x0080)

	)

898 #define 
	#TIM_MasterSlaveMode_Disable
 ((
uint16_t
)0x0000)

	)

899 #define 
	#IS_TIM_MSM_STATE
(
STATE
) (((STATE) == 
TIM_MasterSlaveMode_Enable
) || \

	)

900 ((
STATE
) == 
TIM_MasterSlaveMode_Disable
))

908 #define 
	#TIM2_TIM8_TRGO
 ((
uint16_t
)0x0000)

	)

909 #define 
	#TIM2_ETH_PTP
 ((
uint16_t
)0x0400)

	)

910 #define 
	#TIM2_USBFS_SOF
 ((
uint16_t
)0x0800)

	)

911 #define 
	#TIM2_USBHS_SOF
 ((
uint16_t
)0x0C00)

	)

913 #define 
	#TIM5_GPIO
 ((
uint16_t
)0x0000)

	)

914 #define 
	#TIM5_LSI
 ((
uint16_t
)0x0040)

	)

915 #define 
	#TIM5_LSE
 ((
uint16_t
)0x0080)

	)

916 #define 
	#TIM5_RTC
 ((
uint16_t
)0x00C0)

	)

918 #define 
	#TIM11_GPIO
 ((
uint16_t
)0x0000)

	)

919 #define 
	#TIM11_HSE
 ((
uint16_t
)0x0002)

	)

921 #define 
	#IS_TIM_REMAP
(
TIM_REMAP
) (((TIM_REMAP) == 
TIM2_TIM8_TRGO
)||\

	)

922 ((
TIM_REMAP
) == 
TIM2_ETH_PTP
)||\

923 ((
TIM_REMAP
) == 
TIM2_USBFS_SOF
)||\

924 ((
TIM_REMAP
) == 
TIM2_USBHS_SOF
)||\

925 ((
TIM_REMAP
) == 
TIM5_GPIO
)||\

926 ((
TIM_REMAP
) == 
TIM5_LSI
)||\

927 ((
TIM_REMAP
) == 
TIM5_LSE
)||\

928 ((
TIM_REMAP
) == 
TIM5_RTC
)||\

929 ((
TIM_REMAP
) == 
TIM11_GPIO
)||\

930 ((
TIM_REMAP
) == 
TIM11_HSE
))

939 #define 
	#TIM_FLAG_Update
 ((
uint16_t
)0x0001)

	)

940 #define 
	#TIM_FLAG_CC1
 ((
uint16_t
)0x0002)

	)

941 #define 
	#TIM_FLAG_CC2
 ((
uint16_t
)0x0004)

	)

942 #define 
	#TIM_FLAG_CC3
 ((
uint16_t
)0x0008)

	)

943 #define 
	#TIM_FLAG_CC4
 ((
uint16_t
)0x0010)

	)

944 #define 
	#TIM_FLAG_COM
 ((
uint16_t
)0x0020)

	)

945 #define 
	#TIM_FLAG_Trigger
 ((
uint16_t
)0x0040)

	)

946 #define 
	#TIM_FLAG_Break
 ((
uint16_t
)0x0080)

	)

947 #define 
	#TIM_FLAG_CC1OF
 ((
uint16_t
)0x0200)

	)

948 #define 
	#TIM_FLAG_CC2OF
 ((
uint16_t
)0x0400)

	)

949 #define 
	#TIM_FLAG_CC3OF
 ((
uint16_t
)0x0800)

	)

950 #define 
	#TIM_FLAG_CC4OF
 ((
uint16_t
)0x1000)

	)

951 #define 
	#IS_TIM_GET_FLAG
(
FLAG
) (((FLAG) == 
TIM_FLAG_Update
) || \

	)

952 ((
FLAG
) == 
TIM_FLAG_CC1
) || \

953 ((
FLAG
) == 
TIM_FLAG_CC2
) || \

954 ((
FLAG
) == 
TIM_FLAG_CC3
) || \

955 ((
FLAG
) == 
TIM_FLAG_CC4
) || \

956 ((
FLAG
) == 
TIM_FLAG_COM
) || \

957 ((
FLAG
) == 
TIM_FLAG_Trigger
) || \

958 ((
FLAG
) == 
TIM_FLAG_Break
) || \

959 ((
FLAG
) == 
TIM_FLAG_CC1OF
) || \

960 ((
FLAG
) == 
TIM_FLAG_CC2OF
) || \

961 ((
FLAG
) == 
TIM_FLAG_CC3OF
) || \

962 ((
FLAG
) == 
TIM_FLAG_CC4OF
))

972 #define 
	#IS_TIM_IC_FILTER
(
ICFILTER
) ((ICFILTER) <= 0xF)

	)

981 #define 
	#IS_TIM_EXT_FILTER
(
EXTFILTER
) ((EXTFILTER) <= 0xF)

	)

990 #define 
	#TIM_DMABurstLength_1Byte
 
TIM_DMABurstLength_1Transfer


	)

991 #define 
	#TIM_DMABurstLength_2Bytes
 
TIM_DMABurstLength_2Transfers


	)

992 #define 
	#TIM_DMABurstLength_3Bytes
 
TIM_DMABurstLength_3Transfers


	)

993 #define 
	#TIM_DMABurstLength_4Bytes
 
TIM_DMABurstLength_4Transfers


	)

994 #define 
	#TIM_DMABurstLength_5Bytes
 
TIM_DMABurstLength_5Transfers


	)

995 #define 
	#TIM_DMABurstLength_6Bytes
 
TIM_DMABurstLength_6Transfers


	)

996 #define 
	#TIM_DMABurstLength_7Bytes
 
TIM_DMABurstLength_7Transfers


	)

997 #define 
	#TIM_DMABurstLength_8Bytes
 
TIM_DMABurstLength_8Transfers


	)

998 #define 
	#TIM_DMABurstLength_9Bytes
 
TIM_DMABurstLength_9Transfers


	)

999 #define 
	#TIM_DMABurstLength_10Bytes
 
TIM_DMABurstLength_10Transfers


	)

1000 #define 
	#TIM_DMABurstLength_11Bytes
 
TIM_DMABurstLength_11Transfers


	)

1001 #define 
	#TIM_DMABurstLength_12Bytes
 
TIM_DMABurstLength_12Transfers


	)

1002 #define 
	#TIM_DMABurstLength_13Bytes
 
TIM_DMABurstLength_13Transfers


	)

1003 #define 
	#TIM_DMABurstLength_14Bytes
 
TIM_DMABurstLength_14Transfers


	)

1004 #define 
	#TIM_DMABurstLength_15Bytes
 
TIM_DMABurstLength_15Transfers


	)

1005 #define 
	#TIM_DMABurstLength_16Bytes
 
TIM_DMABurstLength_16Transfers


	)

1006 #define 
	#TIM_DMABurstLength_17Bytes
 
TIM_DMABurstLength_17Transfers


	)

1007 #define 
	#TIM_DMABurstLength_18Bytes
 
TIM_DMABurstLength_18Transfers


	)

1020 void 
TIM_DeInit
(
TIM_TypeDef
* 
TIMx
);

1021 void 
TIM_TimeBaseInit
(
TIM_TypeDef
* 
TIMx
, 
TIM_TimeBaseInitTypeDef
* 
TIM_TimeBaseInitStruct
);

1022 void 
TIM_TimeBaseStructInit
(
TIM_TimeBaseInitTypeDef
* 
TIM_TimeBaseInitStruct
);

1023 void 
TIM_PrescalerConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
Prescaler
, uint16_t 
TIM_PSCReloadMode
);

1024 void 
TIM_CounterModeConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_CounterMode
);

1025 void 
TIM_SetCounter
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Counter
);

1026 void 
TIM_SetAutoreload
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Autoreload
);

1027 
uint32_t
 
TIM_GetCounter
(
TIM_TypeDef
* 
TIMx
);

1028 
uint16_t
 
TIM_GetPrescaler
(
TIM_TypeDef
* 
TIMx
);

1029 void 
TIM_UpdateDisableConfig
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1030 void 
TIM_UpdateRequestConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_UpdateSource
);

1031 void 
TIM_ARRPreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1032 void 
TIM_SelectOnePulseMode
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OPMode
);

1033 void 
TIM_SetClockDivision
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_CKD
);

1034 void 
TIM_Cmd
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1037 void 
TIM_OC1Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
);

1038 void 
TIM_OC2Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
);

1039 void 
TIM_OC3Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
);

1040 void 
TIM_OC4Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
);

1041 void 
TIM_OCStructInit
(
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
);

1042 void 
TIM_SelectOCxM
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Channel
, uint16_t 
TIM_OCMode
);

1043 void 
TIM_SetCompare1
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare1
);

1044 void 
TIM_SetCompare2
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare2
);

1045 void 
TIM_SetCompare3
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare3
);

1046 void 
TIM_SetCompare4
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare4
);

1047 void 
TIM_ForcedOC1Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
);

1048 void 
TIM_ForcedOC2Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
);

1049 void 
TIM_ForcedOC3Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
);

1050 void 
TIM_ForcedOC4Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
);

1051 void 
TIM_OC1PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
);

1052 void 
TIM_OC2PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
);

1053 void 
TIM_OC3PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
);

1054 void 
TIM_OC4PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
);

1055 void 
TIM_OC1FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
);

1056 void 
TIM_OC2FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
);

1057 void 
TIM_OC3FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
);

1058 void 
TIM_OC4FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
);

1059 void 
TIM_ClearOC1Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
);

1060 void 
TIM_ClearOC2Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
);

1061 void 
TIM_ClearOC3Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
);

1062 void 
TIM_ClearOC4Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
);

1063 void 
TIM_OC1PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
);

1064 void 
TIM_OC1NPolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCNPolarity
);

1065 void 
TIM_OC2PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
);

1066 void 
TIM_OC2NPolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCNPolarity
);

1067 void 
TIM_OC3PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
);

1068 void 
TIM_OC3NPolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCNPolarity
);

1069 void 
TIM_OC4PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
);

1070 void 
TIM_CCxCmd
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Channel
, uint16_t 
TIM_CCx
);

1071 void 
TIM_CCxNCmd
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Channel
, uint16_t 
TIM_CCxN
);

1074 void 
TIM_ICInit
(
TIM_TypeDef
* 
TIMx
, 
TIM_ICInitTypeDef
* 
TIM_ICInitStruct
);

1075 void 
TIM_ICStructInit
(
TIM_ICInitTypeDef
* 
TIM_ICInitStruct
);

1076 void 
TIM_PWMIConfig
(
TIM_TypeDef
* 
TIMx
, 
TIM_ICInitTypeDef
* 
TIM_ICInitStruct
);

1077 
uint32_t
 
TIM_GetCapture1
(
TIM_TypeDef
* 
TIMx
);

1078 
uint32_t
 
TIM_GetCapture2
(
TIM_TypeDef
* 
TIMx
);

1079 
uint32_t
 
TIM_GetCapture3
(
TIM_TypeDef
* 
TIMx
);

1080 
uint32_t
 
TIM_GetCapture4
(
TIM_TypeDef
* 
TIMx
);

1081 void 
TIM_SetIC1Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
);

1082 void 
TIM_SetIC2Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
);

1083 void 
TIM_SetIC3Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
);

1084 void 
TIM_SetIC4Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
);

1087 void 
TIM_BDTRConfig
(
TIM_TypeDef
* 
TIMx
, 
TIM_BDTRInitTypeDef
 *
TIM_BDTRInitStruct
);

1088 void 
TIM_BDTRStructInit
(
TIM_BDTRInitTypeDef
* 
TIM_BDTRInitStruct
);

1089 void 
TIM_CtrlPWMOutputs
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1090 void 
TIM_SelectCOM
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1091 void 
TIM_CCPreloadControl
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1094 void 
TIM_ITConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_IT
, 
FunctionalState
 
NewState
);

1095 void 
TIM_GenerateEvent
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_EventSource
);

1096 
FlagStatus
 
TIM_GetFlagStatus
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_FLAG
);

1097 void 
TIM_ClearFlag
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_FLAG
);

1098 
ITStatus
 
TIM_GetITStatus
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_IT
);

1099 void 
TIM_ClearITPendingBit
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_IT
);

1100 void 
TIM_DMAConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_DMABase
, uint16_t 
TIM_DMABurstLength
);

1101 void 
TIM_DMACmd
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_DMASource
, 
FunctionalState
 
NewState
);

1102 void 
TIM_SelectCCDMA
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1105 void 
TIM_InternalClockConfig
(
TIM_TypeDef
* 
TIMx
);

1106 void 
TIM_ITRxExternalClockConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_InputTriggerSource
);

1107 void 
TIM_TIxExternalClockConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_TIxExternalCLKSource
,

1108 
uint16_t
 
TIM_ICPolarity
, uint16_t 
ICFilter
);

1109 void 
TIM_ETRClockMode1Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ExtTRGPrescaler
, uint16_t 
TIM_ExtTRGPolarity
,

1110 
uint16_t
 
ExtTRGFilter
);

1111 void 
TIM_ETRClockMode2Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ExtTRGPrescaler
,

1112 
uint16_t
 
TIM_ExtTRGPolarity
, uint16_t 
ExtTRGFilter
);

1115 void 
TIM_SelectInputTrigger
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_InputTriggerSource
);

1116 void 
TIM_SelectOutputTrigger
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_TRGOSource
);

1117 void 
TIM_SelectSlaveMode
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_SlaveMode
);

1118 void 
TIM_SelectMasterSlaveMode
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_MasterSlaveMode
);

1119 void 
TIM_ETRConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ExtTRGPrescaler
, uint16_t 
TIM_ExtTRGPolarity
,

1120 
uint16_t
 
ExtTRGFilter
);

1123 void 
TIM_EncoderInterfaceConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_EncoderMode
,

1124 
uint16_t
 
TIM_IC1Polarity
, uint16_t 
TIM_IC2Polarity
);

1125 void 
TIM_SelectHallSensor
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
);

1128 void 
TIM_RemapConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Remap
);

1130 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h

24 #ifndef 
__STM32F4xx_USART_H


25 #define 
	#__STM32F4xx_USART_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

50 
uint32_t
 
USART_BaudRate
;

56 
uint16_t
 
USART_WordLength
;

59 
uint16_t
 
USART_StopBits
;

62 
uint16_t
 
USART_Parity
;

69 
uint16_t
 
USART_Mode
;

72 
uint16_t
 
USART_HardwareFlowControl
;

75 } 
	tUSART_InitTypeDef
;

84 
uint16_t
 
USART_Clock
;

87 
uint16_t
 
USART_CPOL
;

90 
uint16_t
 
USART_CPHA
;

93 
uint16_t
 
USART_LastBit
;

96 } 
	tUSART_ClockInitTypeDef
;

104 #define 
	#IS_USART_ALL_PERIPH
(
PERIPH
) (((PERIPH) == 
USART1
) || \

	)

105 ((
PERIPH
) == 
USART2
) || \

106 ((
PERIPH
) == 
USART3
) || \

107 ((
PERIPH
) == 
UART4
) || \

108 ((
PERIPH
) == 
UART5
) || \

109 ((
PERIPH
) == 
USART6
))

111 #define 
	#IS_USART_1236_PERIPH
(
PERIPH
) (((PERIPH) == 
USART1
) || \

	)

112 ((
PERIPH
) == 
USART2
) || \

113 ((
PERIPH
) == 
USART3
) || \

114 ((
PERIPH
) == 
USART6
))

120 #define 
	#USART_WordLength_8b
 ((
uint16_t
)0x0000)

	)

121 #define 
	#USART_WordLength_9b
 ((
uint16_t
)0x1000)

	)

123 #define 
	#IS_USART_WORD_LENGTH
(
LENGTH
) (((LENGTH) == 
USART_WordLength_8b
) || \

	)

124 ((
LENGTH
) == 
USART_WordLength_9b
))

133 #define 
	#USART_StopBits_1
 ((
uint16_t
)0x0000)

	)

134 #define 
	#USART_StopBits_0_5
 ((
uint16_t
)0x1000)

	)

135 #define 
	#USART_StopBits_2
 ((
uint16_t
)0x2000)

	)

136 #define 
	#USART_StopBits_1_5
 ((
uint16_t
)0x3000)

	)

137 #define 
	#IS_USART_STOPBITS
(
STOPBITS
) (((STOPBITS) == 
USART_StopBits_1
) || \

	)

138 ((
STOPBITS
) == 
USART_StopBits_0_5
) || \

139 ((
STOPBITS
) == 
USART_StopBits_2
) || \

140 ((
STOPBITS
) == 
USART_StopBits_1_5
))

149 #define 
	#USART_Parity_No
 ((
uint16_t
)0x0000)

	)

150 #define 
	#USART_Parity_Even
 ((
uint16_t
)0x0400)

	)

151 #define 
	#USART_Parity_Odd
 ((
uint16_t
)0x0600)

	)

152 #define 
	#IS_USART_PARITY
(
PARITY
) (((PARITY) == 
USART_Parity_No
) || \

	)

153 ((
PARITY
) == 
USART_Parity_Even
) || \

154 ((
PARITY
) == 
USART_Parity_Odd
))

163 #define 
	#USART_Mode_Rx
 ((
uint16_t
)0x0004)

	)

164 #define 
	#USART_Mode_Tx
 ((
uint16_t
)0x0008)

	)

165 #define 
	#IS_USART_MODE
(
MODE
) ((((MODE) & (
uint16_t
)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))

	)

173 #define 
	#USART_HardwareFlowControl_None
 ((
uint16_t
)0x0000)

	)

174 #define 
	#USART_HardwareFlowControl_RTS
 ((
uint16_t
)0x0100)

	)

175 #define 
	#USART_HardwareFlowControl_CTS
 ((
uint16_t
)0x0200)

	)

176 #define 
	#USART_HardwareFlowControl_RTS_CTS
 ((
uint16_t
)0x0300)

	)

177 #define 
	#IS_USART_HARDWARE_FLOW_CONTROL
(
CONTROL
)\

	)

178 (((
CONTROL
) == 
USART_HardwareFlowControl_None
) || \

179 ((
CONTROL
) == 
USART_HardwareFlowControl_RTS
) || \

180 ((
CONTROL
) == 
USART_HardwareFlowControl_CTS
) || \

181 ((
CONTROL
) == 
USART_HardwareFlowControl_RTS_CTS
))

189 #define 
	#USART_Clock_Disable
 ((
uint16_t
)0x0000)

	)

190 #define 
	#USART_Clock_Enable
 ((
uint16_t
)0x0800)

	)

191 #define 
	#IS_USART_CLOCK
(
CLOCK
) (((CLOCK) == 
USART_Clock_Disable
) || \

	)

192 ((
CLOCK
) == 
USART_Clock_Enable
))

201 #define 
	#USART_CPOL_Low
 ((
uint16_t
)0x0000)

	)

202 #define 
	#USART_CPOL_High
 ((
uint16_t
)0x0400)

	)

203 #define 
	#IS_USART_CPOL
(
CPOL
) (((CPOL) == 
USART_CPOL_Low
) || ((CPOL) == 
USART_CPOL_High
))

	)

213 #define 
	#USART_CPHA_1Edge
 ((
uint16_t
)0x0000)

	)

214 #define 
	#USART_CPHA_2Edge
 ((
uint16_t
)0x0200)

	)

215 #define 
	#IS_USART_CPHA
(
CPHA
) (((CPHA) == 
USART_CPHA_1Edge
) || ((CPHA) == 
USART_CPHA_2Edge
))

	)

225 #define 
	#USART_LastBit_Disable
 ((
uint16_t
)0x0000)

	)

226 #define 
	#USART_LastBit_Enable
 ((
uint16_t
)0x0100)

	)

227 #define 
	#IS_USART_LASTBIT
(
LASTBIT
) (((LASTBIT) == 
USART_LastBit_Disable
) || \

	)

228 ((
LASTBIT
) == 
USART_LastBit_Enable
))

237 #define 
	#USART_IT_PE
 ((
uint16_t
)0x0028)

	)

238 #define 
	#USART_IT_TXE
 ((
uint16_t
)0x0727)

	)

239 #define 
	#USART_IT_TC
 ((
uint16_t
)0x0626)

	)

240 #define 
	#USART_IT_RXNE
 ((
uint16_t
)0x0525)

	)

241 #define 
	#USART_IT_IDLE
 ((
uint16_t
)0x0424)

	)

242 #define 
	#USART_IT_LBD
 ((
uint16_t
)0x0846)

	)

243 #define 
	#USART_IT_CTS
 ((
uint16_t
)0x096A)

	)

244 #define 
	#USART_IT_ERR
 ((
uint16_t
)0x0060)

	)

245 #define 
	#USART_IT_ORE
 ((
uint16_t
)0x0360)

	)

246 #define 
	#USART_IT_NE
 ((
uint16_t
)0x0260)

	)

247 #define 
	#USART_IT_FE
 ((
uint16_t
)0x0160)

	)

248 #define 
	#IS_USART_CONFIG_IT
(
IT
) (((IT) == 
USART_IT_PE
) || ((IT) == 
USART_IT_TXE
) || \

	)

249 ((
IT
) == 
USART_IT_TC
) || ((IT) == 
USART_IT_RXNE
) || \

250 ((
IT
) == 
USART_IT_IDLE
) || ((IT) == 
USART_IT_LBD
) || \

251 ((
IT
) == 
USART_IT_CTS
) || ((IT) == 
USART_IT_ERR
))

252 #define 
	#IS_USART_GET_IT
(
IT
) (((IT) == 
USART_IT_PE
) || ((IT) == 
USART_IT_TXE
) || \

	)

253 ((
IT
) == 
USART_IT_TC
) || ((IT) == 
USART_IT_RXNE
) || \

254 ((
IT
) == 
USART_IT_IDLE
) || ((IT) == 
USART_IT_LBD
) || \

255 ((
IT
) == 
USART_IT_CTS
) || ((IT) == 
USART_IT_ORE
) || \

256 ((
IT
) == 
USART_IT_NE
) || ((IT) == 
USART_IT_FE
))

257 #define 
	#IS_USART_CLEAR_IT
(
IT
) (((IT) == 
USART_IT_TC
) || ((IT) == 
USART_IT_RXNE
) || \

	)

258 ((
IT
) == 
USART_IT_LBD
) || ((IT) == 
USART_IT_CTS
))

267 #define 
	#USART_DMAReq_Tx
 ((
uint16_t
)0x0080)

	)

268 #define 
	#USART_DMAReq_Rx
 ((
uint16_t
)0x0040)

	)

269 #define 
	#IS_USART_DMAREQ
(
DMAREQ
) ((((DMAREQ) & (
uint16_t
)0xFF3F) == 0x00) && ((DMAREQ) != (uint16_t)0x00))

	)

279 #define 
	#USART_WakeUp_IdleLine
 ((
uint16_t
)0x0000)

	)

280 #define 
	#USART_WakeUp_AddressMark
 ((
uint16_t
)0x0800)

	)

281 #define 
	#IS_USART_WAKEUP
(
WAKEUP
) (((WAKEUP) == 
USART_WakeUp_IdleLine
) || \

	)

282 ((
WAKEUP
) == 
USART_WakeUp_AddressMark
))

291 #define 
	#USART_LINBreakDetectLength_10b
 ((
uint16_t
)0x0000)

	)

292 #define 
	#USART_LINBreakDetectLength_11b
 ((
uint16_t
)0x0020)

	)

293 #define 
	#IS_USART_LIN_BREAK_DETECT_LENGTH
(
LENGTH
) \

	)

294 (((
LENGTH
) == 
USART_LINBreakDetectLength_10b
) || \

295 ((
LENGTH
) == 
USART_LINBreakDetectLength_11b
))

304 #define 
	#USART_IrDAMode_LowPower
 ((
uint16_t
)0x0004)

	)

305 #define 
	#USART_IrDAMode_Normal
 ((
uint16_t
)0x0000)

	)

306 #define 
	#IS_USART_IRDA_MODE
(
MODE
) (((MODE) == 
USART_IrDAMode_LowPower
) || \

	)

307 ((
MODE
) == 
USART_IrDAMode_Normal
))

316 #define 
	#USART_FLAG_CTS
 ((
uint16_t
)0x0200)

	)

317 #define 
	#USART_FLAG_LBD
 ((
uint16_t
)0x0100)

	)

318 #define 
	#USART_FLAG_TXE
 ((
uint16_t
)0x0080)

	)

319 #define 
	#USART_FLAG_TC
 ((
uint16_t
)0x0040)

	)

320 #define 
	#USART_FLAG_RXNE
 ((
uint16_t
)0x0020)

	)

321 #define 
	#USART_FLAG_IDLE
 ((
uint16_t
)0x0010)

	)

322 #define 
	#USART_FLAG_ORE
 ((
uint16_t
)0x0008)

	)

323 #define 
	#USART_FLAG_NE
 ((
uint16_t
)0x0004)

	)

324 #define 
	#USART_FLAG_FE
 ((
uint16_t
)0x0002)

	)

325 #define 
	#USART_FLAG_PE
 ((
uint16_t
)0x0001)

	)

326 #define 
	#IS_USART_FLAG
(
FLAG
) (((FLAG) == 
USART_FLAG_PE
) || ((FLAG) == 
USART_FLAG_TXE
) || \

	)

327 ((
FLAG
) == 
USART_FLAG_TC
) || ((FLAG) == 
USART_FLAG_RXNE
) || \

328 ((
FLAG
) == 
USART_FLAG_IDLE
) || ((FLAG) == 
USART_FLAG_LBD
) || \

329 ((
FLAG
) == 
USART_FLAG_CTS
) || ((FLAG) == 
USART_FLAG_ORE
) || \

330 ((
FLAG
) == 
USART_FLAG_NE
) || ((FLAG) == 
USART_FLAG_FE
))

332 #define 
	#IS_USART_CLEAR_FLAG
(
FLAG
) ((((FLAG) & (
uint16_t
)0xFC9F) == 0x00) && ((FLAG) != (uint16_t)0x00))

	)

334 #define 
	#IS_USART_BAUDRATE
(
BAUDRATE
) (((BAUDRATE) > 0) && ((BAUDRATE) < 7500001))

	)

335 #define 
	#IS_USART_ADDRESS
(
ADDRESS
) ((ADDRESS) <= 0xF)

	)

336 #define 
	#IS_USART_DATA
(
DATA
) ((DATA) <= 0x1FF)

	)

350 void 
USART_DeInit
(
USART_TypeDef
* 
USARTx
);

353 void 
USART_Init
(
USART_TypeDef
* 
USARTx
, 
USART_InitTypeDef
* 
USART_InitStruct
);

354 void 
USART_StructInit
(
USART_InitTypeDef
* 
USART_InitStruct
);

355 void 
USART_ClockInit
(
USART_TypeDef
* 
USARTx
, 
USART_ClockInitTypeDef
* 
USART_ClockInitStruct
);

356 void 
USART_ClockStructInit
(
USART_ClockInitTypeDef
* 
USART_ClockInitStruct
);

357 void 
USART_Cmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

358 void 
USART_SetPrescaler
(
USART_TypeDef
* 
USARTx
, 
uint8_t
 
USART_Prescaler
);

359 void 
USART_OverSampling8Cmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

360 void 
USART_OneBitMethodCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

363 void 
USART_SendData
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
Data
);

364 
uint16_t
 
USART_ReceiveData
(
USART_TypeDef
* 
USARTx
);

367 void 
USART_SetAddress
(
USART_TypeDef
* 
USARTx
, 
uint8_t
 
USART_Address
);

368 void 
USART_WakeUpConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_WakeUp
);

369 void 
USART_ReceiverWakeUpCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

372 void 
USART_LINBreakDetectLengthConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_LINBreakDetectLength
);

373 void 
USART_LINCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

374 void 
USART_SendBreak
(
USART_TypeDef
* 
USARTx
);

377 void 
USART_HalfDuplexCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

380 void 
USART_SmartCardCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

381 void 
USART_SmartCardNACKCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

382 void 
USART_SetGuardTime
(
USART_TypeDef
* 
USARTx
, 
uint8_t
 
USART_GuardTime
);

385 void 
USART_IrDAConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IrDAMode
);

386 void 
USART_IrDACmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
);

389 void 
USART_DMACmd
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_DMAReq
, 
FunctionalState
 
NewState
);

392 void 
USART_ITConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IT
, 
FunctionalState
 
NewState
);

393 
FlagStatus
 
USART_GetFlagStatus
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_FLAG
);

394 void 
USART_ClearFlag
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_FLAG
);

395 
ITStatus
 
USART_GetITStatus
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IT
);

396 void 
USART_ClearITPendingBit
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IT
);

398 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_wwdg.h

24 #ifndef 
__STM32F4xx_WWDG_H


25 #define 
	#__STM32F4xx_WWDG_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

53 #define 
	#WWDG_Prescaler_1
 ((
uint32_t
)0x00000000)

	)

54 #define 
	#WWDG_Prescaler_2
 ((
uint32_t
)0x00000080)

	)

55 #define 
	#WWDG_Prescaler_4
 ((
uint32_t
)0x00000100)

	)

56 #define 
	#WWDG_Prescaler_8
 ((
uint32_t
)0x00000180)

	)

57 #define 
	#IS_WWDG_PRESCALER
(
PRESCALER
) (((PRESCALER) == 
WWDG_Prescaler_1
) || \

	)

58 ((
PRESCALER
) == 
WWDG_Prescaler_2
) || \

59 ((
PRESCALER
) == 
WWDG_Prescaler_4
) || \

60 ((
PRESCALER
) == 
WWDG_Prescaler_8
))

61 #define 
	#IS_WWDG_WINDOW_VALUE
(
VALUE
) ((VALUE) <= 0x7F)

	)

62 #define 
	#IS_WWDG_COUNTER
(
COUNTER
) (((COUNTER) >= 0x40) && ((COUNTER) <= 0x7F))

	)

76 void 
WWDG_DeInit
(void);

79 void 
WWDG_SetPrescaler
(
uint32_t
 
WWDG_Prescaler
);

80 void 
WWDG_SetWindowValue
(
uint8_t
 
WindowValue
);

81 void 
WWDG_EnableIT
(void);

82 void 
WWDG_SetCounter
(
uint8_t
 
Counter
);

85 void 
WWDG_Enable
(
uint8_t
 
Counter
);

88 
FlagStatus
 
WWDG_GetFlagStatus
(void);

89 void 
WWDG_ClearFlag
(void);

91 #ifdef 
__cplusplus


	@Libraries/STM32F4xx_StdPeriph_Driver/src/misc.c

70 #include 
	~"misc.h
"

83 #define 
	#AIRCR_VECTKEY_MASK
 ((
uint32_t
)0x05FA0000)

	)

112 void 
	$NVIC_PriorityGroupConfig
(
uint32_t
 
NVIC_PriorityGroup
)

115 
	`assert_param
(
	`IS_NVIC_PRIORITY_GROUP
(
NVIC_PriorityGroup
));

118 
SCB
->
AIRCR
 = 
AIRCR_VECTKEY_MASK
 | 
NVIC_PriorityGroup
;

119 
	}
}

130 void 
	$NVIC_Init
(
NVIC_InitTypeDef
* 
NVIC_InitStruct
)

132 
uint8_t
 
tmppriority
 = 0x00, 
tmppre
 = 0x00, 
tmpsub
 = 0x0F;

135 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NVIC_InitStruct
->
NVIC_IRQChannelCmd
));

136 
	`assert_param
(
	`IS_NVIC_PREEMPTION_PRIORITY
(
NVIC_InitStruct
->
NVIC_IRQChannelPreemptionPriority
));

137 
	`assert_param
(
	`IS_NVIC_SUB_PRIORITY
(
NVIC_InitStruct
->
NVIC_IRQChannelSubPriority
));

139 if (
NVIC_InitStruct
->
NVIC_IRQChannelCmd
 != 
DISABLE
)

142 
tmppriority
 = (0x700 - ((
SCB
->
AIRCR
) & (
uint32_t
)0x700))>> 0x08;

143 
tmppre
 = (0x4 - 
tmppriority
);

144 
tmpsub
 = tmpsub >> 
tmppriority
;

146 
tmppriority
 = 
NVIC_InitStruct
->
NVIC_IRQChannelPreemptionPriority
 << 
tmppre
;

147 
tmppriority
 |= (
uint8_t
)(
NVIC_InitStruct
->
NVIC_IRQChannelSubPriority
 & 
tmpsub
);

149 
tmppriority
 = tmppriority << 0x04;

151 
NVIC
->
IP
[
NVIC_InitStruct
->
NVIC_IRQChannel
] = 
tmppriority
;

154 
NVIC
->
ISER
[
NVIC_InitStruct
->
NVIC_IRQChannel
 >> 0x05] =

155 (
uint32_t
)0x01 << (
NVIC_InitStruct
->
NVIC_IRQChannel
 & (
uint8_t
)0x1F);

160 
NVIC
->
ICER
[
NVIC_InitStruct
->
NVIC_IRQChannel
 >> 0x05] =

161 (
uint32_t
)0x01 << (
NVIC_InitStruct
->
NVIC_IRQChannel
 & (
uint8_t
)0x1F);

163 
	}
}

174 void 
	$NVIC_SetVectorTable
(
uint32_t
 
NVIC_VectTab
, uint32_t 
Offset
)

177 
	`assert_param
(
	`IS_NVIC_VECTTAB
(
NVIC_VectTab
));

178 
	`assert_param
(
	`IS_NVIC_OFFSET
(
Offset
));

180 
SCB
->
VTOR
 = 
NVIC_VectTab
 | (
Offset
 & (
uint32_t
)0x1FFFFF80);

181 
	}
}

193 void 
	$NVIC_SystemLPConfig
(
uint8_t
 
LowPowerMode
, 
FunctionalState
 
NewState
)

196 
	`assert_param
(
	`IS_NVIC_LP
(
LowPowerMode
));

197 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

199 if (
NewState
 != 
DISABLE
)

201 
SCB
->
SCR
 |= 
LowPowerMode
;

205 
SCB
->
SCR
 &= (
uint32_t
)(~(uint32_t)
LowPowerMode
);

207 
	}
}

217 void 
	$SysTick_CLKSourceConfig
(
uint32_t
 
SysTick_CLKSource
)

220 
	`assert_param
(
	`IS_SYSTICK_CLK_SOURCE
(
SysTick_CLKSource
));

221 if (
SysTick_CLKSource
 == 
SysTick_CLKSource_HCLK
)

223 
SysTick
->
CTRL
 |= 
SysTick_CLKSource_HCLK
;

227 
SysTick
->
CTRL
 &= 
SysTick_CLKSource_HCLK_Div8
;

229 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_adc.c

98 #include 
	~"stm32f4xx_adc.h
"

99 #include 
	~"stm32f4xx_rcc.h
"

114 #define 
	#CR1_DISCNUM_RESET
 ((
uint32_t
)0xFFFF1FFF)

	)

117 #define 
	#CR1_AWDCH_RESET
 ((
uint32_t
)0xFFFFFFE0)

	)

120 #define 
	#CR1_AWDMode_RESET
 ((
uint32_t
)0xFF3FFDFF)

	)

123 #define 
	#CR1_CLEAR_MASK
 ((
uint32_t
)0xFCFFFEFF)

	)

126 #define 
	#CR2_EXTEN_RESET
 ((
uint32_t
)0xCFFFFFFF)

	)

129 #define 
	#CR2_JEXTEN_RESET
 ((
uint32_t
)0xFFCFFFFF)

	)

132 #define 
	#CR2_JEXTSEL_RESET
 ((
uint32_t
)0xFFF0FFFF)

	)

135 #define 
	#CR2_CLEAR_MASK
 ((
uint32_t
)0xC0FFF7FD)

	)

138 #define 
	#SQR3_SQ_SET
 ((
uint32_t
)0x0000001F)

	)

139 #define 
	#SQR2_SQ_SET
 ((
uint32_t
)0x0000001F)

	)

140 #define 
	#SQR1_SQ_SET
 ((
uint32_t
)0x0000001F)

	)

143 #define 
	#SQR1_L_RESET
 ((
uint32_t
)0xFF0FFFFF)

	)

146 #define 
	#JSQR_JSQ_SET
 ((
uint32_t
)0x0000001F)

	)

149 #define 
	#JSQR_JL_SET
 ((
uint32_t
)0x00300000)

	)

150 #define 
	#JSQR_JL_RESET
 ((
uint32_t
)0xFFCFFFFF)

	)

153 #define 
	#SMPR1_SMP_SET
 ((
uint32_t
)0x00000007)

	)

154 #define 
	#SMPR2_SMP_SET
 ((
uint32_t
)0x00000007)

	)

157 #define 
	#JDR_OFFSET
 ((
uint8_t
)0x28)

	)

160 #define 
	#CDR_ADDRESS
 ((
uint32_t
)0x40012308)

	)

163 #define 
	#CR_CLEAR_MASK
 ((
uint32_t
)0xFFFC30E0)

	)

206 void 
	$ADC_DeInit
(void)

209 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_ADC
, 
ENABLE
);

212 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_ADC
, 
DISABLE
);

213 
	}
}

228 void 
	$ADC_Init
(
ADC_TypeDef
* 
ADCx
, 
ADC_InitTypeDef
* 
ADC_InitStruct
)

230 
uint32_t
 
tmpreg1
 = 0;

231 
uint8_t
 
tmpreg2
 = 0;

233 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

234 
	`assert_param
(
	`IS_ADC_RESOLUTION
(
ADC_InitStruct
->
ADC_Resolution
));

235 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
ADC_InitStruct
->
ADC_ScanConvMode
));

236 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
ADC_InitStruct
->
ADC_ContinuousConvMode
));

237 
	`assert_param
(
	`IS_ADC_EXT_TRIG_EDGE
(
ADC_InitStruct
->
ADC_ExternalTrigConvEdge
));

238 
	`assert_param
(
	`IS_ADC_EXT_TRIG
(
ADC_InitStruct
->
ADC_ExternalTrigConv
));

239 
	`assert_param
(
	`IS_ADC_DATA_ALIGN
(
ADC_InitStruct
->
ADC_DataAlign
));

240 
	`assert_param
(
	`IS_ADC_REGULAR_LENGTH
(
ADC_InitStruct
->
ADC_NbrOfConversion
));

244 
tmpreg1
 = 
ADCx
->
CR1
;

247 
tmpreg1
 &= 
CR1_CLEAR_MASK
;

252 
tmpreg1
 |= (
uint32_t
)(((uint32_t)
ADC_InitStruct
->
ADC_ScanConvMode
 << 8) | \

253 
ADC_InitStruct
->
ADC_Resolution
);

255 
ADCx
->
CR1
 = 
tmpreg1
;

258 
tmpreg1
 = 
ADCx
->
CR2
;

261 
tmpreg1
 &= 
CR2_CLEAR_MASK
;

269 
tmpreg1
 |= (
uint32_t
)(
ADC_InitStruct
->
ADC_DataAlign
 | \

270 
ADC_InitStruct
->
ADC_ExternalTrigConv
 |

271 
ADC_InitStruct
->
ADC_ExternalTrigConvEdge
 | \

272 ((
uint32_t
)
ADC_InitStruct
->
ADC_ContinuousConvMode
 << 1));

275 
ADCx
->
CR2
 = 
tmpreg1
;

278 
tmpreg1
 = 
ADCx
->
SQR1
;

281 
tmpreg1
 &= 
SQR1_L_RESET
;

285 
tmpreg2
 |= (
uint8_t
)(
ADC_InitStruct
->
ADC_NbrOfConversion
 - (uint8_t)1);

286 
tmpreg1
 |= ((
uint32_t
)
tmpreg2
 << 20);

289 
ADCx
->
SQR1
 = 
tmpreg1
;

290 
	}
}

303 void 
	$ADC_StructInit
(
ADC_InitTypeDef
* 
ADC_InitStruct
)

306 
ADC_InitStruct
->
ADC_Resolution
 = 
ADC_Resolution_12b
;

309 
ADC_InitStruct
->
ADC_ScanConvMode
 = 
DISABLE
;

312 
ADC_InitStruct
->
ADC_ContinuousConvMode
 = 
DISABLE
;

315 
ADC_InitStruct
->
ADC_ExternalTrigConvEdge
 = 
ADC_ExternalTrigConvEdge_None
;

318 
ADC_InitStruct
->
ADC_ExternalTrigConv
 = 
ADC_ExternalTrigConv_T1_CC1
;

321 
ADC_InitStruct
->
ADC_DataAlign
 = 
ADC_DataAlign_Right
;

324 
ADC_InitStruct
->
ADC_NbrOfConversion
 = 1;

325 
	}
}

334 void 
	$ADC_CommonInit
(
ADC_CommonInitTypeDef
* 
ADC_CommonInitStruct
)

336 
uint32_t
 
tmpreg1
 = 0;

338 
	`assert_param
(
	`IS_ADC_MODE
(
ADC_CommonInitStruct
->
ADC_Mode
));

339 
	`assert_param
(
	`IS_ADC_PRESCALER
(
ADC_CommonInitStruct
->
ADC_Prescaler
));

340 
	`assert_param
(
	`IS_ADC_DMA_ACCESS_MODE
(
ADC_CommonInitStruct
->
ADC_DMAAccessMode
));

341 
	`assert_param
(
	`IS_ADC_SAMPLING_DELAY
(
ADC_CommonInitStruct
->
ADC_TwoSamplingDelay
));

344 
tmpreg1
 = 
ADC
->
CCR
;

347 
tmpreg1
 &= 
CR_CLEAR_MASK
;

355 
tmpreg1
 |= (
uint32_t
)(
ADC_CommonInitStruct
->
ADC_Mode
 |

356 
ADC_CommonInitStruct
->
ADC_Prescaler
 |

357 
ADC_CommonInitStruct
->
ADC_DMAAccessMode
 |

358 
ADC_CommonInitStruct
->
ADC_TwoSamplingDelay
);

361 
ADC
->
CCR
 = 
tmpreg1
;

362 
	}
}

370 void 
	$ADC_CommonStructInit
(
ADC_CommonInitTypeDef
* 
ADC_CommonInitStruct
)

373 
ADC_CommonInitStruct
->
ADC_Mode
 = 
ADC_Mode_Independent
;

376 
ADC_CommonInitStruct
->
ADC_Prescaler
 = 
ADC_Prescaler_Div2
;

379 
ADC_CommonInitStruct
->
ADC_DMAAccessMode
 = 
ADC_DMAAccessMode_Disabled
;

382 
ADC_CommonInitStruct
->
ADC_TwoSamplingDelay
 = 
ADC_TwoSamplingDelay_5Cycles
;

383 
	}
}

392 void 
	$ADC_Cmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

395 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

396 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

397 if (
NewState
 != 
DISABLE
)

400 
ADCx
->
CR2
 |= (
uint32_t
)
ADC_CR2_ADON
;

405 
ADCx
->
CR2
 &= (
uint32_t
)(~
ADC_CR2_ADON
);

407 
	}
}

450 void 
	$ADC_AnalogWatchdogCmd
(
ADC_TypeDef
* 
ADCx
, 
uint32_t
 
ADC_AnalogWatchdog
)

452 
uint32_t
 
tmpreg
 = 0;

454 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

455 
	`assert_param
(
	`IS_ADC_ANALOG_WATCHDOG
(
ADC_AnalogWatchdog
));

458 
tmpreg
 = 
ADCx
->
CR1
;

461 
tmpreg
 &= 
CR1_AWDMode_RESET
;

464 
tmpreg
 |= 
ADC_AnalogWatchdog
;

467 
ADCx
->
CR1
 = 
tmpreg
;

468 
	}
}

479 void 
	$ADC_AnalogWatchdogThresholdsConfig
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
HighThreshold
,

480 
uint16_t
 
LowThreshold
)

483 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

484 
	`assert_param
(
	`IS_ADC_THRESHOLD
(
HighThreshold
));

485 
	`assert_param
(
	`IS_ADC_THRESHOLD
(
LowThreshold
));

488 
ADCx
->
HTR
 = 
HighThreshold
;

491 
ADCx
->
LTR
 = 
LowThreshold
;

492 
	}
}

520 void 
	$ADC_AnalogWatchdogSingleChannelConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_Channel
)

522 
uint32_t
 
tmpreg
 = 0;

524 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

525 
	`assert_param
(
	`IS_ADC_CHANNEL
(
ADC_Channel
));

528 
tmpreg
 = 
ADCx
->
CR1
;

531 
tmpreg
 &= 
CR1_AWDCH_RESET
;

534 
tmpreg
 |= 
ADC_Channel
;

537 
ADCx
->
CR1
 = 
tmpreg
;

538 
	}
}

585 void 
	$ADC_TempSensorVrefintCmd
(
FunctionalState
 
NewState
)

588 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

589 if (
NewState
 != 
DISABLE
)

592 
ADC
->
CCR
 |= (
uint32_t
)
ADC_CCR_TSVREFE
;

597 
ADC
->
CCR
 &= (
uint32_t
)(~
ADC_CCR_TSVREFE
);

599 
	}
}

607 void 
	$ADC_VBATCmd
(
FunctionalState
 
NewState
)

610 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

611 if (
NewState
 != 
DISABLE
)

614 
ADC
->
CCR
 |= (
uint32_t
)
ADC_CCR_VBATE
;

619 
ADC
->
CCR
 &= (
uint32_t
)(~
ADC_CCR_VBATE
);

621 
	}
}

708 void 
	$ADC_RegularChannelConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_Channel
, uint8_t 
Rank
, uint8_t 
ADC_SampleTime
)

710 
uint32_t
 
tmpreg1
 = 0, 
tmpreg2
 = 0;

712 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

713 
	`assert_param
(
	`IS_ADC_CHANNEL
(
ADC_Channel
));

714 
	`assert_param
(
	`IS_ADC_REGULAR_RANK
(
Rank
));

715 
	`assert_param
(
	`IS_ADC_SAMPLE_TIME
(
ADC_SampleTime
));

718 if (
ADC_Channel
 > 
ADC_Channel_9
)

721 
tmpreg1
 = 
ADCx
->
SMPR1
;

724 
tmpreg2
 = 
SMPR1_SMP_SET
 << (3 * (
ADC_Channel
 - 10));

727 
tmpreg1
 &= ~
tmpreg2
;

730 
tmpreg2
 = (
uint32_t
)
ADC_SampleTime
 << (3 * (
ADC_Channel
 - 10));

733 
tmpreg1
 |= 
tmpreg2
;

736 
ADCx
->
SMPR1
 = 
tmpreg1
;

741 
tmpreg1
 = 
ADCx
->
SMPR2
;

744 
tmpreg2
 = 
SMPR2_SMP_SET
 << (3 * 
ADC_Channel
);

747 
tmpreg1
 &= ~
tmpreg2
;

750 
tmpreg2
 = (
uint32_t
)
ADC_SampleTime
 << (3 * 
ADC_Channel
);

753 
tmpreg1
 |= 
tmpreg2
;

756 
ADCx
->
SMPR2
 = 
tmpreg1
;

759 if (
Rank
 < 7)

762 
tmpreg1
 = 
ADCx
->
SQR3
;

765 
tmpreg2
 = 
SQR3_SQ_SET
 << (5 * (
Rank
 - 1));

768 
tmpreg1
 &= ~
tmpreg2
;

771 
tmpreg2
 = (
uint32_t
)
ADC_Channel
 << (5 * (
Rank
 - 1));

774 
tmpreg1
 |= 
tmpreg2
;

777 
ADCx
->
SQR3
 = 
tmpreg1
;

780 else if (
Rank
 < 13)

783 
tmpreg1
 = 
ADCx
->
SQR2
;

786 
tmpreg2
 = 
SQR2_SQ_SET
 << (5 * (
Rank
 - 7));

789 
tmpreg1
 &= ~
tmpreg2
;

792 
tmpreg2
 = (
uint32_t
)
ADC_Channel
 << (5 * (
Rank
 - 7));

795 
tmpreg1
 |= 
tmpreg2
;

798 
ADCx
->
SQR2
 = 
tmpreg1
;

804 
tmpreg1
 = 
ADCx
->
SQR1
;

807 
tmpreg2
 = 
SQR1_SQ_SET
 << (5 * (
Rank
 - 13));

810 
tmpreg1
 &= ~
tmpreg2
;

813 
tmpreg2
 = (
uint32_t
)
ADC_Channel
 << (5 * (
Rank
 - 13));

816 
tmpreg1
 |= 
tmpreg2
;

819 
ADCx
->
SQR1
 = 
tmpreg1
;

821 
	}
}

828 void 
	$ADC_SoftwareStartConv
(
ADC_TypeDef
* 
ADCx
)

831 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

834 
ADCx
->
CR2
 |= (
uint32_t
)
ADC_CR2_SWSTART
;

835 
	}
}

842 
FlagStatus
 
	$ADC_GetSoftwareStartConvStatus
(
ADC_TypeDef
* 
ADCx
)

844 
FlagStatus
 
bitstatus
 = 
RESET
;

846 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

849 if ((
ADCx
->
CR2
 & 
ADC_CR2_JSWSTART
) != (
uint32_t
)
RESET
)

852 
bitstatus
 = 
SET
;

857 
bitstatus
 = 
RESET
;

861 return 
bitstatus
;

862 
	}
}

872 void 
	$ADC_EOCOnEachRegularChannelCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

875 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

876 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

878 if (
NewState
 != 
DISABLE
)

881 
ADCx
->
CR2
 |= (
uint32_t
)
ADC_CR2_EOCS
;

886 
ADCx
->
CR2
 &= (
uint32_t
)(~
ADC_CR2_EOCS
);

888 
	}
}

897 void 
	$ADC_ContinuousModeCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

900 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

901 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

903 if (
NewState
 != 
DISABLE
)

906 
ADCx
->
CR2
 |= (
uint32_t
)
ADC_CR2_CONT
;

911 
ADCx
->
CR2
 &= (
uint32_t
)(~
ADC_CR2_CONT
);

913 
	}
}

923 void 
	$ADC_DiscModeChannelCountConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
Number
)

925 
uint32_t
 
tmpreg1
 = 0;

926 
uint32_t
 
tmpreg2
 = 0;

929 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

930 
	`assert_param
(
	`IS_ADC_REGULAR_DISC_NUMBER
(
Number
));

933 
tmpreg1
 = 
ADCx
->
CR1
;

936 
tmpreg1
 &= 
CR1_DISCNUM_RESET
;

939 
tmpreg2
 = 
Number
 - 1;

940 
tmpreg1
 |= 
tmpreg2
 << 13;

943 
ADCx
->
CR1
 = 
tmpreg1
;

944 
	}
}

955 void 
	$ADC_DiscModeCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

958 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

959 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

961 if (
NewState
 != 
DISABLE
)

964 
ADCx
->
CR1
 |= (
uint32_t
)
ADC_CR1_DISCEN
;

969 
ADCx
->
CR1
 &= (
uint32_t
)(~
ADC_CR1_DISCEN
);

971 
	}
}

978 
uint16_t
 
	$ADC_GetConversionValue
(
ADC_TypeDef
* 
ADCx
)

981 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

984 return (
uint16_t
) 
ADCx
->
DR
;

985 
	}
}

999 
uint32_t
 
	$ADC_GetMultiModeConversionValue
(void)

1002 return (*(
__IO
 
uint32_t
 *) 
CDR_ADDRESS
);

1003 
	}
}

1048 void 
	$ADC_DMACmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

1051 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1052 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1053 if (
NewState
 != 
DISABLE
)

1056 
ADCx
->
CR2
 |= (
uint32_t
)
ADC_CR2_DMA
;

1061 
ADCx
->
CR2
 &= (
uint32_t
)(~
ADC_CR2_DMA
);

1063 
	}
}

1072 void 
	$ADC_DMARequestAfterLastTransferCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

1075 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1076 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1077 if (
NewState
 != 
DISABLE
)

1080 
ADCx
->
CR2
 |= (
uint32_t
)
ADC_CR2_DDS
;

1085 
ADCx
->
CR2
 &= (
uint32_t
)(~
ADC_CR2_DDS
);

1087 
	}
}

1099 void 
	$ADC_MultiModeDMARequestAfterLastTransferCmd
(
FunctionalState
 
NewState
)

1102 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1103 if (
NewState
 != 
DISABLE
)

1106 
ADC
->
CCR
 |= (
uint32_t
)
ADC_CCR_DDS
;

1111 
ADC
->
CCR
 &= (
uint32_t
)(~
ADC_CCR_DDS
);

1113 
	}
}

1186 void 
	$ADC_InjectedChannelConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_Channel
, uint8_t 
Rank
, uint8_t 
ADC_SampleTime
)

1188 
uint32_t
 
tmpreg1
 = 0, 
tmpreg2
 = 0, 
tmpreg3
 = 0;

1190 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1191 
	`assert_param
(
	`IS_ADC_CHANNEL
(
ADC_Channel
));

1192 
	`assert_param
(
	`IS_ADC_INJECTED_RANK
(
Rank
));

1193 
	`assert_param
(
	`IS_ADC_SAMPLE_TIME
(
ADC_SampleTime
));

1195 if (
ADC_Channel
 > 
ADC_Channel_9
)

1198 
tmpreg1
 = 
ADCx
->
SMPR1
;

1200 
tmpreg2
 = 
SMPR1_SMP_SET
 << (3*(
ADC_Channel
 - 10));

1202 
tmpreg1
 &= ~
tmpreg2
;

1204 
tmpreg2
 = (
uint32_t
)
ADC_SampleTime
 << (3*(
ADC_Channel
 - 10));

1206 
tmpreg1
 |= 
tmpreg2
;

1208 
ADCx
->
SMPR1
 = 
tmpreg1
;

1213 
tmpreg1
 = 
ADCx
->
SMPR2
;

1215 
tmpreg2
 = 
SMPR2_SMP_SET
 << (3 * 
ADC_Channel
);

1217 
tmpreg1
 &= ~
tmpreg2
;

1219 
tmpreg2
 = (
uint32_t
)
ADC_SampleTime
 << (3 * 
ADC_Channel
);

1221 
tmpreg1
 |= 
tmpreg2
;

1223 
ADCx
->
SMPR2
 = 
tmpreg1
;

1227 
tmpreg1
 = 
ADCx
->
JSQR
;

1229 
tmpreg3
 = (
tmpreg1
 & 
JSQR_JL_SET
)>> 20;

1231 
tmpreg2
 = 
JSQR_JSQ_SET
 << (5 * (
uint8_t
)((
Rank
 + 3) - (
tmpreg3
 + 1)));

1233 
tmpreg1
 &= ~
tmpreg2
;

1235 
tmpreg2
 = (
uint32_t
)
ADC_Channel
 << (5 * (
uint8_t
)((
Rank
 + 3) - (
tmpreg3
 + 1)));

1237 
tmpreg1
 |= 
tmpreg2
;

1239 
ADCx
->
JSQR
 = 
tmpreg1
;

1240 
	}
}

1249 void 
	$ADC_InjectedSequencerLengthConfig
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
Length
)

1251 
uint32_t
 
tmpreg1
 = 0;

1252 
uint32_t
 
tmpreg2
 = 0;

1254 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1255 
	`assert_param
(
	`IS_ADC_INJECTED_LENGTH
(
Length
));

1258 
tmpreg1
 = 
ADCx
->
JSQR
;

1261 
tmpreg1
 &= 
JSQR_JL_RESET
;

1264 
tmpreg2
 = 
Length
 - 1;

1265 
tmpreg1
 |= 
tmpreg2
 << 20;

1268 
ADCx
->
JSQR
 = 
tmpreg1
;

1269 
	}
}

1284 void 
	$ADC_SetInjectedOffset
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_InjectedChannel
, 
uint16_t
 
Offset
)

1286 
__IO
 
uint32_t
 
tmp
 = 0;

1288 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1289 
	`assert_param
(
	`IS_ADC_INJECTED_CHANNEL
(
ADC_InjectedChannel
));

1290 
	`assert_param
(
	`IS_ADC_OFFSET
(
Offset
));

1292 
tmp
 = (
uint32_t
)
ADCx
;

1293 
tmp
 += 
ADC_InjectedChannel
;

1296 *(
__IO
 
uint32_t
 *) 
tmp
 = (uint32_t)
Offset
;

1297 
	}
}

1322 void 
	$ADC_ExternalTrigInjectedConvConfig
(
ADC_TypeDef
* 
ADCx
, 
uint32_t
 
ADC_ExternalTrigInjecConv
)

1324 
uint32_t
 
tmpreg
 = 0;

1326 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1327 
	`assert_param
(
	`IS_ADC_EXT_INJEC_TRIG
(
ADC_ExternalTrigInjecConv
));

1330 
tmpreg
 = 
ADCx
->
CR2
;

1333 
tmpreg
 &= 
CR2_JEXTSEL_RESET
;

1336 
tmpreg
 |= 
ADC_ExternalTrigInjecConv
;

1339 
ADCx
->
CR2
 = 
tmpreg
;

1340 
	}
}

1356 void 
	$ADC_ExternalTrigInjectedConvEdgeConfig
(
ADC_TypeDef
* 
ADCx
, 
uint32_t
 
ADC_ExternalTrigInjecConvEdge
)

1358 
uint32_t
 
tmpreg
 = 0;

1360 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1361 
	`assert_param
(
	`IS_ADC_EXT_INJEC_TRIG_EDGE
(
ADC_ExternalTrigInjecConvEdge
));

1363 
tmpreg
 = 
ADCx
->
CR2
;

1365 
tmpreg
 &= 
CR2_JEXTEN_RESET
;

1367 
tmpreg
 |= 
ADC_ExternalTrigInjecConvEdge
;

1369 
ADCx
->
CR2
 = 
tmpreg
;

1370 
	}
}

1377 void 
	$ADC_SoftwareStartInjectedConv
(
ADC_TypeDef
* 
ADCx
)

1380 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1382 
ADCx
->
CR2
 |= (
uint32_t
)
ADC_CR2_JSWSTART
;

1383 
	}
}

1390 
FlagStatus
 
	$ADC_GetSoftwareStartInjectedConvCmdStatus
(
ADC_TypeDef
* 
ADCx
)

1392 
FlagStatus
 
bitstatus
 = 
RESET
;

1394 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1397 if ((
ADCx
->
CR2
 & 
ADC_CR2_JSWSTART
) != (
uint32_t
)
RESET
)

1400 
bitstatus
 = 
SET
;

1405 
bitstatus
 = 
RESET
;

1408 return 
bitstatus
;

1409 
	}
}

1419 void 
	$ADC_AutoInjectedConvCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

1422 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1423 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1424 if (
NewState
 != 
DISABLE
)

1427 
ADCx
->
CR1
 |= (
uint32_t
)
ADC_CR1_JAUTO
;

1432 
ADCx
->
CR1
 &= (
uint32_t
)(~
ADC_CR1_JAUTO
);

1434 
	}
}

1445 void 
	$ADC_InjectedDiscModeCmd
(
ADC_TypeDef
* 
ADCx
, 
FunctionalState
 
NewState
)

1448 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1449 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1450 if (
NewState
 != 
DISABLE
)

1453 
ADCx
->
CR1
 |= (
uint32_t
)
ADC_CR1_JDISCEN
;

1458 
ADCx
->
CR1
 &= (
uint32_t
)(~
ADC_CR1_JDISCEN
);

1460 
	}
}

1473 
uint16_t
 
	$ADC_GetInjectedConversionValue
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_InjectedChannel
)

1475 
__IO
 
uint32_t
 
tmp
 = 0;

1478 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1479 
	`assert_param
(
	`IS_ADC_INJECTED_CHANNEL
(
ADC_InjectedChannel
));

1481 
tmp
 = (
uint32_t
)
ADCx
;

1482 
tmp
 += 
ADC_InjectedChannel
 + 
JDR_OFFSET
;

1485 return (
uint16_t
) (*(
__IO
 
uint32_t
*) 
tmp
);

1486 
	}
}

1581 void 
	$ADC_ITConfig
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
ADC_IT
, 
FunctionalState
 
NewState
)

1583 
uint32_t
 
itmask
 = 0;

1585 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1586 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1587 
	`assert_param
(
	`IS_ADC_IT
(
ADC_IT
));

1590 
itmask
 = (
uint8_t
)
ADC_IT
;

1591 
itmask
 = (
uint32_t
)0x01 << itmask;

1593 if (
NewState
 != 
DISABLE
)

1596 
ADCx
->
CR1
 |= 
itmask
;

1601 
ADCx
->
CR1
 &= (~(
uint32_t
)
itmask
);

1603 
	}
}

1618 
FlagStatus
 
	$ADC_GetFlagStatus
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_FLAG
)

1620 
FlagStatus
 
bitstatus
 = 
RESET
;

1622 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1623 
	`assert_param
(
	`IS_ADC_GET_FLAG
(
ADC_FLAG
));

1626 if ((
ADCx
->
SR
 & 
ADC_FLAG
) != (
uint8_t
)
RESET
)

1629 
bitstatus
 = 
SET
;

1634 
bitstatus
 = 
RESET
;

1637 return 
bitstatus
;

1638 
	}
}

1653 void 
	$ADC_ClearFlag
(
ADC_TypeDef
* 
ADCx
, 
uint8_t
 
ADC_FLAG
)

1656 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1657 
	`assert_param
(
	`IS_ADC_CLEAR_FLAG
(
ADC_FLAG
));

1660 
ADCx
->
SR
 = ~(
uint32_t
)
ADC_FLAG
;

1661 
	}
}

1674 
ITStatus
 
	$ADC_GetITStatus
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
ADC_IT
)

1676 
ITStatus
 
bitstatus
 = 
RESET
;

1677 
uint32_t
 
itmask
 = 0, 
enablestatus
 = 0;

1680 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1681 
	`assert_param
(
	`IS_ADC_IT
(
ADC_IT
));

1684 
itmask
 = 
ADC_IT
 >> 8;

1687 
enablestatus
 = (
ADCx
->
CR1
 & ((
uint32_t
)0x01 << (
uint8_t
)
ADC_IT
)) ;

1690 if (((
ADCx
->
SR
 & 
itmask
) != (
uint32_t
)
RESET
) && 
enablestatus
)

1693 
bitstatus
 = 
SET
;

1698 
bitstatus
 = 
RESET
;

1701 return 
bitstatus
;

1702 
	}
}

1715 void 
	$ADC_ClearITPendingBit
(
ADC_TypeDef
* 
ADCx
, 
uint16_t
 
ADC_IT
)

1717 
uint8_t
 
itmask
 = 0;

1719 
	`assert_param
(
	`IS_ADC_ALL_PERIPH
(
ADCx
));

1720 
	`assert_param
(
	`IS_ADC_IT
(
ADC_IT
));

1722 
itmask
 = (
uint8_t
)(
ADC_IT
 >> 8);

1724 
ADCx
->
SR
 = ~(
uint32_t
)
itmask
;

1725 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_can.c

80 #include 
	~"stm32f4xx_can.h
"

81 #include 
	~"stm32f4xx_rcc.h
"

95 #define 
	#MCR_DBF
 ((
uint32_t
)0x00010000)

	)

98 #define 
	#TMIDxR_TXRQ
 ((
uint32_t
)0x00000001)

	)

101 #define 
	#FMR_FINIT
 ((
uint32_t
)0x00000001)

	)

104 #define 
	#INAK_TIMEOUT
 ((
uint32_t
)0x0000FFFF)

	)

106 #define 
	#SLAK_TIMEOUT
 ((
uint32_t
)0x0000FFFF)

	)

109 #define 
	#CAN_FLAGS_TSR
 ((
uint32_t
)0x08000000)

	)

111 #define 
	#CAN_FLAGS_RF1R
 ((
uint32_t
)0x04000000)

	)

113 #define 
	#CAN_FLAGS_RF0R
 ((
uint32_t
)0x02000000)

	)

115 #define 
	#CAN_FLAGS_MSR
 ((
uint32_t
)0x01000000)

	)

117 #define 
	#CAN_FLAGS_ESR
 ((
uint32_t
)0x00F00000)

	)

120 #define 
	#CAN_TXMAILBOX_0
 ((
uint8_t
)0x00)

	)

121 #define 
	#CAN_TXMAILBOX_1
 ((
uint8_t
)0x01)

	)

122 #define 
	#CAN_TXMAILBOX_2
 ((
uint8_t
)0x02)

	)

124 #define 
	#CAN_MODE_MASK
 ((
uint32_t
) 0x00000003)

	)

130 static 
ITStatus
 
CheckITStatus
(
uint32_t
 
CAN_Reg
, uint32_t 
It_Bit
);

162 void 
	$CAN_DeInit
(
CAN_TypeDef
* 
CANx
)

165 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

167 if (
CANx
 == 
CAN1
)

170 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_CAN1
, 
ENABLE
);

172 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_CAN1
, 
DISABLE
);

177 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_CAN2
, 
ENABLE
);

179 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_CAN2
, 
DISABLE
);

181 
	}
}

192 
uint8_t
 
	$CAN_Init
(
CAN_TypeDef
* 
CANx
, 
CAN_InitTypeDef
* 
CAN_InitStruct
)

194 
uint8_t
 
InitStatus
 = 
CAN_InitStatus_Failed
;

195 
uint32_t
 
wait_ack
 = 0x00000000;

197 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

198 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
CAN_InitStruct
->
CAN_TTCM
));

199 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
CAN_InitStruct
->
CAN_ABOM
));

200 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
CAN_InitStruct
->
CAN_AWUM
));

201 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
CAN_InitStruct
->
CAN_NART
));

202 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
CAN_InitStruct
->
CAN_RFLM
));

203 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
CAN_InitStruct
->
CAN_TXFP
));

204 
	`assert_param
(
	`IS_CAN_MODE
(
CAN_InitStruct
->
CAN_Mode
));

205 
	`assert_param
(
	`IS_CAN_SJW
(
CAN_InitStruct
->
CAN_SJW
));

206 
	`assert_param
(
	`IS_CAN_BS1
(
CAN_InitStruct
->
CAN_BS1
));

207 
	`assert_param
(
	`IS_CAN_BS2
(
CAN_InitStruct
->
CAN_BS2
));

208 
	`assert_param
(
	`IS_CAN_PRESCALER
(
CAN_InitStruct
->
CAN_Prescaler
));

211 
CANx
->
MCR
 &= (~(
uint32_t
)
CAN_MCR_SLEEP
);

214 
CANx
->
MCR
 |= 
CAN_MCR_INRQ
 ;

217 while (((
CANx
->
MSR
 & 
CAN_MSR_INAK
) != CAN_MSR_INAK) && (
wait_ack
 != 
INAK_TIMEOUT
))

219 
wait_ack
++;

223 if ((
CANx
->
MSR
 & 
CAN_MSR_INAK
) != CAN_MSR_INAK)

225 
InitStatus
 = 
CAN_InitStatus_Failed
;

230 if (
CAN_InitStruct
->
CAN_TTCM
 == 
ENABLE
)

232 
CANx
->
MCR
 |= 
CAN_MCR_TTCM
;

236 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_TTCM
;

240 if (
CAN_InitStruct
->
CAN_ABOM
 == 
ENABLE
)

242 
CANx
->
MCR
 |= 
CAN_MCR_ABOM
;

246 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_ABOM
;

250 if (
CAN_InitStruct
->
CAN_AWUM
 == 
ENABLE
)

252 
CANx
->
MCR
 |= 
CAN_MCR_AWUM
;

256 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_AWUM
;

260 if (
CAN_InitStruct
->
CAN_NART
 == 
ENABLE
)

262 
CANx
->
MCR
 |= 
CAN_MCR_NART
;

266 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_NART
;

270 if (
CAN_InitStruct
->
CAN_RFLM
 == 
ENABLE
)

272 
CANx
->
MCR
 |= 
CAN_MCR_RFLM
;

276 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_RFLM
;

280 if (
CAN_InitStruct
->
CAN_TXFP
 == 
ENABLE
)

282 
CANx
->
MCR
 |= 
CAN_MCR_TXFP
;

286 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_TXFP
;

290 
CANx
->
BTR
 = (
uint32_t
)((uint32_t)
CAN_InitStruct
->
CAN_Mode
 << 30) | \

291 ((
uint32_t
)
CAN_InitStruct
->
CAN_SJW
 << 24) | \

292 ((
uint32_t
)
CAN_InitStruct
->
CAN_BS1
 << 16) | \

293 ((
uint32_t
)
CAN_InitStruct
->
CAN_BS2
 << 20) | \

294 ((
uint32_t
)
CAN_InitStruct
->
CAN_Prescaler
 - 1);

297 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_INRQ
;

300 
wait_ack
 = 0;

302 while (((
CANx
->
MSR
 & 
CAN_MSR_INAK
) == CAN_MSR_INAK) && (
wait_ack
 != 
INAK_TIMEOUT
))

304 
wait_ack
++;

308 if ((
CANx
->
MSR
 & 
CAN_MSR_INAK
) == CAN_MSR_INAK)

310 
InitStatus
 = 
CAN_InitStatus_Failed
;

314 
InitStatus
 = 
CAN_InitStatus_Success
 ;

319 return 
InitStatus
;

320 
	}
}

329 void 
	$CAN_FilterInit
(
CAN_FilterInitTypeDef
* 
CAN_FilterInitStruct
)

331 
uint32_t
 
filter_number_bit_pos
 = 0;

333 
	`assert_param
(
	`IS_CAN_FILTER_NUMBER
(
CAN_FilterInitStruct
->
CAN_FilterNumber
));

334 
	`assert_param
(
	`IS_CAN_FILTER_MODE
(
CAN_FilterInitStruct
->
CAN_FilterMode
));

335 
	`assert_param
(
	`IS_CAN_FILTER_SCALE
(
CAN_FilterInitStruct
->
CAN_FilterScale
));

336 
	`assert_param
(
	`IS_CAN_FILTER_FIFO
(
CAN_FilterInitStruct
->
CAN_FilterFIFOAssignment
));

337 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
CAN_FilterInitStruct
->
CAN_FilterActivation
));

339 
filter_number_bit_pos
 = ((
uint32_t
)1) << 
CAN_FilterInitStruct
->
CAN_FilterNumber
;

342 
CAN1
->
FMR
 |= 
FMR_FINIT
;

345 
CAN1
->
FA1R
 &= ~(
uint32_t
)
filter_number_bit_pos
;

348 if (
CAN_FilterInitStruct
->
CAN_FilterScale
 == 
CAN_FilterScale_16bit
)

351 
CAN1
->
FS1R
 &= ~(
uint32_t
)
filter_number_bit_pos
;

355 
CAN1
->
sFilterRegister
[
CAN_FilterInitStruct
->
CAN_FilterNumber
].
FR1
 =

356 ((0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterMaskIdLow
) << 16) |

357 (0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterIdLow
);

361 
CAN1
->
sFilterRegister
[
CAN_FilterInitStruct
->
CAN_FilterNumber
].
FR2
 =

362 ((0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterMaskIdHigh
) << 16) |

363 (0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterIdHigh
);

366 if (
CAN_FilterInitStruct
->
CAN_FilterScale
 == 
CAN_FilterScale_32bit
)

369 
CAN1
->
FS1R
 |= 
filter_number_bit_pos
;

371 
CAN1
->
sFilterRegister
[
CAN_FilterInitStruct
->
CAN_FilterNumber
].
FR1
 =

372 ((0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterIdHigh
) << 16) |

373 (0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterIdLow
);

375 
CAN1
->
sFilterRegister
[
CAN_FilterInitStruct
->
CAN_FilterNumber
].
FR2
 =

376 ((0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterMaskIdHigh
) << 16) |

377 (0x0000FFFF & (
uint32_t
)
CAN_FilterInitStruct
->
CAN_FilterMaskIdLow
);

381 if (
CAN_FilterInitStruct
->
CAN_FilterMode
 == 
CAN_FilterMode_IdMask
)

384 
CAN1
->
FM1R
 &= ~(
uint32_t
)
filter_number_bit_pos
;

389 
CAN1
->
FM1R
 |= (
uint32_t
)
filter_number_bit_pos
;

393 if (
CAN_FilterInitStruct
->
CAN_FilterFIFOAssignment
 == 
CAN_Filter_FIFO0
)

396 
CAN1
->
FFA1R
 &= ~(
uint32_t
)
filter_number_bit_pos
;

399 if (
CAN_FilterInitStruct
->
CAN_FilterFIFOAssignment
 == 
CAN_Filter_FIFO1
)

402 
CAN1
->
FFA1R
 |= (
uint32_t
)
filter_number_bit_pos
;

406 if (
CAN_FilterInitStruct
->
CAN_FilterActivation
 == 
ENABLE
)

408 
CAN1
->
FA1R
 |= 
filter_number_bit_pos
;

412 
CAN1
->
FMR
 &= ~
FMR_FINIT
;

413 
	}
}

420 void 
	$CAN_StructInit
(
CAN_InitTypeDef
* 
CAN_InitStruct
)

425 
CAN_InitStruct
->
CAN_TTCM
 = 
DISABLE
;

428 
CAN_InitStruct
->
CAN_ABOM
 = 
DISABLE
;

431 
CAN_InitStruct
->
CAN_AWUM
 = 
DISABLE
;

434 
CAN_InitStruct
->
CAN_NART
 = 
DISABLE
;

437 
CAN_InitStruct
->
CAN_RFLM
 = 
DISABLE
;

440 
CAN_InitStruct
->
CAN_TXFP
 = 
DISABLE
;

443 
CAN_InitStruct
->
CAN_Mode
 = 
CAN_Mode_Normal
;

446 
CAN_InitStruct
->
CAN_SJW
 = 
CAN_SJW_1tq
;

449 
CAN_InitStruct
->
CAN_BS1
 = 
CAN_BS1_4tq
;

452 
CAN_InitStruct
->
CAN_BS2
 = 
CAN_BS2_3tq
;

455 
CAN_InitStruct
->
CAN_Prescaler
 = 1;

456 
	}
}

463 void 
	$CAN_SlaveStartBank
(
uint8_t
 
CAN_BankNumber
)

466 
	`assert_param
(
	`IS_CAN_BANKNUMBER
(
CAN_BankNumber
));

469 
CAN1
->
FMR
 |= 
FMR_FINIT
;

472 
CAN1
->
FMR
 &= (
uint32_t
)0xFFFFC0F1 ;

473 
CAN1
->
FMR
 |= (
uint32_t
)(
CAN_BankNumber
)<<8;

476 
CAN1
->
FMR
 &= ~
FMR_FINIT
;

477 
	}
}

488 void 
	$CAN_DBGFreeze
(
CAN_TypeDef
* 
CANx
, 
FunctionalState
 
NewState
)

491 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

492 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

494 if (
NewState
 != 
DISABLE
)

497 
CANx
->
MCR
 |= 
MCR_DBF
;

502 
CANx
->
MCR
 &= ~
MCR_DBF
;

504 
	}
}

518 void 
	$CAN_TTComModeCmd
(
CAN_TypeDef
* 
CANx
, 
FunctionalState
 
NewState
)

521 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

522 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

523 if (
NewState
 != 
DISABLE
)

526 
CANx
->
MCR
 |= 
CAN_MCR_TTCM
;

529 
CANx
->
sTxMailBox
[0].
TDTR
 |= ((
uint32_t
)
CAN_TDT0R_TGT
);

530 
CANx
->
sTxMailBox
[1].
TDTR
 |= ((
uint32_t
)
CAN_TDT1R_TGT
);

531 
CANx
->
sTxMailBox
[2].
TDTR
 |= ((
uint32_t
)
CAN_TDT2R_TGT
);

536 
CANx
->
MCR
 &= (
uint32_t
)(~(uint32_t)
CAN_MCR_TTCM
);

539 
CANx
->
sTxMailBox
[0].
TDTR
 &= ((
uint32_t
)~
CAN_TDT0R_TGT
);

540 
CANx
->
sTxMailBox
[1].
TDTR
 &= ((
uint32_t
)~
CAN_TDT1R_TGT
);

541 
CANx
->
sTxMailBox
[2].
TDTR
 &= ((
uint32_t
)~
CAN_TDT2R_TGT
);

543 
	}
}

572 
uint8_t
 
	$CAN_Transmit
(
CAN_TypeDef
* 
CANx
, 
CanTxMsg
* 
TxMessage
)

574 
uint8_t
 
transmit_mailbox
 = 0;

576 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

577 
	`assert_param
(
	`IS_CAN_IDTYPE
(
TxMessage
->
IDE
));

578 
	`assert_param
(
	`IS_CAN_RTR
(
TxMessage
->
RTR
));

579 
	`assert_param
(
	`IS_CAN_DLC
(
TxMessage
->
DLC
));

582 if ((
CANx
->
TSR
&
CAN_TSR_TME0
) == CAN_TSR_TME0)

584 
transmit_mailbox
 = 0;

586 else if ((
CANx
->
TSR
&
CAN_TSR_TME1
) == CAN_TSR_TME1)

588 
transmit_mailbox
 = 1;

590 else if ((
CANx
->
TSR
&
CAN_TSR_TME2
) == CAN_TSR_TME2)

592 
transmit_mailbox
 = 2;

596 
transmit_mailbox
 = 
CAN_TxStatus_NoMailBox
;

599 if (
transmit_mailbox
 != 
CAN_TxStatus_NoMailBox
)

602 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TIR
 &= 
TMIDxR_TXRQ
;

603 if (
TxMessage
->
IDE
 == 
CAN_Id_Standard
)

605 
	`assert_param
(
	`IS_CAN_STDID
(
TxMessage
->
StdId
));

606 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TIR
 |= ((
TxMessage
->
StdId
 << 21) | \

607 
TxMessage
->
RTR
);

611 
	`assert_param
(
	`IS_CAN_EXTID
(
TxMessage
->
ExtId
));

612 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TIR
 |= ((
TxMessage
->
ExtId
 << 3) | \

613 
TxMessage
->
IDE
 | \

614 
TxMessage
->
RTR
);

618 
TxMessage
->
DLC
 &= (
uint8_t
)0x0000000F;

619 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TDTR
 &= (
uint32_t
)0xFFFFFFF0;

620 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TDTR
 |= 
TxMessage
->
DLC
;

623 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TDLR
 = (((
uint32_t
)
TxMessage
->
Data
[3] << 24) |

624 ((
uint32_t
)
TxMessage
->
Data
[2] << 16) |

625 ((
uint32_t
)
TxMessage
->
Data
[1] << 8) |

626 ((
uint32_t
)
TxMessage
->
Data
[0]));

627 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TDHR
 = (((
uint32_t
)
TxMessage
->
Data
[7] << 24) |

628 ((
uint32_t
)
TxMessage
->
Data
[6] << 16) |

629 ((
uint32_t
)
TxMessage
->
Data
[5] << 8) |

630 ((
uint32_t
)
TxMessage
->
Data
[4]));

632 
CANx
->
sTxMailBox
[
transmit_mailbox
].
TIR
 |= 
TMIDxR_TXRQ
;

634 return 
transmit_mailbox
;

635 
	}
}

644 
uint8_t
 
	$CAN_TransmitStatus
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
TransmitMailbox
)

646 
uint32_t
 
state
 = 0;

649 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

650 
	`assert_param
(
	`IS_CAN_TRANSMITMAILBOX
(
TransmitMailbox
));

652 switch (
TransmitMailbox
)

654 case (
CAN_TXMAILBOX_0
):

655 
state
 = 
CANx
->
TSR
 & (
CAN_TSR_RQCP0
 | 
CAN_TSR_TXOK0
 | 
CAN_TSR_TME0
);

657 case (
CAN_TXMAILBOX_1
):

658 
state
 = 
CANx
->
TSR
 & (
CAN_TSR_RQCP1
 | 
CAN_TSR_TXOK1
 | 
CAN_TSR_TME1
);

660 case (
CAN_TXMAILBOX_2
):

661 
state
 = 
CANx
->
TSR
 & (
CAN_TSR_RQCP2
 | 
CAN_TSR_TXOK2
 | 
CAN_TSR_TME2
);

664 
state
 = 
CAN_TxStatus_Failed
;

667 switch (
state
)

670 case (0x0): 
state
 = 
CAN_TxStatus_Pending
;

673 case (
CAN_TSR_RQCP0
 | 
CAN_TSR_TME0
): 
state
 = 
CAN_TxStatus_Failed
;

675 case (
CAN_TSR_RQCP1
 | 
CAN_TSR_TME1
): 
state
 = 
CAN_TxStatus_Failed
;

677 case (
CAN_TSR_RQCP2
 | 
CAN_TSR_TME2
): 
state
 = 
CAN_TxStatus_Failed
;

680 case (
CAN_TSR_RQCP0
 | 
CAN_TSR_TXOK0
 | 
CAN_TSR_TME0
):
state
 = 
CAN_TxStatus_Ok
;

682 case (
CAN_TSR_RQCP1
 | 
CAN_TSR_TXOK1
 | 
CAN_TSR_TME1
):
state
 = 
CAN_TxStatus_Ok
;

684 case (
CAN_TSR_RQCP2
 | 
CAN_TSR_TXOK2
 | 
CAN_TSR_TME2
):
state
 = 
CAN_TxStatus_Ok
;

686 default: 
state
 = 
CAN_TxStatus_Failed
;

689 return (
uint8_t
) 
state
;

690 
	}
}

698 void 
	$CAN_CancelTransmit
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
Mailbox
)

701 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

702 
	`assert_param
(
	`IS_CAN_TRANSMITMAILBOX
(
Mailbox
));

704 switch (
Mailbox
)

706 case (
CAN_TXMAILBOX_0
): 
CANx
->
TSR
 |= 
CAN_TSR_ABRQ0
;

708 case (
CAN_TXMAILBOX_1
): 
CANx
->
TSR
 |= 
CAN_TSR_ABRQ1
;

710 case (
CAN_TXMAILBOX_2
): 
CANx
->
TSR
 |= 
CAN_TSR_ABRQ2
;

715 
	}
}

745 void 
	$CAN_Receive
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
FIFONumber
, 
CanRxMsg
* 
RxMessage
)

748 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

749 
	`assert_param
(
	`IS_CAN_FIFO
(
FIFONumber
));

751 
RxMessage
->
IDE
 = (
uint8_t
)0x04 & 
CANx
->
sFIFOMailBox
[
FIFONumber
].
RIR
;

752 if (
RxMessage
->
IDE
 == 
CAN_Id_Standard
)

754 
RxMessage
->
StdId
 = (
uint32_t
)0x000007FF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RIR
 >> 21);

758 
RxMessage
->
ExtId
 = (
uint32_t
)0x1FFFFFFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RIR
 >> 3);

761 
RxMessage
->
RTR
 = (
uint8_t
)0x02 & 
CANx
->
sFIFOMailBox
[
FIFONumber
].
RIR
;

763 
RxMessage
->
DLC
 = (
uint8_t
)0x0F & 
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDTR
;

765 
RxMessage
->
FMI
 = (
uint8_t
)0xFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDTR
 >> 8);

767 
RxMessage
->
Data
[0] = (
uint8_t
)0xFF & 
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDLR
;

768 
RxMessage
->
Data
[1] = (
uint8_t
)0xFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDLR
 >> 8);

769 
RxMessage
->
Data
[2] = (
uint8_t
)0xFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDLR
 >> 16);

770 
RxMessage
->
Data
[3] = (
uint8_t
)0xFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDLR
 >> 24);

771 
RxMessage
->
Data
[4] = (
uint8_t
)0xFF & 
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDHR
;

772 
RxMessage
->
Data
[5] = (
uint8_t
)0xFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDHR
 >> 8);

773 
RxMessage
->
Data
[6] = (
uint8_t
)0xFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDHR
 >> 16);

774 
RxMessage
->
Data
[7] = (
uint8_t
)0xFF & (
CANx
->
sFIFOMailBox
[
FIFONumber
].
RDHR
 >> 24);

777 if (
FIFONumber
 == 
CAN_FIFO0
)

779 
CANx
->
RF0R
 |= 
CAN_RF0R_RFOM0
;

784 
CANx
->
RF1R
 |= 
CAN_RF1R_RFOM1
;

786 
	}
}

794 void 
	$CAN_FIFORelease
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
FIFONumber
)

797 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

798 
	`assert_param
(
	`IS_CAN_FIFO
(
FIFONumber
));

800 if (
FIFONumber
 == 
CAN_FIFO0
)

802 
CANx
->
RF0R
 |= 
CAN_RF0R_RFOM0
;

807 
CANx
->
RF1R
 |= 
CAN_RF1R_RFOM1
;

809 
	}
}

817 
uint8_t
 
	$CAN_MessagePending
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
FIFONumber
)

819 
uint8_t
 
message_pending
=0;

821 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

822 
	`assert_param
(
	`IS_CAN_FIFO
(
FIFONumber
));

823 if (
FIFONumber
 == 
CAN_FIFO0
)

825 
message_pending
 = (
uint8_t
)(
CANx
->
RF0R
&(
uint32_t
)0x03);

827 else if (
FIFONumber
 == 
CAN_FIFO1
)

829 
message_pending
 = (
uint8_t
)(
CANx
->
RF1R
&(
uint32_t
)0x03);

833 
message_pending
 = 0;

835 return 
message_pending
;

836 
	}
}

867 
uint8_t
 
	$CAN_OperatingModeRequest
(
CAN_TypeDef
* 
CANx
, 
uint8_t
 
CAN_OperatingMode
)

869 
uint8_t
 
status
 = 
CAN_ModeStatus_Failed
;

872 
uint32_t
 
timeout
 = 
INAK_TIMEOUT
;

875 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

876 
	`assert_param
(
	`IS_CAN_OPERATING_MODE
(
CAN_OperatingMode
));

878 if (
CAN_OperatingMode
 == 
CAN_OperatingMode_Initialization
)

881 
CANx
->
MCR
 = (
uint32_t
)((CANx->MCR & (uint32_t)(~(uint32_t)
CAN_MCR_SLEEP
)) | 
CAN_MCR_INRQ
);

884 while (((
CANx
->
MSR
 & 
CAN_MODE_MASK
) != 
CAN_MSR_INAK
) && (
timeout
 != 0))

886 
timeout
--;

888 if ((
CANx
->
MSR
 & 
CAN_MODE_MASK
) != 
CAN_MSR_INAK
)

890 
status
 = 
CAN_ModeStatus_Failed
;

894 
status
 = 
CAN_ModeStatus_Success
;

897 else if (
CAN_OperatingMode
 == 
CAN_OperatingMode_Normal
)

900 
CANx
->
MCR
 &= (
uint32_t
)(~(
CAN_MCR_SLEEP
|
CAN_MCR_INRQ
));

903 while (((
CANx
->
MSR
 & 
CAN_MODE_MASK
) != 0) && (
timeout
!=0))

905 
timeout
--;

907 if ((
CANx
->
MSR
 & 
CAN_MODE_MASK
) != 0)

909 
status
 = 
CAN_ModeStatus_Failed
;

913 
status
 = 
CAN_ModeStatus_Success
;

916 else if (
CAN_OperatingMode
 == 
CAN_OperatingMode_Sleep
)

919 
CANx
->
MCR
 = (
uint32_t
)((CANx->MCR & (uint32_t)(~(uint32_t)
CAN_MCR_INRQ
)) | 
CAN_MCR_SLEEP
);

922 while (((
CANx
->
MSR
 & 
CAN_MODE_MASK
) != 
CAN_MSR_SLAK
) && (
timeout
!=0))

924 
timeout
--;

926 if ((
CANx
->
MSR
 & 
CAN_MODE_MASK
) != 
CAN_MSR_SLAK
)

928 
status
 = 
CAN_ModeStatus_Failed
;

932 
status
 = 
CAN_ModeStatus_Success
;

937 
status
 = 
CAN_ModeStatus_Failed
;

940 return (
uint8_t
) 
status
;

941 
	}
}

948 
uint8_t
 
	$CAN_Sleep
(
CAN_TypeDef
* 
CANx
)

950 
uint8_t
 
sleepstatus
 = 
CAN_Sleep_Failed
;

953 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

956 
CANx
->
MCR
 = (((CANx->MCR) & (
uint32_t
)(~(uint32_t)
CAN_MCR_INRQ
)) | 
CAN_MCR_SLEEP
);

959 if ((
CANx
->
MSR
 & (
CAN_MSR_SLAK
|
CAN_MSR_INAK
)) == CAN_MSR_SLAK)

962 
sleepstatus
 = 
CAN_Sleep_Ok
;

965 return (
uint8_t
)
sleepstatus
;

966 
	}
}

973 
uint8_t
 
	$CAN_WakeUp
(
CAN_TypeDef
* 
CANx
)

975 
uint32_t
 
wait_slak
 = 
SLAK_TIMEOUT
;

976 
uint8_t
 
wakeupstatus
 = 
CAN_WakeUp_Failed
;

979 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

982 
CANx
->
MCR
 &= ~(
uint32_t
)
CAN_MCR_SLEEP
;

985 while(((
CANx
->
MSR
 & 
CAN_MSR_SLAK
) == CAN_MSR_SLAK)&&(
wait_slak
!=0x00))

987 
wait_slak
--;

989 if((
CANx
->
MSR
 & 
CAN_MSR_SLAK
) != CAN_MSR_SLAK)

992 
wakeupstatus
 = 
CAN_WakeUp_Ok
;

995 return (
uint8_t
)
wakeupstatus
;

996 
	}
}

1035 
uint8_t
 
	$CAN_GetLastErrorCode
(
CAN_TypeDef
* 
CANx
)

1037 
uint8_t
 
errorcode
=0;

1040 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1043 
errorcode
 = (((
uint8_t
)
CANx
->
ESR
) & (uint8_t)
CAN_ESR_LEC
);

1046 return 
errorcode
;

1047 
	}
}

1060 
uint8_t
 
	$CAN_GetReceiveErrorCounter
(
CAN_TypeDef
* 
CANx
)

1062 
uint8_t
 
counter
=0;

1065 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1068 
counter
 = (
uint8_t
)((
CANx
->
ESR
 & 
CAN_ESR_REC
)>> 24);

1071 return 
counter
;

1072 
	}
}

1080 
uint8_t
 
	$CAN_GetLSBTransmitErrorCounter
(
CAN_TypeDef
* 
CANx
)

1082 
uint8_t
 
counter
=0;

1085 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1088 
counter
 = (
uint8_t
)((
CANx
->
ESR
 & 
CAN_ESR_TEC
)>> 16);

1091 return 
counter
;

1092 
	}
}

1287 void 
	$CAN_ITConfig
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_IT
, 
FunctionalState
 
NewState
)

1290 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1291 
	`assert_param
(
	`IS_CAN_IT
(
CAN_IT
));

1292 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1294 if (
NewState
 != 
DISABLE
)

1297 
CANx
->
IER
 |= 
CAN_IT
;

1302 
CANx
->
IER
 &= ~
CAN_IT
;

1304 
	}
}

1327 
FlagStatus
 
	$CAN_GetFlagStatus
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_FLAG
)

1329 
FlagStatus
 
bitstatus
 = 
RESET
;

1332 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1333 
	`assert_param
(
	`IS_CAN_GET_FLAG
(
CAN_FLAG
));

1336 if((
CAN_FLAG
 & 
CAN_FLAGS_ESR
) != (
uint32_t
)
RESET
)

1339 if ((
CANx
->
ESR
 & (
CAN_FLAG
 & 0x000FFFFF)) != (
uint32_t
)
RESET
)

1342 
bitstatus
 = 
SET
;

1347 
bitstatus
 = 
RESET
;

1350 else if((
CAN_FLAG
 & 
CAN_FLAGS_MSR
) != (
uint32_t
)
RESET
)

1353 if ((
CANx
->
MSR
 & (
CAN_FLAG
 & 0x000FFFFF)) != (
uint32_t
)
RESET
)

1356 
bitstatus
 = 
SET
;

1361 
bitstatus
 = 
RESET
;

1364 else if((
CAN_FLAG
 & 
CAN_FLAGS_TSR
) != (
uint32_t
)
RESET
)

1367 if ((
CANx
->
TSR
 & (
CAN_FLAG
 & 0x000FFFFF)) != (
uint32_t
)
RESET
)

1370 
bitstatus
 = 
SET
;

1375 
bitstatus
 = 
RESET
;

1378 else if((
CAN_FLAG
 & 
CAN_FLAGS_RF0R
) != (
uint32_t
)
RESET
)

1381 if ((
CANx
->
RF0R
 & (
CAN_FLAG
 & 0x000FFFFF)) != (
uint32_t
)
RESET
)

1384 
bitstatus
 = 
SET
;

1389 
bitstatus
 = 
RESET
;

1395 if ((
uint32_t
)(
CANx
->
RF1R
 & (
CAN_FLAG
 & 0x000FFFFF)) != (uint32_t)
RESET
)

1398 
bitstatus
 = 
SET
;

1403 
bitstatus
 = 
RESET
;

1407 return 
bitstatus
;

1408 
	}
}

1427 void 
	$CAN_ClearFlag
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_FLAG
)

1429 
uint32_t
 
flagtmp
=0;

1431 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1432 
	`assert_param
(
	`IS_CAN_CLEAR_FLAG
(
CAN_FLAG
));

1434 if (
CAN_FLAG
 == 
CAN_FLAG_LEC
)

1437 
CANx
->
ESR
 = (
uint32_t
)
RESET
;

1441 
flagtmp
 = 
CAN_FLAG
 & 0x000FFFFF;

1443 if ((
CAN_FLAG
 & 
CAN_FLAGS_RF0R
)!=(
uint32_t
)
RESET
)

1446 
CANx
->
RF0R
 = (
uint32_t
)(
flagtmp
);

1448 else if ((
CAN_FLAG
 & 
CAN_FLAGS_RF1R
)!=(
uint32_t
)
RESET
)

1451 
CANx
->
RF1R
 = (
uint32_t
)(
flagtmp
);

1453 else if ((
CAN_FLAG
 & 
CAN_FLAGS_TSR
)!=(
uint32_t
)
RESET
)

1456 
CANx
->
TSR
 = (
uint32_t
)(
flagtmp
);

1461 
CANx
->
MSR
 = (
uint32_t
)(
flagtmp
);

1464 
	}
}

1487 
ITStatus
 
	$CAN_GetITStatus
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_IT
)

1489 
ITStatus
 
itstatus
 = 
RESET
;

1491 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1492 
	`assert_param
(
	`IS_CAN_IT
(
CAN_IT
));

1495 if((
CANx
->
IER
 & 
CAN_IT
) != 
RESET
)

1498 switch (
CAN_IT
)

1500 case 
CAN_IT_TME
:

1502 
itstatus
 = 
	`CheckITStatus
(
CANx
->
TSR
, 
CAN_TSR_RQCP0
|
CAN_TSR_RQCP1
|
CAN_TSR_RQCP2
);

1504 case 
CAN_IT_FMP0
:

1506 
itstatus
 = 
	`CheckITStatus
(
CANx
->
RF0R
, 
CAN_RF0R_FMP0
);

1508 case 
CAN_IT_FF0
:

1510 
itstatus
 = 
	`CheckITStatus
(
CANx
->
RF0R
, 
CAN_RF0R_FULL0
);

1512 case 
CAN_IT_FOV0
:

1514 
itstatus
 = 
	`CheckITStatus
(
CANx
->
RF0R
, 
CAN_RF0R_FOVR0
);

1516 case 
CAN_IT_FMP1
:

1518 
itstatus
 = 
	`CheckITStatus
(
CANx
->
RF1R
, 
CAN_RF1R_FMP1
);

1520 case 
CAN_IT_FF1
:

1522 
itstatus
 = 
	`CheckITStatus
(
CANx
->
RF1R
, 
CAN_RF1R_FULL1
);

1524 case 
CAN_IT_FOV1
:

1526 
itstatus
 = 
	`CheckITStatus
(
CANx
->
RF1R
, 
CAN_RF1R_FOVR1
);

1528 case 
CAN_IT_WKU
:

1530 
itstatus
 = 
	`CheckITStatus
(
CANx
->
MSR
, 
CAN_MSR_WKUI
);

1532 case 
CAN_IT_SLK
:

1534 
itstatus
 = 
	`CheckITStatus
(
CANx
->
MSR
, 
CAN_MSR_SLAKI
);

1536 case 
CAN_IT_EWG
:

1538 
itstatus
 = 
	`CheckITStatus
(
CANx
->
ESR
, 
CAN_ESR_EWGF
);

1540 case 
CAN_IT_EPV
:

1542 
itstatus
 = 
	`CheckITStatus
(
CANx
->
ESR
, 
CAN_ESR_EPVF
);

1544 case 
CAN_IT_BOF
:

1546 
itstatus
 = 
	`CheckITStatus
(
CANx
->
ESR
, 
CAN_ESR_BOFF
);

1548 case 
CAN_IT_LEC
:

1550 
itstatus
 = 
	`CheckITStatus
(
CANx
->
ESR
, 
CAN_ESR_LEC
);

1552 case 
CAN_IT_ERR
:

1554 
itstatus
 = 
	`CheckITStatus
(
CANx
->
MSR
, 
CAN_MSR_ERRI
);

1558 
itstatus
 = 
RESET
;

1565 
itstatus
 = 
RESET
;

1569 return 
itstatus
;

1570 
	}
}

1591 void 
	$CAN_ClearITPendingBit
(
CAN_TypeDef
* 
CANx
, 
uint32_t
 
CAN_IT
)

1594 
	`assert_param
(
	`IS_CAN_ALL_PERIPH
(
CANx
));

1595 
	`assert_param
(
	`IS_CAN_CLEAR_IT
(
CAN_IT
));

1597 switch (
CAN_IT
)

1599 case 
CAN_IT_TME
:

1601 
CANx
->
TSR
 = 
CAN_TSR_RQCP0
|
CAN_TSR_RQCP1
|
CAN_TSR_RQCP2
;

1603 case 
CAN_IT_FF0
:

1605 
CANx
->
RF0R
 = 
CAN_RF0R_FULL0
;

1607 case 
CAN_IT_FOV0
:

1609 
CANx
->
RF0R
 = 
CAN_RF0R_FOVR0
;

1611 case 
CAN_IT_FF1
:

1613 
CANx
->
RF1R
 = 
CAN_RF1R_FULL1
;

1615 case 
CAN_IT_FOV1
:

1617 
CANx
->
RF1R
 = 
CAN_RF1R_FOVR1
;

1619 case 
CAN_IT_WKU
:

1621 
CANx
->
MSR
 = 
CAN_MSR_WKUI
;

1623 case 
CAN_IT_SLK
:

1625 
CANx
->
MSR
 = 
CAN_MSR_SLAKI
;

1627 case 
CAN_IT_EWG
:

1629 
CANx
->
MSR
 = 
CAN_MSR_ERRI
;

1632 case 
CAN_IT_EPV
:

1634 
CANx
->
MSR
 = 
CAN_MSR_ERRI
;

1637 case 
CAN_IT_BOF
:

1639 
CANx
->
MSR
 = 
CAN_MSR_ERRI
;

1642 case 
CAN_IT_LEC
:

1644 
CANx
->
ESR
 = 
RESET
;

1646 
CANx
->
MSR
 = 
CAN_MSR_ERRI
;

1648 case 
CAN_IT_ERR
:

1650 
CANx
->
ESR
 = 
RESET
;

1652 
CANx
->
MSR
 = 
CAN_MSR_ERRI
;

1658 
	}
}

1669 static 
ITStatus
 
	$CheckITStatus
(
uint32_t
 
CAN_Reg
, uint32_t 
It_Bit
)

1671 
ITStatus
 
pendingbitstatus
 = 
RESET
;

1673 if ((
CAN_Reg
 & 
It_Bit
) != (
uint32_t
)
RESET
)

1676 
pendingbitstatus
 = 
SET
;

1681 
pendingbitstatus
 = 
RESET
;

1683 return 
pendingbitstatus
;

1684 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_crc.c

23 #include 
	~"stm32f4xx_crc.h
"

50 void 
	$CRC_ResetDR
(void)

53 
CRC
->
CR
 = 
CRC_CR_RESET
;

54 
	}
}

61 
uint32_t
 
	$CRC_CalcCRC
(
uint32_t
 
Data
)

63 
CRC
->
DR
 = 
Data
;

65 return (
CRC
->
DR
);

66 
	}
}

74 
uint32_t
 
	$CRC_CalcBlockCRC
(
uint32_t
 
pBuffer
[], uint32_t 
BufferLength
)

76 
uint32_t
 
index
 = 0;

78 for(
index
 = 0; index < 
BufferLength
; index++)

80 
CRC
->
DR
 = 
pBuffer
[
index
];

82 return (
CRC
->
DR
);

83 
	}
}

90 
uint32_t
 
	$CRC_GetCRC
(void)

92 return (
CRC
->
DR
);

93 
	}
}

100 void 
	$CRC_SetIDRegister
(
uint8_t
 
IDValue
)

102 
CRC
->
IDR
 = 
IDValue
;

103 
	}
}

110 
uint8_t
 
	$CRC_GetIDRegister
(void)

112 return (
CRC
->
IDR
);

113 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp.c

159 #include 
	~"stm32f4xx_cryp.h
"

160 #include 
	~"stm32f4xx_rcc.h
"

173 #define 
	#FLAG_MASK
 ((
uint8_t
)0x20)

	)

174 #define 
	#MAX_TIMEOUT
 ((
uint16_t
)0xFFFF)

	)

215 void 
	$CRYP_DeInit
(void)

218 
	`RCC_AHB2PeriphResetCmd
(
RCC_AHB2Periph_CRYP
, 
ENABLE
);

221 
	`RCC_AHB2PeriphResetCmd
(
RCC_AHB2Periph_CRYP
, 
DISABLE
);

222 
	}
}

231 void 
	$CRYP_Init
(
CRYP_InitTypeDef
* 
CRYP_InitStruct
)

234 
	`assert_param
(
	`IS_CRYP_ALGOMODE
(
CRYP_InitStruct
->
CRYP_AlgoMode
));

235 
	`assert_param
(
	`IS_CRYP_DATATYPE
(
CRYP_InitStruct
->
CRYP_DataType
));

236 
	`assert_param
(
	`IS_CRYP_ALGODIR
(
CRYP_InitStruct
->
CRYP_AlgoDir
));

239 
CRYP
->
CR
 &= ~
CRYP_CR_ALGOMODE
;

240 
CRYP
->
CR
 |= 
CRYP_InitStruct
->
CRYP_AlgoMode
;

243 
CRYP
->
CR
 &= ~
CRYP_CR_DATATYPE
;

244 
CRYP
->
CR
 |= 
CRYP_InitStruct
->
CRYP_DataType
;

247 if ((
CRYP_InitStruct
->
CRYP_AlgoMode
 == 
CRYP_AlgoMode_AES_ECB
) ||

248 (
CRYP_InitStruct
->
CRYP_AlgoMode
 == 
CRYP_AlgoMode_AES_CBC
) ||

249 (
CRYP_InitStruct
->
CRYP_AlgoMode
 == 
CRYP_AlgoMode_AES_CTR
) ||

250 (
CRYP_InitStruct
->
CRYP_AlgoMode
 == 
CRYP_AlgoMode_AES_Key
))

252 
	`assert_param
(
	`IS_CRYP_KEYSIZE
(
CRYP_InitStruct
->
CRYP_KeySize
));

253 
CRYP
->
CR
 &= ~
CRYP_CR_KEYSIZE
;

254 
CRYP
->
CR
 |= 
CRYP_InitStruct
->
CRYP_KeySize
;

260 
CRYP
->
CR
 &= ~
CRYP_CR_ALGODIR
;

261 
CRYP
->
CR
 |= 
CRYP_InitStruct
->
CRYP_AlgoDir
;

262 
	}
}

270 void 
	$CRYP_StructInit
(
CRYP_InitTypeDef
* 
CRYP_InitStruct
)

273 
CRYP_InitStruct
->
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

276 
CRYP_InitStruct
->
CRYP_AlgoMode
 = 
CRYP_AlgoMode_TDES_ECB
;

279 
CRYP_InitStruct
->
CRYP_DataType
 = 
CRYP_DataType_32b
;

282 
CRYP_InitStruct
->
CRYP_KeySize
 = 
CRYP_KeySize_128b
;

283 
	}
}

292 void 
	$CRYP_KeyInit
(
CRYP_KeyInitTypeDef
* 
CRYP_KeyInitStruct
)

295 
CRYP
->
K0LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key0Left
;

296 
CRYP
->
K0RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key0Right
;

297 
CRYP
->
K1LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key1Left
;

298 
CRYP
->
K1RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key1Right
;

299 
CRYP
->
K2LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key2Left
;

300 
CRYP
->
K2RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key2Right
;

301 
CRYP
->
K3LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key3Left
;

302 
CRYP
->
K3RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key3Right
;

303 
	}
}

311 void 
	$CRYP_KeyStructInit
(
CRYP_KeyInitTypeDef
* 
CRYP_KeyInitStruct
)

313 
CRYP_KeyInitStruct
->
CRYP_Key0Left
 = 0;

314 
CRYP_KeyInitStruct
->
CRYP_Key0Right
 = 0;

315 
CRYP_KeyInitStruct
->
CRYP_Key1Left
 = 0;

316 
CRYP_KeyInitStruct
->
CRYP_Key1Right
 = 0;

317 
CRYP_KeyInitStruct
->
CRYP_Key2Left
 = 0;

318 
CRYP_KeyInitStruct
->
CRYP_Key2Right
 = 0;

319 
CRYP_KeyInitStruct
->
CRYP_Key3Left
 = 0;

320 
CRYP_KeyInitStruct
->
CRYP_Key3Right
 = 0;

321 
	}
}

329 void 
	$CRYP_IVInit
(
CRYP_IVInitTypeDef
* 
CRYP_IVInitStruct
)

331 
CRYP
->
IV0LR
 = 
CRYP_IVInitStruct
->
CRYP_IV0Left
;

332 
CRYP
->
IV0RR
 = 
CRYP_IVInitStruct
->
CRYP_IV0Right
;

333 
CRYP
->
IV1LR
 = 
CRYP_IVInitStruct
->
CRYP_IV1Left
;

334 
CRYP
->
IV1RR
 = 
CRYP_IVInitStruct
->
CRYP_IV1Right
;

335 
	}
}

343 void 
	$CRYP_IVStructInit
(
CRYP_IVInitTypeDef
* 
CRYP_IVInitStruct
)

345 
CRYP_IVInitStruct
->
CRYP_IV0Left
 = 0;

346 
CRYP_IVInitStruct
->
CRYP_IV0Right
 = 0;

347 
CRYP_IVInitStruct
->
CRYP_IV1Left
 = 0;

348 
CRYP_IVInitStruct
->
CRYP_IV1Right
 = 0;

349 
	}
}

358 void 
	$CRYP_FIFOFlush
(void)

361 
CRYP
->
CR
 |= 
CRYP_CR_FFLUSH
;

362 
	}
}

370 void 
	$CRYP_Cmd
(
FunctionalState
 
NewState
)

373 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

375 if (
NewState
 != 
DISABLE
)

378 
CRYP
->
CR
 |= 
CRYP_CR_CRYPEN
;

383 
CRYP
->
CR
 &= ~
CRYP_CR_CRYPEN
;

385 
	}
}

413 void 
	$CRYP_DataIn
(
uint32_t
 
Data
)

415 
CRYP
->
DR
 = 
Data
;

416 
	}
}

423 
uint32_t
 
	$CRYP_DataOut
(void)

425 return 
CRYP
->
DOUT
;

426 
	}
}

466 
ErrorStatus
 
	$CRYP_SaveContext
(
CRYP_Context
* 
CRYP_ContextSave
,

467 
CRYP_KeyInitTypeDef
* 
CRYP_KeyInitStruct
)

469 
__IO
 
uint32_t
 
timeout
 = 0;

470 
uint32_t
 
ckeckmask
 = 0, 
bitstatus
;

471 
ErrorStatus
 
status
 = 
ERROR
;

474 
CRYP
->
DMACR
 &= ~(
uint32_t
)
CRYP_DMACR_DIEN
;

480 if ((
CRYP
->
CR
 & (
uint32_t
)(
CRYP_CR_ALGOMODE_TDES_ECB
 | 
CRYP_CR_ALGOMODE_TDES_CBC
)) != (uint32_t)0 )

482 
ckeckmask
 = 
CRYP_SR_IFEM
 | 
CRYP_SR_BUSY
 ;

486 
ckeckmask
 = 
CRYP_SR_IFEM
 | 
CRYP_SR_BUSY
 | 
CRYP_SR_OFNE
;

491 
bitstatus
 = 
CRYP
->
SR
 & 
ckeckmask
;

492 
timeout
++;

494 while ((
timeout
 != 
MAX_TIMEOUT
) && (
bitstatus
 != 
CRYP_SR_IFEM
));

496 if ((
CRYP
->
SR
 & 
ckeckmask
) != 
CRYP_SR_IFEM
)

498 
status
 = 
ERROR
;

506 
CRYP
->
DMACR
 &= ~(
uint32_t
)
CRYP_DMACR_DOEN
;

507 
CRYP
->
CR
 &= ~(
uint32_t
)
CRYP_CR_CRYPEN
;

510 
CRYP_ContextSave
->
CR_bits9to2
 = 
CRYP
->
CR
 & (
CRYP_CR_KEYSIZE
 |

511 
CRYP_CR_DATATYPE
 |

512 
CRYP_CR_ALGOMODE
 |

513 
CRYP_CR_ALGODIR
);

516 
CRYP_ContextSave
->
CRYP_IV0LR
 = 
CRYP
->
IV0LR
;

517 
CRYP_ContextSave
->
CRYP_IV0RR
 = 
CRYP
->
IV0RR
;

518 
CRYP_ContextSave
->
CRYP_IV1LR
 = 
CRYP
->
IV1LR
;

519 
CRYP_ContextSave
->
CRYP_IV1RR
 = 
CRYP
->
IV1RR
;

522 
CRYP_ContextSave
->
CRYP_K0LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key0Left
;

523 
CRYP_ContextSave
->
CRYP_K0RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key0Right
;

524 
CRYP_ContextSave
->
CRYP_K1LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key1Left
;

525 
CRYP_ContextSave
->
CRYP_K1RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key1Right
;

526 
CRYP_ContextSave
->
CRYP_K2LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key2Left
;

527 
CRYP_ContextSave
->
CRYP_K2RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key2Right
;

528 
CRYP_ContextSave
->
CRYP_K3LR
 = 
CRYP_KeyInitStruct
->
CRYP_Key3Left
;

529 
CRYP_ContextSave
->
CRYP_K3RR
 = 
CRYP_KeyInitStruct
->
CRYP_Key3Right
;

534 
status
 = 
SUCCESS
;

537 return 
status
;

538 
	}
}

551 void 
	$CRYP_RestoreContext
(
CRYP_Context
* 
CRYP_ContextRestore
)

555 
CRYP
->
CR
 = 
CRYP_ContextRestore
->
CR_bits9to2
;

558 
CRYP
->
K0LR
 = 
CRYP_ContextRestore
->
CRYP_K0LR
;

559 
CRYP
->
K0RR
 = 
CRYP_ContextRestore
->
CRYP_K0RR
;

560 
CRYP
->
K1LR
 = 
CRYP_ContextRestore
->
CRYP_K1LR
;

561 
CRYP
->
K1RR
 = 
CRYP_ContextRestore
->
CRYP_K1RR
;

562 
CRYP
->
K2LR
 = 
CRYP_ContextRestore
->
CRYP_K2LR
;

563 
CRYP
->
K2RR
 = 
CRYP_ContextRestore
->
CRYP_K2RR
;

564 
CRYP
->
K3LR
 = 
CRYP_ContextRestore
->
CRYP_K3LR
;

565 
CRYP
->
K3RR
 = 
CRYP_ContextRestore
->
CRYP_K3RR
;

568 
CRYP
->
IV0LR
 = 
CRYP_ContextRestore
->
CRYP_IV0LR
;

569 
CRYP
->
IV0RR
 = 
CRYP_ContextRestore
->
CRYP_IV0RR
;

570 
CRYP
->
IV1LR
 = 
CRYP_ContextRestore
->
CRYP_IV1LR
;

571 
CRYP
->
IV1RR
 = 
CRYP_ContextRestore
->
CRYP_IV1RR
;

574 
CRYP
->
CR
 |= 
CRYP_CR_CRYPEN
;

575 
	}
}

612 void 
	$CRYP_DMACmd
(
uint8_t
 
CRYP_DMAReq
, 
FunctionalState
 
NewState
)

615 
	`assert_param
(
	`IS_CRYP_DMAREQ
(
CRYP_DMAReq
));

616 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

618 if (
NewState
 != 
DISABLE
)

621 
CRYP
->
DMACR
 |= 
CRYP_DMAReq
;

626 
CRYP
->
DMACR
 &= (
uint8_t
)~
CRYP_DMAReq
;

628 
	}
}

737 void 
	$CRYP_ITConfig
(
uint8_t
 
CRYP_IT
, 
FunctionalState
 
NewState
)

740 
	`assert_param
(
	`IS_CRYP_CONFIG_IT
(
CRYP_IT
));

741 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

743 if (
NewState
 != 
DISABLE
)

746 
CRYP
->
IMSCR
 |= 
CRYP_IT
;

751 
CRYP
->
IMSCR
 &= (
uint8_t
)~
CRYP_IT
;

753 
	}
}

765 
ITStatus
 
	$CRYP_GetITStatus
(
uint8_t
 
CRYP_IT
)

767 
ITStatus
 
bitstatus
 = 
RESET
;

769 
	`assert_param
(
	`IS_CRYP_GET_IT
(
CRYP_IT
));

772 if ((
CRYP
->
MISR
 & 
CRYP_IT
) != (
uint8_t
)
RESET
)

775 
bitstatus
 = 
SET
;

780 
bitstatus
 = 
RESET
;

783 return 
bitstatus
;

784 
	}
}

799 
FlagStatus
 
	$CRYP_GetFlagStatus
(
uint8_t
 
CRYP_FLAG
)

801 
FlagStatus
 
bitstatus
 = 
RESET
;

802 
uint32_t
 
tempreg
 = 0;

805 
	`assert_param
(
	`IS_CRYP_GET_FLAG
(
CRYP_FLAG
));

808 if ((
CRYP_FLAG
 & 
FLAG_MASK
) != 0x00)

810 
tempreg
 = 
CRYP
->
RISR
;

814 
tempreg
 = 
CRYP
->
SR
;

819 if ((
tempreg
 & 
CRYP_FLAG
 ) != (
uint8_t
)
RESET
)

822 
bitstatus
 = 
SET
;

827 
bitstatus
 = 
RESET
;

831 return 
bitstatus
;

832 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_aes.c

46 #include 
	~"stm32f4xx_cryp.h
"

59 #define 
	#AESBUSY_TIMEOUT
 ((
uint32_t
) 0x00010000)

	)

98 
ErrorStatus
 
	$CRYP_AES_ECB
(
uint8_t
 
Mode
, uint8_t* 
Key
, 
uint16_t
 
Keysize
,

99 
uint8_t
* 
Input
, 
uint32_t
 
Ilength
, uint8_t* 
Output
)

101 
CRYP_InitTypeDef
 
AES_CRYP_InitStructure
;

102 
CRYP_KeyInitTypeDef
 
AES_CRYP_KeyInitStructure
;

103 
__IO
 
uint32_t
 
counter
 = 0;

104 
uint32_t
 
busystatus
 = 0;

105 
ErrorStatus
 
status
 = 
SUCCESS
;

106 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

107 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

108 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

109 
uint32_t
 
i
 = 0;

112 
	`CRYP_KeyStructInit
(&
AES_CRYP_KeyInitStructure
);

114 switch(
Keysize
)

117 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_128b
;

118 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

119 
keyaddr
+=4;

120 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

121 
keyaddr
+=4;

122 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

123 
keyaddr
+=4;

124 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

127 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_192b
;

128 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

129 
keyaddr
+=4;

130 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

131 
keyaddr
+=4;

132 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

133 
keyaddr
+=4;

134 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

135 
keyaddr
+=4;

136 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

137 
keyaddr
+=4;

138 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

141 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_256b
;

142 
AES_CRYP_KeyInitStructure
.
CRYP_Key0Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

143 
keyaddr
+=4;

144 
AES_CRYP_KeyInitStructure
.
CRYP_Key0Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

145 
keyaddr
+=4;

146 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

147 
keyaddr
+=4;

148 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

149 
keyaddr
+=4;

150 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

151 
keyaddr
+=4;

152 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

153 
keyaddr
+=4;

154 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

155 
keyaddr
+=4;

156 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

163 if(
Mode
 == 
MODE_DECRYPT
)

166 
	`CRYP_FIFOFlush
();

169 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

170 
AES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_AES_Key
;

171 
AES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_32b
;

172 
	`CRYP_Init
(&
AES_CRYP_InitStructure
);

175 
	`CRYP_KeyInit
(&
AES_CRYP_KeyInitStructure
);

178 
	`CRYP_Cmd
(
ENABLE
);

183 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

184 
counter
++;

185 }while ((
counter
 != 
AESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

187 if (
busystatus
 != 
RESET
)

189 
status
 = 
ERROR
;

194 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

201 
	`CRYP_KeyInit
(&
AES_CRYP_KeyInitStructure
);

204 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

207 
AES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_AES_ECB
;

208 
AES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_8b
;

209 
	`CRYP_Init
(&
AES_CRYP_InitStructure
);

212 
	`CRYP_FIFOFlush
();

215 
	`CRYP_Cmd
(
ENABLE
);

217 for(
i
=0; ((i<
Ilength
) && (
status
 != 
ERROR
)); i+=16)

221 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

222 
inputaddr
+=4;

223 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

224 
inputaddr
+=4;

225 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

226 
inputaddr
+=4;

227 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

228 
inputaddr
+=4;

231 
counter
 = 0;

234 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

235 
counter
++;

236 }while ((
counter
 != 
AESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

238 if (
busystatus
 != 
RESET
)

240 
status
 = 
ERROR
;

246 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

247 
outputaddr
+=4;

248 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

249 
outputaddr
+=4;

250 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

251 
outputaddr
+=4;

252 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

253 
outputaddr
+=4;

258 
	`CRYP_Cmd
(
DISABLE
);

260 return 
status
;

261 
	}
}

279 
ErrorStatus
 
	$CRYP_AES_CBC
(
uint8_t
 
Mode
, uint8_t 
InitVectors
[16], uint8_t *
Key
,

280 
uint16_t
 
Keysize
, 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

281 
uint8_t
 *
Output
)

283 
CRYP_InitTypeDef
 
AES_CRYP_InitStructure
;

284 
CRYP_KeyInitTypeDef
 
AES_CRYP_KeyInitStructure
;

285 
CRYP_IVInitTypeDef
 
AES_CRYP_IVInitStructure
;

286 
__IO
 
uint32_t
 
counter
 = 0;

287 
uint32_t
 
busystatus
 = 0;

288 
ErrorStatus
 
status
 = 
SUCCESS
;

289 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

290 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

291 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

292 
uint32_t
 
ivaddr
 = (uint32_t)
InitVectors
;

293 
uint32_t
 
i
 = 0;

296 
	`CRYP_KeyStructInit
(&
AES_CRYP_KeyInitStructure
);

298 switch(
Keysize
)

301 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_128b
;

302 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

303 
keyaddr
+=4;

304 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

305 
keyaddr
+=4;

306 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

307 
keyaddr
+=4;

308 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

311 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_192b
;

312 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

313 
keyaddr
+=4;

314 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

315 
keyaddr
+=4;

316 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

317 
keyaddr
+=4;

318 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

319 
keyaddr
+=4;

320 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

321 
keyaddr
+=4;

322 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

325 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_256b
;

326 
AES_CRYP_KeyInitStructure
.
CRYP_Key0Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

327 
keyaddr
+=4;

328 
AES_CRYP_KeyInitStructure
.
CRYP_Key0Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

329 
keyaddr
+=4;

330 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

331 
keyaddr
+=4;

332 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

333 
keyaddr
+=4;

334 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

335 
keyaddr
+=4;

336 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

337 
keyaddr
+=4;

338 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

339 
keyaddr
+=4;

340 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

347 
AES_CRYP_IVInitStructure
.
CRYP_IV0Left
 = 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

348 
ivaddr
+=4;

349 
AES_CRYP_IVInitStructure
.
CRYP_IV0Right
= 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

350 
ivaddr
+=4;

351 
AES_CRYP_IVInitStructure
.
CRYP_IV1Left
 = 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

352 
ivaddr
+=4;

353 
AES_CRYP_IVInitStructure
.
CRYP_IV1Right
= 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

357 if(
Mode
 == 
MODE_DECRYPT
)

360 
	`CRYP_FIFOFlush
();

363 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

364 
AES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_AES_Key
;

365 
AES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_32b
;

367 
	`CRYP_Init
(&
AES_CRYP_InitStructure
);

370 
	`CRYP_KeyInit
(&
AES_CRYP_KeyInitStructure
);

373 
	`CRYP_Cmd
(
ENABLE
);

378 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

379 
counter
++;

380 }while ((
counter
 != 
AESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

382 if (
busystatus
 != 
RESET
)

384 
status
 = 
ERROR
;

389 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

395 
	`CRYP_KeyInit
(&
AES_CRYP_KeyInitStructure
);

398 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

400 
AES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_AES_CBC
;

401 
AES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_8b
;

402 
	`CRYP_Init
(&
AES_CRYP_InitStructure
);

405 
	`CRYP_IVInit
(&
AES_CRYP_IVInitStructure
);

408 
	`CRYP_FIFOFlush
();

411 
	`CRYP_Cmd
(
ENABLE
);

414 for(
i
=0; ((i<
Ilength
) && (
status
 != 
ERROR
)); i+=16)

418 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

419 
inputaddr
+=4;

420 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

421 
inputaddr
+=4;

422 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

423 
inputaddr
+=4;

424 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

425 
inputaddr
+=4;

427 
counter
 = 0;

430 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

431 
counter
++;

432 }while ((
counter
 != 
AESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

434 if (
busystatus
 != 
RESET
)

436 
status
 = 
ERROR
;

442 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

443 
outputaddr
+=4;

444 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

445 
outputaddr
+=4;

446 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

447 
outputaddr
+=4;

448 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

449 
outputaddr
+=4;

454 
	`CRYP_Cmd
(
DISABLE
);

456 return 
status
;

457 
	}
}

475 
ErrorStatus
 
	$CRYP_AES_CTR
(
uint8_t
 
Mode
, uint8_t 
InitVectors
[16], uint8_t *
Key
,

476 
uint16_t
 
Keysize
, 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
,

477 
uint8_t
 *
Output
)

479 
CRYP_InitTypeDef
 
AES_CRYP_InitStructure
;

480 
CRYP_KeyInitTypeDef
 
AES_CRYP_KeyInitStructure
;

481 
CRYP_IVInitTypeDef
 
AES_CRYP_IVInitStructure
;

482 
__IO
 
uint32_t
 
counter
 = 0;

483 
uint32_t
 
busystatus
 = 0;

484 
ErrorStatus
 
status
 = 
SUCCESS
;

485 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

486 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

487 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

488 
uint32_t
 
ivaddr
 = (uint32_t)
InitVectors
;

489 
uint32_t
 
i
 = 0;

492 
	`CRYP_KeyStructInit
(&
AES_CRYP_KeyInitStructure
);

494 switch(
Keysize
)

497 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_128b
;

498 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

499 
keyaddr
+=4;

500 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

501 
keyaddr
+=4;

502 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

503 
keyaddr
+=4;

504 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

507 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_192b
;

508 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

509 
keyaddr
+=4;

510 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

511 
keyaddr
+=4;

512 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

513 
keyaddr
+=4;

514 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

515 
keyaddr
+=4;

516 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

517 
keyaddr
+=4;

518 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

521 
AES_CRYP_InitStructure
.
CRYP_KeySize
 = 
CRYP_KeySize_256b
;

522 
AES_CRYP_KeyInitStructure
.
CRYP_Key0Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

523 
keyaddr
+=4;

524 
AES_CRYP_KeyInitStructure
.
CRYP_Key0Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

525 
keyaddr
+=4;

526 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

527 
keyaddr
+=4;

528 
AES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

529 
keyaddr
+=4;

530 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

531 
keyaddr
+=4;

532 
AES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

533 
keyaddr
+=4;

534 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

535 
keyaddr
+=4;

536 
AES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

542 
AES_CRYP_IVInitStructure
.
CRYP_IV0Left
 = 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

543 
ivaddr
+=4;

544 
AES_CRYP_IVInitStructure
.
CRYP_IV0Right
= 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

545 
ivaddr
+=4;

546 
AES_CRYP_IVInitStructure
.
CRYP_IV1Left
 = 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

547 
ivaddr
+=4;

548 
AES_CRYP_IVInitStructure
.
CRYP_IV1Right
= 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

551 
	`CRYP_KeyInit
(&
AES_CRYP_KeyInitStructure
);

554 if(
Mode
 == 
MODE_DECRYPT
)

557 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

563 
AES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

565 
AES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_AES_CTR
;

566 
AES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_8b
;

567 
	`CRYP_Init
(&
AES_CRYP_InitStructure
);

570 
	`CRYP_IVInit
(&
AES_CRYP_IVInitStructure
);

573 
	`CRYP_FIFOFlush
();

576 
	`CRYP_Cmd
(
ENABLE
);

578 for(
i
=0; ((i<
Ilength
) && (
status
 != 
ERROR
)); i+=16)

582 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

583 
inputaddr
+=4;

584 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

585 
inputaddr
+=4;

586 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

587 
inputaddr
+=4;

588 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

589 
inputaddr
+=4;

591 
counter
 = 0;

594 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

595 
counter
++;

596 }while ((
counter
 != 
AESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

598 if (
busystatus
 != 
RESET
)

600 
status
 = 
ERROR
;

606 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

607 
outputaddr
+=4;

608 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

609 
outputaddr
+=4;

610 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

611 
outputaddr
+=4;

612 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

613 
outputaddr
+=4;

617 
	`CRYP_Cmd
(
DISABLE
);

619 return 
status
;

620 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_des.c

43 #include 
	~"stm32f4xx_cryp.h
"

57 #define 
	#DESBUSY_TIMEOUT
 ((
uint32_t
) 0x00010000)

	)

94 
ErrorStatus
 
	$CRYP_DES_ECB
(
uint8_t
 
Mode
, uint8_t 
Key
[8], uint8_t *
Input
,

95 
uint32_t
 
Ilength
, 
uint8_t
 *
Output
)

97 
CRYP_InitTypeDef
 
DES_CRYP_InitStructure
;

98 
CRYP_KeyInitTypeDef
 
DES_CRYP_KeyInitStructure
;

99 
__IO
 
uint32_t
 
counter
 = 0;

100 
uint32_t
 
busystatus
 = 0;

101 
ErrorStatus
 
status
 = 
SUCCESS
;

102 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

103 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

104 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

105 
uint32_t
 
i
 = 0;

108 
	`CRYP_KeyStructInit
(&
DES_CRYP_KeyInitStructure
);

111 if( 
Mode
 == 
MODE_ENCRYPT
 )

113 
DES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

117 
DES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

120 
DES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_DES_ECB
;

121 
DES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_8b
;

122 
	`CRYP_Init
(&
DES_CRYP_InitStructure
);

125 
DES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

126 
keyaddr
+=4;

127 
DES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

128 
	`CRYP_KeyInit
(& 
DES_CRYP_KeyInitStructure
);

131 
	`CRYP_FIFOFlush
();

134 
	`CRYP_Cmd
(
ENABLE
);

136 for(
i
=0; ((i<
Ilength
) && (
status
 != 
ERROR
)); i+=8)

140 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

141 
inputaddr
+=4;

142 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

143 
inputaddr
+=4;

146 
counter
 = 0;

149 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

150 
counter
++;

151 }while ((
counter
 != 
DESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

153 if (
busystatus
 != 
RESET
)

155 
status
 = 
ERROR
;

161 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

162 
outputaddr
+=4;

163 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

164 
outputaddr
+=4;

169 
	`CRYP_Cmd
(
DISABLE
);

171 return 
status
;

172 
	}
}

189 
ErrorStatus
 
	$CRYP_DES_CBC
(
uint8_t
 
Mode
, uint8_t 
Key
[8], uint8_t 
InitVectors
[8],

190 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
, uint8_t *
Output
)

192 
CRYP_InitTypeDef
 
DES_CRYP_InitStructure
;

193 
CRYP_KeyInitTypeDef
 
DES_CRYP_KeyInitStructure
;

194 
CRYP_IVInitTypeDef
 
DES_CRYP_IVInitStructure
;

195 
__IO
 
uint32_t
 
counter
 = 0;

196 
uint32_t
 
busystatus
 = 0;

197 
ErrorStatus
 
status
 = 
SUCCESS
;

198 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

199 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

200 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

201 
uint32_t
 
ivaddr
 = (uint32_t)
InitVectors
;

202 
uint32_t
 
i
 = 0;

205 
	`CRYP_KeyStructInit
(&
DES_CRYP_KeyInitStructure
);

208 if(
Mode
 == 
MODE_ENCRYPT
)

210 
DES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

214 
DES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

217 
DES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_DES_CBC
;

218 
DES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_8b
;

219 
	`CRYP_Init
(&
DES_CRYP_InitStructure
);

222 
DES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

223 
keyaddr
+=4;

224 
DES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

225 
	`CRYP_KeyInit
(& 
DES_CRYP_KeyInitStructure
);

228 
DES_CRYP_IVInitStructure
.
CRYP_IV0Left
 = 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

229 
ivaddr
+=4;

230 
DES_CRYP_IVInitStructure
.
CRYP_IV0Right
= 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

231 
	`CRYP_IVInit
(&
DES_CRYP_IVInitStructure
);

234 
	`CRYP_FIFOFlush
();

237 
	`CRYP_Cmd
(
ENABLE
);

239 for(
i
=0; ((i<
Ilength
) && (
status
 != 
ERROR
)); i+=8)

242 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

243 
inputaddr
+=4;

244 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

245 
inputaddr
+=4;

248 
counter
 = 0;

251 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

252 
counter
++;

253 }while ((
counter
 != 
DESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

255 if (
busystatus
 != 
RESET
)

257 
status
 = 
ERROR
;

262 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

263 
outputaddr
+=4;

264 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

265 
outputaddr
+=4;

270 
	`CRYP_Cmd
(
DISABLE
);

272 return 
status
;

273 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_tdes.c

43 #include 
	~"stm32f4xx_cryp.h
"

57 #define 
	#TDESBUSY_TIMEOUT
 ((
uint32_t
) 0x00010000)

	)

96 
ErrorStatus
 
	$CRYP_TDES_ECB
(
uint8_t
 
Mode
, uint8_t 
Key
[24], uint8_t *
Input
,

97 
uint32_t
 
Ilength
, 
uint8_t
 *
Output
)

99 
CRYP_InitTypeDef
 
TDES_CRYP_InitStructure
;

100 
CRYP_KeyInitTypeDef
 
TDES_CRYP_KeyInitStructure
;

101 
__IO
 
uint32_t
 
counter
 = 0;

102 
uint32_t
 
busystatus
 = 0;

103 
ErrorStatus
 
status
 = 
SUCCESS
;

104 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

105 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

106 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

107 
uint32_t
 
i
 = 0;

110 
	`CRYP_KeyStructInit
(&
TDES_CRYP_KeyInitStructure
);

113 if(
Mode
 == 
MODE_ENCRYPT
)

115 
TDES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

119 
TDES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

122 
TDES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_TDES_ECB
;

123 
TDES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_8b
;

124 
	`CRYP_Init
(&
TDES_CRYP_InitStructure
);

127 
TDES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

128 
keyaddr
+=4;

129 
TDES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

130 
keyaddr
+=4;

131 
TDES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

132 
keyaddr
+=4;

133 
TDES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

134 
keyaddr
+=4;

135 
TDES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

136 
keyaddr
+=4;

137 
TDES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

138 
	`CRYP_KeyInit
(& 
TDES_CRYP_KeyInitStructure
);

141 
	`CRYP_FIFOFlush
();

144 
	`CRYP_Cmd
(
ENABLE
);

146 for(
i
=0; ((i<
Ilength
) && (
status
 != 
ERROR
)); i+=8)

149 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

150 
inputaddr
+=4;

151 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

152 
inputaddr
+=4;

155 
counter
 = 0;

158 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

159 
counter
++;

160 }while ((
counter
 != 
TDESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

162 if (
busystatus
 != 
RESET
)

164 
status
 = 
ERROR
;

170 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

171 
outputaddr
+=4;

172 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

173 
outputaddr
+=4;

178 
	`CRYP_Cmd
(
DISABLE
);

180 return 
status
;

181 
	}
}

198 
ErrorStatus
 
	$CRYP_TDES_CBC
(
uint8_t
 
Mode
, uint8_t 
Key
[24], uint8_t 
InitVectors
[8],

199 
uint8_t
 *
Input
, 
uint32_t
 
Ilength
, uint8_t *
Output
)

201 
CRYP_InitTypeDef
 
TDES_CRYP_InitStructure
;

202 
CRYP_KeyInitTypeDef
 
TDES_CRYP_KeyInitStructure
;

203 
CRYP_IVInitTypeDef
 
TDES_CRYP_IVInitStructure
;

204 
__IO
 
uint32_t
 
counter
 = 0;

205 
uint32_t
 
busystatus
 = 0;

206 
ErrorStatus
 
status
 = 
SUCCESS
;

207 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

208 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

209 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

210 
uint32_t
 
ivaddr
 = (uint32_t)
InitVectors
;

211 
uint32_t
 
i
 = 0;

214 
	`CRYP_KeyStructInit
(&
TDES_CRYP_KeyInitStructure
);

217 if(
Mode
 == 
MODE_ENCRYPT
)

219 
TDES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Encrypt
;

223 
TDES_CRYP_InitStructure
.
CRYP_AlgoDir
 = 
CRYP_AlgoDir_Decrypt
;

225 
TDES_CRYP_InitStructure
.
CRYP_AlgoMode
 = 
CRYP_AlgoMode_TDES_CBC
;

226 
TDES_CRYP_InitStructure
.
CRYP_DataType
 = 
CRYP_DataType_8b
;

228 
	`CRYP_Init
(&
TDES_CRYP_InitStructure
);

231 
TDES_CRYP_KeyInitStructure
.
CRYP_Key1Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

232 
keyaddr
+=4;

233 
TDES_CRYP_KeyInitStructure
.
CRYP_Key1Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

234 
keyaddr
+=4;

235 
TDES_CRYP_KeyInitStructure
.
CRYP_Key2Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

236 
keyaddr
+=4;

237 
TDES_CRYP_KeyInitStructure
.
CRYP_Key2Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

238 
keyaddr
+=4;

239 
TDES_CRYP_KeyInitStructure
.
CRYP_Key3Left
 = 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

240 
keyaddr
+=4;

241 
TDES_CRYP_KeyInitStructure
.
CRYP_Key3Right
= 
	`__REV
(*(
uint32_t
*)(
keyaddr
));

242 
	`CRYP_KeyInit
(& 
TDES_CRYP_KeyInitStructure
);

245 
TDES_CRYP_IVInitStructure
.
CRYP_IV0Left
 = 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

246 
ivaddr
+=4;

247 
TDES_CRYP_IVInitStructure
.
CRYP_IV0Right
= 
	`__REV
(*(
uint32_t
*)(
ivaddr
));

248 
	`CRYP_IVInit
(&
TDES_CRYP_IVInitStructure
);

251 
	`CRYP_FIFOFlush
();

254 
	`CRYP_Cmd
(
ENABLE
);

256 for(
i
=0; ((i<
Ilength
) && (
status
 != 
ERROR
)); i+=8)

259 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

260 
inputaddr
+=4;

261 
	`CRYP_DataIn
(*(
uint32_t
*)(
inputaddr
));

262 
inputaddr
+=4;

265 
counter
 = 0;

268 
busystatus
 = 
	`CRYP_GetFlagStatus
(
CRYP_FLAG_BUSY
);

269 
counter
++;

270 }while ((
counter
 != 
TDESBUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

272 if (
busystatus
 != 
RESET
)

274 
status
 = 
ERROR
;

280 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

281 
outputaddr
+=4;

282 *(
uint32_t
*)(
outputaddr
) = 
	`CRYP_DataOut
();

283 
outputaddr
+=4;

288 
	`CRYP_Cmd
(
DISABLE
);

290 return 
status
;

291 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c

118 #include 
	~"stm32f4xx_dac.h
"

119 #include 
	~"stm32f4xx_rcc.h
"

134 #define 
	#CR_CLEAR_MASK
 ((
uint32_t
)0x00000FFE)

	)

137 #define 
	#DUAL_SWTRIG_SET
 ((
uint32_t
)0x00000003)

	)

138 #define 
	#DUAL_SWTRIG_RESET
 ((
uint32_t
)0xFFFFFFFC)

	)

141 #define 
	#DHR12R1_OFFSET
 ((
uint32_t
)0x00000008)

	)

142 #define 
	#DHR12R2_OFFSET
 ((
uint32_t
)0x00000014)

	)

143 #define 
	#DHR12RD_OFFSET
 ((
uint32_t
)0x00000020)

	)

146 #define 
	#DOR_OFFSET
 ((
uint32_t
)0x0000002C)

	)

174 void 
	$DAC_DeInit
(void)

177 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_DAC
, 
ENABLE
);

179 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_DAC
, 
DISABLE
);

180 
	}
}

193 void 
	$DAC_Init
(
uint32_t
 
DAC_Channel
, 
DAC_InitTypeDef
* 
DAC_InitStruct
)

195 
uint32_t
 
tmpreg1
 = 0, 
tmpreg2
 = 0;

198 
	`assert_param
(
	`IS_DAC_TRIGGER
(
DAC_InitStruct
->
DAC_Trigger
));

199 
	`assert_param
(
	`IS_DAC_GENERATE_WAVE
(
DAC_InitStruct
->
DAC_WaveGeneration
));

200 
	`assert_param
(
	`IS_DAC_LFSR_UNMASK_TRIANGLE_AMPLITUDE
(
DAC_InitStruct
->
DAC_LFSRUnmask_TriangleAmplitude
));

201 
	`assert_param
(
	`IS_DAC_OUTPUT_BUFFER_STATE
(
DAC_InitStruct
->
DAC_OutputBuffer
));

205 
tmpreg1
 = 
DAC
->
CR
;

207 
tmpreg1
 &= ~(
CR_CLEAR_MASK
 << 
DAC_Channel
);

214 
tmpreg2
 = (
DAC_InitStruct
->
DAC_Trigger
 | DAC_InitStruct->
DAC_WaveGeneration
 |

215 
DAC_InitStruct
->
DAC_LFSRUnmask_TriangleAmplitude
 | \

216 
DAC_InitStruct
->
DAC_OutputBuffer
);

218 
tmpreg1
 |= 
tmpreg2
 << 
DAC_Channel
;

220 
DAC
->
CR
 = 
tmpreg1
;

221 
	}
}

229 void 
	$DAC_StructInit
(
DAC_InitTypeDef
* 
DAC_InitStruct
)

233 
DAC_InitStruct
->
DAC_Trigger
 = 
DAC_Trigger_None
;

235 
DAC_InitStruct
->
DAC_WaveGeneration
 = 
DAC_WaveGeneration_None
;

237 
DAC_InitStruct
->
DAC_LFSRUnmask_TriangleAmplitude
 = 
DAC_LFSRUnmask_Bit0
;

239 
DAC_InitStruct
->
DAC_OutputBuffer
 = 
DAC_OutputBuffer_Enable
;

240 
	}
}

253 void 
	$DAC_Cmd
(
uint32_t
 
DAC_Channel
, 
FunctionalState
 
NewState
)

256 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

257 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

259 if (
NewState
 != 
DISABLE
)

262 
DAC
->
CR
 |= (
DAC_CR_EN1
 << 
DAC_Channel
);

267 
DAC
->
CR
 &= (~(
DAC_CR_EN1
 << 
DAC_Channel
));

269 
	}
}

281 void 
	$DAC_SoftwareTriggerCmd
(
uint32_t
 
DAC_Channel
, 
FunctionalState
 
NewState
)

284 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

285 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

287 if (
NewState
 != 
DISABLE
)

290 
DAC
->
SWTRIGR
 |= (
uint32_t
)
DAC_SWTRIGR_SWTRIG1
 << (
DAC_Channel
 >> 4);

295 
DAC
->
SWTRIGR
 &= ~((
uint32_t
)
DAC_SWTRIGR_SWTRIG1
 << (
DAC_Channel
 >> 4));

297 
	}
}

305 void 
	$DAC_DualSoftwareTriggerCmd
(
FunctionalState
 
NewState
)

308 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

310 if (
NewState
 != 
DISABLE
)

313 
DAC
->
SWTRIGR
 |= 
DUAL_SWTRIG_SET
;

318 
DAC
->
SWTRIGR
 &= 
DUAL_SWTRIG_RESET
;

320 
	}
}

336 void 
	$DAC_WaveGenerationCmd
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_Wave
, 
FunctionalState
 
NewState
)

339 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

340 
	`assert_param
(
	`IS_DAC_WAVE
(
DAC_Wave
));

341 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

343 if (
NewState
 != 
DISABLE
)

346 
DAC
->
CR
 |= 
DAC_Wave
 << 
DAC_Channel
;

351 
DAC
->
CR
 &= ~(
DAC_Wave
 << 
DAC_Channel
);

353 
	}
}

365 void 
	$DAC_SetChannel1Data
(
uint32_t
 
DAC_Align
, 
uint16_t
 
Data
)

367 
__IO
 
uint32_t
 
tmp
 = 0;

370 
	`assert_param
(
	`IS_DAC_ALIGN
(
DAC_Align
));

371 
	`assert_param
(
	`IS_DAC_DATA
(
Data
));

373 
tmp
 = (
uint32_t
)
DAC_BASE
;

374 
tmp
 += 
DHR12R1_OFFSET
 + 
DAC_Align
;

377 *(
__IO
 
uint32_t
 *) 
tmp
 = 
Data
;

378 
	}
}

390 void 
	$DAC_SetChannel2Data
(
uint32_t
 
DAC_Align
, 
uint16_t
 
Data
)

392 
__IO
 
uint32_t
 
tmp
 = 0;

395 
	`assert_param
(
	`IS_DAC_ALIGN
(
DAC_Align
));

396 
	`assert_param
(
	`IS_DAC_DATA
(
Data
));

398 
tmp
 = (
uint32_t
)
DAC_BASE
;

399 
tmp
 += 
DHR12R2_OFFSET
 + 
DAC_Align
;

402 *(
__IO
 
uint32_t
 *)
tmp
 = 
Data
;

403 
	}
}

418 void 
	$DAC_SetDualChannelData
(
uint32_t
 
DAC_Align
, 
uint16_t
 
Data2
, uint16_t 
Data1
)

420 
uint32_t
 
data
 = 0, 
tmp
 = 0;

423 
	`assert_param
(
	`IS_DAC_ALIGN
(
DAC_Align
));

424 
	`assert_param
(
	`IS_DAC_DATA
(
Data1
));

425 
	`assert_param
(
	`IS_DAC_DATA
(
Data2
));

428 if (
DAC_Align
 == 
DAC_Align_8b_R
)

430 
data
 = ((
uint32_t
)
Data2
 << 8) | 
Data1
;

434 
data
 = ((
uint32_t
)
Data2
 << 16) | 
Data1
;

437 
tmp
 = (
uint32_t
)
DAC_BASE
;

438 
tmp
 += 
DHR12RD_OFFSET
 + 
DAC_Align
;

441 *(
__IO
 
uint32_t
 *)
tmp
 = 
data
;

442 
	}
}

452 
uint16_t
 
	$DAC_GetDataOutputValue
(
uint32_t
 
DAC_Channel
)

454 
__IO
 
uint32_t
 
tmp
 = 0;

457 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

459 
tmp
 = (
uint32_t
) 
DAC_BASE
 ;

460 
tmp
 += 
DOR_OFFSET
 + ((
uint32_t
)
DAC_Channel
 >> 2);

463 return (
uint16_t
) (*(
__IO
 
uint32_t
*) 
tmp
);

464 
	}
}

497 void 
	$DAC_DMACmd
(
uint32_t
 
DAC_Channel
, 
FunctionalState
 
NewState
)

500 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

501 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

503 if (
NewState
 != 
DISABLE
)

506 
DAC
->
CR
 |= (
DAC_CR_DMAEN1
 << 
DAC_Channel
);

511 
DAC
->
CR
 &= (~(
DAC_CR_DMAEN1
 << 
DAC_Channel
));

513 
	}
}

545 void 
	$DAC_ITConfig
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_IT
, 
FunctionalState
 
NewState
)

548 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

549 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

550 
	`assert_param
(
	`IS_DAC_IT
(
DAC_IT
));

552 if (
NewState
 != 
DISABLE
)

555 
DAC
->
CR
 |= (
DAC_IT
 << 
DAC_Channel
);

560 
DAC
->
CR
 &= (~(
uint32_t
)(
DAC_IT
 << 
DAC_Channel
));

562 
	}
}

577 
FlagStatus
 
	$DAC_GetFlagStatus
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_FLAG
)

579 
FlagStatus
 
bitstatus
 = 
RESET
;

581 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

582 
	`assert_param
(
	`IS_DAC_FLAG
(
DAC_FLAG
));

585 if ((
DAC
->
SR
 & (
DAC_FLAG
 << 
DAC_Channel
)) != (
uint8_t
)
RESET
)

588 
bitstatus
 = 
SET
;

593 
bitstatus
 = 
RESET
;

596 return 
bitstatus
;

597 
	}
}

612 void 
	$DAC_ClearFlag
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_FLAG
)

615 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

616 
	`assert_param
(
	`IS_DAC_FLAG
(
DAC_FLAG
));

619 
DAC
->
SR
 = (
DAC_FLAG
 << 
DAC_Channel
);

620 
	}
}

635 
ITStatus
 
	$DAC_GetITStatus
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_IT
)

637 
ITStatus
 
bitstatus
 = 
RESET
;

638 
uint32_t
 
enablestatus
 = 0;

641 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

642 
	`assert_param
(
	`IS_DAC_IT
(
DAC_IT
));

645 
enablestatus
 = (
DAC
->
CR
 & (
DAC_IT
 << 
DAC_Channel
)) ;

648 if (((
DAC
->
SR
 & (
DAC_IT
 << 
DAC_Channel
)) != (
uint32_t
)
RESET
) && 
enablestatus
)

651 
bitstatus
 = 
SET
;

656 
bitstatus
 = 
RESET
;

659 return 
bitstatus
;

660 
	}
}

675 void 
	$DAC_ClearITPendingBit
(
uint32_t
 
DAC_Channel
, uint32_t 
DAC_IT
)

678 
	`assert_param
(
	`IS_DAC_CHANNEL
(
DAC_Channel
));

679 
	`assert_param
(
	`IS_DAC_IT
(
DAC_IT
));

682 
DAC
->
SR
 = (
DAC_IT
 << 
DAC_Channel
);

683 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dbgmcu.c

23 #include 
	~"stm32f4xx_dbgmcu.h
"

36 #define 
	#IDCODE_DEVID_MASK
 ((
uint32_t
)0x00000FFF)

	)

52 
uint32_t
 
	$DBGMCU_GetREVID
(void)

54 return(
DBGMCU
->
IDCODE
 >> 16);

55 
	}
}

62 
uint32_t
 
	$DBGMCU_GetDEVID
(void)

64 return(
DBGMCU
->
IDCODE
 & 
IDCODE_DEVID_MASK
);

65 
	}
}

78 void 
	$DBGMCU_Config
(
uint32_t
 
DBGMCU_Periph
, 
FunctionalState
 
NewState
)

81 
	`assert_param
(
	`IS_DBGMCU_PERIPH
(
DBGMCU_Periph
));

82 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

83 if (
NewState
 != 
DISABLE
)

85 
DBGMCU
->
CR
 |= 
DBGMCU_Periph
;

89 
DBGMCU
->
CR
 &= ~
DBGMCU_Periph
;

91 
	}
}

117 void 
	$DBGMCU_APB1PeriphConfig
(
uint32_t
 
DBGMCU_Periph
, 
FunctionalState
 
NewState
)

120 
	`assert_param
(
	`IS_DBGMCU_APB1PERIPH
(
DBGMCU_Periph
));

121 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

123 if (
NewState
 != 
DISABLE
)

125 
DBGMCU
->
APB1FZ
 |= 
DBGMCU_Periph
;

129 
DBGMCU
->
APB1FZ
 &= ~
DBGMCU_Periph
;

131 
	}
}

146 void 
	$DBGMCU_APB2PeriphConfig
(
uint32_t
 
DBGMCU_Periph
, 
FunctionalState
 
NewState
)

149 
	`assert_param
(
	`IS_DBGMCU_APB2PERIPH
(
DBGMCU_Periph
));

150 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

152 if (
NewState
 != 
DISABLE
)

154 
DBGMCU
->
APB2FZ
 |= 
DBGMCU_Periph
;

158 
DBGMCU
->
APB2FZ
 &= ~
DBGMCU_Periph
;

160 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dcmi.c

82 #include 
	~"stm32f4xx_dcmi.h
"

83 #include 
	~"stm32f4xx_rcc.h
"

122 void 
	$DCMI_DeInit
(void)

124 
DCMI
->
CR
 = 0x0;

125 
DCMI
->
IER
 = 0x0;

126 
DCMI
->
ICR
 = 0x1F;

127 
DCMI
->
ESCR
 = 0x0;

128 
DCMI
->
ESUR
 = 0x0;

129 
DCMI
->
CWSTRTR
 = 0x0;

130 
DCMI
->
CWSIZER
 = 0x0;

131 
	}
}

139 void 
	$DCMI_Init
(
DCMI_InitTypeDef
* 
DCMI_InitStruct
)

141 
uint32_t
 
temp
 = 0x0;

144 
	`assert_param
(
	`IS_DCMI_CAPTURE_MODE
(
DCMI_InitStruct
->
DCMI_CaptureMode
));

145 
	`assert_param
(
	`IS_DCMI_SYNCHRO
(
DCMI_InitStruct
->
DCMI_SynchroMode
));

146 
	`assert_param
(
	`IS_DCMI_PCKPOLARITY
(
DCMI_InitStruct
->
DCMI_PCKPolarity
));

147 
	`assert_param
(
	`IS_DCMI_VSPOLARITY
(
DCMI_InitStruct
->
DCMI_VSPolarity
));

148 
	`assert_param
(
	`IS_DCMI_HSPOLARITY
(
DCMI_InitStruct
->
DCMI_HSPolarity
));

149 
	`assert_param
(
	`IS_DCMI_CAPTURE_RATE
(
DCMI_InitStruct
->
DCMI_CaptureRate
));

150 
	`assert_param
(
	`IS_DCMI_EXTENDED_DATA
(
DCMI_InitStruct
->
DCMI_ExtendedDataMode
));

154 
DCMI
->
CR
 &= ~(
DCMI_CR_ENABLE
 | 
DCMI_CR_CAPTURE
);

157 
temp
 = 
DCMI
->
CR
;

159 
temp
 &= ~((
uint32_t
)
DCMI_CR_CM
 | 
DCMI_CR_ESS
 | 
DCMI_CR_PCKPOL
 |

160 
DCMI_CR_HSPOL
 | 
DCMI_CR_VSPOL
 | 
DCMI_CR_FCRC_0
 |

161 
DCMI_CR_FCRC_1
 | 
DCMI_CR_EDM_0
 | 
DCMI_CR_EDM_1
);

164 
temp
 |= ((
uint32_t
)
DCMI_InitStruct
->
DCMI_CaptureMode
 |

165 
DCMI_InitStruct
->
DCMI_SynchroMode
 |

166 
DCMI_InitStruct
->
DCMI_PCKPolarity
 |

167 
DCMI_InitStruct
->
DCMI_VSPolarity
 |

168 
DCMI_InitStruct
->
DCMI_HSPolarity
 |

169 
DCMI_InitStruct
->
DCMI_CaptureRate
 |

170 
DCMI_InitStruct
->
DCMI_ExtendedDataMode
);

172 
DCMI
->
CR
 = 
temp
;

173 
	}
}

181 void 
	$DCMI_StructInit
(
DCMI_InitTypeDef
* 
DCMI_InitStruct
)

184 
DCMI_InitStruct
->
DCMI_CaptureMode
 = 
DCMI_CaptureMode_Continuous
;

185 
DCMI_InitStruct
->
DCMI_SynchroMode
 = 
DCMI_SynchroMode_Hardware
;

186 
DCMI_InitStruct
->
DCMI_PCKPolarity
 = 
DCMI_PCKPolarity_Falling
;

187 
DCMI_InitStruct
->
DCMI_VSPolarity
 = 
DCMI_VSPolarity_Low
;

188 
DCMI_InitStruct
->
DCMI_HSPolarity
 = 
DCMI_HSPolarity_Low
;

189 
DCMI_InitStruct
->
DCMI_CaptureRate
 = 
DCMI_CaptureRate_All_Frame
;

190 
DCMI_InitStruct
->
DCMI_ExtendedDataMode
 = 
DCMI_ExtendedDataMode_8b
;

191 
	}
}

201 void 
	$DCMI_CROPConfig
(
DCMI_CROPInitTypeDef
* 
DCMI_CROPInitStruct
)

204 
DCMI
->
CWSTRTR
 = (
uint32_t
)((uint32_t)
DCMI_CROPInitStruct
->
DCMI_HorizontalOffsetCount
 |

205 ((
uint32_t
)
DCMI_CROPInitStruct
->
DCMI_VerticalStartLine
 << 16));

208 
DCMI
->
CWSIZER
 = (
uint32_t
)(
DCMI_CROPInitStruct
->
DCMI_CaptureCount
 |

209 ((
uint32_t
)
DCMI_CROPInitStruct
->
DCMI_VerticalLineCount
 << 16));

210 
	}
}

219 void 
	$DCMI_CROPCmd
(
FunctionalState
 
NewState
)

222 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

224 if (
NewState
 != 
DISABLE
)

227 
DCMI
->
CR
 |= (
uint32_t
)
DCMI_CR_CROP
;

232 
DCMI
->
CR
 &= ~(
uint32_t
)
DCMI_CR_CROP
;

234 
	}
}

242 void 
	$DCMI_SetEmbeddedSynchroCodes
(
DCMI_CodesInitTypeDef
* 
DCMI_CodesInitStruct
)

244 
DCMI
->
ESCR
 = (
uint32_t
)(
DCMI_CodesInitStruct
->
DCMI_FrameStartCode
 |

245 ((
uint32_t
)
DCMI_CodesInitStruct
->
DCMI_LineStartCode
 << 8)|

246 ((
uint32_t
)
DCMI_CodesInitStruct
->
DCMI_LineEndCode
 << 16)|

247 ((
uint32_t
)
DCMI_CodesInitStruct
->
DCMI_FrameEndCode
 << 24));

248 
	}
}

257 void 
	$DCMI_JPEGCmd
(
FunctionalState
 
NewState
)

260 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

262 if (
NewState
 != 
DISABLE
)

265 
DCMI
->
CR
 |= (
uint32_t
)
DCMI_CR_JPEG
;

270 
DCMI
->
CR
 &= ~(
uint32_t
)
DCMI_CR_JPEG
;

272 
	}
}

295 void 
	$DCMI_Cmd
(
FunctionalState
 
NewState
)

298 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

300 if (
NewState
 != 
DISABLE
)

303 
DCMI
->
CR
 |= (
uint32_t
)
DCMI_CR_ENABLE
;

308 
DCMI
->
CR
 &= ~(
uint32_t
)
DCMI_CR_ENABLE
;

310 
	}
}

318 void 
	$DCMI_CaptureCmd
(
FunctionalState
 
NewState
)

321 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

323 if (
NewState
 != 
DISABLE
)

326 
DCMI
->
CR
 |= (
uint32_t
)
DCMI_CR_CAPTURE
;

331 
DCMI
->
CR
 &= ~(
uint32_t
)
DCMI_CR_CAPTURE
;

333 
	}
}

340 
uint32_t
 
	$DCMI_ReadData
(void)

342 return 
DCMI
->
DR
;

343 
	}
}

373 void 
	$DCMI_ITConfig
(
uint16_t
 
DCMI_IT
, 
FunctionalState
 
NewState
)

376 
	`assert_param
(
	`IS_DCMI_CONFIG_IT
(
DCMI_IT
));

377 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

379 if (
NewState
 != 
DISABLE
)

382 
DCMI
->
IER
 |= 
DCMI_IT
;

387 
DCMI
->
IER
 &= (
uint16_t
)(~
DCMI_IT
);

389 
	}
}

410 
FlagStatus
 
	$DCMI_GetFlagStatus
(
uint16_t
 
DCMI_FLAG
)

412 
FlagStatus
 
bitstatus
 = 
RESET
;

413 
uint32_t
 
dcmireg
, 
tempreg
 = 0;

416 
	`assert_param
(
	`IS_DCMI_GET_FLAG
(
DCMI_FLAG
));

419 
dcmireg
 = (((
uint16_t
)
DCMI_FLAG
) >> 12);

421 if (
dcmireg
 == 0x01)

423 
tempreg
= 
DCMI
->
RISR
;

425 else if (
dcmireg
 == 0x02)

427 
tempreg
 = 
DCMI
->
SR
;

431 
tempreg
 = 
DCMI
->
MISR
;

434 if ((
tempreg
 & 
DCMI_FLAG
) != (
uint16_t
)
RESET
 )

436 
bitstatus
 = 
SET
;

440 
bitstatus
 = 
RESET
;

443 return 
bitstatus
;

444 
	}
}

457 void 
	$DCMI_ClearFlag
(
uint16_t
 
DCMI_FLAG
)

460 
	`assert_param
(
	`IS_DCMI_CLEAR_FLAG
(
DCMI_FLAG
));

465 
DCMI
->
ICR
 = 
DCMI_FLAG
;

466 
	}
}

479 
ITStatus
 
	$DCMI_GetITStatus
(
uint16_t
 
DCMI_IT
)

481 
ITStatus
 
bitstatus
 = 
RESET
;

482 
uint32_t
 
itstatus
 = 0;

485 
	`assert_param
(
	`IS_DCMI_GET_IT
(
DCMI_IT
));

487 
itstatus
 = 
DCMI
->
MISR
 & 
DCMI_IT
;

489 if ((
itstatus
 != (
uint16_t
)
RESET
))

491 
bitstatus
 = 
SET
;

495 
bitstatus
 = 
RESET
;

497 return 
bitstatus
;

498 
	}
}

511 void 
	$DCMI_ClearITPendingBit
(
uint16_t
 
DCMI_IT
)

516 
DCMI
->
ICR
 = 
DCMI_IT
;

517 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma.c

116 #include 
	~"stm32f4xx_dma.h
"

117 #include 
	~"stm32f4xx_rcc.h
"

132 #define 
	#TRANSFER_IT_ENABLE_MASK
 (
uint32_t
)(
DMA_SxCR_TCIE
 | 
DMA_SxCR_HTIE
 | \

	)

133 
	gDMA_SxCR_TEIE
 | 
	gDMA_SxCR_DMEIE
)

135 #define 
	#DMA_Stream0_IT_MASK
 (
uint32_t
)(
DMA_LISR_FEIF0
 | 
DMA_LISR_DMEIF0
 | \

	)

136 
	gDMA_LISR_TEIF0
 | 
	gDMA_LISR_HTIF0
 | \

137 
	gDMA_LISR_TCIF0
)

139 #define 
	#DMA_Stream1_IT_MASK
 (
uint32_t
)(
DMA_Stream0_IT_MASK
 << 6)

	)

140 #define 
	#DMA_Stream2_IT_MASK
 (
uint32_t
)(
DMA_Stream0_IT_MASK
 << 16)

	)

141 #define 
	#DMA_Stream3_IT_MASK
 (
uint32_t
)(
DMA_Stream0_IT_MASK
 << 22)

	)

142 #define 
	#DMA_Stream4_IT_MASK
 (
uint32_t
)(
DMA_Stream0_IT_MASK
 | (uint32_t)0x20000000)

	)

143 #define 
	#DMA_Stream5_IT_MASK
 (
uint32_t
)(
DMA_Stream1_IT_MASK
 | (uint32_t)0x20000000)

	)

144 #define 
	#DMA_Stream6_IT_MASK
 (
uint32_t
)(
DMA_Stream2_IT_MASK
 | (uint32_t)0x20000000)

	)

145 #define 
	#DMA_Stream7_IT_MASK
 (
uint32_t
)(
DMA_Stream3_IT_MASK
 | (uint32_t)0x20000000)

	)

146 #define 
	#TRANSFER_IT_MASK
 (
uint32_t
)0x0F3C0F3C

	)

147 #define 
	#HIGH_ISR_MASK
 (
uint32_t
)0x20000000

	)

148 #define 
	#RESERVED_MASK
 (
uint32_t
)0x0F7D0F7D

	)

188 void 
	$DMA_DeInit
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
)

191 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

194 
DMAy_Streamx
->
CR
 &= ~((
uint32_t
)
DMA_SxCR_EN
);

197 
DMAy_Streamx
->
CR
 = 0;

200 
DMAy_Streamx
->
NDTR
 = 0;

203 
DMAy_Streamx
->
PAR
 = 0;

206 
DMAy_Streamx
->
M0AR
 = 0;

209 
DMAy_Streamx
->
M1AR
 = 0;

212 
DMAy_Streamx
->
FCR
 = (
uint32_t
)0x00000021;

215 if (
DMAy_Streamx
 == 
DMA1_Stream0
)

218 
DMA1
->
LIFCR
 = 
DMA_Stream0_IT_MASK
;

220 else if (
DMAy_Streamx
 == 
DMA1_Stream1
)

223 
DMA1
->
LIFCR
 = 
DMA_Stream1_IT_MASK
;

225 else if (
DMAy_Streamx
 == 
DMA1_Stream2
)

228 
DMA1
->
LIFCR
 = 
DMA_Stream2_IT_MASK
;

230 else if (
DMAy_Streamx
 == 
DMA1_Stream3
)

233 
DMA1
->
LIFCR
 = 
DMA_Stream3_IT_MASK
;

235 else if (
DMAy_Streamx
 == 
DMA1_Stream4
)

238 
DMA1
->
HIFCR
 = 
DMA_Stream4_IT_MASK
;

240 else if (
DMAy_Streamx
 == 
DMA1_Stream5
)

243 
DMA1
->
HIFCR
 = 
DMA_Stream5_IT_MASK
;

245 else if (
DMAy_Streamx
 == 
DMA1_Stream6
)

248 
DMA1
->
HIFCR
 = (
uint32_t
)
DMA_Stream6_IT_MASK
;

250 else if (
DMAy_Streamx
 == 
DMA1_Stream7
)

253 
DMA1
->
HIFCR
 = 
DMA_Stream7_IT_MASK
;

255 else if (
DMAy_Streamx
 == 
DMA2_Stream0
)

258 
DMA2
->
LIFCR
 = 
DMA_Stream0_IT_MASK
;

260 else if (
DMAy_Streamx
 == 
DMA2_Stream1
)

263 
DMA2
->
LIFCR
 = 
DMA_Stream1_IT_MASK
;

265 else if (
DMAy_Streamx
 == 
DMA2_Stream2
)

268 
DMA2
->
LIFCR
 = 
DMA_Stream2_IT_MASK
;

270 else if (
DMAy_Streamx
 == 
DMA2_Stream3
)

273 
DMA2
->
LIFCR
 = 
DMA_Stream3_IT_MASK
;

275 else if (
DMAy_Streamx
 == 
DMA2_Stream4
)

278 
DMA2
->
HIFCR
 = 
DMA_Stream4_IT_MASK
;

280 else if (
DMAy_Streamx
 == 
DMA2_Stream5
)

283 
DMA2
->
HIFCR
 = 
DMA_Stream5_IT_MASK
;

285 else if (
DMAy_Streamx
 == 
DMA2_Stream6
)

288 
DMA2
->
HIFCR
 = 
DMA_Stream6_IT_MASK
;

292 if (
DMAy_Streamx
 == 
DMA2_Stream7
)

295 
DMA2
->
HIFCR
 = 
DMA_Stream7_IT_MASK
;

298 
	}
}

311 void 
	$DMA_Init
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
DMA_InitTypeDef
* 
DMA_InitStruct
)

313 
uint32_t
 
tmpreg
 = 0;

316 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

317 
	`assert_param
(
	`IS_DMA_CHANNEL
(
DMA_InitStruct
->
DMA_Channel
));

318 
	`assert_param
(
	`IS_DMA_DIRECTION
(
DMA_InitStruct
->
DMA_DIR
));

319 
	`assert_param
(
	`IS_DMA_BUFFER_SIZE
(
DMA_InitStruct
->
DMA_BufferSize
));

320 
	`assert_param
(
	`IS_DMA_PERIPHERAL_INC_STATE
(
DMA_InitStruct
->
DMA_PeripheralInc
));

321 
	`assert_param
(
	`IS_DMA_MEMORY_INC_STATE
(
DMA_InitStruct
->
DMA_MemoryInc
));

322 
	`assert_param
(
	`IS_DMA_PERIPHERAL_DATA_SIZE
(
DMA_InitStruct
->
DMA_PeripheralDataSize
));

323 
	`assert_param
(
	`IS_DMA_MEMORY_DATA_SIZE
(
DMA_InitStruct
->
DMA_MemoryDataSize
));

324 
	`assert_param
(
	`IS_DMA_MODE
(
DMA_InitStruct
->
DMA_Mode
));

325 
	`assert_param
(
	`IS_DMA_PRIORITY
(
DMA_InitStruct
->
DMA_Priority
));

326 
	`assert_param
(
	`IS_DMA_FIFO_MODE_STATE
(
DMA_InitStruct
->
DMA_FIFOMode
));

327 
	`assert_param
(
	`IS_DMA_FIFO_THRESHOLD
(
DMA_InitStruct
->
DMA_FIFOThreshold
));

328 
	`assert_param
(
	`IS_DMA_MEMORY_BURST
(
DMA_InitStruct
->
DMA_MemoryBurst
));

329 
	`assert_param
(
	`IS_DMA_PERIPHERAL_BURST
(
DMA_InitStruct
->
DMA_PeripheralBurst
));

333 
tmpreg
 = 
DMAy_Streamx
->
CR
;

336 
tmpreg
 &= ((
uint32_t
)~(
DMA_SxCR_CHSEL
 | 
DMA_SxCR_MBURST
 | 
DMA_SxCR_PBURST
 | \

337 
DMA_SxCR_PL
 | 
DMA_SxCR_MSIZE
 | 
DMA_SxCR_PSIZE
 | \

338 
DMA_SxCR_MINC
 | 
DMA_SxCR_PINC
 | 
DMA_SxCR_CIRC
 | \

339 
DMA_SxCR_DIR
));

352 
tmpreg
 |= 
DMA_InitStruct
->
DMA_Channel
 | DMA_InitStruct->
DMA_DIR
 |

353 
DMA_InitStruct
->
DMA_PeripheralInc
 | DMA_InitStruct->
DMA_MemoryInc
 |

354 
DMA_InitStruct
->
DMA_PeripheralDataSize
 | DMA_InitStruct->
DMA_MemoryDataSize
 |

355 
DMA_InitStruct
->
DMA_Mode
 | DMA_InitStruct->
DMA_Priority
 |

356 
DMA_InitStruct
->
DMA_MemoryBurst
 | DMA_InitStruct->
DMA_PeripheralBurst
;

359 
DMAy_Streamx
->
CR
 = 
tmpreg
;

363 
tmpreg
 = 
DMAy_Streamx
->
FCR
;

366 
tmpreg
 &= (
uint32_t
)~(
DMA_SxFCR_DMDIS
 | 
DMA_SxFCR_FTH
);

371 
tmpreg
 |= 
DMA_InitStruct
->
DMA_FIFOMode
 | DMA_InitStruct->
DMA_FIFOThreshold
;

374 
DMAy_Streamx
->
FCR
 = 
tmpreg
;

378 
DMAy_Streamx
->
NDTR
 = 
DMA_InitStruct
->
DMA_BufferSize
;

382 
DMAy_Streamx
->
PAR
 = 
DMA_InitStruct
->
DMA_PeripheralBaseAddr
;

386 
DMAy_Streamx
->
M0AR
 = 
DMA_InitStruct
->
DMA_Memory0BaseAddr
;

387 
	}
}

395 void 
	$DMA_StructInit
(
DMA_InitTypeDef
* 
DMA_InitStruct
)

399 
DMA_InitStruct
->
DMA_Channel
 = 0;

402 
DMA_InitStruct
->
DMA_PeripheralBaseAddr
 = 0;

405 
DMA_InitStruct
->
DMA_Memory0BaseAddr
 = 0;

408 
DMA_InitStruct
->
DMA_DIR
 = 
DMA_DIR_PeripheralToMemory
;

411 
DMA_InitStruct
->
DMA_BufferSize
 = 0;

414 
DMA_InitStruct
->
DMA_PeripheralInc
 = 
DMA_PeripheralInc_Disable
;

417 
DMA_InitStruct
->
DMA_MemoryInc
 = 
DMA_MemoryInc_Disable
;

420 
DMA_InitStruct
->
DMA_PeripheralDataSize
 = 
DMA_PeripheralDataSize_Byte
;

423 
DMA_InitStruct
->
DMA_MemoryDataSize
 = 
DMA_MemoryDataSize_Byte
;

426 
DMA_InitStruct
->
DMA_Mode
 = 
DMA_Mode_Normal
;

429 
DMA_InitStruct
->
DMA_Priority
 = 
DMA_Priority_Low
;

432 
DMA_InitStruct
->
DMA_FIFOMode
 = 
DMA_FIFOMode_Disable
;

435 
DMA_InitStruct
->
DMA_FIFOThreshold
 = 
DMA_FIFOThreshold_1QuarterFull
;

438 
DMA_InitStruct
->
DMA_MemoryBurst
 = 
DMA_MemoryBurst_Single
;

441 
DMA_InitStruct
->
DMA_PeripheralBurst
 = 
DMA_PeripheralBurst_Single
;

442 
	}
}

470 void 
	$DMA_Cmd
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
FunctionalState
 
NewState
)

473 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

474 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

476 if (
NewState
 != 
DISABLE
)

479 
DMAy_Streamx
->
CR
 |= (
uint32_t
)
DMA_SxCR_EN
;

484 
DMAy_Streamx
->
CR
 &= ~(
uint32_t
)
DMA_SxCR_EN
;

486 
	}
}

506 void 
	$DMA_PeriphIncOffsetSizeConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_Pincos
)

509 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

510 
	`assert_param
(
	`IS_DMA_PINCOS_SIZE
(
DMA_Pincos
));

513 if(
DMA_Pincos
 != 
DMA_PINCOS_Psize
)

516 
DMAy_Streamx
->
CR
 |= (
uint32_t
)
DMA_SxCR_PINCOS
;

521 
DMAy_Streamx
->
CR
 &= ~(
uint32_t
)
DMA_SxCR_PINCOS
;

523 
	}
}

542 void 
	$DMA_FlowControllerConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_FlowCtrl
)

545 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

546 
	`assert_param
(
	`IS_DMA_FLOW_CTRL
(
DMA_FlowCtrl
));

549 if(
DMA_FlowCtrl
 != 
DMA_FlowCtrl_Memory
)

552 
DMAy_Streamx
->
CR
 |= (
uint32_t
)
DMA_SxCR_PFCTRL
;

557 
DMAy_Streamx
->
CR
 &= ~(
uint32_t
)
DMA_SxCR_PFCTRL
;

559 
	}
}

626 void 
	$DMA_SetCurrDataCounter
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint16_t
 
Counter
)

629 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

632 
DMAy_Streamx
->
NDTR
 = (
uint16_t
)
Counter
;

633 
	}
}

641 
uint16_t
 
	$DMA_GetCurrDataCounter
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
)

644 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

647 return ((
uint16_t
)(
DMAy_Streamx
->
NDTR
));

648 
	}
}

718 void 
	$DMA_DoubleBufferModeConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
Memory1BaseAddr
,

719 
uint32_t
 
DMA_CurrentMemory
)

722 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

723 
	`assert_param
(
	`IS_DMA_CURRENT_MEM
(
DMA_CurrentMemory
));

725 if (
DMA_CurrentMemory
 != 
DMA_Memory_0
)

728 
DMAy_Streamx
->
CR
 |= (
uint32_t
)(
DMA_SxCR_CT
);

733 
DMAy_Streamx
->
CR
 &= ~(
uint32_t
)(
DMA_SxCR_CT
);

737 
DMAy_Streamx
->
M1AR
 = 
Memory1BaseAddr
;

738 
	}
}

749 void 
	$DMA_DoubleBufferModeCmd
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
FunctionalState
 
NewState
)

752 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

753 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

756 if (
NewState
 != 
DISABLE
)

759 
DMAy_Streamx
->
CR
 |= (
uint32_t
)
DMA_SxCR_DBM
;

764 
DMAy_Streamx
->
CR
 &= ~(
uint32_t
)
DMA_SxCR_DBM
;

766 
	}
}

790 void 
	$DMA_MemoryTargetConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
MemoryBaseAddr
,

791 
uint32_t
 
DMA_MemoryTarget
)

794 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

795 
	`assert_param
(
	`IS_DMA_CURRENT_MEM
(
DMA_MemoryTarget
));

798 if (
DMA_MemoryTarget
 != 
DMA_Memory_0
)

801 
DMAy_Streamx
->
M1AR
 = 
MemoryBaseAddr
;

806 
DMAy_Streamx
->
M0AR
 = 
MemoryBaseAddr
;

808 
	}
}

816 
uint32_t
 
	$DMA_GetCurrentMemoryTarget
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
)

818 
uint32_t
 
tmp
 = 0;

821 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

824 if ((
DMAy_Streamx
->
CR
 & 
DMA_SxCR_CT
) != 0)

827 
tmp
 = 1;

832 
tmp
 = 0;

834 return 
tmp
;

835 
	}
}

925 
FunctionalState
 
	$DMA_GetCmdStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
)

927 
FunctionalState
 
state
 = 
DISABLE
;

930 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

932 if ((
DMAy_Streamx
->
CR
 & (
uint32_t
)
DMA_SxCR_EN
) != 0)

935 
state
 = 
ENABLE
;

941 
state
 = 
DISABLE
;

943 return 
state
;

944 
	}
}

959 
uint32_t
 
	$DMA_GetFIFOStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
)

961 
uint32_t
 
tmpreg
 = 0;

964 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

967 
tmpreg
 = (
uint32_t
)((
DMAy_Streamx
->
FCR
 & 
DMA_SxFCR_FS
));

969 return 
tmpreg
;

970 
	}
}

986 
FlagStatus
 
	$DMA_GetFlagStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_FLAG
)

988 
FlagStatus
 
bitstatus
 = 
RESET
;

989 
DMA_TypeDef
* 
DMAy
;

990 
uint32_t
 
tmpreg
 = 0;

993 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

994 
	`assert_param
(
	`IS_DMA_GET_FLAG
(
DMA_FLAG
));

997 if (
DMAy_Streamx
 < 
DMA2_Stream0
)

1000 
DMAy
 = 
DMA1
;

1005 
DMAy
 = 
DMA2
;

1009 if ((
DMA_FLAG
 & 
HIGH_ISR_MASK
) != (
uint32_t
)
RESET
)

1012 
tmpreg
 = 
DMAy
->
HISR
;

1017 
tmpreg
 = 
DMAy
->
LISR
;

1021 
tmpreg
 &= (
uint32_t
)
RESERVED_MASK
;

1024 if ((
tmpreg
 & 
DMA_FLAG
) != (
uint32_t
)
RESET
)

1027 
bitstatus
 = 
SET
;

1032 
bitstatus
 = 
RESET
;

1036 return 
bitstatus
;

1037 
	}
}

1053 void 
	$DMA_ClearFlag
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_FLAG
)

1055 
DMA_TypeDef
* 
DMAy
;

1058 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

1059 
	`assert_param
(
	`IS_DMA_CLEAR_FLAG
(
DMA_FLAG
));

1062 if (
DMAy_Streamx
 < 
DMA2_Stream0
)

1065 
DMAy
 = 
DMA1
;

1070 
DMAy
 = 
DMA2
;

1074 if ((
DMA_FLAG
 & 
HIGH_ISR_MASK
) != (
uint32_t
)
RESET
)

1077 
DMAy
->
HIFCR
 = (
uint32_t
)(
DMA_FLAG
 & 
RESERVED_MASK
);

1082 
DMAy
->
LIFCR
 = (
uint32_t
)(
DMA_FLAG
 & 
RESERVED_MASK
);

1084 
	}
}

1100 void 
	$DMA_ITConfig
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_IT
, 
FunctionalState
 
NewState
)

1103 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

1104 
	`assert_param
(
	`IS_DMA_CONFIG_IT
(
DMA_IT
));

1105 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1108 if ((
DMA_IT
 & 
DMA_IT_FE
) != 0)

1110 if (
NewState
 != 
DISABLE
)

1113 
DMAy_Streamx
->
FCR
 |= (
uint32_t
)
DMA_IT_FE
;

1118 
DMAy_Streamx
->
FCR
 &= ~(
uint32_t
)
DMA_IT_FE
;

1123 if (
DMA_IT
 != 
DMA_IT_FE
)

1125 if (
NewState
 != 
DISABLE
)

1128 
DMAy_Streamx
->
CR
 |= (
uint32_t
)(
DMA_IT
 & 
TRANSFER_IT_ENABLE_MASK
);

1133 
DMAy_Streamx
->
CR
 &= ~(
uint32_t
)(
DMA_IT
 & 
TRANSFER_IT_ENABLE_MASK
);

1136 
	}
}

1152 
ITStatus
 
	$DMA_GetITStatus
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_IT
)

1154 
ITStatus
 
bitstatus
 = 
RESET
;

1155 
DMA_TypeDef
* 
DMAy
;

1156 
uint32_t
 
tmpreg
 = 0, 
enablestatus
 = 0;

1159 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

1160 
	`assert_param
(
	`IS_DMA_GET_IT
(
DMA_IT
));

1163 if (
DMAy_Streamx
 < 
DMA2_Stream0
)

1166 
DMAy
 = 
DMA1
;

1171 
DMAy
 = 
DMA2
;

1175 if ((
DMA_IT
 & 
TRANSFER_IT_MASK
) != (
uint32_t
)
RESET
)

1178 
tmpreg
 = (
uint32_t
)((
DMA_IT
 >> 11) & 
TRANSFER_IT_ENABLE_MASK
);

1181 
enablestatus
 = (
uint32_t
)(
DMAy_Streamx
->
CR
 & 
tmpreg
);

1186 
enablestatus
 = (
uint32_t
)(
DMAy_Streamx
->
FCR
 & 
DMA_IT_FE
);

1190 if ((
DMA_IT
 & 
HIGH_ISR_MASK
) != (
uint32_t
)
RESET
)

1193 
tmpreg
 = 
DMAy
->
HISR
 ;

1198 
tmpreg
 = 
DMAy
->
LISR
 ;

1202 
tmpreg
 &= (
uint32_t
)
RESERVED_MASK
;

1205 if (((
tmpreg
 & 
DMA_IT
) != (
uint32_t
)
RESET
) && (
enablestatus
 != (uint32_t)RESET))

1208 
bitstatus
 = 
SET
;

1213 
bitstatus
 = 
RESET
;

1217 return 
bitstatus
;

1218 
	}
}

1234 void 
	$DMA_ClearITPendingBit
(
DMA_Stream_TypeDef
* 
DMAy_Streamx
, 
uint32_t
 
DMA_IT
)

1236 
DMA_TypeDef
* 
DMAy
;

1239 
	`assert_param
(
	`IS_DMA_ALL_PERIPH
(
DMAy_Streamx
));

1240 
	`assert_param
(
	`IS_DMA_CLEAR_IT
(
DMA_IT
));

1243 if (
DMAy_Streamx
 < 
DMA2_Stream0
)

1246 
DMAy
 = 
DMA1
;

1251 
DMAy
 = 
DMA2
;

1255 if ((
DMA_IT
 & 
HIGH_ISR_MASK
) != (
uint32_t
)
RESET
)

1258 
DMAy
->
HIFCR
 = (
uint32_t
)(
DMA_IT
 & 
RESERVED_MASK
);

1263 
DMAy
->
LIFCR
 = (
uint32_t
)(
DMA_IT
 & 
RESERVED_MASK
);

1265 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_exti.c

61 #include 
	~"stm32f4xx_exti.h
"

75 #define 
	#EXTI_LINENONE
 ((
uint32_t
)0x00000)

	)

103 void 
	$EXTI_DeInit
(void)

105 
EXTI
->
IMR
 = 0x00000000;

106 
EXTI
->
EMR
 = 0x00000000;

107 
EXTI
->
RTSR
 = 0x00000000;

108 
EXTI
->
FTSR
 = 0x00000000;

109 
EXTI
->
PR
 = 0x007FFFFF;

110 
	}
}

119 void 
	$EXTI_Init
(
EXTI_InitTypeDef
* 
EXTI_InitStruct
)

121 
uint32_t
 
tmp
 = 0;

124 
	`assert_param
(
	`IS_EXTI_MODE
(
EXTI_InitStruct
->
EXTI_Mode
));

125 
	`assert_param
(
	`IS_EXTI_TRIGGER
(
EXTI_InitStruct
->
EXTI_Trigger
));

126 
	`assert_param
(
	`IS_EXTI_LINE
(
EXTI_InitStruct
->
EXTI_Line
));

127 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
EXTI_InitStruct
->
EXTI_LineCmd
));

129 
tmp
 = (
uint32_t
)
EXTI_BASE
;

131 if (
EXTI_InitStruct
->
EXTI_LineCmd
 != 
DISABLE
)

134 
EXTI
->
IMR
 &= ~
EXTI_InitStruct
->
EXTI_Line
;

135 
EXTI
->
EMR
 &= ~
EXTI_InitStruct
->
EXTI_Line
;

137 
tmp
 += 
EXTI_InitStruct
->
EXTI_Mode
;

139 *(
__IO
 
uint32_t
 *) 
tmp
 |= 
EXTI_InitStruct
->
EXTI_Line
;

142 
EXTI
->
RTSR
 &= ~
EXTI_InitStruct
->
EXTI_Line
;

143 
EXTI
->
FTSR
 &= ~
EXTI_InitStruct
->
EXTI_Line
;

146 if (
EXTI_InitStruct
->
EXTI_Trigger
 == 
EXTI_Trigger_Rising_Falling
)

149 
EXTI
->
RTSR
 |= 
EXTI_InitStruct
->
EXTI_Line
;

150 
EXTI
->
FTSR
 |= 
EXTI_InitStruct
->
EXTI_Line
;

154 
tmp
 = (
uint32_t
)
EXTI_BASE
;

155 
tmp
 += 
EXTI_InitStruct
->
EXTI_Trigger
;

157 *(
__IO
 
uint32_t
 *) 
tmp
 |= 
EXTI_InitStruct
->
EXTI_Line
;

162 
tmp
 += 
EXTI_InitStruct
->
EXTI_Mode
;

165 *(
__IO
 
uint32_t
 *) 
tmp
 &= ~
EXTI_InitStruct
->
EXTI_Line
;

167 
	}
}

175 void 
	$EXTI_StructInit
(
EXTI_InitTypeDef
* 
EXTI_InitStruct
)

177 
EXTI_InitStruct
->
EXTI_Line
 = 
EXTI_LINENONE
;

178 
EXTI_InitStruct
->
EXTI_Mode
 = 
EXTI_Mode_Interrupt
;

179 
EXTI_InitStruct
->
EXTI_Trigger
 = 
EXTI_Trigger_Falling
;

180 
EXTI_InitStruct
->
EXTI_LineCmd
 = 
DISABLE
;

181 
	}
}

190 void 
	$EXTI_GenerateSWInterrupt
(
uint32_t
 
EXTI_Line
)

193 
	`assert_param
(
	`IS_EXTI_LINE
(
EXTI_Line
));

195 
EXTI
->
SWIER
 |= 
EXTI_Line
;

196 
	}
}

220 
FlagStatus
 
	$EXTI_GetFlagStatus
(
uint32_t
 
EXTI_Line
)

222 
FlagStatus
 
bitstatus
 = 
RESET
;

224 
	`assert_param
(
	`IS_GET_EXTI_LINE
(
EXTI_Line
));

226 if ((
EXTI
->
PR
 & 
EXTI_Line
) != (
uint32_t
)
RESET
)

228 
bitstatus
 = 
SET
;

232 
bitstatus
 = 
RESET
;

234 return 
bitstatus
;

235 
	}
}

243 void 
	$EXTI_ClearFlag
(
uint32_t
 
EXTI_Line
)

246 
	`assert_param
(
	`IS_EXTI_LINE
(
EXTI_Line
));

248 
EXTI
->
PR
 = 
EXTI_Line
;

249 
	}
}

257 
ITStatus
 
	$EXTI_GetITStatus
(
uint32_t
 
EXTI_Line
)

259 
ITStatus
 
bitstatus
 = 
RESET
;

260 
uint32_t
 
enablestatus
 = 0;

262 
	`assert_param
(
	`IS_GET_EXTI_LINE
(
EXTI_Line
));

264 
enablestatus
 = 
EXTI
->
IMR
 & 
EXTI_Line
;

265 if (((
EXTI
->
PR
 & 
EXTI_Line
) != (
uint32_t
)
RESET
) && (
enablestatus
 != (uint32_t)RESET))

267 
bitstatus
 = 
SET
;

271 
bitstatus
 = 
RESET
;

273 return 
bitstatus
;

274 
	}
}

282 void 
	$EXTI_ClearITPendingBit
(
uint32_t
 
EXTI_Line
)

285 
	`assert_param
(
	`IS_EXTI_LINE
(
EXTI_Line
));

287 
EXTI
->
PR
 = 
EXTI_Line
;

288 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash.c

70 #include 
	~"stm32f4xx_flash.h
"

83 #define 
	#SECTOR_MASK
 ((
uint32_t
)0xFFFFFF07)

	)

164 void 
	$FLASH_SetLatency
(
uint32_t
 
FLASH_Latency
)

167 
	`assert_param
(
	`IS_FLASH_LATENCY
(
FLASH_Latency
));

170 *(
__IO
 
uint8_t
 *)
ACR_BYTE0_ADDRESS
 = (uint8_t)
FLASH_Latency
;

171 
	}
}

179 void 
	$FLASH_PrefetchBufferCmd
(
FunctionalState
 
NewState
)

182 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

185 if(
NewState
 != 
DISABLE
)

187 
FLASH
->
ACR
 |= 
FLASH_ACR_PRFTEN
;

191 
FLASH
->
ACR
 &= (~
FLASH_ACR_PRFTEN
);

193 
	}
}

201 void 
	$FLASH_InstructionCacheCmd
(
FunctionalState
 
NewState
)

204 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

206 if(
NewState
 != 
DISABLE
)

208 
FLASH
->
ACR
 |= 
FLASH_ACR_ICEN
;

212 
FLASH
->
ACR
 &= (~
FLASH_ACR_ICEN
);

214 
	}
}

222 void 
	$FLASH_DataCacheCmd
(
FunctionalState
 
NewState
)

225 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

227 if(
NewState
 != 
DISABLE
)

229 
FLASH
->
ACR
 |= 
FLASH_ACR_DCEN
;

233 
FLASH
->
ACR
 &= (~
FLASH_ACR_DCEN
);

235 
	}
}

243 void 
	$FLASH_InstructionCacheReset
(void)

245 
FLASH
->
ACR
 |= 
FLASH_ACR_ICRST
;

246 
	}
}

254 void 
	$FLASH_DataCacheReset
(void)

256 
FLASH
->
ACR
 |= 
FLASH_ACR_DCRST
;

257 
	}
}

298 void 
	$FLASH_Unlock
(void)

300 if((
FLASH
->
CR
 & 
FLASH_CR_LOCK
) != 
RESET
)

303 
FLASH
->
KEYR
 = 
FLASH_KEY1
;

304 
FLASH
->
KEYR
 = 
FLASH_KEY2
;

306 
	}
}

313 void 
	$FLASH_Lock
(void)

316 
FLASH
->
CR
 |= 
FLASH_CR_LOCK
;

317 
	}
}

339 
FLASH_Status
 
	$FLASH_EraseSector
(
uint32_t
 
FLASH_Sector
, 
uint8_t
 
VoltageRange
)

341 
uint32_t
 
tmp_psize
 = 0x0;

342 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

345 
	`assert_param
(
	`IS_FLASH_SECTOR
(
FLASH_Sector
));

346 
	`assert_param
(
	`IS_VOLTAGERANGE
(
VoltageRange
));

348 if(
VoltageRange
 == 
VoltageRange_1
)

350 
tmp_psize
 = 
FLASH_PSIZE_BYTE
;

352 else if(
VoltageRange
 == 
VoltageRange_2
)

354 
tmp_psize
 = 
FLASH_PSIZE_HALF_WORD
;

356 else if(
VoltageRange
 == 
VoltageRange_3
)

358 
tmp_psize
 = 
FLASH_PSIZE_WORD
;

362 
tmp_psize
 = 
FLASH_PSIZE_DOUBLE_WORD
;

365 
status
 = 
	`FLASH_WaitForLastOperation
();

367 if(
status
 == 
FLASH_COMPLETE
)

370 
FLASH
->
CR
 &= 
CR_PSIZE_MASK
;

371 
FLASH
->
CR
 |= 
tmp_psize
;

372 
FLASH
->
CR
 &= 
SECTOR_MASK
;

373 
FLASH
->
CR
 |= 
FLASH_CR_SER
 | 
FLASH_Sector
;

374 
FLASH
->
CR
 |= 
FLASH_CR_STRT
;

377 
status
 = 
	`FLASH_WaitForLastOperation
();

380 
FLASH
->
CR
 &= (~
FLASH_CR_SER
);

381 
FLASH
->
CR
 &= 
SECTOR_MASK
;

384 return 
status
;

385 
	}
}

404 
FLASH_Status
 
	$FLASH_EraseAllSectors
(
uint8_t
 
VoltageRange
)

406 
uint32_t
 
tmp_psize
 = 0x0;

407 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

410 
status
 = 
	`FLASH_WaitForLastOperation
();

411 
	`assert_param
(
	`IS_VOLTAGERANGE
(
VoltageRange
));

413 if(
VoltageRange
 == 
VoltageRange_1
)

415 
tmp_psize
 = 
FLASH_PSIZE_BYTE
;

417 else if(
VoltageRange
 == 
VoltageRange_2
)

419 
tmp_psize
 = 
FLASH_PSIZE_HALF_WORD
;

421 else if(
VoltageRange
 == 
VoltageRange_3
)

423 
tmp_psize
 = 
FLASH_PSIZE_WORD
;

427 
tmp_psize
 = 
FLASH_PSIZE_DOUBLE_WORD
;

429 if(
status
 == 
FLASH_COMPLETE
)

432 
FLASH
->
CR
 &= 
CR_PSIZE_MASK
;

433 
FLASH
->
CR
 |= 
tmp_psize
;

434 
FLASH
->
CR
 |= 
FLASH_CR_MER
;

435 
FLASH
->
CR
 |= 
FLASH_CR_STRT
;

438 
status
 = 
	`FLASH_WaitForLastOperation
();

441 
FLASH
->
CR
 &= (~
FLASH_CR_MER
);

445 return 
status
;

446 
	}
}

457 
FLASH_Status
 
	$FLASH_ProgramDoubleWord
(
uint32_t
 
Address
, 
uint64_t
 
Data
)

459 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

462 
	`assert_param
(
	`IS_FLASH_ADDRESS
(
Address
));

465 
status
 = 
	`FLASH_WaitForLastOperation
();

467 if(
status
 == 
FLASH_COMPLETE
)

470 
FLASH
->
CR
 &= 
CR_PSIZE_MASK
;

471 
FLASH
->
CR
 |= 
FLASH_PSIZE_DOUBLE_WORD
;

472 
FLASH
->
CR
 |= 
FLASH_CR_PG
;

474 *(
__IO
 
uint64_t
*)
Address
 = 
Data
;

477 
status
 = 
	`FLASH_WaitForLastOperation
();

480 
FLASH
->
CR
 &= (~
FLASH_CR_PG
);

483 return 
status
;

484 
	}
}

495 
FLASH_Status
 
	$FLASH_ProgramWord
(
uint32_t
 
Address
, uint32_t 
Data
)

497 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

500 
	`assert_param
(
	`IS_FLASH_ADDRESS
(
Address
));

503 
status
 = 
	`FLASH_WaitForLastOperation
();

505 if(
status
 == 
FLASH_COMPLETE
)

508 
FLASH
->
CR
 &= 
CR_PSIZE_MASK
;

509 
FLASH
->
CR
 |= 
FLASH_PSIZE_WORD
;

510 
FLASH
->
CR
 |= 
FLASH_CR_PG
;

512 *(
__IO
 
uint32_t
*)
Address
 = 
Data
;

515 
status
 = 
	`FLASH_WaitForLastOperation
();

518 
FLASH
->
CR
 &= (~
FLASH_CR_PG
);

521 return 
status
;

522 
	}
}

533 
FLASH_Status
 
	$FLASH_ProgramHalfWord
(
uint32_t
 
Address
, 
uint16_t
 
Data
)

535 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

538 
	`assert_param
(
	`IS_FLASH_ADDRESS
(
Address
));

541 
status
 = 
	`FLASH_WaitForLastOperation
();

543 if(
status
 == 
FLASH_COMPLETE
)

546 
FLASH
->
CR
 &= 
CR_PSIZE_MASK
;

547 
FLASH
->
CR
 |= 
FLASH_PSIZE_HALF_WORD
;

548 
FLASH
->
CR
 |= 
FLASH_CR_PG
;

550 *(
__IO
 
uint16_t
*)
Address
 = 
Data
;

553 
status
 = 
	`FLASH_WaitForLastOperation
();

556 
FLASH
->
CR
 &= (~
FLASH_CR_PG
);

559 return 
status
;

560 
	}
}

571 
FLASH_Status
 
	$FLASH_ProgramByte
(
uint32_t
 
Address
, 
uint8_t
 
Data
)

573 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

576 
	`assert_param
(
	`IS_FLASH_ADDRESS
(
Address
));

579 
status
 = 
	`FLASH_WaitForLastOperation
();

581 if(
status
 == 
FLASH_COMPLETE
)

584 
FLASH
->
CR
 &= 
CR_PSIZE_MASK
;

585 
FLASH
->
CR
 |= 
FLASH_PSIZE_BYTE
;

586 
FLASH
->
CR
 |= 
FLASH_CR_PG
;

588 *(
__IO
 
uint8_t
*)
Address
 = 
Data
;

591 
status
 = 
	`FLASH_WaitForLastOperation
();

594 
FLASH
->
CR
 &= (~
FLASH_CR_PG
);

598 return 
status
;

599 
	}
}

656 void 
	$FLASH_OB_Unlock
(void)

658 if((
FLASH
->
OPTCR
 & 
FLASH_OPTCR_OPTLOCK
) != 
RESET
)

661 
FLASH
->
OPTKEYR
 = 
FLASH_OPT_KEY1
;

662 
FLASH
->
OPTKEYR
 = 
FLASH_OPT_KEY2
;

664 
	}
}

671 void 
	$FLASH_OB_Lock
(void)

674 
FLASH
->
OPTCR
 |= 
FLASH_OPTCR_OPTLOCK
;

675 
	}
}

687 void 
	$FLASH_OB_WRPConfig
(
uint32_t
 
OB_WRP
, 
FunctionalState
 
NewState
)

689 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

692 
	`assert_param
(
	`IS_OB_WRP
(
OB_WRP
));

693 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

695 
status
 = 
	`FLASH_WaitForLastOperation
();

697 if(
status
 == 
FLASH_COMPLETE
)

699 if(
NewState
 != 
DISABLE
)

701 *(
__IO
 
uint16_t
*)
OPTCR_BYTE2_ADDRESS
 &= (~
OB_WRP
);

705 *(
__IO
 
uint16_t
*)
OPTCR_BYTE2_ADDRESS
 |= (uint16_t)
OB_WRP
;

708 
	}
}

722 void 
	$FLASH_OB_RDPConfig
(
uint8_t
 
OB_RDP
)

724 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

727 
	`assert_param
(
	`IS_OB_RDP
(
OB_RDP
));

729 
status
 = 
	`FLASH_WaitForLastOperation
();

731 if(
status
 == 
FLASH_COMPLETE
)

733 *(
__IO
 
uint8_t
*)
OPTCR_BYTE1_ADDRESS
 = 
OB_RDP
;

736 
	}
}

754 void 
	$FLASH_OB_UserConfig
(
uint8_t
 
OB_IWDG
, uint8_t 
OB_STOP
, uint8_t 
OB_STDBY
)

756 
uint8_t
 
optiontmp
 = 0xFF;

757 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

760 
	`assert_param
(
	`IS_OB_IWDG_SOURCE
(
OB_IWDG
));

761 
	`assert_param
(
	`IS_OB_STOP_SOURCE
(
OB_STOP
));

762 
	`assert_param
(
	`IS_OB_STDBY_SOURCE
(
OB_STDBY
));

765 
status
 = 
	`FLASH_WaitForLastOperation
();

767 if(
status
 == 
FLASH_COMPLETE
)

770 
optiontmp
 = (
uint8_t
)((*(
__IO
 uint8_t *)
OPTCR_BYTE0_ADDRESS
) & (uint8_t)0x0F);

773 *(
__IO
 
uint8_t
 *)
OPTCR_BYTE0_ADDRESS
 = 
OB_IWDG
 | (uint8_t)(
OB_STDBY
 | (uint8_t)(
OB_STOP
 | ((uint8_t)
optiontmp
)));

775 
	}
}

787 void 
	$FLASH_OB_BORConfig
(
uint8_t
 
OB_BOR
)

790 
	`assert_param
(
	`IS_OB_BOR
(
OB_BOR
));

793 *(
__IO
 
uint8_t
 *)
OPTCR_BYTE0_ADDRESS
 &= (~
FLASH_OPTCR_BOR_LEV
);

794 *(
__IO
 
uint8_t
 *)
OPTCR_BYTE0_ADDRESS
 |= 
OB_BOR
;

796 
	}
}

804 
FLASH_Status
 
	$FLASH_OB_Launch
(void)

806 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

809 *(
__IO
 
uint8_t
 *)
OPTCR_BYTE0_ADDRESS
 |= 
FLASH_OPTCR_OPTSTRT
;

812 
status
 = 
	`FLASH_WaitForLastOperation
();

814 return 
status
;

815 
	}
}

823 
uint8_t
 
	$FLASH_OB_GetUser
(void)

826 return (
uint8_t
)(
FLASH
->
OPTCR
 >> 5);

827 
	}
}

834 
uint16_t
 
	$FLASH_OB_GetWRP
(void)

837 return (*(
__IO
 
uint16_t
 *)(
OPTCR_BYTE2_ADDRESS
));

838 
	}
}

847 
FlagStatus
 
	$FLASH_OB_GetRDP
(void)

849 
FlagStatus
 
readstatus
 = 
RESET
;

851 if ((*(
__IO
 
uint8_t
*)(
OPTCR_BYTE1_ADDRESS
) != (uint8_t)
OB_RDP_Level_0
))

853 
readstatus
 = 
SET
;

857 
readstatus
 = 
RESET
;

859 return 
readstatus
;

860 
	}
}

871 
uint8_t
 
	$FLASH_OB_GetBOR
(void)

874 return (
uint8_t
)(*(
__IO
 uint8_t *)(
OPTCR_BYTE0_ADDRESS
) & (uint8_t)0x0C);

875 
	}
}

901 void 
	$FLASH_ITConfig
(
uint32_t
 
FLASH_IT
, 
FunctionalState
 
NewState
)

904 
	`assert_param
(
	`IS_FLASH_IT
(
FLASH_IT
));

905 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

907 if(
NewState
 != 
DISABLE
)

910 
FLASH
->
CR
 |= 
FLASH_IT
;

915 
FLASH
->
CR
 &= ~(
uint32_t
)
FLASH_IT
;

917 
	}
}

932 
FlagStatus
 
	$FLASH_GetFlagStatus
(
uint32_t
 
FLASH_FLAG
)

934 
FlagStatus
 
bitstatus
 = 
RESET
;

936 
	`assert_param
(
	`IS_FLASH_GET_FLAG
(
FLASH_FLAG
));

938 if((
FLASH
->
SR
 & 
FLASH_FLAG
) != (
uint32_t
)
RESET
)

940 
bitstatus
 = 
SET
;

944 
bitstatus
 = 
RESET
;

947 return 
bitstatus
;

948 
	}
}

962 void 
	$FLASH_ClearFlag
(
uint32_t
 
FLASH_FLAG
)

965 
	`assert_param
(
	`IS_FLASH_CLEAR_FLAG
(
FLASH_FLAG
));

968 
FLASH
->
SR
 = 
FLASH_FLAG
;

969 
	}
}

977 
FLASH_Status
 
	$FLASH_GetStatus
(void)

979 
FLASH_Status
 
flashstatus
 = 
FLASH_COMPLETE
;

981 if((
FLASH
->
SR
 & 
FLASH_FLAG_BSY
) == FLASH_FLAG_BSY)

983 
flashstatus
 = 
FLASH_BUSY
;

987 if((
FLASH
->
SR
 & 
FLASH_FLAG_WRPERR
) != (
uint32_t
)0x00)

989 
flashstatus
 = 
FLASH_ERROR_WRP
;

993 if((
FLASH
->
SR
 & (
uint32_t
)0xEF) != (uint32_t)0x00)

995 
flashstatus
 = 
FLASH_ERROR_PROGRAM
;

999 if((
FLASH
->
SR
 & 
FLASH_FLAG_OPERR
) != (
uint32_t
)0x00)

1001 
flashstatus
 = 
FLASH_ERROR_OPERATION
;

1005 
flashstatus
 = 
FLASH_COMPLETE
;

1011 return 
flashstatus
;

1012 
	}
}

1020 
FLASH_Status
 
	$FLASH_WaitForLastOperation
(void)

1022 
__IO
 
FLASH_Status
 
status
 = 
FLASH_COMPLETE
;

1025 
status
 = 
	`FLASH_GetStatus
();

1030 while(
status
 == 
FLASH_BUSY
)

1032 
status
 = 
	`FLASH_GetStatus
();

1035 return 
status
;

1036 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fsmc.c

30 #include 
	~"stm32f4xx_fsmc.h
"

31 #include 
	~"stm32f4xx_rcc.h
"

47 #define 
	#BCR_MBKEN_SET
 ((
uint32_t
)0x00000001)

	)

48 #define 
	#BCR_MBKEN_RESET
 ((
uint32_t
)0x000FFFFE)

	)

49 #define 
	#BCR_FACCEN_SET
 ((
uint32_t
)0x00000040)

	)

52 #define 
	#PCR_PBKEN_SET
 ((
uint32_t
)0x00000004)

	)

53 #define 
	#PCR_PBKEN_RESET
 ((
uint32_t
)0x000FFFFB)

	)

54 #define 
	#PCR_ECCEN_SET
 ((
uint32_t
)0x00000040)

	)

55 #define 
	#PCR_ECCEN_RESET
 ((
uint32_t
)0x000FFFBF)

	)

56 #define 
	#PCR_MEMORYTYPE_NAND
 ((
uint32_t
)0x00000008)

	)

116 void 
	$FSMC_NORSRAMDeInit
(
uint32_t
 
FSMC_Bank
)

119 
	`assert_param
(
	`IS_FSMC_NORSRAM_BANK
(
FSMC_Bank
));

122 if(
FSMC_Bank
 == 
FSMC_Bank1_NORSRAM1
)

124 
FSMC_Bank1
->
BTCR
[
FSMC_Bank
] = 0x000030DB;

129 
FSMC_Bank1
->
BTCR
[
FSMC_Bank
] = 0x000030D2;

131 
FSMC_Bank1
->
BTCR
[
FSMC_Bank
 + 1] = 0x0FFFFFFF;

132 
FSMC_Bank1E
->
BWTR
[
FSMC_Bank
] = 0x0FFFFFFF;

133 
	}
}

143 void 
	$FSMC_NORSRAMInit
(
FSMC_NORSRAMInitTypeDef
* 
FSMC_NORSRAMInitStruct
)

146 
	`assert_param
(
	`IS_FSMC_NORSRAM_BANK
(
FSMC_NORSRAMInitStruct
->
FSMC_Bank
));

147 
	`assert_param
(
	`IS_FSMC_MUX
(
FSMC_NORSRAMInitStruct
->
FSMC_DataAddressMux
));

148 
	`assert_param
(
	`IS_FSMC_MEMORY
(
FSMC_NORSRAMInitStruct
->
FSMC_MemoryType
));

149 
	`assert_param
(
	`IS_FSMC_MEMORY_WIDTH
(
FSMC_NORSRAMInitStruct
->
FSMC_MemoryDataWidth
));

150 
	`assert_param
(
	`IS_FSMC_BURSTMODE
(
FSMC_NORSRAMInitStruct
->
FSMC_BurstAccessMode
));

151 
	`assert_param
(
	`IS_FSMC_ASYNWAIT
(
FSMC_NORSRAMInitStruct
->
FSMC_AsynchronousWait
));

152 
	`assert_param
(
	`IS_FSMC_WAIT_POLARITY
(
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignalPolarity
));

153 
	`assert_param
(
	`IS_FSMC_WRAP_MODE
(
FSMC_NORSRAMInitStruct
->
FSMC_WrapMode
));

154 
	`assert_param
(
	`IS_FSMC_WAIT_SIGNAL_ACTIVE
(
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignalActive
));

155 
	`assert_param
(
	`IS_FSMC_WRITE_OPERATION
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteOperation
));

156 
	`assert_param
(
	`IS_FSMC_WAITE_SIGNAL
(
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignal
));

157 
	`assert_param
(
	`IS_FSMC_EXTENDED_MODE
(
FSMC_NORSRAMInitStruct
->
FSMC_ExtendedMode
));

158 
	`assert_param
(
	`IS_FSMC_WRITE_BURST
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteBurst
));

159 
	`assert_param
(
	`IS_FSMC_ADDRESS_SETUP_TIME
(
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AddressSetupTime
));

160 
	`assert_param
(
	`IS_FSMC_ADDRESS_HOLD_TIME
(
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AddressHoldTime
));

161 
	`assert_param
(
	`IS_FSMC_DATASETUP_TIME
(
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_DataSetupTime
));

162 
	`assert_param
(
	`IS_FSMC_TURNAROUND_TIME
(
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_BusTurnAroundDuration
));

163 
	`assert_param
(
	`IS_FSMC_CLK_DIV
(
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_CLKDivision
));

164 
	`assert_param
(
	`IS_FSMC_DATA_LATENCY
(
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_DataLatency
));

165 
	`assert_param
(
	`IS_FSMC_ACCESS_MODE
(
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AccessMode
));

168 
FSMC_Bank1
->
BTCR
[
FSMC_NORSRAMInitStruct
->
FSMC_Bank
] =

169 (
uint32_t
)
FSMC_NORSRAMInitStruct
->
FSMC_DataAddressMux
 |

170 
FSMC_NORSRAMInitStruct
->
FSMC_MemoryType
 |

171 
FSMC_NORSRAMInitStruct
->
FSMC_MemoryDataWidth
 |

172 
FSMC_NORSRAMInitStruct
->
FSMC_BurstAccessMode
 |

173 
FSMC_NORSRAMInitStruct
->
FSMC_AsynchronousWait
 |

174 
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignalPolarity
 |

175 
FSMC_NORSRAMInitStruct
->
FSMC_WrapMode
 |

176 
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignalActive
 |

177 
FSMC_NORSRAMInitStruct
->
FSMC_WriteOperation
 |

178 
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignal
 |

179 
FSMC_NORSRAMInitStruct
->
FSMC_ExtendedMode
 |

180 
FSMC_NORSRAMInitStruct
->
FSMC_WriteBurst
;

181 if(
FSMC_NORSRAMInitStruct
->
FSMC_MemoryType
 == 
FSMC_MemoryType_NOR
)

183 
FSMC_Bank1
->
BTCR
[
FSMC_NORSRAMInitStruct
->
FSMC_Bank
] |= (
uint32_t
)
BCR_FACCEN_SET
;

186 
FSMC_Bank1
->
BTCR
[
FSMC_NORSRAMInitStruct
->
FSMC_Bank
+1] =

187 (
uint32_t
)
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AddressSetupTime
 |

188 (
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AddressHoldTime
 << 4) |

189 (
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_DataSetupTime
 << 8) |

190 (
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_BusTurnAroundDuration
 << 16) |

191 (
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_CLKDivision
 << 20) |

192 (
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_DataLatency
 << 24) |

193 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AccessMode
;

197 if(
FSMC_NORSRAMInitStruct
->
FSMC_ExtendedMode
 == 
FSMC_ExtendedMode_Enable
)

199 
	`assert_param
(
	`IS_FSMC_ADDRESS_SETUP_TIME
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AddressSetupTime
));

200 
	`assert_param
(
	`IS_FSMC_ADDRESS_HOLD_TIME
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AddressHoldTime
));

201 
	`assert_param
(
	`IS_FSMC_DATASETUP_TIME
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_DataSetupTime
));

202 
	`assert_param
(
	`IS_FSMC_CLK_DIV
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_CLKDivision
));

203 
	`assert_param
(
	`IS_FSMC_DATA_LATENCY
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_DataLatency
));

204 
	`assert_param
(
	`IS_FSMC_ACCESS_MODE
(
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AccessMode
));

205 
FSMC_Bank1E
->
BWTR
[
FSMC_NORSRAMInitStruct
->
FSMC_Bank
] =

206 (
uint32_t
)
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AddressSetupTime
 |

207 (
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AddressHoldTime
 << 4 )|

208 (
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_DataSetupTime
 << 8) |

209 (
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_CLKDivision
 << 20) |

210 (
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_DataLatency
 << 24) |

211 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AccessMode
;

215 
FSMC_Bank1E
->
BWTR
[
FSMC_NORSRAMInitStruct
->
FSMC_Bank
] = 0x0FFFFFFF;

217 
	}
}

225 void 
	$FSMC_NORSRAMStructInit
(
FSMC_NORSRAMInitTypeDef
* 
FSMC_NORSRAMInitStruct
)

228 
FSMC_NORSRAMInitStruct
->
FSMC_Bank
 = 
FSMC_Bank1_NORSRAM1
;

229 
FSMC_NORSRAMInitStruct
->
FSMC_DataAddressMux
 = 
FSMC_DataAddressMux_Enable
;

230 
FSMC_NORSRAMInitStruct
->
FSMC_MemoryType
 = 
FSMC_MemoryType_SRAM
;

231 
FSMC_NORSRAMInitStruct
->
FSMC_MemoryDataWidth
 = 
FSMC_MemoryDataWidth_8b
;

232 
FSMC_NORSRAMInitStruct
->
FSMC_BurstAccessMode
 = 
FSMC_BurstAccessMode_Disable
;

233 
FSMC_NORSRAMInitStruct
->
FSMC_AsynchronousWait
 = 
FSMC_AsynchronousWait_Disable
;

234 
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignalPolarity
 = 
FSMC_WaitSignalPolarity_Low
;

235 
FSMC_NORSRAMInitStruct
->
FSMC_WrapMode
 = 
FSMC_WrapMode_Disable
;

236 
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignalActive
 = 
FSMC_WaitSignalActive_BeforeWaitState
;

237 
FSMC_NORSRAMInitStruct
->
FSMC_WriteOperation
 = 
FSMC_WriteOperation_Enable
;

238 
FSMC_NORSRAMInitStruct
->
FSMC_WaitSignal
 = 
FSMC_WaitSignal_Enable
;

239 
FSMC_NORSRAMInitStruct
->
FSMC_ExtendedMode
 = 
FSMC_ExtendedMode_Disable
;

240 
FSMC_NORSRAMInitStruct
->
FSMC_WriteBurst
 = 
FSMC_WriteBurst_Disable
;

241 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AddressSetupTime
 = 0xF;

242 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AddressHoldTime
 = 0xF;

243 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_DataSetupTime
 = 0xFF;

244 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_BusTurnAroundDuration
 = 0xF;

245 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_CLKDivision
 = 0xF;

246 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_DataLatency
 = 0xF;

247 
FSMC_NORSRAMInitStruct
->
FSMC_ReadWriteTimingStruct
->
FSMC_AccessMode
 = 
FSMC_AccessMode_A
;

248 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AddressSetupTime
 = 0xF;

249 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AddressHoldTime
 = 0xF;

250 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_DataSetupTime
 = 0xFF;

251 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_BusTurnAroundDuration
 = 0xF;

252 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_CLKDivision
 = 0xF;

253 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_DataLatency
 = 0xF;

254 
FSMC_NORSRAMInitStruct
->
FSMC_WriteTimingStruct
->
FSMC_AccessMode
 = 
FSMC_AccessMode_A
;

255 
	}
}

268 void 
	$FSMC_NORSRAMCmd
(
uint32_t
 
FSMC_Bank
, 
FunctionalState
 
NewState
)

270 
	`assert_param
(
	`IS_FSMC_NORSRAM_BANK
(
FSMC_Bank
));

271 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

273 if (
NewState
 != 
DISABLE
)

276 
FSMC_Bank1
->
BTCR
[
FSMC_Bank
] |= 
BCR_MBKEN_SET
;

281 
FSMC_Bank1
->
BTCR
[
FSMC_Bank
] &= 
BCR_MBKEN_RESET
;

283 
	}
}

339 void 
	$FSMC_NANDDeInit
(
uint32_t
 
FSMC_Bank
)

342 
	`assert_param
(
	`IS_FSMC_NAND_BANK
(
FSMC_Bank
));

344 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

347 
FSMC_Bank2
->
PCR2
 = 0x00000018;

348 
FSMC_Bank2
->
SR2
 = 0x00000040;

349 
FSMC_Bank2
->
PMEM2
 = 0xFCFCFCFC;

350 
FSMC_Bank2
->
PATT2
 = 0xFCFCFCFC;

356 
FSMC_Bank3
->
PCR3
 = 0x00000018;

357 
FSMC_Bank3
->
SR3
 = 0x00000040;

358 
FSMC_Bank3
->
PMEM3
 = 0xFCFCFCFC;

359 
FSMC_Bank3
->
PATT3
 = 0xFCFCFCFC;

361 
	}
}

370 void 
	$FSMC_NANDInit
(
FSMC_NANDInitTypeDef
* 
FSMC_NANDInitStruct
)

372 
uint32_t
 
tmppcr
 = 0x00000000, 
tmppmem
 = 0x00000000, 
tmppatt
 = 0x00000000;

375 
	`assert_param
( 
	`IS_FSMC_NAND_BANK
(
FSMC_NANDInitStruct
->
FSMC_Bank
));

376 
	`assert_param
( 
	`IS_FSMC_WAIT_FEATURE
(
FSMC_NANDInitStruct
->
FSMC_Waitfeature
));

377 
	`assert_param
( 
	`IS_FSMC_MEMORY_WIDTH
(
FSMC_NANDInitStruct
->
FSMC_MemoryDataWidth
));

378 
	`assert_param
( 
	`IS_FSMC_ECC_STATE
(
FSMC_NANDInitStruct
->
FSMC_ECC
));

379 
	`assert_param
( 
	`IS_FSMC_ECCPAGE_SIZE
(
FSMC_NANDInitStruct
->
FSMC_ECCPageSize
));

380 
	`assert_param
( 
	`IS_FSMC_TCLR_TIME
(
FSMC_NANDInitStruct
->
FSMC_TCLRSetupTime
));

381 
	`assert_param
( 
	`IS_FSMC_TAR_TIME
(
FSMC_NANDInitStruct
->
FSMC_TARSetupTime
));

382 
	`assert_param
(
	`IS_FSMC_SETUP_TIME
(
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_SetupTime
));

383 
	`assert_param
(
	`IS_FSMC_WAIT_TIME
(
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_WaitSetupTime
));

384 
	`assert_param
(
	`IS_FSMC_HOLD_TIME
(
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HoldSetupTime
));

385 
	`assert_param
(
	`IS_FSMC_HIZ_TIME
(
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HiZSetupTime
));

386 
	`assert_param
(
	`IS_FSMC_SETUP_TIME
(
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_SetupTime
));

387 
	`assert_param
(
	`IS_FSMC_WAIT_TIME
(
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_WaitSetupTime
));

388 
	`assert_param
(
	`IS_FSMC_HOLD_TIME
(
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HoldSetupTime
));

389 
	`assert_param
(
	`IS_FSMC_HIZ_TIME
(
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HiZSetupTime
));

392 
tmppcr
 = (
uint32_t
)
FSMC_NANDInitStruct
->
FSMC_Waitfeature
 |

393 
PCR_MEMORYTYPE_NAND
 |

394 
FSMC_NANDInitStruct
->
FSMC_MemoryDataWidth
 |

395 
FSMC_NANDInitStruct
->
FSMC_ECC
 |

396 
FSMC_NANDInitStruct
->
FSMC_ECCPageSize
 |

397 (
FSMC_NANDInitStruct
->
FSMC_TCLRSetupTime
 << 9 )|

398 (
FSMC_NANDInitStruct
->
FSMC_TARSetupTime
 << 13);

401 
tmppmem
 = (
uint32_t
)
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_SetupTime
 |

402 (
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_WaitSetupTime
 << 8) |

403 (
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HoldSetupTime
 << 16)|

404 (
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HiZSetupTime
 << 24);

407 
tmppatt
 = (
uint32_t
)
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_SetupTime
 |

408 (
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_WaitSetupTime
 << 8) |

409 (
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HoldSetupTime
 << 16)|

410 (
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HiZSetupTime
 << 24);

412 if(
FSMC_NANDInitStruct
->
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

415 
FSMC_Bank2
->
PCR2
 = 
tmppcr
;

416 
FSMC_Bank2
->
PMEM2
 = 
tmppmem
;

417 
FSMC_Bank2
->
PATT2
 = 
tmppatt
;

422 
FSMC_Bank3
->
PCR3
 = 
tmppcr
;

423 
FSMC_Bank3
->
PMEM3
 = 
tmppmem
;

424 
FSMC_Bank3
->
PATT3
 = 
tmppatt
;

426 
	}
}

435 void 
	$FSMC_NANDStructInit
(
FSMC_NANDInitTypeDef
* 
FSMC_NANDInitStruct
)

438 
FSMC_NANDInitStruct
->
FSMC_Bank
 = 
FSMC_Bank2_NAND
;

439 
FSMC_NANDInitStruct
->
FSMC_Waitfeature
 = 
FSMC_Waitfeature_Disable
;

440 
FSMC_NANDInitStruct
->
FSMC_MemoryDataWidth
 = 
FSMC_MemoryDataWidth_8b
;

441 
FSMC_NANDInitStruct
->
FSMC_ECC
 = 
FSMC_ECC_Disable
;

442 
FSMC_NANDInitStruct
->
FSMC_ECCPageSize
 = 
FSMC_ECCPageSize_256Bytes
;

443 
FSMC_NANDInitStruct
->
FSMC_TCLRSetupTime
 = 0x0;

444 
FSMC_NANDInitStruct
->
FSMC_TARSetupTime
 = 0x0;

445 
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_SetupTime
 = 0xFC;

446 
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_WaitSetupTime
 = 0xFC;

447 
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HoldSetupTime
 = 0xFC;

448 
FSMC_NANDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HiZSetupTime
 = 0xFC;

449 
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_SetupTime
 = 0xFC;

450 
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_WaitSetupTime
 = 0xFC;

451 
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HoldSetupTime
 = 0xFC;

452 
FSMC_NANDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HiZSetupTime
 = 0xFC;

453 
	}
}

464 void 
	$FSMC_NANDCmd
(
uint32_t
 
FSMC_Bank
, 
FunctionalState
 
NewState
)

466 
	`assert_param
(
	`IS_FSMC_NAND_BANK
(
FSMC_Bank
));

467 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

469 if (
NewState
 != 
DISABLE
)

472 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

474 
FSMC_Bank2
->
PCR2
 |= 
PCR_PBKEN_SET
;

478 
FSMC_Bank3
->
PCR3
 |= 
PCR_PBKEN_SET
;

484 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

486 
FSMC_Bank2
->
PCR2
 &= 
PCR_PBKEN_RESET
;

490 
FSMC_Bank3
->
PCR3
 &= 
PCR_PBKEN_RESET
;

493 
	}
}

504 void 
	$FSMC_NANDECCCmd
(
uint32_t
 
FSMC_Bank
, 
FunctionalState
 
NewState
)

506 
	`assert_param
(
	`IS_FSMC_NAND_BANK
(
FSMC_Bank
));

507 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

509 if (
NewState
 != 
DISABLE
)

512 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

514 
FSMC_Bank2
->
PCR2
 |= 
PCR_ECCEN_SET
;

518 
FSMC_Bank3
->
PCR3
 |= 
PCR_ECCEN_SET
;

524 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

526 
FSMC_Bank2
->
PCR2
 &= 
PCR_ECCEN_RESET
;

530 
FSMC_Bank3
->
PCR3
 &= 
PCR_ECCEN_RESET
;

533 
	}
}

543 
uint32_t
 
	$FSMC_GetECC
(
uint32_t
 
FSMC_Bank
)

545 
uint32_t
 
eccval
 = 0x00000000;

547 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

550 
eccval
 = 
FSMC_Bank2
->
ECCR2
;

555 
eccval
 = 
FSMC_Bank3
->
ECCR3
;

558 return(
eccval
);

559 
	}
}

607 void 
	$FSMC_PCCARDDeInit
(void)

610 
FSMC_Bank4
->
PCR4
 = 0x00000018;

611 
FSMC_Bank4
->
SR4
 = 0x00000000;

612 
FSMC_Bank4
->
PMEM4
 = 0xFCFCFCFC;

613 
FSMC_Bank4
->
PATT4
 = 0xFCFCFCFC;

614 
FSMC_Bank4
->
PIO4
 = 0xFCFCFCFC;

615 
	}
}

624 void 
	$FSMC_PCCARDInit
(
FSMC_PCCARDInitTypeDef
* 
FSMC_PCCARDInitStruct
)

627 
	`assert_param
(
	`IS_FSMC_WAIT_FEATURE
(
FSMC_PCCARDInitStruct
->
FSMC_Waitfeature
));

628 
	`assert_param
(
	`IS_FSMC_TCLR_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_TCLRSetupTime
));

629 
	`assert_param
(
	`IS_FSMC_TAR_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_TARSetupTime
));

631 
	`assert_param
(
	`IS_FSMC_SETUP_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_SetupTime
));

632 
	`assert_param
(
	`IS_FSMC_WAIT_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_WaitSetupTime
));

633 
	`assert_param
(
	`IS_FSMC_HOLD_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HoldSetupTime
));

634 
	`assert_param
(
	`IS_FSMC_HIZ_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HiZSetupTime
));

636 
	`assert_param
(
	`IS_FSMC_SETUP_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_SetupTime
));

637 
	`assert_param
(
	`IS_FSMC_WAIT_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_WaitSetupTime
));

638 
	`assert_param
(
	`IS_FSMC_HOLD_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HoldSetupTime
));

639 
	`assert_param
(
	`IS_FSMC_HIZ_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HiZSetupTime
));

640 
	`assert_param
(
	`IS_FSMC_SETUP_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_SetupTime
));

641 
	`assert_param
(
	`IS_FSMC_WAIT_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_WaitSetupTime
));

642 
	`assert_param
(
	`IS_FSMC_HOLD_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_HoldSetupTime
));

643 
	`assert_param
(
	`IS_FSMC_HIZ_TIME
(
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_HiZSetupTime
));

646 
FSMC_Bank4
->
PCR4
 = (
uint32_t
)
FSMC_PCCARDInitStruct
->
FSMC_Waitfeature
 |

647 
FSMC_MemoryDataWidth_16b
 |

648 (
FSMC_PCCARDInitStruct
->
FSMC_TCLRSetupTime
 << 9) |

649 (
FSMC_PCCARDInitStruct
->
FSMC_TARSetupTime
 << 13);

652 
FSMC_Bank4
->
PMEM4
 = (
uint32_t
)
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_SetupTime
 |

653 (
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_WaitSetupTime
 << 8) |

654 (
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HoldSetupTime
 << 16)|

655 (
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HiZSetupTime
 << 24);

658 
FSMC_Bank4
->
PATT4
 = (
uint32_t
)
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_SetupTime
 |

659 (
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_WaitSetupTime
 << 8) |

660 (
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HoldSetupTime
 << 16)|

661 (
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HiZSetupTime
 << 24);

664 
FSMC_Bank4
->
PIO4
 = (
uint32_t
)
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_SetupTime
 |

665 (
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_WaitSetupTime
 << 8) |

666 (
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_HoldSetupTime
 << 16)|

667 (
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_HiZSetupTime
 << 24);

668 
	}
}

676 void 
	$FSMC_PCCARDStructInit
(
FSMC_PCCARDInitTypeDef
* 
FSMC_PCCARDInitStruct
)

679 
FSMC_PCCARDInitStruct
->
FSMC_Waitfeature
 = 
FSMC_Waitfeature_Disable
;

680 
FSMC_PCCARDInitStruct
->
FSMC_TCLRSetupTime
 = 0x0;

681 
FSMC_PCCARDInitStruct
->
FSMC_TARSetupTime
 = 0x0;

682 
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_SetupTime
 = 0xFC;

683 
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_WaitSetupTime
 = 0xFC;

684 
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HoldSetupTime
 = 0xFC;

685 
FSMC_PCCARDInitStruct
->
FSMC_CommonSpaceTimingStruct
->
FSMC_HiZSetupTime
 = 0xFC;

686 
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_SetupTime
 = 0xFC;

687 
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_WaitSetupTime
 = 0xFC;

688 
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HoldSetupTime
 = 0xFC;

689 
FSMC_PCCARDInitStruct
->
FSMC_AttributeSpaceTimingStruct
->
FSMC_HiZSetupTime
 = 0xFC;

690 
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_SetupTime
 = 0xFC;

691 
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_WaitSetupTime
 = 0xFC;

692 
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_HoldSetupTime
 = 0xFC;

693 
FSMC_PCCARDInitStruct
->
FSMC_IOSpaceTimingStruct
->
FSMC_HiZSetupTime
 = 0xFC;

694 
	}
}

702 void 
	$FSMC_PCCARDCmd
(
FunctionalState
 
NewState
)

704 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

706 if (
NewState
 != 
DISABLE
)

709 
FSMC_Bank4
->
PCR4
 |= 
PCR_PBKEN_SET
;

714 
FSMC_Bank4
->
PCR4
 &= 
PCR_PBKEN_RESET
;

716 
	}
}

749 void 
	$FSMC_ITConfig
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_IT
, 
FunctionalState
 
NewState
)

751 
	`assert_param
(
	`IS_FSMC_IT_BANK
(
FSMC_Bank
));

752 
	`assert_param
(
	`IS_FSMC_IT
(
FSMC_IT
));

753 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

755 if (
NewState
 != 
DISABLE
)

758 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

760 
FSMC_Bank2
->
SR2
 |= 
FSMC_IT
;

763 else if (
FSMC_Bank
 == 
FSMC_Bank3_NAND
)

765 
FSMC_Bank3
->
SR3
 |= 
FSMC_IT
;

770 
FSMC_Bank4
->
SR4
 |= 
FSMC_IT
;

776 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

779 
FSMC_Bank2
->
SR2
 &= (
uint32_t
)~
FSMC_IT
;

782 else if (
FSMC_Bank
 == 
FSMC_Bank3_NAND
)

784 
FSMC_Bank3
->
SR3
 &= (
uint32_t
)~
FSMC_IT
;

789 
FSMC_Bank4
->
SR4
 &= (
uint32_t
)~
FSMC_IT
;

792 
	}
}

809 
FlagStatus
 
	$FSMC_GetFlagStatus
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_FLAG
)

811 
FlagStatus
 
bitstatus
 = 
RESET
;

812 
uint32_t
 
tmpsr
 = 0x00000000;

815 
	`assert_param
(
	`IS_FSMC_GETFLAG_BANK
(
FSMC_Bank
));

816 
	`assert_param
(
	`IS_FSMC_GET_FLAG
(
FSMC_FLAG
));

818 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

820 
tmpsr
 = 
FSMC_Bank2
->
SR2
;

822 else if(
FSMC_Bank
 == 
FSMC_Bank3_NAND
)

824 
tmpsr
 = 
FSMC_Bank3
->
SR3
;

829 
tmpsr
 = 
FSMC_Bank4
->
SR4
;

833 if ((
tmpsr
 & 
FSMC_FLAG
) != (
uint16_t
)
RESET
 )

835 
bitstatus
 = 
SET
;

839 
bitstatus
 = 
RESET
;

842 return 
bitstatus
;

843 
	}
}

859 void 
	$FSMC_ClearFlag
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_FLAG
)

862 
	`assert_param
(
	`IS_FSMC_GETFLAG_BANK
(
FSMC_Bank
));

863 
	`assert_param
(
	`IS_FSMC_CLEAR_FLAG
(
FSMC_FLAG
)) ;

865 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

867 
FSMC_Bank2
->
SR2
 &= ~
FSMC_FLAG
;

869 else if(
FSMC_Bank
 == 
FSMC_Bank3_NAND
)

871 
FSMC_Bank3
->
SR3
 &= ~
FSMC_FLAG
;

876 
FSMC_Bank4
->
SR4
 &= ~
FSMC_FLAG
;

878 
	}
}

894 
ITStatus
 
	$FSMC_GetITStatus
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_IT
)

896 
ITStatus
 
bitstatus
 = 
RESET
;

897 
uint32_t
 
tmpsr
 = 0x0, 
itstatus
 = 0x0, 
itenable
 = 0x0;

900 
	`assert_param
(
	`IS_FSMC_IT_BANK
(
FSMC_Bank
));

901 
	`assert_param
(
	`IS_FSMC_GET_IT
(
FSMC_IT
));

903 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

905 
tmpsr
 = 
FSMC_Bank2
->
SR2
;

907 else if(
FSMC_Bank
 == 
FSMC_Bank3_NAND
)

909 
tmpsr
 = 
FSMC_Bank3
->
SR3
;

914 
tmpsr
 = 
FSMC_Bank4
->
SR4
;

917 
itstatus
 = 
tmpsr
 & 
FSMC_IT
;

919 
itenable
 = 
tmpsr
 & (
FSMC_IT
 >> 3);

920 if ((
itstatus
 != (
uint32_t
)
RESET
) && (
itenable
 != (uint32_t)RESET))

922 
bitstatus
 = 
SET
;

926 
bitstatus
 = 
RESET
;

928 return 
bitstatus
;

929 
	}
}

945 void 
	$FSMC_ClearITPendingBit
(
uint32_t
 
FSMC_Bank
, uint32_t 
FSMC_IT
)

948 
	`assert_param
(
	`IS_FSMC_IT_BANK
(
FSMC_Bank
));

949 
	`assert_param
(
	`IS_FSMC_IT
(
FSMC_IT
));

951 if(
FSMC_Bank
 == 
FSMC_Bank2_NAND
)

953 
FSMC_Bank2
->
SR2
 &= ~(
FSMC_IT
 >> 3);

955 else if(
FSMC_Bank
 == 
FSMC_Bank3_NAND
)

957 
FSMC_Bank3
->
SR3
 &= ~(
FSMC_IT
 >> 3);

962 
FSMC_Bank4
->
SR4
 &= ~(
FSMC_IT
 >> 3);

964 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c

79 #include 
	~"stm32f4xx_gpio.h
"

80 #include 
	~"stm32f4xx_rcc.h
"

120 void 
	$GPIO_DeInit
(
GPIO_TypeDef
* 
GPIOx
)

123 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

125 if (
GPIOx
 == 
GPIOA
)

127 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOA
, 
ENABLE
);

128 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOA
, 
DISABLE
);

130 else if (
GPIOx
 == 
GPIOB
)

132 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOB
, 
ENABLE
);

133 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOB
, 
DISABLE
);

135 else if (
GPIOx
 == 
GPIOC
)

137 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOC
, 
ENABLE
);

138 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOC
, 
DISABLE
);

140 else if (
GPIOx
 == 
GPIOD
)

142 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOD
, 
ENABLE
);

143 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOD
, 
DISABLE
);

145 else if (
GPIOx
 == 
GPIOE
)

147 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOE
, 
ENABLE
);

148 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOE
, 
DISABLE
);

150 else if (
GPIOx
 == 
GPIOF
)

152 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOF
, 
ENABLE
);

153 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOF
, 
DISABLE
);

155 else if (
GPIOx
 == 
GPIOG
)

157 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOG
, 
ENABLE
);

158 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOG
, 
DISABLE
);

160 else if (
GPIOx
 == 
GPIOH
)

162 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOH
, 
ENABLE
);

163 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOH
, 
DISABLE
);

167 if (
GPIOx
 == 
GPIOI
)

169 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOI
, 
ENABLE
);

170 
	`RCC_AHB1PeriphResetCmd
(
RCC_AHB1Periph_GPIOI
, 
DISABLE
);

173 
	}
}

182 void 
	$GPIO_Init
(
GPIO_TypeDef
* 
GPIOx
, 
GPIO_InitTypeDef
* 
GPIO_InitStruct
)

184 
uint32_t
 
pinpos
 = 0x00, 
pos
 = 0x00 , 
currentpin
 = 0x00;

187 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

188 
	`assert_param
(
	`IS_GPIO_PIN
(
GPIO_InitStruct
->
GPIO_Pin
));

189 
	`assert_param
(
	`IS_GPIO_MODE
(
GPIO_InitStruct
->
GPIO_Mode
));

190 
	`assert_param
(
	`IS_GPIO_PUPD
(
GPIO_InitStruct
->
GPIO_PuPd
));

194 for (
pinpos
 = 0x00; pinpos < 0x10; pinpos++)

196 
pos
 = ((
uint32_t
)0x01) << 
pinpos
;

198 
currentpin
 = (
GPIO_InitStruct
->
GPIO_Pin
) & 
pos
;

200 if (
currentpin
 == 
pos
)

202 
GPIOx
->
MODER
 &= ~(
GPIO_MODER_MODER0
 << (
pinpos
 * 2));

203 
GPIOx
->
MODER
 |= (((
uint32_t
)
GPIO_InitStruct
->
GPIO_Mode
) << (
pinpos
 * 2));

205 if ((
GPIO_InitStruct
->
GPIO_Mode
 == 
GPIO_Mode_OUT
) || (GPIO_InitStruct->GPIO_Mode == 
GPIO_Mode_AF
))

208 
	`assert_param
(
	`IS_GPIO_SPEED
(
GPIO_InitStruct
->
GPIO_Speed
));

211 
GPIOx
->
OSPEEDR
 &= ~(
GPIO_OSPEEDER_OSPEEDR0
 << (
pinpos
 * 2));

212 
GPIOx
->
OSPEEDR
 |= ((
uint32_t
)(
GPIO_InitStruct
->
GPIO_Speed
) << (
pinpos
 * 2));

215 
	`assert_param
(
	`IS_GPIO_OTYPE
(
GPIO_InitStruct
->
GPIO_OType
));

218 
GPIOx
->
OTYPER
 &= ~((
GPIO_OTYPER_OT_0
) << ((
uint16_t
)
pinpos
)) ;

219 
GPIOx
->
OTYPER
 |= (
uint16_t
)(((uint16_t)
GPIO_InitStruct
->
GPIO_OType
) << ((uint16_t)
pinpos
));

223 
GPIOx
->
PUPDR
 &= ~(
GPIO_PUPDR_PUPDR0
 << ((
uint16_t
)
pinpos
 * 2));

224 
GPIOx
->
PUPDR
 |= (((
uint32_t
)
GPIO_InitStruct
->
GPIO_PuPd
) << (
pinpos
 * 2));

227 
	}
}

234 void 
	$GPIO_StructInit
(
GPIO_InitTypeDef
* 
GPIO_InitStruct
)

237 
GPIO_InitStruct
->
GPIO_Pin
 = 
GPIO_Pin_All
;

238 
GPIO_InitStruct
->
GPIO_Mode
 = 
GPIO_Mode_IN
;

239 
GPIO_InitStruct
->
GPIO_Speed
 = 
GPIO_Speed_2MHz
;

240 
GPIO_InitStruct
->
GPIO_OType
 = 
GPIO_OType_PP
;

241 
GPIO_InitStruct
->
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

242 
	}
}

255 void 
	$GPIO_PinLockConfig
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
)

257 
__IO
 
uint32_t
 
tmp
 = 0x00010000;

260 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

261 
	`assert_param
(
	`IS_GPIO_PIN
(
GPIO_Pin
));

263 
tmp
 |= 
GPIO_Pin
;

265 
GPIOx
->
LCKR
 = 
tmp
;

267 
GPIOx
->
LCKR
 = 
GPIO_Pin
;

269 
GPIOx
->
LCKR
 = 
tmp
;

271 
tmp
 = 
GPIOx
->
LCKR
;

273 
tmp
 = 
GPIOx
->
LCKR
;

274 
	}
}

299 
uint8_t
 
	$GPIO_ReadInputDataBit
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
)

301 
uint8_t
 
bitstatus
 = 0x00;

304 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

305 
	`assert_param
(
	`IS_GET_GPIO_PIN
(
GPIO_Pin
));

307 if ((
GPIOx
->
IDR
 & 
GPIO_Pin
) != (
uint32_t
)
Bit_RESET
)

309 
bitstatus
 = (
uint8_t
)
Bit_SET
;

313 
bitstatus
 = (
uint8_t
)
Bit_RESET
;

315 return 
bitstatus
;

316 
	}
}

323 
uint16_t
 
	$GPIO_ReadInputData
(
GPIO_TypeDef
* 
GPIOx
)

326 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

328 return ((
uint16_t
)
GPIOx
->
IDR
);

329 
	}
}

338 
uint8_t
 
	$GPIO_ReadOutputDataBit
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
)

340 
uint8_t
 
bitstatus
 = 0x00;

343 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

344 
	`assert_param
(
	`IS_GET_GPIO_PIN
(
GPIO_Pin
));

346 if ((
GPIOx
->
ODR
 & 
GPIO_Pin
) != (
uint32_t
)
Bit_RESET
)

348 
bitstatus
 = (
uint8_t
)
Bit_SET
;

352 
bitstatus
 = (
uint8_t
)
Bit_RESET
;

354 return 
bitstatus
;

355 
	}
}

362 
uint16_t
 
	$GPIO_ReadOutputData
(
GPIO_TypeDef
* 
GPIOx
)

365 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

367 return ((
uint16_t
)
GPIOx
->
ODR
);

368 
	}
}

380 void 
	$GPIO_SetBits
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
)

383 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

384 
	`assert_param
(
	`IS_GPIO_PIN
(
GPIO_Pin
));

386 
GPIOx
->
BSRRL
 = 
GPIO_Pin
;

387 
	}
}

399 void 
	$GPIO_ResetBits
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
)

402 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

403 
	`assert_param
(
	`IS_GPIO_PIN
(
GPIO_Pin
));

405 
GPIOx
->
BSRRH
 = 
GPIO_Pin
;

406 
	}
}

419 void 
	$GPIO_WriteBit
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
, 
BitAction
 
BitVal
)

422 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

423 
	`assert_param
(
	`IS_GET_GPIO_PIN
(
GPIO_Pin
));

424 
	`assert_param
(
	`IS_GPIO_BIT_ACTION
(
BitVal
));

426 if (
BitVal
 != 
Bit_RESET
)

428 
GPIOx
->
BSRRL
 = 
GPIO_Pin
;

432 
GPIOx
->
BSRRH
 = 
GPIO_Pin
 ;

434 
	}
}

442 void 
	$GPIO_Write
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
PortVal
)

445 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

447 
GPIOx
->
ODR
 = 
PortVal
;

448 
	}
}

456 void 
	$GPIO_ToggleBits
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_Pin
)

459 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

461 
GPIOx
->
ODR
 ^= 
GPIO_Pin
;

462 
	}
}

529 void 
	$GPIO_PinAFConfig
(
GPIO_TypeDef
* 
GPIOx
, 
uint16_t
 
GPIO_PinSource
, 
uint8_t
 
GPIO_AF
)

531 
uint32_t
 
temp
 = 0x00;

532 
uint32_t
 
temp_2
 = 0x00;

535 
	`assert_param
(
	`IS_GPIO_ALL_PERIPH
(
GPIOx
));

536 
	`assert_param
(
	`IS_GPIO_PIN_SOURCE
(
GPIO_PinSource
));

537 
	`assert_param
(
	`IS_GPIO_AF
(
GPIO_AF
));

539 
temp
 = ((
uint32_t
)(
GPIO_AF
) << ((uint32_t)((uint32_t)
GPIO_PinSource
 & (uint32_t)0x07) * 4)) ;

540 
GPIOx
->
AFR
[
GPIO_PinSource
 >> 0x03] &= ~((
uint32_t
)0xF << ((uint32_t)((uint32_t)GPIO_PinSource & (uint32_t)0x07) * 4)) ;

541 
temp_2
 = 
GPIOx
->
AFR
[
GPIO_PinSource
 >> 0x03] | 
temp
;

542 
GPIOx
->
AFR
[
GPIO_PinSource
 >> 0x03] = 
temp_2
;

543 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash.c

123 #include 
	~"stm32f4xx_hash.h
"

124 #include 
	~"stm32f4xx_rcc.h
"

171 void 
	$HASH_DeInit
(void)

174 
	`RCC_AHB2PeriphResetCmd
(
RCC_AHB2Periph_HASH
, 
ENABLE
);

176 
	`RCC_AHB2PeriphResetCmd
(
RCC_AHB2Periph_HASH
, 
DISABLE
);

177 
	}
}

191 void 
	$HASH_Init
(
HASH_InitTypeDef
* 
HASH_InitStruct
)

194 
	`assert_param
(
	`IS_HASH_ALGOSELECTION
(
HASH_InitStruct
->
HASH_AlgoSelection
));

195 
	`assert_param
(
	`IS_HASH_DATATYPE
(
HASH_InitStruct
->
HASH_DataType
));

196 
	`assert_param
(
	`IS_HASH_ALGOMODE
(
HASH_InitStruct
->
HASH_AlgoMode
));

199 
HASH
->
CR
 &= ~ (
HASH_CR_ALGO
 | 
HASH_CR_DATATYPE
 | 
HASH_CR_MODE
);

200 
HASH
->
CR
 |= (
HASH_InitStruct
->
HASH_AlgoSelection
 | \

201 
HASH_InitStruct
->
HASH_DataType
 | \

202 
HASH_InitStruct
->
HASH_AlgoMode
);

205 if(
HASH_InitStruct
->
HASH_AlgoMode
 == 
HASH_AlgoMode_HMAC
)

207 
	`assert_param
(
	`IS_HASH_HMAC_KEYTYPE
(
HASH_InitStruct
->
HASH_HMACKeyType
));

208 
HASH
->
CR
 &= ~
HASH_CR_LKEY
;

209 
HASH
->
CR
 |= 
HASH_InitStruct
->
HASH_HMACKeyType
;

214 
HASH
->
CR
 |= 
HASH_CR_INIT
;

215 
	}
}

225 void 
	$HASH_StructInit
(
HASH_InitTypeDef
* 
HASH_InitStruct
)

228 
HASH_InitStruct
->
HASH_AlgoSelection
 = 
HASH_AlgoSelection_SHA1
;

231 
HASH_InitStruct
->
HASH_AlgoMode
 = 
HASH_AlgoMode_HASH
;

234 
HASH_InitStruct
->
HASH_DataType
 = 
HASH_DataType_32b
;

237 
HASH_InitStruct
->
HASH_HMACKeyType
 = 
HASH_HMACKeyType_ShortKey
;

238 
	}
}

249 void 
	$HASH_Reset
(void)

252 
HASH
->
CR
 |= 
HASH_CR_INIT
;

253 
	}
}

291 void 
	$HASH_SetLastWordValidBitsNbr
(
uint16_t
 
ValidNumber
)

294 
	`assert_param
(
	`IS_HASH_VALIDBITSNUMBER
(
ValidNumber
));

297 
HASH
->
STR
 &= ~(
HASH_STR_NBW
);

298 
HASH
->
STR
 |= 
ValidNumber
;

299 
	}
}

306 void 
	$HASH_DataIn
(
uint32_t
 
Data
)

309 
HASH
->
DIN
 = 
Data
;

310 
	}
}

317 
uint8_t
 
	$HASH_GetInFIFOWordsNbr
(void)

320 return ((
HASH
->
CR
 & 
HASH_CR_NBW
) >> 8);

321 
	}
}

331 void 
	$HASH_GetDigest
(
HASH_MsgDigest
* 
HASH_MessageDigest
)

334 
HASH_MessageDigest
->
Data
[0] = 
HASH
->
HR
[0];

335 
HASH_MessageDigest
->
Data
[1] = 
HASH
->
HR
[1];

336 
HASH_MessageDigest
->
Data
[2] = 
HASH
->
HR
[2];

337 
HASH_MessageDigest
->
Data
[3] = 
HASH
->
HR
[3];

338 
HASH_MessageDigest
->
Data
[4] = 
HASH
->
HR
[4];

339 
	}
}

346 void 
	$HASH_StartDigest
(void)

349 
HASH
->
STR
 |= 
HASH_STR_DCAL
;

350 
	}
}

389 void 
	$HASH_SaveContext
(
HASH_Context
* 
HASH_ContextSave
)

391 
uint8_t
 
i
 = 0;

394 
HASH_ContextSave
->
HASH_IMR
 = 
HASH
->
IMR
;

395 
HASH_ContextSave
->
HASH_STR
 = 
HASH
->
STR
;

396 
HASH_ContextSave
->
HASH_CR
 = 
HASH
->
CR
;

397 for(
i
=0; i<=50;i++)

399 
HASH_ContextSave
->
HASH_CSR
[
i
] = 
HASH
->
CSR
[i];

401 
	}
}

411 void 
	$HASH_RestoreContext
(
HASH_Context
* 
HASH_ContextRestore
)

413 
uint8_t
 
i
 = 0;

416 
HASH
->
IMR
 = 
HASH_ContextRestore
->
HASH_IMR
;

417 
HASH
->
STR
 = 
HASH_ContextRestore
->
HASH_STR
;

418 
HASH
->
CR
 = 
HASH_ContextRestore
->
HASH_CR
;

421 
HASH
->
CR
 |= 
HASH_CR_INIT
;

424 for(
i
=0; i<=50;i++)

426 
HASH
->
CSR
[
i
] = 
HASH_ContextRestore
->
HASH_CSR
[i];

428 
	}
}

460 void 
	$HASH_DMACmd
(
FunctionalState
 
NewState
)

463 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

465 if (
NewState
 != 
DISABLE
)

468 
HASH
->
CR
 |= 
HASH_CR_DMAE
;

473 
HASH
->
CR
 &= ~
HASH_CR_DMAE
;

475 
	}
}

555 void 
	$HASH_ITConfig
(
uint8_t
 
HASH_IT
, 
FunctionalState
 
NewState
)

558 
	`assert_param
(
	`IS_HASH_IT
(
HASH_IT
));

559 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

561 if (
NewState
 != 
DISABLE
)

564 
HASH
->
IMR
 |= 
HASH_IT
;

569 
HASH
->
IMR
 &= (
uint8_t
) ~
HASH_IT
;

571 
	}
}

584 
FlagStatus
 
	$HASH_GetFlagStatus
(
uint16_t
 
HASH_FLAG
)

586 
FlagStatus
 
bitstatus
 = 
RESET
;

587 
uint32_t
 
tempreg
 = 0;

590 
	`assert_param
(
	`IS_HASH_GET_FLAG
(
HASH_FLAG
));

593 if ((
HASH_FLAG
 & 
HASH_FLAG_DINNE
) != (
uint16_t
)
RESET
 )

595 
tempreg
 = 
HASH
->
CR
;

599 
tempreg
 = 
HASH
->
SR
;

603 if ((
tempreg
 & 
HASH_FLAG
) != (
uint16_t
)
RESET
)

606 
bitstatus
 = 
SET
;

611 
bitstatus
 = 
RESET
;

615 return 
bitstatus
;

616 
	}
}

625 void 
	$HASH_ClearFlag
(
uint16_t
 
HASH_FLAG
)

628 
	`assert_param
(
	`IS_HASH_CLEAR_FLAG
(
HASH_FLAG
));

631 
HASH
->
SR
 = ~(
uint32_t
)
HASH_FLAG
;

632 
	}
}

641 
ITStatus
 
	$HASH_GetITStatus
(
uint8_t
 
HASH_IT
)

643 
ITStatus
 
bitstatus
 = 
RESET
;

644 
uint32_t
 
tmpreg
 = 0;

647 
	`assert_param
(
	`IS_HASH_GET_IT
(
HASH_IT
));

651 
tmpreg
 = 
HASH
->
SR
;

653 if (((
HASH
->
IMR
 & 
tmpreg
) & 
HASH_IT
) != 
RESET
)

656 
bitstatus
 = 
SET
;

661 
bitstatus
 = 
RESET
;

664 return 
bitstatus
;

665 
	}
}

675 void 
	$HASH_ClearITPendingBit
(
uint8_t
 
HASH_IT
)

678 
	`assert_param
(
	`IS_HASH_IT
(
HASH_IT
));

681 
HASH
->
SR
 = (
uint8_t
)~
HASH_IT
;

682 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_md5.c

41 #include 
	~"stm32f4xx_hash.h
"

54 #define 
	#MD5BUSY_TIMEOUT
 ((
uint32_t
) 0x00010000)

	)

87 
ErrorStatus
 
	$HASH_MD5
(
uint8_t
 *
Input
, 
uint32_t
 
Ilen
, uint8_t 
Output
[16])

89 
HASH_InitTypeDef
 
MD5_HASH_InitStructure
;

90 
HASH_MsgDigest
 
MD5_MessageDigest
;

91 
__IO
 
uint16_t
 
nbvalidbitsdata
 = 0;

92 
uint32_t
 
i
 = 0;

93 
__IO
 
uint32_t
 
counter
 = 0;

94 
uint32_t
 
busystatus
 = 0;

95 
ErrorStatus
 
status
 = 
SUCCESS
;

96 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

97 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

101 
nbvalidbitsdata
 = 8 * (
Ilen
 % 4);

104 
	`HASH_DeInit
();

107 
MD5_HASH_InitStructure
.
HASH_AlgoSelection
 = 
HASH_AlgoSelection_MD5
;

108 
MD5_HASH_InitStructure
.
HASH_AlgoMode
 = 
HASH_AlgoMode_HASH
;

109 
MD5_HASH_InitStructure
.
HASH_DataType
 = 
HASH_DataType_8b
;

110 
	`HASH_Init
(&
MD5_HASH_InitStructure
);

113 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitsdata
);

116 for(
i
=0; i<
Ilen
; i+=4)

118 
	`HASH_DataIn
(*(
uint32_t
*)
inputaddr
);

119 
inputaddr
+=4;

123 
	`HASH_StartDigest
();

128 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

129 
counter
++;

130 }while ((
counter
 != 
MD5BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

132 if (
busystatus
 != 
RESET
)

134 
status
 = 
ERROR
;

139 
	`HASH_GetDigest
(&
MD5_MessageDigest
);

140 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[0]);

141 
outputaddr
+=4;

142 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[1]);

143 
outputaddr
+=4;

144 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[2]);

145 
outputaddr
+=4;

146 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[3]);

148 return 
status
;

149 
	}
}

162 
ErrorStatus
 
	$HMAC_MD5
(
uint8_t
 *
Key
, 
uint32_t
 
Keylen
, uint8_t *
Input
,

163 
uint32_t
 
Ilen
, 
uint8_t
 
Output
[16])

165 
HASH_InitTypeDef
 
MD5_HASH_InitStructure
;

166 
HASH_MsgDigest
 
MD5_MessageDigest
;

167 
__IO
 
uint16_t
 
nbvalidbitsdata
 = 0;

168 
__IO
 
uint16_t
 
nbvalidbitskey
 = 0;

169 
uint32_t
 
i
 = 0;

170 
__IO
 
uint32_t
 
counter
 = 0;

171 
uint32_t
 
busystatus
 = 0;

172 
ErrorStatus
 
status
 = 
SUCCESS
;

173 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

174 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

175 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

178 
nbvalidbitsdata
 = 8 * (
Ilen
 % 4);

181 
nbvalidbitskey
 = 8 * (
Keylen
 % 4);

184 
	`HASH_DeInit
();

187 
MD5_HASH_InitStructure
.
HASH_AlgoSelection
 = 
HASH_AlgoSelection_MD5
;

188 
MD5_HASH_InitStructure
.
HASH_AlgoMode
 = 
HASH_AlgoMode_HMAC
;

189 
MD5_HASH_InitStructure
.
HASH_DataType
 = 
HASH_DataType_8b
;

190 if(
Keylen
 > 64)

193 
MD5_HASH_InitStructure
.
HASH_HMACKeyType
 = 
HASH_HMACKeyType_LongKey
;

198 
MD5_HASH_InitStructure
.
HASH_HMACKeyType
 = 
HASH_HMACKeyType_ShortKey
;

200 
	`HASH_Init
(&
MD5_HASH_InitStructure
);

203 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitskey
);

206 for(
i
=0; i<
Keylen
; i+=4)

208 
	`HASH_DataIn
(*(
uint32_t
*)
keyaddr
);

209 
keyaddr
+=4;

213 
	`HASH_StartDigest
();

218 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

219 
counter
++;

220 }while ((
counter
 != 
MD5BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

222 if (
busystatus
 != 
RESET
)

224 
status
 = 
ERROR
;

229 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitsdata
);

232 for(
i
=0; i<
Ilen
; i+=4)

234 
	`HASH_DataIn
(*(
uint32_t
*)
inputaddr
);

235 
inputaddr
+=4;

239 
	`HASH_StartDigest
();

242 
counter
 =0;

245 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

246 
counter
++;

247 }while ((
counter
 != 
MD5BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

249 if (
busystatus
 != 
RESET
)

251 
status
 = 
ERROR
;

256 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitskey
);

259 
keyaddr
 = (
uint32_t
)
Key
;

260 for(
i
=0; i<
Keylen
; i+=4)

262 
	`HASH_DataIn
(*(
uint32_t
*)
keyaddr
);

263 
keyaddr
+=4;

267 
	`HASH_StartDigest
();

270 
counter
 =0;

273 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

274 
counter
++;

275 }while ((
counter
 != 
MD5BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

277 if (
busystatus
 != 
RESET
)

279 
status
 = 
ERROR
;

284 
	`HASH_GetDigest
(&
MD5_MessageDigest
);

285 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[0]);

286 
outputaddr
+=4;

287 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[1]);

288 
outputaddr
+=4;

289 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[2]);

290 
outputaddr
+=4;

291 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
MD5_MessageDigest
.
Data
[3]);

295 return 
status
;

296 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_sha1.c

41 #include 
	~"stm32f4xx_hash.h
"

54 #define 
	#SHA1BUSY_TIMEOUT
 ((
uint32_t
) 0x00010000)

	)

87 
ErrorStatus
 
	$HASH_SHA1
(
uint8_t
 *
Input
, 
uint32_t
 
Ilen
, uint8_t 
Output
[20])

89 
HASH_InitTypeDef
 
SHA1_HASH_InitStructure
;

90 
HASH_MsgDigest
 
SHA1_MessageDigest
;

91 
__IO
 
uint16_t
 
nbvalidbitsdata
 = 0;

92 
uint32_t
 
i
 = 0;

93 
__IO
 
uint32_t
 
counter
 = 0;

94 
uint32_t
 
busystatus
 = 0;

95 
ErrorStatus
 
status
 = 
SUCCESS
;

96 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

97 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

100 
nbvalidbitsdata
 = 8 * (
Ilen
 % 4);

103 
	`HASH_DeInit
();

106 
SHA1_HASH_InitStructure
.
HASH_AlgoSelection
 = 
HASH_AlgoSelection_SHA1
;

107 
SHA1_HASH_InitStructure
.
HASH_AlgoMode
 = 
HASH_AlgoMode_HASH
;

108 
SHA1_HASH_InitStructure
.
HASH_DataType
 = 
HASH_DataType_8b
;

109 
	`HASH_Init
(&
SHA1_HASH_InitStructure
);

112 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitsdata
);

115 for(
i
=0; i<
Ilen
; i+=4)

117 
	`HASH_DataIn
(*(
uint32_t
*)
inputaddr
);

118 
inputaddr
+=4;

122 
	`HASH_StartDigest
();

127 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

128 
counter
++;

129 }while ((
counter
 != 
SHA1BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

131 if (
busystatus
 != 
RESET
)

133 
status
 = 
ERROR
;

138 
	`HASH_GetDigest
(&
SHA1_MessageDigest
);

139 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[0]);

140 
outputaddr
+=4;

141 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[1]);

142 
outputaddr
+=4;

143 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[2]);

144 
outputaddr
+=4;

145 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[3]);

146 
outputaddr
+=4;

147 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[4]);

149 return 
status
;

150 
	}
}

163 
ErrorStatus
 
	$HMAC_SHA1
(
uint8_t
 *
Key
, 
uint32_t
 
Keylen
, uint8_t *
Input
,

164 
uint32_t
 
Ilen
, 
uint8_t
 
Output
[20])

166 
HASH_InitTypeDef
 
SHA1_HASH_InitStructure
;

167 
HASH_MsgDigest
 
SHA1_MessageDigest
;

168 
__IO
 
uint16_t
 
nbvalidbitsdata
 = 0;

169 
__IO
 
uint16_t
 
nbvalidbitskey
 = 0;

170 
uint32_t
 
i
 = 0;

171 
__IO
 
uint32_t
 
counter
 = 0;

172 
uint32_t
 
busystatus
 = 0;

173 
ErrorStatus
 
status
 = 
SUCCESS
;

174 
uint32_t
 
keyaddr
 = (uint32_t)
Key
;

175 
uint32_t
 
inputaddr
 = (uint32_t)
Input
;

176 
uint32_t
 
outputaddr
 = (uint32_t)
Output
;

179 
nbvalidbitsdata
 = 8 * (
Ilen
 % 4);

182 
nbvalidbitskey
 = 8 * (
Keylen
 % 4);

185 
	`HASH_DeInit
();

188 
SHA1_HASH_InitStructure
.
HASH_AlgoSelection
 = 
HASH_AlgoSelection_SHA1
;

189 
SHA1_HASH_InitStructure
.
HASH_AlgoMode
 = 
HASH_AlgoMode_HMAC
;

190 
SHA1_HASH_InitStructure
.
HASH_DataType
 = 
HASH_DataType_8b
;

191 if(
Keylen
 > 64)

194 
SHA1_HASH_InitStructure
.
HASH_HMACKeyType
 = 
HASH_HMACKeyType_LongKey
;

199 
SHA1_HASH_InitStructure
.
HASH_HMACKeyType
 = 
HASH_HMACKeyType_ShortKey
;

201 
	`HASH_Init
(&
SHA1_HASH_InitStructure
);

204 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitskey
);

207 for(
i
=0; i<
Keylen
; i+=4)

209 
	`HASH_DataIn
(*(
uint32_t
*)
keyaddr
);

210 
keyaddr
+=4;

214 
	`HASH_StartDigest
();

219 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

220 
counter
++;

221 }while ((
counter
 != 
SHA1BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

223 if (
busystatus
 != 
RESET
)

225 
status
 = 
ERROR
;

230 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitsdata
);

233 for(
i
=0; i<
Ilen
; i+=4)

235 
	`HASH_DataIn
(*(
uint32_t
*)
inputaddr
);

236 
inputaddr
+=4;

240 
	`HASH_StartDigest
();

244 
counter
 =0;

247 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

248 
counter
++;

249 }while ((
counter
 != 
SHA1BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

251 if (
busystatus
 != 
RESET
)

253 
status
 = 
ERROR
;

258 
	`HASH_SetLastWordValidBitsNbr
(
nbvalidbitskey
);

261 
keyaddr
 = (
uint32_t
)
Key
;

262 for(
i
=0; i<
Keylen
; i+=4)

264 
	`HASH_DataIn
(*(
uint32_t
*)
keyaddr
);

265 
keyaddr
+=4;

269 
	`HASH_StartDigest
();

272 
counter
 =0;

275 
busystatus
 = 
	`HASH_GetFlagStatus
(
HASH_FLAG_BUSY
);

276 
counter
++;

277 }while ((
counter
 != 
SHA1BUSY_TIMEOUT
) && (
busystatus
 != 
RESET
));

279 if (
busystatus
 != 
RESET
)

281 
status
 = 
ERROR
;

286 
	`HASH_GetDigest
(&
SHA1_MessageDigest
);

287 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[0]);

288 
outputaddr
+=4;

289 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[1]);

290 
outputaddr
+=4;

291 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[2]);

292 
outputaddr
+=4;

293 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[3]);

294 
outputaddr
+=4;

295 *(
uint32_t
*)(
outputaddr
) = 
	`__REV
(
SHA1_MessageDigest
.
Data
[4]);

299 return 
status
;

300 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_i2c.c

87 #include 
	~"stm32f4xx_i2c.h
"

88 #include 
	~"stm32f4xx_rcc.h
"

102 #define 
	#CR1_CLEAR_MASK
 ((
uint16_t
)0xFBF5)

	)

103 #define 
	#FLAG_MASK
 ((
uint32_t
)0x00FFFFFF)

	)

104 #define 
	#ITEN_MASK
 ((
uint32_t
)0x07000000)

	)

132 void 
	$I2C_DeInit
(
I2C_TypeDef
* 
I2Cx
)

135 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

137 if (
I2Cx
 == 
I2C1
)

140 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_I2C1
, 
ENABLE
);

142 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_I2C1
, 
DISABLE
);

144 else if (
I2Cx
 == 
I2C2
)

147 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_I2C2
, 
ENABLE
);

149 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_I2C2
, 
DISABLE
);

153 if (
I2Cx
 == 
I2C3
)

156 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_I2C3
, 
ENABLE
);

158 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_I2C3
, 
DISABLE
);

161 
	}
}

175 void 
	$I2C_Init
(
I2C_TypeDef
* 
I2Cx
, 
I2C_InitTypeDef
* 
I2C_InitStruct
)

177 
uint16_t
 
tmpreg
 = 0, 
freqrange
 = 0;

178 
uint16_t
 
result
 = 0x04;

179 
uint32_t
 
pclk1
 = 8000000;

180 
RCC_ClocksTypeDef
 
rcc_clocks
;

182 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

183 
	`assert_param
(
	`IS_I2C_CLOCK_SPEED
(
I2C_InitStruct
->
I2C_ClockSpeed
));

184 
	`assert_param
(
	`IS_I2C_MODE
(
I2C_InitStruct
->
I2C_Mode
));

185 
	`assert_param
(
	`IS_I2C_DUTY_CYCLE
(
I2C_InitStruct
->
I2C_DutyCycle
));

186 
	`assert_param
(
	`IS_I2C_OWN_ADDRESS1
(
I2C_InitStruct
->
I2C_OwnAddress1
));

187 
	`assert_param
(
	`IS_I2C_ACK_STATE
(
I2C_InitStruct
->
I2C_Ack
));

188 
	`assert_param
(
	`IS_I2C_ACKNOWLEDGE_ADDRESS
(
I2C_InitStruct
->
I2C_AcknowledgedAddress
));

192 
tmpreg
 = 
I2Cx
->
CR2
;

194 
tmpreg
 &= (
uint16_t
)~((uint16_t)
I2C_CR2_FREQ
);

196 
	`RCC_GetClocksFreq
(&
rcc_clocks
);

197 
pclk1
 = 
rcc_clocks
.
PCLK1_Frequency
;

199 
freqrange
 = (
uint16_t
)(
pclk1
 / 1000000);

200 
tmpreg
 |= 
freqrange
;

202 
I2Cx
->
CR2
 = 
tmpreg
;

206 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_PE
);

209 
tmpreg
 = 0;

212 if (
I2C_InitStruct
->
I2C_ClockSpeed
 <= 100000)

215 
result
 = (
uint16_t
)(
pclk1
 / (
I2C_InitStruct
->
I2C_ClockSpeed
 << 1));

217 if (
result
 < 0x04)

220 
result
 = 0x04;

223 
tmpreg
 |= 
result
;

225 
I2Cx
->
TRISE
 = 
freqrange
 + 1;

232 if (
I2C_InitStruct
->
I2C_DutyCycle
 == 
I2C_DutyCycle_2
)

235 
result
 = (
uint16_t
)(
pclk1
 / (
I2C_InitStruct
->
I2C_ClockSpeed
 * 3));

240 
result
 = (
uint16_t
)(
pclk1
 / (
I2C_InitStruct
->
I2C_ClockSpeed
 * 25));

242 
result
 |= 
I2C_DutyCycle_16_9
;

246 if ((
result
 & 
I2C_CCR_CCR
) == 0)

249 
result
 |= (
uint16_t
)0x0001;

252 
tmpreg
 |= (
uint16_t
)(
result
 | 
I2C_CCR_FS
);

254 
I2Cx
->
TRISE
 = (
uint16_t
)(((
freqrange
 * (uint16_t)300) / (uint16_t)1000) + (uint16_t)1);

258 
I2Cx
->
CCR
 = 
tmpreg
;

260 
I2Cx
->
CR1
 |= 
I2C_CR1_PE
;

264 
tmpreg
 = 
I2Cx
->
CR1
;

266 
tmpreg
 &= 
CR1_CLEAR_MASK
;

270 
tmpreg
 |= (
uint16_t
)((
uint32_t
)
I2C_InitStruct
->
I2C_Mode
 | I2C_InitStruct->
I2C_Ack
);

272 
I2Cx
->
CR1
 = 
tmpreg
;

276 
I2Cx
->
OAR1
 = (
I2C_InitStruct
->
I2C_AcknowledgedAddress
 | I2C_InitStruct->
I2C_OwnAddress1
);

277 
	}
}

284 void 
	$I2C_StructInit
(
I2C_InitTypeDef
* 
I2C_InitStruct
)

288 
I2C_InitStruct
->
I2C_ClockSpeed
 = 5000;

290 
I2C_InitStruct
->
I2C_Mode
 = 
I2C_Mode_I2C
;

292 
I2C_InitStruct
->
I2C_DutyCycle
 = 
I2C_DutyCycle_2
;

294 
I2C_InitStruct
->
I2C_OwnAddress1
 = 0;

296 
I2C_InitStruct
->
I2C_Ack
 = 
I2C_Ack_Disable
;

298 
I2C_InitStruct
->
I2C_AcknowledgedAddress
 = 
I2C_AcknowledgedAddress_7bit
;

299 
	}
}

308 void 
	$I2C_Cmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

311 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

312 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

313 if (
NewState
 != 
DISABLE
)

316 
I2Cx
->
CR1
 |= 
I2C_CR1_PE
;

321 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_PE
);

323 
	}
}

332 void 
	$I2C_GenerateSTART
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

335 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

336 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

337 if (
NewState
 != 
DISABLE
)

340 
I2Cx
->
CR1
 |= 
I2C_CR1_START
;

345 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_START
);

347 
	}
}

356 void 
	$I2C_GenerateSTOP
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

359 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

360 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

361 if (
NewState
 != 
DISABLE
)

364 
I2Cx
->
CR1
 |= 
I2C_CR1_STOP
;

369 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_STOP
);

371 
	}
}

384 void 
	$I2C_Send7bitAddress
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
Address
, uint8_t 
I2C_Direction
)

387 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

388 
	`assert_param
(
	`IS_I2C_DIRECTION
(
I2C_Direction
));

390 if (
I2C_Direction
 != 
I2C_Direction_Transmitter
)

393 
Address
 |= 
I2C_OAR1_ADD0
;

398 
Address
 &= (
uint8_t
)~((uint8_t)
I2C_OAR1_ADD0
);

401 
I2Cx
->
DR
 = 
Address
;

402 
	}
}

411 void 
	$I2C_AcknowledgeConfig
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

414 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

415 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

416 if (
NewState
 != 
DISABLE
)

419 
I2Cx
->
CR1
 |= 
I2C_CR1_ACK
;

424 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_ACK
);

426 
	}
}

434 void 
	$I2C_OwnAddress2Config
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
Address
)

436 
uint16_t
 
tmpreg
 = 0;

439 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

442 
tmpreg
 = 
I2Cx
->
OAR2
;

445 
tmpreg
 &= (
uint16_t
)~((uint16_t)
I2C_OAR2_ADD2
);

448 
tmpreg
 |= (
uint16_t
)((uint16_t)
Address
 & (uint16_t)0x00FE);

451 
I2Cx
->
OAR2
 = 
tmpreg
;

452 
	}
}

461 void 
	$I2C_DualAddressCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

464 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

465 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

466 if (
NewState
 != 
DISABLE
)

469 
I2Cx
->
OAR2
 |= 
I2C_OAR2_ENDUAL
;

474 
I2Cx
->
OAR2
 &= (
uint16_t
)~((uint16_t)
I2C_OAR2_ENDUAL
);

476 
	}
}

485 void 
	$I2C_GeneralCallCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

488 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

489 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

490 if (
NewState
 != 
DISABLE
)

493 
I2Cx
->
CR1
 |= 
I2C_CR1_ENGC
;

498 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_ENGC
);

500 
	}
}

511 void 
	$I2C_SoftwareResetCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

514 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

515 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

516 if (
NewState
 != 
DISABLE
)

519 
I2Cx
->
CR1
 |= 
I2C_CR1_SWRST
;

524 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_SWRST
);

526 
	}
}

535 void 
	$I2C_StretchClockCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

538 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

539 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

540 if (
NewState
 == 
DISABLE
)

543 
I2Cx
->
CR1
 |= 
I2C_CR1_NOSTRETCH
;

548 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_NOSTRETCH
);

550 
	}
}

561 void 
	$I2C_FastModeDutyCycleConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_DutyCycle
)

564 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

565 
	`assert_param
(
	`IS_I2C_DUTY_CYCLE
(
I2C_DutyCycle
));

566 if (
I2C_DutyCycle
 != 
I2C_DutyCycle_16_9
)

569 
I2Cx
->
CCR
 &= 
I2C_DutyCycle_2
;

574 
I2Cx
->
CCR
 |= 
I2C_DutyCycle_16_9
;

576 
	}
}

599 void 
	$I2C_NACKPositionConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_NACKPosition
)

602 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

603 
	`assert_param
(
	`IS_I2C_NACK_POSITION
(
I2C_NACKPosition
));

606 if (
I2C_NACKPosition
 == 
I2C_NACKPosition_Next
)

609 
I2Cx
->
CR1
 |= 
I2C_NACKPosition_Next
;

614 
I2Cx
->
CR1
 &= 
I2C_NACKPosition_Current
;

616 
	}
}

627 void 
	$I2C_SMBusAlertConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_SMBusAlert
)

630 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

631 
	`assert_param
(
	`IS_I2C_SMBUS_ALERT
(
I2C_SMBusAlert
));

632 if (
I2C_SMBusAlert
 == 
I2C_SMBusAlert_Low
)

635 
I2Cx
->
CR1
 |= 
I2C_SMBusAlert_Low
;

640 
I2Cx
->
CR1
 &= 
I2C_SMBusAlert_High
;

642 
	}
}

651 void 
	$I2C_ARPCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

654 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

655 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

656 if (
NewState
 != 
DISABLE
)

659 
I2Cx
->
CR1
 |= 
I2C_CR1_ENARP
;

664 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_ENARP
);

666 
	}
}

689 void 
	$I2C_SendData
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
Data
)

692 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

694 
I2Cx
->
DR
 = 
Data
;

695 
	}
}

702 
uint8_t
 
	$I2C_ReceiveData
(
I2C_TypeDef
* 
I2Cx
)

705 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

707 return (
uint8_t
)
I2Cx
->
DR
;

708 
	}
}

733 void 
	$I2C_TransmitPEC
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

736 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

737 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

738 if (
NewState
 != 
DISABLE
)

741 
I2Cx
->
CR1
 |= 
I2C_CR1_PEC
;

746 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_PEC
);

748 
	}
}

764 void 
	$I2C_PECPositionConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_PECPosition
)

767 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

768 
	`assert_param
(
	`IS_I2C_PEC_POSITION
(
I2C_PECPosition
));

769 if (
I2C_PECPosition
 == 
I2C_PECPosition_Next
)

772 
I2Cx
->
CR1
 |= 
I2C_PECPosition_Next
;

777 
I2Cx
->
CR1
 &= 
I2C_PECPosition_Current
;

779 
	}
}

788 void 
	$I2C_CalculatePEC
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

791 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

792 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

793 if (
NewState
 != 
DISABLE
)

796 
I2Cx
->
CR1
 |= 
I2C_CR1_ENPEC
;

801 
I2Cx
->
CR1
 &= (
uint16_t
)~((uint16_t)
I2C_CR1_ENPEC
);

803 
	}
}

810 
uint8_t
 
	$I2C_GetPEC
(
I2C_TypeDef
* 
I2Cx
)

813 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

815 return ((
I2Cx
->
SR2
) >> 8);

816 
	}
}

843 void 
	$I2C_DMACmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

846 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

847 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

848 if (
NewState
 != 
DISABLE
)

851 
I2Cx
->
CR2
 |= 
I2C_CR2_DMAEN
;

856 
I2Cx
->
CR2
 &= (
uint16_t
)~((uint16_t)
I2C_CR2_DMAEN
);

858 
	}
}

867 void 
	$I2C_DMALastTransferCmd
(
I2C_TypeDef
* 
I2Cx
, 
FunctionalState
 
NewState
)

870 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

871 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

872 if (
NewState
 != 
DISABLE
)

875 
I2Cx
->
CR2
 |= 
I2C_CR2_LAST
;

880 
I2Cx
->
CR2
 &= (
uint16_t
)~((uint16_t)
I2C_CR2_LAST
);

882 
	}
}

1005 
uint16_t
 
	$I2C_ReadRegister
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
I2C_Register
)

1007 
__IO
 
uint32_t
 
tmp
 = 0;

1010 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1011 
	`assert_param
(
	`IS_I2C_REGISTER
(
I2C_Register
));

1013 
tmp
 = (
uint32_t
) 
I2Cx
;

1014 
tmp
 += 
I2C_Register
;

1017 return (*(
__IO
 
uint16_t
 *) 
tmp
);

1018 
	}
}

1032 void 
	$I2C_ITConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint16_t
 
I2C_IT
, 
FunctionalState
 
NewState
)

1035 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1036 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1037 
	`assert_param
(
	`IS_I2C_CONFIG_IT
(
I2C_IT
));

1039 if (
NewState
 != 
DISABLE
)

1042 
I2Cx
->
CR2
 |= 
I2C_IT
;

1047 
I2Cx
->
CR2
 &= (
uint16_t
)~
I2C_IT
;

1049 
	}
}

1091 
ErrorStatus
 
	$I2C_CheckEvent
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_EVENT
)

1093 
uint32_t
 
lastevent
 = 0;

1094 
uint32_t
 
flag1
 = 0, 
flag2
 = 0;

1095 
ErrorStatus
 
status
 = 
ERROR
;

1098 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1099 
	`assert_param
(
	`IS_I2C_EVENT
(
I2C_EVENT
));

1102 
flag1
 = 
I2Cx
->
SR1
;

1103 
flag2
 = 
I2Cx
->
SR2
;

1104 
flag2
 = flag2 << 16;

1107 
lastevent
 = (
flag1
 | 
flag2
) & 
FLAG_MASK
;

1110 if ((
lastevent
 & 
I2C_EVENT
) == I2C_EVENT)

1113 
status
 = 
SUCCESS
;

1118 
status
 = 
ERROR
;

1121 return 
status
;

1122 
	}
}

1139 
uint32_t
 
	$I2C_GetLastEvent
(
I2C_TypeDef
* 
I2Cx
)

1141 
uint32_t
 
lastevent
 = 0;

1142 
uint32_t
 
flag1
 = 0, 
flag2
 = 0;

1145 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1148 
flag1
 = 
I2Cx
->
SR1
;

1149 
flag2
 = 
I2Cx
->
SR2
;

1150 
flag2
 = flag2 << 16;

1153 
lastevent
 = (
flag1
 | 
flag2
) & 
FLAG_MASK
;

1156 return 
lastevent
;

1157 
	}
}

1194 
FlagStatus
 
	$I2C_GetFlagStatus
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_FLAG
)

1196 
FlagStatus
 
bitstatus
 = 
RESET
;

1197 
__IO
 
uint32_t
 
i2creg
 = 0, 
i2cxbase
 = 0;

1200 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1201 
	`assert_param
(
	`IS_I2C_GET_FLAG
(
I2C_FLAG
));

1204 
i2cxbase
 = (
uint32_t
)
I2Cx
;

1207 
i2creg
 = 
I2C_FLAG
 >> 28;

1210 
I2C_FLAG
 &= 
FLAG_MASK
;

1212 if(
i2creg
 != 0)

1215 
i2cxbase
 += 0x14;

1220 
I2C_FLAG
 = (
uint32_t
)(I2C_FLAG >> 16);

1222 
i2cxbase
 += 0x18;

1225 if(((*(
__IO
 
uint32_t
 *)
i2cxbase
) & 
I2C_FLAG
) != (uint32_t)
RESET
)

1228 
bitstatus
 = 
SET
;

1233 
bitstatus
 = 
RESET
;

1237 return 
bitstatus
;

1238 
	}
}

1271 void 
	$I2C_ClearFlag
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_FLAG
)

1273 
uint32_t
 
flagpos
 = 0;

1275 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1276 
	`assert_param
(
	`IS_I2C_CLEAR_FLAG
(
I2C_FLAG
));

1278 
flagpos
 = 
I2C_FLAG
 & 
FLAG_MASK
;

1280 
I2Cx
->
SR1
 = (
uint16_t
)~
flagpos
;

1281 
	}
}

1305 
ITStatus
 
	$I2C_GetITStatus
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_IT
)

1307 
ITStatus
 
bitstatus
 = 
RESET
;

1308 
uint32_t
 
enablestatus
 = 0;

1311 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1312 
	`assert_param
(
	`IS_I2C_GET_IT
(
I2C_IT
));

1315 
enablestatus
 = (
uint32_t
)(((
I2C_IT
 & 
ITEN_MASK
) >> 16) & (
I2Cx
->
CR2
)) ;

1318 
I2C_IT
 &= 
FLAG_MASK
;

1321 if (((
I2Cx
->
SR1
 & 
I2C_IT
) != (
uint32_t
)
RESET
) && 
enablestatus
)

1324 
bitstatus
 = 
SET
;

1329 
bitstatus
 = 
RESET
;

1332 return 
bitstatus
;

1333 
	}
}

1365 void 
	$I2C_ClearITPendingBit
(
I2C_TypeDef
* 
I2Cx
, 
uint32_t
 
I2C_IT
)

1367 
uint32_t
 
flagpos
 = 0;

1369 
	`assert_param
(
	`IS_I2C_ALL_PERIPH
(
I2Cx
));

1370 
	`assert_param
(
	`IS_I2C_CLEAR_IT
(
I2C_IT
));

1373 
flagpos
 = 
I2C_IT
 & 
FLAG_MASK
;

1376 
I2Cx
->
SR1
 = (
uint16_t
)~
flagpos
;

1377 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_iwdg.c

82 #include 
	~"stm32f4xx_iwdg.h
"

97 #define 
	#KR_KEY_RELOAD
 ((
uint16_t
)0xAAAA)

	)

98 #define 
	#KR_KEY_ENABLE
 ((
uint16_t
)0xCCCC)

	)

129 void 
	$IWDG_WriteAccessCmd
(
uint16_t
 
IWDG_WriteAccess
)

132 
	`assert_param
(
	`IS_IWDG_WRITE_ACCESS
(
IWDG_WriteAccess
));

133 
IWDG
->
KR
 = 
IWDG_WriteAccess
;

134 
	}
}

149 void 
	$IWDG_SetPrescaler
(
uint8_t
 
IWDG_Prescaler
)

152 
	`assert_param
(
	`IS_IWDG_PRESCALER
(
IWDG_Prescaler
));

153 
IWDG
->
PR
 = 
IWDG_Prescaler
;

154 
	}
}

162 void 
	$IWDG_SetReload
(
uint16_t
 
Reload
)

165 
	`assert_param
(
	`IS_IWDG_RELOAD
(
Reload
));

166 
IWDG
->
RLR
 = 
Reload
;

167 
	}
}

175 void 
	$IWDG_ReloadCounter
(void)

177 
IWDG
->
KR
 = 
KR_KEY_RELOAD
;

178 
	}
}

201 void 
	$IWDG_Enable
(void)

203 
IWDG
->
KR
 = 
KR_KEY_ENABLE
;

204 
	}
}

230 
FlagStatus
 
	$IWDG_GetFlagStatus
(
uint16_t
 
IWDG_FLAG
)

232 
FlagStatus
 
bitstatus
 = 
RESET
;

234 
	`assert_param
(
	`IS_IWDG_FLAG
(
IWDG_FLAG
));

235 if ((
IWDG
->
SR
 & 
IWDG_FLAG
) != (
uint32_t
)
RESET
)

237 
bitstatus
 = 
SET
;

241 
bitstatus
 = 
RESET
;

244 return 
bitstatus
;

245 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c

32 #include 
	~"stm32f4xx_pwr.h
"

33 #include 
	~"stm32f4xx_rcc.h
"

47 #define 
	#PWR_OFFSET
 (
PWR_BASE
 - 
PERIPH_BASE
)

	)

52 #define 
	#CR_OFFSET
 (
PWR_OFFSET
 + 0x00)

	)

53 #define 
	#DBP_BitNumber
 0x08

	)

54 #define 
	#CR_DBP_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
DBP_BitNumber
 * 4))

	)

57 #define 
	#PVDE_BitNumber
 0x04

	)

58 #define 
	#CR_PVDE_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
PVDE_BitNumber
 * 4))

	)

61 #define 
	#FPDS_BitNumber
 0x09

	)

62 #define 
	#CR_FPDS_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
FPDS_BitNumber
 * 4))

	)

65 #define 
	#PMODE_BitNumber
 0x0E

	)

66 #define 
	#CR_PMODE_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
PMODE_BitNumber
 * 4))

	)

72 #define 
	#CSR_OFFSET
 (
PWR_OFFSET
 + 0x04)

	)

73 #define 
	#EWUP_BitNumber
 0x08

	)

74 #define 
	#CSR_EWUP_BB
 (
PERIPH_BB_BASE
 + (
CSR_OFFSET
 * 32) + (
EWUP_BitNumber
 * 4))

	)

77 #define 
	#BRE_BitNumber
 0x09

	)

78 #define 
	#CSR_BRE_BB
 (
PERIPH_BB_BASE
 + (
CSR_OFFSET
 * 32) + (
BRE_BitNumber
 * 4))

	)

83 #define 
	#CR_DS_MASK
 ((
uint32_t
)0xFFFFFFFC)

	)

84 #define 
	#CR_PLS_MASK
 ((
uint32_t
)0xFFFFFF1F)

	)

120 void 
	$PWR_DeInit
(void)

122 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_PWR
, 
ENABLE
);

123 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_PWR
, 
DISABLE
);

124 
	}
}

135 void 
	$PWR_BackupAccessCmd
(
FunctionalState
 
NewState
)

138 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

140 *(
__IO
 
uint32_t
 *) 
CR_DBP_BB
 = (uint32_t)
NewState
;

141 
	}
}

181 void 
	$PWR_PVDLevelConfig
(
uint32_t
 
PWR_PVDLevel
)

183 
uint32_t
 
tmpreg
 = 0;

186 
	`assert_param
(
	`IS_PWR_PVD_LEVEL
(
PWR_PVDLevel
));

188 
tmpreg
 = 
PWR
->
CR
;

191 
tmpreg
 &= 
CR_PLS_MASK
;

194 
tmpreg
 |= 
PWR_PVDLevel
;

197 
PWR
->
CR
 = 
tmpreg
;

198 
	}
}

206 void 
	$PWR_PVDCmd
(
FunctionalState
 
NewState
)

209 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

211 *(
__IO
 
uint32_t
 *) 
CR_PVDE_BB
 = (uint32_t)
NewState
;

212 
	}
}

240 void 
	$PWR_WakeUpPinCmd
(
FunctionalState
 
NewState
)

243 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

245 *(
__IO
 
uint32_t
 *) 
CSR_EWUP_BB
 = (uint32_t)
NewState
;

246 
	}
}

288 void 
	$PWR_BackupRegulatorCmd
(
FunctionalState
 
NewState
)

291 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

293 *(
__IO
 
uint32_t
 *) 
CSR_BRE_BB
 = (uint32_t)
NewState
;

294 
	}
}

329 void 
	$PWR_HighPerformanceModeCmd
(
FunctionalState
 
NewState
)

332 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

334 *(
__IO
 
uint32_t
 *) 
CR_PMODE_BB
 = (uint32_t)
NewState
;

335 
	}
}

343 void 
	$PWR_FlashPowerDownCmd
(
FunctionalState
 
NewState
)

346 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

348 *(
__IO
 
uint32_t
 *) 
CR_FPDS_BB
 = (uint32_t)
NewState
;

349 
	}
}

483 void 
	$PWR_EnterSTOPMode
(
uint32_t
 
PWR_Regulator
, 
uint8_t
 
PWR_STOPEntry
)

485 
uint32_t
 
tmpreg
 = 0;

488 
	`assert_param
(
	`IS_PWR_REGULATOR
(
PWR_Regulator
));

489 
	`assert_param
(
	`IS_PWR_STOP_ENTRY
(
PWR_STOPEntry
));

492 
tmpreg
 = 
PWR
->
CR
;

494 
tmpreg
 &= 
CR_DS_MASK
;

497 
tmpreg
 |= 
PWR_Regulator
;

500 
PWR
->
CR
 = 
tmpreg
;

503 
SCB
->
SCR
 |= 
SCB_SCR_SLEEPDEEP_Msk
;

506 if(
PWR_STOPEntry
 == 
PWR_STOPEntry_WFI
)

509 
	`__WFI
();

514 
	`__WFE
();

517 
SCB
->
SCR
 &= (
uint32_t
)~((uint32_t)
SCB_SCR_SLEEPDEEP_Msk
);

518 
	}
}

531 void 
	$PWR_EnterSTANDBYMode
(void)

534 
PWR
->
CR
 |= 
PWR_CR_CWUF
;

537 
PWR
->
CR
 |= 
PWR_CR_PDDS
;

540 
SCB
->
SCR
 |= 
SCB_SCR_SLEEPDEEP_Msk
;

543 #if 
	`defined
 ( 
__CC_ARM
 )

544 
	`__force_stores
();

547 
	`__WFI
();

548 
	}
}

587 
FlagStatus
 
	$PWR_GetFlagStatus
(
uint32_t
 
PWR_FLAG
)

589 
FlagStatus
 
bitstatus
 = 
RESET
;

592 
	`assert_param
(
	`IS_PWR_GET_FLAG
(
PWR_FLAG
));

594 if ((
PWR
->
CSR
 & 
PWR_FLAG
) != (
uint32_t
)
RESET
)

596 
bitstatus
 = 
SET
;

600 
bitstatus
 = 
RESET
;

603 return 
bitstatus
;

604 
	}
}

614 void 
	$PWR_ClearFlag
(
uint32_t
 
PWR_FLAG
)

617 
	`assert_param
(
	`IS_PWR_CLEAR_FLAG
(
PWR_FLAG
));

619 
PWR
->
CR
 |= 
PWR_FLAG
 << 2;

620 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rcc.c

56 #include 
	~"stm32f4xx_rcc.h
"

70 #define 
	#RCC_OFFSET
 (
RCC_BASE
 - 
PERIPH_BASE
)

	)

73 #define 
	#CR_OFFSET
 (
RCC_OFFSET
 + 0x00)

	)

74 #define 
	#HSION_BitNumber
 0x00

	)

75 #define 
	#CR_HSION_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
HSION_BitNumber
 * 4))

	)

77 #define 
	#CSSON_BitNumber
 0x13

	)

78 #define 
	#CR_CSSON_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
CSSON_BitNumber
 * 4))

	)

80 #define 
	#PLLON_BitNumber
 0x18

	)

81 #define 
	#CR_PLLON_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
PLLON_BitNumber
 * 4))

	)

83 #define 
	#PLLI2SON_BitNumber
 0x1A

	)

84 #define 
	#CR_PLLI2SON_BB
 (
PERIPH_BB_BASE
 + (
CR_OFFSET
 * 32) + (
PLLI2SON_BitNumber
 * 4))

	)

88 #define 
	#CFGR_OFFSET
 (
RCC_OFFSET
 + 0x08)

	)

89 #define 
	#I2SSRC_BitNumber
 0x17

	)

90 #define 
	#CFGR_I2SSRC_BB
 (
PERIPH_BB_BASE
 + (
CFGR_OFFSET
 * 32) + (
I2SSRC_BitNumber
 * 4))

	)

94 #define 
	#BDCR_OFFSET
 (
RCC_OFFSET
 + 0x70)

	)

95 #define 
	#RTCEN_BitNumber
 0x0F

	)

96 #define 
	#BDCR_RTCEN_BB
 (
PERIPH_BB_BASE
 + (
BDCR_OFFSET
 * 32) + (
RTCEN_BitNumber
 * 4))

	)

98 #define 
	#BDRST_BitNumber
 0x10

	)

99 #define 
	#BDCR_BDRST_BB
 (
PERIPH_BB_BASE
 + (
BDCR_OFFSET
 * 32) + (
BDRST_BitNumber
 * 4))

	)

102 #define 
	#CSR_OFFSET
 (
RCC_OFFSET
 + 0x74)

	)

103 #define 
	#LSION_BitNumber
 0x00

	)

104 #define 
	#CSR_LSION_BB
 (
PERIPH_BB_BASE
 + (
CSR_OFFSET
 * 32) + (
LSION_BitNumber
 * 4))

	)

107 #define 
	#CFGR_MCO2_RESET_MASK
 ((
uint32_t
)0x07FFFFFF)

	)

108 #define 
	#CFGR_MCO1_RESET_MASK
 ((
uint32_t
)0xF89FFFFF)

	)

111 #define 
	#FLAG_MASK
 ((
uint8_t
)0x1F)

	)

114 #define 
	#CR_BYTE3_ADDRESS
 ((
uint32_t
)0x40023802)

	)

117 #define 
	#CIR_BYTE2_ADDRESS
 ((
uint32_t
)(
RCC_BASE
 + 0x0C + 0x01))

	)

120 #define 
	#CIR_BYTE3_ADDRESS
 ((
uint32_t
)(
RCC_BASE
 + 0x0C + 0x02))

	)

123 #define 
	#BDCR_ADDRESS
 (
PERIPH_BASE
 + 
BDCR_OFFSET
)

	)

127 static 
__I
 
uint8_t
 
	gAPBAHBPrescTable
[16] = {0, 0, 0, 0, 1, 2, 3, 4, 1, 2, 3, 4, 6, 7, 8, 9};

196 void 
	$RCC_DeInit
(void)

199 
RCC
->
CR
 |= (
uint32_t
)0x00000001;

202 
RCC
->
CFGR
 = 0x00000000;

205 
RCC
->
CR
 &= (
uint32_t
)0xFEF6FFFF;

208 
RCC
->
PLLCFGR
 = 0x24003010;

211 
RCC
->
CR
 &= (
uint32_t
)0xFFFBFFFF;

214 
RCC
->
CIR
 = 0x00000000;

215 
	}
}

237 void 
	$RCC_HSEConfig
(
uint8_t
 
RCC_HSE
)

240 
	`assert_param
(
	`IS_RCC_HSE
(
RCC_HSE
));

243 *(
__IO
 
uint8_t
 *) 
CR_BYTE3_ADDRESS
 = 
RCC_HSE_OFF
;

246 *(
__IO
 
uint8_t
 *) 
CR_BYTE3_ADDRESS
 = 
RCC_HSE
;

247 
	}
}

261 
ErrorStatus
 
	$RCC_WaitForHSEStartUp
(void)

263 
__IO
 
uint32_t
 
startupcounter
 = 0;

264 
ErrorStatus
 
status
 = 
ERROR
;

265 
FlagStatus
 
hsestatus
 = 
RESET
;

269 
hsestatus
 = 
	`RCC_GetFlagStatus
(
RCC_FLAG_HSERDY
);

270 
startupcounter
++;

271 } while((
startupcounter
 != 
HSE_STARTUP_TIMEOUT
) && (
hsestatus
 == 
RESET
));

273 if (
	`RCC_GetFlagStatus
(
RCC_FLAG_HSERDY
) != 
RESET
)

275 
status
 = 
SUCCESS
;

279 
status
 = 
ERROR
;

281 return (
status
);

282 
	}
}

292 void 
	$RCC_AdjustHSICalibrationValue
(
uint8_t
 
HSICalibrationValue
)

294 
uint32_t
 
tmpreg
 = 0;

296 
	`assert_param
(
	`IS_RCC_CALIBRATION_VALUE
(
HSICalibrationValue
));

298 
tmpreg
 = 
RCC
->
CR
;

301 
tmpreg
 &= ~
RCC_CR_HSITRIM
;

304 
tmpreg
 |= (
uint32_t
)
HSICalibrationValue
 << 3;

307 
RCC
->
CR
 = 
tmpreg
;

308 
	}
}

328 void 
	$RCC_HSICmd
(
FunctionalState
 
NewState
)

331 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

333 *(
__IO
 
uint32_t
 *) 
CR_HSION_BB
 = (uint32_t)
NewState
;

334 
	}
}

353 void 
	$RCC_LSEConfig
(
uint8_t
 
RCC_LSE
)

356 
	`assert_param
(
	`IS_RCC_LSE
(
RCC_LSE
));

360 *(
__IO
 
uint8_t
 *) 
BDCR_ADDRESS
 = 
RCC_LSE_OFF
;

363 *(
__IO
 
uint8_t
 *) 
BDCR_ADDRESS
 = 
RCC_LSE_OFF
;

366 switch (
RCC_LSE
)

368 case 
RCC_LSE_ON
:

370 *(
__IO
 
uint8_t
 *) 
BDCR_ADDRESS
 = 
RCC_LSE_ON
;

372 case 
RCC_LSE_Bypass
:

374 *(
__IO
 
uint8_t
 *) 
BDCR_ADDRESS
 = 
RCC_LSE_Bypass
 | 
RCC_LSE_ON
;

379 
	}
}

393 void 
	$RCC_LSICmd
(
FunctionalState
 
NewState
)

396 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

398 *(
__IO
 
uint32_t
 *) 
CSR_LSION_BB
 = (uint32_t)
NewState
;

399 
	}
}

436 void 
	$RCC_PLLConfig
(
uint32_t
 
RCC_PLLSource
, uint32_t 
PLLM
, uint32_t 
PLLN
, uint32_t 
PLLP
, uint32_t 
PLLQ
)

439 
	`assert_param
(
	`IS_RCC_PLL_SOURCE
(
RCC_PLLSource
));

440 
	`assert_param
(
	`IS_RCC_PLLM_VALUE
(
PLLM
));

441 
	`assert_param
(
	`IS_RCC_PLLN_VALUE
(
PLLN
));

442 
	`assert_param
(
	`IS_RCC_PLLP_VALUE
(
PLLP
));

443 
	`assert_param
(
	`IS_RCC_PLLQ_VALUE
(
PLLQ
));

445 
RCC
->
PLLCFGR
 = 
PLLM
 | (
PLLN
 << 6) | (((
PLLP
 >> 1) -1) << 16) | (
RCC_PLLSource
) |

446 (
PLLQ
 << 24);

447 
	}
}

459 void 
	$RCC_PLLCmd
(
FunctionalState
 
NewState
)

462 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

463 *(
__IO
 
uint32_t
 *) 
CR_PLLON_BB
 = (uint32_t)
NewState
;

464 
	}
}

486 void 
	$RCC_PLLI2SConfig
(
uint32_t
 
PLLI2SN
, uint32_t 
PLLI2SR
)

489 
	`assert_param
(
	`IS_RCC_PLLI2SN_VALUE
(
PLLI2SN
));

490 
	`assert_param
(
	`IS_RCC_PLLI2SR_VALUE
(
PLLI2SR
));

492 
RCC
->
PLLI2SCFGR
 = (
PLLI2SN
 << 6) | (
PLLI2SR
 << 28);

493 
	}
}

502 void 
	$RCC_PLLI2SCmd
(
FunctionalState
 
NewState
)

505 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

506 *(
__IO
 
uint32_t
 *) 
CR_PLLI2SON_BB
 = (uint32_t)
NewState
;

507 
	}
}

520 void 
	$RCC_ClockSecuritySystemCmd
(
FunctionalState
 
NewState
)

523 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

524 *(
__IO
 
uint32_t
 *) 
CR_CSSON_BB
 = (uint32_t)
NewState
;

525 
	}
}

545 void 
	$RCC_MCO1Config
(
uint32_t
 
RCC_MCO1Source
, uint32_t 
RCC_MCO1Div
)

547 
uint32_t
 
tmpreg
 = 0;

550 
	`assert_param
(
	`IS_RCC_MCO1SOURCE
(
RCC_MCO1Source
));

551 
	`assert_param
(
	`IS_RCC_MCO1DIV
(
RCC_MCO1Div
));

553 
tmpreg
 = 
RCC
->
CFGR
;

556 
tmpreg
 &= 
CFGR_MCO1_RESET_MASK
;

559 
tmpreg
 |= 
RCC_MCO1Source
 | 
RCC_MCO1Div
;

562 
RCC
->
CFGR
 = 
tmpreg
;

563 
	}
}

583 void 
	$RCC_MCO2Config
(
uint32_t
 
RCC_MCO2Source
, uint32_t 
RCC_MCO2Div
)

585 
uint32_t
 
tmpreg
 = 0;

588 
	`assert_param
(
	`IS_RCC_MCO2SOURCE
(
RCC_MCO2Source
));

589 
	`assert_param
(
	`IS_RCC_MCO2DIV
(
RCC_MCO2Div
));

591 
tmpreg
 = 
RCC
->
CFGR
;

594 
tmpreg
 &= 
CFGR_MCO2_RESET_MASK
;

597 
tmpreg
 |= 
RCC_MCO2Source
 | 
RCC_MCO2Div
;

600 
RCC
->
CFGR
 = 
tmpreg
;

601 
	}
}

688 void 
	$RCC_SYSCLKConfig
(
uint32_t
 
RCC_SYSCLKSource
)

690 
uint32_t
 
tmpreg
 = 0;

693 
	`assert_param
(
	`IS_RCC_SYSCLK_SOURCE
(
RCC_SYSCLKSource
));

695 
tmpreg
 = 
RCC
->
CFGR
;

698 
tmpreg
 &= ~
RCC_CFGR_SW
;

701 
tmpreg
 |= 
RCC_SYSCLKSource
;

704 
RCC
->
CFGR
 = 
tmpreg
;

705 
	}
}

716 
uint8_t
 
	$RCC_GetSYSCLKSource
(void)

718 return ((
uint8_t
)(
RCC
->
CFGR
 & 
RCC_CFGR_SWS
));

719 
	}
}

741 void 
	$RCC_HCLKConfig
(
uint32_t
 
RCC_SYSCLK
)

743 
uint32_t
 
tmpreg
 = 0;

746 
	`assert_param
(
	`IS_RCC_HCLK
(
RCC_SYSCLK
));

748 
tmpreg
 = 
RCC
->
CFGR
;

751 
tmpreg
 &= ~
RCC_CFGR_HPRE
;

754 
tmpreg
 |= 
RCC_SYSCLK
;

757 
RCC
->
CFGR
 = 
tmpreg
;

758 
	}
}

773 void 
	$RCC_PCLK1Config
(
uint32_t
 
RCC_HCLK
)

775 
uint32_t
 
tmpreg
 = 0;

778 
	`assert_param
(
	`IS_RCC_PCLK
(
RCC_HCLK
));

780 
tmpreg
 = 
RCC
->
CFGR
;

783 
tmpreg
 &= ~
RCC_CFGR_PPRE1
;

786 
tmpreg
 |= 
RCC_HCLK
;

789 
RCC
->
CFGR
 = 
tmpreg
;

790 
	}
}

804 void 
	$RCC_PCLK2Config
(
uint32_t
 
RCC_HCLK
)

806 
uint32_t
 
tmpreg
 = 0;

809 
	`assert_param
(
	`IS_RCC_PCLK
(
RCC_HCLK
));

811 
tmpreg
 = 
RCC
->
CFGR
;

814 
tmpreg
 &= ~
RCC_CFGR_PPRE2
;

817 
tmpreg
 |= 
RCC_HCLK
 << 3;

820 
RCC
->
CFGR
 = 
tmpreg
;

821 
	}
}

856 void 
	$RCC_GetClocksFreq
(
RCC_ClocksTypeDef
* 
RCC_Clocks
)

858 
uint32_t
 
tmp
 = 0, 
presc
 = 0, 
pllvco
 = 0, 
pllp
 = 2, 
pllsource
 = 0, 
pllm
 = 2;

861 
tmp
 = 
RCC
->
CFGR
 & 
RCC_CFGR_SWS
;

863 switch (
tmp
)

866 
RCC_Clocks
->
SYSCLK_Frequency
 = 
HSI_VALUE
;

869 
RCC_Clocks
->
SYSCLK_Frequency
 = 
HSE_VALUE
;

876 
pllsource
 = (
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLSRC
) >> 22;

877 
pllm
 = 
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLM
;

879 if (
pllsource
 != 0)

882 
pllvco
 = (
HSE_VALUE
 / 
pllm
) * ((
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLN
) >> 6);

887 
pllvco
 = (
HSI_VALUE
 / 
pllm
) * ((
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLN
) >> 6);

890 
pllp
 = (((
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLP
) >>16) + 1 ) *2;

891 
RCC_Clocks
->
SYSCLK_Frequency
 = 
pllvco
/
pllp
;

894 
RCC_Clocks
->
SYSCLK_Frequency
 = 
HSI_VALUE
;

900 
tmp
 = 
RCC
->
CFGR
 & 
RCC_CFGR_HPRE
;

901 
tmp
 = tmp >> 4;

902 
presc
 = 
APBAHBPrescTable
[
tmp
];

904 
RCC_Clocks
->
HCLK_Frequency
 = RCC_Clocks->
SYSCLK_Frequency
 >> 
presc
;

907 
tmp
 = 
RCC
->
CFGR
 & 
RCC_CFGR_PPRE1
;

908 
tmp
 = tmp >> 10;

909 
presc
 = 
APBAHBPrescTable
[
tmp
];

911 
RCC_Clocks
->
PCLK1_Frequency
 = RCC_Clocks->
HCLK_Frequency
 >> 
presc
;

914 
tmp
 = 
RCC
->
CFGR
 & 
RCC_CFGR_PPRE2
;

915 
tmp
 = tmp >> 13;

916 
presc
 = 
APBAHBPrescTable
[
tmp
];

918 
RCC_Clocks
->
PCLK2_Frequency
 = RCC_Clocks->
HCLK_Frequency
 >> 
presc
;

919 
	}
}

981 void 
	$RCC_RTCCLKConfig
(
uint32_t
 
RCC_RTCCLKSource
)

983 
uint32_t
 
tmpreg
 = 0;

986 
	`assert_param
(
	`IS_RCC_RTCCLK_SOURCE
(
RCC_RTCCLKSource
));

988 if ((
RCC_RTCCLKSource
 & 0x00000300) == 0x00000300)

990 
tmpreg
 = 
RCC
->
CFGR
;

993 
tmpreg
 &= ~
RCC_CFGR_RTCPRE
;

996 
tmpreg
 |= (
RCC_RTCCLKSource
 & 0xFFFFCFF);

999 
RCC
->
CFGR
 = 
tmpreg
;

1003 
RCC
->
BDCR
 |= (
RCC_RTCCLKSource
 & 0x00000FFF);

1004 
	}
}

1013 void 
	$RCC_RTCCLKCmd
(
FunctionalState
 
NewState
)

1016 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1018 *(
__IO
 
uint32_t
 *) 
BDCR_RTCEN_BB
 = (uint32_t)
NewState
;

1019 
	}
}

1030 void 
	$RCC_BackupResetCmd
(
FunctionalState
 
NewState
)

1033 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1034 *(
__IO
 
uint32_t
 *) 
BDCR_BDRST_BB
 = (uint32_t)
NewState
;

1035 
	}
}

1050 void 
	$RCC_I2SCLKConfig
(
uint32_t
 
RCC_I2SCLKSource
)

1053 
	`assert_param
(
	`IS_RCC_I2SCLK_SOURCE
(
RCC_I2SCLKSource
));

1055 *(
__IO
 
uint32_t
 *) 
CFGR_I2SSRC_BB
 = 
RCC_I2SCLKSource
;

1056 
	}
}

1088 void 
	$RCC_AHB1PeriphClockCmd
(
uint32_t
 
RCC_AHB1Periph
, 
FunctionalState
 
NewState
)

1091 
	`assert_param
(
	`IS_RCC_AHB1_CLOCK_PERIPH
(
RCC_AHB1Periph
));

1093 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1094 if (
NewState
 != 
DISABLE
)

1096 
RCC
->
AHB1ENR
 |= 
RCC_AHB1Periph
;

1100 
RCC
->
AHB1ENR
 &= ~
RCC_AHB1Periph
;

1102 
	}
}

1120 void 
	$RCC_AHB2PeriphClockCmd
(
uint32_t
 
RCC_AHB2Periph
, 
FunctionalState
 
NewState
)

1123 
	`assert_param
(
	`IS_RCC_AHB2_PERIPH
(
RCC_AHB2Periph
));

1124 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1126 if (
NewState
 != 
DISABLE
)

1128 
RCC
->
AHB2ENR
 |= 
RCC_AHB2Periph
;

1132 
RCC
->
AHB2ENR
 &= ~
RCC_AHB2Periph
;

1134 
	}
}

1147 void 
	$RCC_AHB3PeriphClockCmd
(
uint32_t
 
RCC_AHB3Periph
, 
FunctionalState
 
NewState
)

1150 
	`assert_param
(
	`IS_RCC_AHB3_PERIPH
(
RCC_AHB3Periph
));

1151 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1153 if (
NewState
 != 
DISABLE
)

1155 
RCC
->
AHB3ENR
 |= 
RCC_AHB3Periph
;

1159 
RCC
->
AHB3ENR
 &= ~
RCC_AHB3Periph
;

1161 
	}
}

1197 void 
	$RCC_APB1PeriphClockCmd
(
uint32_t
 
RCC_APB1Periph
, 
FunctionalState
 
NewState
)

1200 
	`assert_param
(
	`IS_RCC_APB1_PERIPH
(
RCC_APB1Periph
));

1201 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1203 if (
NewState
 != 
DISABLE
)

1205 
RCC
->
APB1ENR
 |= 
RCC_APB1Periph
;

1209 
RCC
->
APB1ENR
 &= ~
RCC_APB1Periph
;

1211 
	}
}

1237 void 
	$RCC_APB2PeriphClockCmd
(
uint32_t
 
RCC_APB2Periph
, 
FunctionalState
 
NewState
)

1240 
	`assert_param
(
	`IS_RCC_APB2_PERIPH
(
RCC_APB2Periph
));

1241 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1243 if (
NewState
 != 
DISABLE
)

1245 
RCC
->
APB2ENR
 |= 
RCC_APB2Periph
;

1249 
RCC
->
APB2ENR
 &= ~
RCC_APB2Periph
;

1251 
	}
}

1276 void 
	$RCC_AHB1PeriphResetCmd
(
uint32_t
 
RCC_AHB1Periph
, 
FunctionalState
 
NewState
)

1279 
	`assert_param
(
	`IS_RCC_AHB1_RESET_PERIPH
(
RCC_AHB1Periph
));

1280 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1282 if (
NewState
 != 
DISABLE
)

1284 
RCC
->
AHB1RSTR
 |= 
RCC_AHB1Periph
;

1288 
RCC
->
AHB1RSTR
 &= ~
RCC_AHB1Periph
;

1290 
	}
}

1305 void 
	$RCC_AHB2PeriphResetCmd
(
uint32_t
 
RCC_AHB2Periph
, 
FunctionalState
 
NewState
)

1308 
	`assert_param
(
	`IS_RCC_AHB2_PERIPH
(
RCC_AHB2Periph
));

1309 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1311 if (
NewState
 != 
DISABLE
)

1313 
RCC
->
AHB2RSTR
 |= 
RCC_AHB2Periph
;

1317 
RCC
->
AHB2RSTR
 &= ~
RCC_AHB2Periph
;

1319 
	}
}

1329 void 
	$RCC_AHB3PeriphResetCmd
(
uint32_t
 
RCC_AHB3Periph
, 
FunctionalState
 
NewState
)

1332 
	`assert_param
(
	`IS_RCC_AHB3_PERIPH
(
RCC_AHB3Periph
));

1333 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1335 if (
NewState
 != 
DISABLE
)

1337 
RCC
->
AHB3RSTR
 |= 
RCC_AHB3Periph
;

1341 
RCC
->
AHB3RSTR
 &= ~
RCC_AHB3Periph
;

1343 
	}
}

1376 void 
	$RCC_APB1PeriphResetCmd
(
uint32_t
 
RCC_APB1Periph
, 
FunctionalState
 
NewState
)

1379 
	`assert_param
(
	`IS_RCC_APB1_PERIPH
(
RCC_APB1Periph
));

1380 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1381 if (
NewState
 != 
DISABLE
)

1383 
RCC
->
APB1RSTR
 |= 
RCC_APB1Periph
;

1387 
RCC
->
APB1RSTR
 &= ~
RCC_APB1Periph
;

1389 
	}
}

1412 void 
	$RCC_APB2PeriphResetCmd
(
uint32_t
 
RCC_APB2Periph
, 
FunctionalState
 
NewState
)

1415 
	`assert_param
(
	`IS_RCC_APB2_RESET_PERIPH
(
RCC_APB2Periph
));

1416 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1417 if (
NewState
 != 
DISABLE
)

1419 
RCC
->
APB2RSTR
 |= 
RCC_APB2Periph
;

1423 
RCC
->
APB2RSTR
 &= ~
RCC_APB2Periph
;

1425 
	}
}

1458 void 
	$RCC_AHB1PeriphClockLPModeCmd
(
uint32_t
 
RCC_AHB1Periph
, 
FunctionalState
 
NewState
)

1461 
	`assert_param
(
	`IS_RCC_AHB1_LPMODE_PERIPH
(
RCC_AHB1Periph
));

1462 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1463 if (
NewState
 != 
DISABLE
)

1465 
RCC
->
AHB1LPENR
 |= 
RCC_AHB1Periph
;

1469 
RCC
->
AHB1LPENR
 &= ~
RCC_AHB1Periph
;

1471 
	}
}

1490 void 
	$RCC_AHB2PeriphClockLPModeCmd
(
uint32_t
 
RCC_AHB2Periph
, 
FunctionalState
 
NewState
)

1493 
	`assert_param
(
	`IS_RCC_AHB2_PERIPH
(
RCC_AHB2Periph
));

1494 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1495 if (
NewState
 != 
DISABLE
)

1497 
RCC
->
AHB2LPENR
 |= 
RCC_AHB2Periph
;

1501 
RCC
->
AHB2LPENR
 &= ~
RCC_AHB2Periph
;

1503 
	}
}

1517 void 
	$RCC_AHB3PeriphClockLPModeCmd
(
uint32_t
 
RCC_AHB3Periph
, 
FunctionalState
 
NewState
)

1520 
	`assert_param
(
	`IS_RCC_AHB3_PERIPH
(
RCC_AHB3Periph
));

1521 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1522 if (
NewState
 != 
DISABLE
)

1524 
RCC
->
AHB3LPENR
 |= 
RCC_AHB3Periph
;

1528 
RCC
->
AHB3LPENR
 &= ~
RCC_AHB3Periph
;

1530 
	}
}

1567 void 
	$RCC_APB1PeriphClockLPModeCmd
(
uint32_t
 
RCC_APB1Periph
, 
FunctionalState
 
NewState
)

1570 
	`assert_param
(
	`IS_RCC_APB1_PERIPH
(
RCC_APB1Periph
));

1571 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1572 if (
NewState
 != 
DISABLE
)

1574 
RCC
->
APB1LPENR
 |= 
RCC_APB1Periph
;

1578 
RCC
->
APB1LPENR
 &= ~
RCC_APB1Periph
;

1580 
	}
}

1607 void 
	$RCC_APB2PeriphClockLPModeCmd
(
uint32_t
 
RCC_APB2Periph
, 
FunctionalState
 
NewState
)

1610 
	`assert_param
(
	`IS_RCC_APB2_PERIPH
(
RCC_APB2Periph
));

1611 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1612 if (
NewState
 != 
DISABLE
)

1614 
RCC
->
APB2LPENR
 |= 
RCC_APB2Periph
;

1618 
RCC
->
APB2LPENR
 &= ~
RCC_APB2Periph
;

1620 
	}
}

1652 void 
	$RCC_ITConfig
(
uint8_t
 
RCC_IT
, 
FunctionalState
 
NewState
)

1655 
	`assert_param
(
	`IS_RCC_IT
(
RCC_IT
));

1656 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1657 if (
NewState
 != 
DISABLE
)

1660 *(
__IO
 
uint8_t
 *) 
CIR_BYTE2_ADDRESS
 |= 
RCC_IT
;

1665 *(
__IO
 
uint8_t
 *) 
CIR_BYTE2_ADDRESS
 &= (uint8_t)~
RCC_IT
;

1667 
	}
}

1688 
FlagStatus
 
	$RCC_GetFlagStatus
(
uint8_t
 
RCC_FLAG
)

1690 
uint32_t
 
tmp
 = 0;

1691 
uint32_t
 
statusreg
 = 0;

1692 
FlagStatus
 
bitstatus
 = 
RESET
;

1695 
	`assert_param
(
	`IS_RCC_FLAG
(
RCC_FLAG
));

1698 
tmp
 = 
RCC_FLAG
 >> 5;

1699 if (
tmp
 == 1)

1701 
statusreg
 = 
RCC
->
CR
;

1703 else if (
tmp
 == 2)

1705 
statusreg
 = 
RCC
->
BDCR
;

1709 
statusreg
 = 
RCC
->
CSR
;

1713 
tmp
 = 
RCC_FLAG
 & 
FLAG_MASK
;

1714 if ((
statusreg
 & ((
uint32_t
)1 << 
tmp
)) != (uint32_t)
RESET
)

1716 
bitstatus
 = 
SET
;

1720 
bitstatus
 = 
RESET
;

1723 return 
bitstatus
;

1724 
	}
}

1733 void 
	$RCC_ClearFlag
(void)

1736 
RCC
->
CSR
 |= 
RCC_CSR_RMVF
;

1737 
	}
}

1752 
ITStatus
 
	$RCC_GetITStatus
(
uint8_t
 
RCC_IT
)

1754 
ITStatus
 
bitstatus
 = 
RESET
;

1757 
	`assert_param
(
	`IS_RCC_GET_IT
(
RCC_IT
));

1760 if ((
RCC
->
CIR
 & 
RCC_IT
) != (
uint32_t
)
RESET
)

1762 
bitstatus
 = 
SET
;

1766 
bitstatus
 = 
RESET
;

1769 return 
bitstatus
;

1770 
	}
}

1785 void 
	$RCC_ClearITPendingBit
(
uint8_t
 
RCC_IT
)

1788 
	`assert_param
(
	`IS_RCC_CLEAR_IT
(
RCC_IT
));

1792 *(
__IO
 
uint8_t
 *) 
CIR_BYTE3_ADDRESS
 = 
RCC_IT
;

1793 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rng.c

51 #include 
	~"stm32f4xx_rng.h
"

52 #include 
	~"stm32f4xx_rcc.h
"

94 void 
	$RNG_DeInit
(void)

97 
	`RCC_AHB2PeriphResetCmd
(
RCC_AHB2Periph_RNG
, 
ENABLE
);

100 
	`RCC_AHB2PeriphResetCmd
(
RCC_AHB2Periph_RNG
, 
DISABLE
);

101 
	}
}

109 void 
	$RNG_Cmd
(
FunctionalState
 
NewState
)

112 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

114 if (
NewState
 != 
DISABLE
)

117 
RNG
->
CR
 |= 
RNG_CR_RNGEN
;

122 
RNG
->
CR
 &= ~
RNG_CR_RNGEN
;

124 
	}
}

171 
uint32_t
 
	$RNG_GetRandomNumber
(void)

174 return 
RNG
->
DR
;

175 
	}
}

268 void 
	$RNG_ITConfig
(
FunctionalState
 
NewState
)

271 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

273 if (
NewState
 != 
DISABLE
)

276 
RNG
->
CR
 |= 
RNG_CR_IE
;

281 
RNG
->
CR
 &= ~
RNG_CR_IE
;

283 
	}
}

294 
FlagStatus
 
	$RNG_GetFlagStatus
(
uint8_t
 
RNG_FLAG
)

296 
FlagStatus
 
bitstatus
 = 
RESET
;

298 
	`assert_param
(
	`IS_RNG_GET_FLAG
(
RNG_FLAG
));

301 if ((
RNG
->
SR
 & 
RNG_FLAG
) != (
uint8_t
)
RESET
)

304 
bitstatus
 = 
SET
;

309 
bitstatus
 = 
RESET
;

312 return 
bitstatus
;

313 
	}
}

327 void 
	$RNG_ClearFlag
(
uint8_t
 
RNG_FLAG
)

330 
	`assert_param
(
	`IS_RNG_CLEAR_FLAG
(
RNG_FLAG
));

332 
RNG
->
SR
 = ~(
uint32_t
)(((uint32_t)
RNG_FLAG
) << 4);

333 
	}
}

343 
ITStatus
 
	$RNG_GetITStatus
(
uint8_t
 
RNG_IT
)

345 
ITStatus
 
bitstatus
 = 
RESET
;

347 
	`assert_param
(
	`IS_RNG_GET_IT
(
RNG_IT
));

350 if ((
RNG
->
SR
 & 
RNG_IT
) != (
uint8_t
)
RESET
)

353 
bitstatus
 = 
SET
;

358 
bitstatus
 = 
RESET
;

361 return 
bitstatus
;

362 
	}
}

373 void 
	$RNG_ClearITPendingBit
(
uint8_t
 
RNG_IT
)

376 
	`assert_param
(
	`IS_RNG_IT
(
RNG_IT
));

379 
RNG
->
SR
 = (
uint8_t
)~
RNG_IT
;

380 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rtc.c

277 #include 
	~"stm32f4xx_rtc.h
"

278 #include 
	~"stm32f4xx_rcc.h
"

293 #define 
	#RTC_TR_RESERVED_MASK
 ((
uint32_t
)0x007F7F7F)

	)

294 #define 
	#RTC_DR_RESERVED_MASK
 ((
uint32_t
)0x00FFFF3F)

	)

295 #define 
	#RTC_INIT_MASK
 ((
uint32_t
)0xFFFFFFFF)

	)

296 #define 
	#RTC_RSF_MASK
 ((
uint32_t
)0xFFFFFF5F)

	)

297 #define 
	#RTC_FLAGS_MASK
 ((
uint32_t
)(
RTC_FLAG_TSOVF
 | 
RTC_FLAG_TSF
 | 
RTC_FLAG_WUTF
 | \

	)

298 
	gRTC_FLAG_ALRBF
 | 
	gRTC_FLAG_ALRAF
 | 
	gRTC_FLAG_INITF
 | \

299 
	gRTC_FLAG_RSF
 | 
	gRTC_FLAG_INITS
 | 
	gRTC_FLAG_WUTWF
 | \

300 
	gRTC_FLAG_ALRBWF
 | 
	gRTC_FLAG_ALRAWF
 | 
	gRTC_FLAG_TAMP1F
 ))

302 #define 
	#INITMODE_TIMEOUT
 ((
uint32_t
) 0x00010000)

	)

303 #define 
	#SYNCHRO_TIMEOUT
 ((
uint32_t
) 0x00020000)

	)

304 #define 
	#RECALPF_TIMEOUT
 ((
uint32_t
) 0x00020000)

	)

305 #define 
	#SHPF_TIMEOUT
 ((
uint32_t
) 0x00001000)

	)

310 static 
uint8_t
 
RTC_ByteToBcd2
(uint8_t 
Value
);

311 static 
uint8_t
 
RTC_Bcd2ToByte
(uint8_t 
Value
);

367 
ErrorStatus
 
	$RTC_DeInit
(void)

369 
__IO
 
uint32_t
 
wutcounter
 = 0x00;

370 
uint32_t
 
wutwfstatus
 = 0x00;

371 
ErrorStatus
 
status
 = 
ERROR
;

374 
RTC
->
WPR
 = 0xCA;

375 
RTC
->
WPR
 = 0x53;

378 if (
	`RTC_EnterInitMode
() == 
ERROR
)

380 
status
 = 
ERROR
;

385 
RTC
->
TR
 = (
uint32_t
)0x00000000;

386 
RTC
->
DR
 = (
uint32_t
)0x00002101;

388 
RTC
->
CR
 &= (
uint32_t
)0x00000007;

393 
wutwfstatus
 = 
RTC
->
ISR
 & 
RTC_ISR_WUTWF
;

394 
wutcounter
++;

395 } while((
wutcounter
 != 
INITMODE_TIMEOUT
) && (
wutwfstatus
 == 0x00));

397 if ((
RTC
->
ISR
 & 
RTC_ISR_WUTWF
) == 
RESET
)

399 
status
 = 
ERROR
;

404 
RTC
->
CR
 &= (
uint32_t
)0x00000000;

405 
RTC
->
WUTR
 = (
uint32_t
)0x0000FFFF;

406 
RTC
->
PRER
 = (
uint32_t
)0x007F00FF;

407 
RTC
->
CALIBR
 = (
uint32_t
)0x00000000;

408 
RTC
->
ALRMAR
 = (
uint32_t
)0x00000000;

409 
RTC
->
ALRMBR
 = (
uint32_t
)0x00000000;

412 
RTC
->
ISR
 = (
uint32_t
)0x00000000;

415 
RTC
->
TAFCR
 = 0x00000000;

417 if(
	`RTC_WaitForSynchro
() == 
ERROR
)

419 
status
 = 
ERROR
;

423 
status
 = 
SUCCESS
;

429 
RTC
->
WPR
 = 0xFF;

431 return 
status
;

432 
	}
}

445 
ErrorStatus
 
	$RTC_Init
(
RTC_InitTypeDef
* 
RTC_InitStruct
)

447 
ErrorStatus
 
status
 = 
ERROR
;

450 
	`assert_param
(
	`IS_RTC_HOUR_FORMAT
(
RTC_InitStruct
->
RTC_HourFormat
));

451 
	`assert_param
(
	`IS_RTC_ASYNCH_PREDIV
(
RTC_InitStruct
->
RTC_AsynchPrediv
));

452 
	`assert_param
(
	`IS_RTC_SYNCH_PREDIV
(
RTC_InitStruct
->
RTC_SynchPrediv
));

455 
RTC
->
WPR
 = 0xCA;

456 
RTC
->
WPR
 = 0x53;

459 if (
	`RTC_EnterInitMode
() == 
ERROR
)

461 
status
 = 
ERROR
;

466 
RTC
->
CR
 &= ((
uint32_t
)~(
RTC_CR_FMT
));

468 
RTC
->
CR
 |= ((
uint32_t
)(
RTC_InitStruct
->
RTC_HourFormat
));

471 
RTC
->
PRER
 = (
uint32_t
)(
RTC_InitStruct
->
RTC_SynchPrediv
);

472 
RTC
->
PRER
 |= (
uint32_t
)(
RTC_InitStruct
->
RTC_AsynchPrediv
 << 16);

475 
	`RTC_ExitInitMode
();

477 
status
 = 
SUCCESS
;

480 
RTC
->
WPR
 = 0xFF;

482 return 
status
;

483 
	}
}

491 void 
	$RTC_StructInit
(
RTC_InitTypeDef
* 
RTC_InitStruct
)

494 
RTC_InitStruct
->
RTC_HourFormat
 = 
RTC_HourFormat_24
;

497 
RTC_InitStruct
->
RTC_AsynchPrediv
 = (
uint32_t
)0x7F;

500 
RTC_InitStruct
->
RTC_SynchPrediv
 = (
uint32_t
)0xFF;

501 
	}
}

513 void 
	$RTC_WriteProtectionCmd
(
FunctionalState
 
NewState
)

516 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

518 if (
NewState
 != 
DISABLE
)

521 
RTC
->
WPR
 = 0xFF;

526 
RTC
->
WPR
 = 0xCA;

527 
RTC
->
WPR
 = 0x53;

529 
	}
}

540 
ErrorStatus
 
	$RTC_EnterInitMode
(void)

542 
__IO
 
uint32_t
 
initcounter
 = 0x00;

543 
ErrorStatus
 
status
 = 
ERROR
;

544 
uint32_t
 
initstatus
 = 0x00;

547 if ((
RTC
->
ISR
 & 
RTC_ISR_INITF
) == (
uint32_t
)
RESET
)

550 
RTC
->
ISR
 = (
uint32_t
)
RTC_INIT_MASK
;

555 
initstatus
 = 
RTC
->
ISR
 & 
RTC_ISR_INITF
;

556 
initcounter
++;

557 } while((
initcounter
 != 
INITMODE_TIMEOUT
) && (
initstatus
 == 0x00));

559 if ((
RTC
->
ISR
 & 
RTC_ISR_INITF
) != 
RESET
)

561 
status
 = 
SUCCESS
;

565 
status
 = 
ERROR
;

570 
status
 = 
SUCCESS
;

573 return (
status
);

574 
	}
}

585 void 
	$RTC_ExitInitMode
(void)

588 
RTC
->
ISR
 &= (
uint32_t
)~
RTC_ISR_INIT
;

589 
	}
}

607 
ErrorStatus
 
	$RTC_WaitForSynchro
(void)

609 
__IO
 
uint32_t
 
synchrocounter
 = 0;

610 
ErrorStatus
 
status
 = 
ERROR
;

611 
uint32_t
 
synchrostatus
 = 0x00;

614 
RTC
->
WPR
 = 0xCA;

615 
RTC
->
WPR
 = 0x53;

618 
RTC
->
ISR
 &= (
uint32_t
)
RTC_RSF_MASK
;

623 
synchrostatus
 = 
RTC
->
ISR
 & 
RTC_ISR_RSF
;

624 
synchrocounter
++;

625 } while((
synchrocounter
 != 
SYNCHRO_TIMEOUT
) && (
synchrostatus
 == 0x00));

627 if ((
RTC
->
ISR
 & 
RTC_ISR_RSF
) != 
RESET
)

629 
status
 = 
SUCCESS
;

633 
status
 = 
ERROR
;

637 
RTC
->
WPR
 = 0xFF;

639 return (
status
);

640 
	}
}

650 
ErrorStatus
 
	$RTC_RefClockCmd
(
FunctionalState
 
NewState
)

652 
ErrorStatus
 
status
 = 
ERROR
;

655 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

658 
RTC
->
WPR
 = 0xCA;

659 
RTC
->
WPR
 = 0x53;

662 if (
	`RTC_EnterInitMode
() == 
ERROR
)

664 
status
 = 
ERROR
;

668 if (
NewState
 != 
DISABLE
)

671 
RTC
->
CR
 |= 
RTC_CR_REFCKON
;

676 
RTC
->
CR
 &= ~
RTC_CR_REFCKON
;

679 
	`RTC_ExitInitMode
();

681 
status
 = 
SUCCESS
;

685 
RTC
->
WPR
 = 0xFF;

687 return 
status
;

688 
	}
}

698 void 
	$RTC_BypassShadowCmd
(
FunctionalState
 
NewState
)

701 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

704 
RTC
->
WPR
 = 0xCA;

705 
RTC
->
WPR
 = 0x53;

707 if (
NewState
 != 
DISABLE
)

710 
RTC
->
CR
 |= (
uint8_t
)
RTC_CR_BYPSHAD
;

715 
RTC
->
CR
 &= (
uint8_t
)~
RTC_CR_BYPSHAD
;

719 
RTC
->
WPR
 = 0xFF;

720 
	}
}

753 
ErrorStatus
 
	$RTC_SetTime
(
uint32_t
 
RTC_Format
, 
RTC_TimeTypeDef
* 
RTC_TimeStruct
)

755 
uint32_t
 
tmpreg
 = 0;

756 
ErrorStatus
 
status
 = 
ERROR
;

759 
	`assert_param
(
	`IS_RTC_FORMAT
(
RTC_Format
));

761 if (
RTC_Format
 == 
RTC_Format_BIN
)

763 if ((
RTC
->
CR
 & 
RTC_CR_FMT
) != (
uint32_t
)
RESET
)

765 
	`assert_param
(
	`IS_RTC_HOUR12
(
RTC_TimeStruct
->
RTC_Hours
));

766 
	`assert_param
(
	`IS_RTC_H12
(
RTC_TimeStruct
->
RTC_H12
));

770 
RTC_TimeStruct
->
RTC_H12
 = 0x00;

771 
	`assert_param
(
	`IS_RTC_HOUR24
(
RTC_TimeStruct
->
RTC_Hours
));

773 
	`assert_param
(
	`IS_RTC_MINUTES
(
RTC_TimeStruct
->
RTC_Minutes
));

774 
	`assert_param
(
	`IS_RTC_SECONDS
(
RTC_TimeStruct
->
RTC_Seconds
));

778 if ((
RTC
->
CR
 & 
RTC_CR_FMT
) != (
uint32_t
)
RESET
)

780 
tmpreg
 = 
	`RTC_Bcd2ToByte
(
RTC_TimeStruct
->
RTC_Hours
);

781 
	`assert_param
(
	`IS_RTC_HOUR12
(
tmpreg
));

782 
	`assert_param
(
	`IS_RTC_H12
(
RTC_TimeStruct
->
RTC_H12
));

786 
RTC_TimeStruct
->
RTC_H12
 = 0x00;

787 
	`assert_param
(
	`IS_RTC_HOUR24
(
	`RTC_Bcd2ToByte
(
RTC_TimeStruct
->
RTC_Hours
)));

789 
	`assert_param
(
	`IS_RTC_MINUTES
(
	`RTC_Bcd2ToByte
(
RTC_TimeStruct
->
RTC_Minutes
)));

790 
	`assert_param
(
	`IS_RTC_SECONDS
(
	`RTC_Bcd2ToByte
(
RTC_TimeStruct
->
RTC_Seconds
)));

794 if (
RTC_Format
 != 
RTC_Format_BIN
)

796 
tmpreg
 = (((
uint32_t
)(
RTC_TimeStruct
->
RTC_Hours
) << 16) | \

797 ((
uint32_t
)(
RTC_TimeStruct
->
RTC_Minutes
) << 8) | \

798 ((
uint32_t
)
RTC_TimeStruct
->
RTC_Seconds
) | \

799 ((
uint32_t
)(
RTC_TimeStruct
->
RTC_H12
) << 16));

803 
tmpreg
 = (
uint32_t
)(((uint32_t)
	`RTC_ByteToBcd2
(
RTC_TimeStruct
->
RTC_Hours
) << 16) | \

804 ((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_TimeStruct
->
RTC_Minutes
) << 8) | \

805 ((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_TimeStruct
->
RTC_Seconds
)) | \

806 (((
uint32_t
)
RTC_TimeStruct
->
RTC_H12
) << 16));

810 
RTC
->
WPR
 = 0xCA;

811 
RTC
->
WPR
 = 0x53;

814 if (
	`RTC_EnterInitMode
() == 
ERROR
)

816 
status
 = 
ERROR
;

821 
RTC
->
TR
 = (
uint32_t
)(
tmpreg
 & 
RTC_TR_RESERVED_MASK
);

824 
	`RTC_ExitInitMode
();

826 if(
	`RTC_WaitForSynchro
() == 
ERROR
)

828 
status
 = 
ERROR
;

832 
status
 = 
SUCCESS
;

837 
RTC
->
WPR
 = 0xFF;

839 return 
status
;

840 
	}
}

849 void 
	$RTC_TimeStructInit
(
RTC_TimeTypeDef
* 
RTC_TimeStruct
)

852 
RTC_TimeStruct
->
RTC_H12
 = 
RTC_H12_AM
;

853 
RTC_TimeStruct
->
RTC_Hours
 = 0;

854 
RTC_TimeStruct
->
RTC_Minutes
 = 0;

855 
RTC_TimeStruct
->
RTC_Seconds
 = 0;

856 
	}
}

868 void 
	$RTC_GetTime
(
uint32_t
 
RTC_Format
, 
RTC_TimeTypeDef
* 
RTC_TimeStruct
)

870 
uint32_t
 
tmpreg
 = 0;

873 
	`assert_param
(
	`IS_RTC_FORMAT
(
RTC_Format
));

876 
tmpreg
 = (
uint32_t
)(
RTC
->
TR
 & 
RTC_TR_RESERVED_MASK
);

879 
RTC_TimeStruct
->
RTC_Hours
 = (
uint8_t
)((
tmpreg
 & (
RTC_TR_HT
 | 
RTC_TR_HU
)) >> 16);

880 
RTC_TimeStruct
->
RTC_Minutes
 = (
uint8_t
)((
tmpreg
 & (
RTC_TR_MNT
 | 
RTC_TR_MNU
)) >>8);

881 
RTC_TimeStruct
->
RTC_Seconds
 = (
uint8_t
)(
tmpreg
 & (
RTC_TR_ST
 | 
RTC_TR_SU
));

882 
RTC_TimeStruct
->
RTC_H12
 = (
uint8_t
)((
tmpreg
 & (
RTC_TR_PM
)) >> 16);

885 if (
RTC_Format
 == 
RTC_Format_BIN
)

888 
RTC_TimeStruct
->
RTC_Hours
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_TimeStruct->RTC_Hours);

889 
RTC_TimeStruct
->
RTC_Minutes
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_TimeStruct->RTC_Minutes);

890 
RTC_TimeStruct
->
RTC_Seconds
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_TimeStruct->RTC_Seconds);

892 
	}
}

901 
uint32_t
 
	$RTC_GetSubSecond
(void)

903 
uint32_t
 
tmpreg
 = 0;

906 
tmpreg
 = (
uint32_t
)(
RTC
->
SSR
);

909 (void) (
RTC
->
DR
);

911 return (
tmpreg
);

912 
	}
}

926 
ErrorStatus
 
	$RTC_SetDate
(
uint32_t
 
RTC_Format
, 
RTC_DateTypeDef
* 
RTC_DateStruct
)

928 
uint32_t
 
tmpreg
 = 0;

929 
ErrorStatus
 
status
 = 
ERROR
;

932 
	`assert_param
(
	`IS_RTC_FORMAT
(
RTC_Format
));

934 if ((
RTC_Format
 == 
RTC_Format_BIN
) && ((
RTC_DateStruct
->
RTC_Month
 & 0x10) == 0x10))

936 
RTC_DateStruct
->
RTC_Month
 = (RTC_DateStruct->RTC_Month & (
uint32_t
)~(0x10)) + 0x0A;

938 if (
RTC_Format
 == 
RTC_Format_BIN
)

940 
	`assert_param
(
	`IS_RTC_YEAR
(
RTC_DateStruct
->
RTC_Year
));

941 
	`assert_param
(
	`IS_RTC_MONTH
(
RTC_DateStruct
->
RTC_Month
));

942 
	`assert_param
(
	`IS_RTC_DATE
(
RTC_DateStruct
->
RTC_Date
));

946 
	`assert_param
(
	`IS_RTC_YEAR
(
	`RTC_Bcd2ToByte
(
RTC_DateStruct
->
RTC_Year
)));

947 
tmpreg
 = 
	`RTC_Bcd2ToByte
(
RTC_DateStruct
->
RTC_Month
);

948 
	`assert_param
(
	`IS_RTC_MONTH
(
tmpreg
));

949 
tmpreg
 = 
	`RTC_Bcd2ToByte
(
RTC_DateStruct
->
RTC_Date
);

950 
	`assert_param
(
	`IS_RTC_DATE
(
tmpreg
));

952 
	`assert_param
(
	`IS_RTC_WEEKDAY
(
RTC_DateStruct
->
RTC_WeekDay
));

955 if (
RTC_Format
 != 
RTC_Format_BIN
)

957 
tmpreg
 = ((((
uint32_t
)
RTC_DateStruct
->
RTC_Year
) << 16) | \

958 (((
uint32_t
)
RTC_DateStruct
->
RTC_Month
) << 8) | \

959 ((
uint32_t
)
RTC_DateStruct
->
RTC_Date
) | \

960 (((
uint32_t
)
RTC_DateStruct
->
RTC_WeekDay
) << 13));

964 
tmpreg
 = (((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_DateStruct
->
RTC_Year
) << 16) | \

965 ((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_DateStruct
->
RTC_Month
) << 8) | \

966 ((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_DateStruct
->
RTC_Date
)) | \

967 ((
uint32_t
)
RTC_DateStruct
->
RTC_WeekDay
 << 13));

971 
RTC
->
WPR
 = 0xCA;

972 
RTC
->
WPR
 = 0x53;

975 if (
	`RTC_EnterInitMode
() == 
ERROR
)

977 
status
 = 
ERROR
;

982 
RTC
->
DR
 = (
uint32_t
)(
tmpreg
 & 
RTC_DR_RESERVED_MASK
);

985 
	`RTC_ExitInitMode
();

987 if(
	`RTC_WaitForSynchro
() == 
ERROR
)

989 
status
 = 
ERROR
;

993 
status
 = 
SUCCESS
;

997 
RTC
->
WPR
 = 0xFF;

999 return 
status
;

1000 
	}
}

1009 void 
	$RTC_DateStructInit
(
RTC_DateTypeDef
* 
RTC_DateStruct
)

1012 
RTC_DateStruct
->
RTC_WeekDay
 = 
RTC_Weekday_Monday
;

1013 
RTC_DateStruct
->
RTC_Date
 = 1;

1014 
RTC_DateStruct
->
RTC_Month
 = 
RTC_Month_January
;

1015 
RTC_DateStruct
->
RTC_Year
 = 0;

1016 
	}
}

1028 void 
	$RTC_GetDate
(
uint32_t
 
RTC_Format
, 
RTC_DateTypeDef
* 
RTC_DateStruct
)

1030 
uint32_t
 
tmpreg
 = 0;

1033 
	`assert_param
(
	`IS_RTC_FORMAT
(
RTC_Format
));

1036 
tmpreg
 = (
uint32_t
)(
RTC
->
DR
 & 
RTC_DR_RESERVED_MASK
);

1039 
RTC_DateStruct
->
RTC_Year
 = (
uint8_t
)((
tmpreg
 & (
RTC_DR_YT
 | 
RTC_DR_YU
)) >> 16);

1040 
RTC_DateStruct
->
RTC_Month
 = (
uint8_t
)((
tmpreg
 & (
RTC_DR_MT
 | 
RTC_DR_MU
)) >> 8);

1041 
RTC_DateStruct
->
RTC_Date
 = (
uint8_t
)(
tmpreg
 & (
RTC_DR_DT
 | 
RTC_DR_DU
));

1042 
RTC_DateStruct
->
RTC_WeekDay
 = (
uint8_t
)((
tmpreg
 & (
RTC_DR_WDU
)) >> 13);

1045 if (
RTC_Format
 == 
RTC_Format_BIN
)

1048 
RTC_DateStruct
->
RTC_Year
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_DateStruct->RTC_Year);

1049 
RTC_DateStruct
->
RTC_Month
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_DateStruct->RTC_Month);

1050 
RTC_DateStruct
->
RTC_Date
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_DateStruct->RTC_Date);

1051 
RTC_DateStruct
->
RTC_WeekDay
 = (
uint8_t
)(RTC_DateStruct->RTC_WeekDay);

1053 
	}
}

1089 void 
	$RTC_SetAlarm
(
uint32_t
 
RTC_Format
, uint32_t 
RTC_Alarm
, 
RTC_AlarmTypeDef
* 
RTC_AlarmStruct
)

1091 
uint32_t
 
tmpreg
 = 0;

1094 
	`assert_param
(
	`IS_RTC_FORMAT
(
RTC_Format
));

1095 
	`assert_param
(
	`IS_RTC_ALARM
(
RTC_Alarm
));

1096 
	`assert_param
(
	`IS_ALARM_MASK
(
RTC_AlarmStruct
->
RTC_AlarmMask
));

1097 
	`assert_param
(
	`IS_RTC_ALARM_DATE_WEEKDAY_SEL
(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDaySel
));

1099 if (
RTC_Format
 == 
RTC_Format_BIN
)

1101 if ((
RTC
->
CR
 & 
RTC_CR_FMT
) != (
uint32_t
)
RESET
)

1103 
	`assert_param
(
	`IS_RTC_HOUR12
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
));

1104 
	`assert_param
(
	`IS_RTC_H12
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
));

1108 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
 = 0x00;

1109 
	`assert_param
(
	`IS_RTC_HOUR24
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
));

1111 
	`assert_param
(
	`IS_RTC_MINUTES
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Minutes
));

1112 
	`assert_param
(
	`IS_RTC_SECONDS
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Seconds
));

1114 if(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDaySel
 == 
RTC_AlarmDateWeekDaySel_Date
)

1116 
	`assert_param
(
	`IS_RTC_ALARM_DATE_WEEKDAY_DATE
(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
));

1120 
	`assert_param
(
	`IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY
(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
));

1125 if ((
RTC
->
CR
 & 
RTC_CR_FMT
) != (
uint32_t
)
RESET
)

1127 
tmpreg
 = 
	`RTC_Bcd2ToByte
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
);

1128 
	`assert_param
(
	`IS_RTC_HOUR12
(
tmpreg
));

1129 
	`assert_param
(
	`IS_RTC_H12
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
));

1133 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
 = 0x00;

1134 
	`assert_param
(
	`IS_RTC_HOUR24
(
	`RTC_Bcd2ToByte
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
)));

1137 
	`assert_param
(
	`IS_RTC_MINUTES
(
	`RTC_Bcd2ToByte
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Minutes
)));

1138 
	`assert_param
(
	`IS_RTC_SECONDS
(
	`RTC_Bcd2ToByte
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Seconds
)));

1140 if(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDaySel
 == 
RTC_AlarmDateWeekDaySel_Date
)

1142 
tmpreg
 = 
	`RTC_Bcd2ToByte
(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
);

1143 
	`assert_param
(
	`IS_RTC_ALARM_DATE_WEEKDAY_DATE
(
tmpreg
));

1147 
tmpreg
 = 
	`RTC_Bcd2ToByte
(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
);

1148 
	`assert_param
(
	`IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY
(
tmpreg
));

1153 if (
RTC_Format
 != 
RTC_Format_BIN
)

1155 
tmpreg
 = (((
uint32_t
)(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
) << 16) | \

1156 ((
uint32_t
)(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Minutes
) << 8) | \

1157 ((
uint32_t
)
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Seconds
) | \

1158 ((
uint32_t
)(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
) << 16) | \

1159 ((
uint32_t
)(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
) << 24) | \

1160 ((
uint32_t
)
RTC_AlarmStruct
->
RTC_AlarmDateWeekDaySel
) | \

1161 ((
uint32_t
)
RTC_AlarmStruct
->
RTC_AlarmMask
));

1165 
tmpreg
 = (((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
) << 16) | \

1166 ((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Minutes
) << 8) | \

1167 ((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Seconds
)) | \

1168 ((
uint32_t
)(
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
) << 16) | \

1169 ((
uint32_t
)
	`RTC_ByteToBcd2
(
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
) << 24) | \

1170 ((
uint32_t
)
RTC_AlarmStruct
->
RTC_AlarmDateWeekDaySel
) | \

1171 ((
uint32_t
)
RTC_AlarmStruct
->
RTC_AlarmMask
));

1175 
RTC
->
WPR
 = 0xCA;

1176 
RTC
->
WPR
 = 0x53;

1179 if (
RTC_Alarm
 == 
RTC_Alarm_A
)

1181 
RTC
->
ALRMAR
 = (
uint32_t
)
tmpreg
;

1185 
RTC
->
ALRMBR
 = (
uint32_t
)
tmpreg
;

1189 
RTC
->
WPR
 = 0xFF;

1190 
	}
}

1200 void 
	$RTC_AlarmStructInit
(
RTC_AlarmTypeDef
* 
RTC_AlarmStruct
)

1203 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
 = 
RTC_H12_AM
;

1204 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
 = 0;

1205 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Minutes
 = 0;

1206 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Seconds
 = 0;

1209 
RTC_AlarmStruct
->
RTC_AlarmDateWeekDaySel
 = 
RTC_AlarmDateWeekDaySel_Date
;

1210 
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
 = 1;

1213 
RTC_AlarmStruct
->
RTC_AlarmMask
 = 
RTC_AlarmMask_None
;

1214 
	}
}

1230 void 
	$RTC_GetAlarm
(
uint32_t
 
RTC_Format
, uint32_t 
RTC_Alarm
, 
RTC_AlarmTypeDef
* 
RTC_AlarmStruct
)

1232 
uint32_t
 
tmpreg
 = 0;

1235 
	`assert_param
(
	`IS_RTC_FORMAT
(
RTC_Format
));

1236 
	`assert_param
(
	`IS_RTC_ALARM
(
RTC_Alarm
));

1239 if (
RTC_Alarm
 == 
RTC_Alarm_A
)

1241 
tmpreg
 = (
uint32_t
)(
RTC
->
ALRMAR
);

1245 
tmpreg
 = (
uint32_t
)(
RTC
->
ALRMBR
);

1249 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
 = (
uint32_t
)((
tmpreg
 & (
RTC_ALRMAR_HT
 | \

1250 
RTC_ALRMAR_HU
)) >> 16);

1251 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Minutes
 = (
uint32_t
)((
tmpreg
 & (
RTC_ALRMAR_MNT
 | \

1252 
RTC_ALRMAR_MNU
)) >> 8);

1253 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Seconds
 = (
uint32_t
)(
tmpreg
 & (
RTC_ALRMAR_ST
 | \

1254 
RTC_ALRMAR_SU
));

1255 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_H12
 = (
uint32_t
)((
tmpreg
 & 
RTC_ALRMAR_PM
) >> 16);

1256 
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
 = (
uint32_t
)((
tmpreg
 & (
RTC_ALRMAR_DT
 | 
RTC_ALRMAR_DU
)) >> 24);

1257 
RTC_AlarmStruct
->
RTC_AlarmDateWeekDaySel
 = (
uint32_t
)(
tmpreg
 & 
RTC_ALRMAR_WDSEL
);

1258 
RTC_AlarmStruct
->
RTC_AlarmMask
 = (
uint32_t
)(
tmpreg
 & 
RTC_AlarmMask_All
);

1260 if (
RTC_Format
 == 
RTC_Format_BIN
)

1262 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Hours
 = 
	`RTC_Bcd2ToByte
(RTC_AlarmStruct-> \

1263 
RTC_AlarmTime
.
RTC_Hours
);

1264 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Minutes
 = 
	`RTC_Bcd2ToByte
(RTC_AlarmStruct-> \

1265 
RTC_AlarmTime
.
RTC_Minutes
);

1266 
RTC_AlarmStruct
->
RTC_AlarmTime
.
RTC_Seconds
 = 
	`RTC_Bcd2ToByte
(RTC_AlarmStruct-> \

1267 
RTC_AlarmTime
.
RTC_Seconds
);

1268 
RTC_AlarmStruct
->
RTC_AlarmDateWeekDay
 = 
	`RTC_Bcd2ToByte
(RTC_AlarmStruct->RTC_AlarmDateWeekDay);

1270 
	}
}

1284 
ErrorStatus
 
	$RTC_AlarmCmd
(
uint32_t
 
RTC_Alarm
, 
FunctionalState
 
NewState
)

1286 
__IO
 
uint32_t
 
alarmcounter
 = 0x00;

1287 
uint32_t
 
alarmstatus
 = 0x00;

1288 
ErrorStatus
 
status
 = 
ERROR
;

1291 
	`assert_param
(
	`IS_RTC_CMD_ALARM
(
RTC_Alarm
));

1292 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1295 
RTC
->
WPR
 = 0xCA;

1296 
RTC
->
WPR
 = 0x53;

1299 if (
NewState
 != 
DISABLE
)

1301 
RTC
->
CR
 |= (
uint32_t
)
RTC_Alarm
;

1303 
status
 = 
SUCCESS
;

1308 
RTC
->
CR
 &= (
uint32_t
)~
RTC_Alarm
;

1313 
alarmstatus
 = 
RTC
->
ISR
 & (
RTC_Alarm
 >> 8);

1314 
alarmcounter
++;

1315 } while((
alarmcounter
 != 
INITMODE_TIMEOUT
) && (
alarmstatus
 == 0x00));

1317 if ((
RTC
->
ISR
 & (
RTC_Alarm
 >> 8)) == 
RESET
)

1319 
status
 = 
ERROR
;

1323 
status
 = 
SUCCESS
;

1328 
RTC
->
WPR
 = 0xFF;

1330 return 
status
;

1331 
	}
}

1378 void 
	$RTC_AlarmSubSecondConfig
(
uint32_t
 
RTC_Alarm
, uint32_t 
RTC_AlarmSubSecondValue
, uint32_t 
RTC_AlarmSubSecondMask
)

1380 
uint32_t
 
tmpreg
 = 0;

1383 
	`assert_param
(
	`IS_RTC_ALARM
(
RTC_Alarm
));

1384 
	`assert_param
(
	`IS_RTC_ALARM_SUB_SECOND_VALUE
(
RTC_AlarmSubSecondValue
));

1385 
	`assert_param
(
	`IS_RTC_ALARM_SUB_SECOND_MASK
(
RTC_AlarmSubSecondMask
));

1388 
RTC
->
WPR
 = 0xCA;

1389 
RTC
->
WPR
 = 0x53;

1392 
tmpreg
 = (
uint32_t
) (uint32_t)(
RTC_AlarmSubSecondValue
) | (uint32_t)(
RTC_AlarmSubSecondMask
);

1394 if (
RTC_Alarm
 == 
RTC_Alarm_A
)

1397 
RTC
->
ALRMASSR
 = 
tmpreg
;

1402 
RTC
->
ALRMBSSR
 = 
tmpreg
;

1406 
RTC
->
WPR
 = 0xFF;

1408 
	}
}

1419 
uint32_t
 
	$RTC_GetAlarmSubSecond
(
uint32_t
 
RTC_Alarm
)

1421 
uint32_t
 
tmpreg
 = 0;

1424 if (
RTC_Alarm
 == 
RTC_Alarm_A
)

1426 
tmpreg
 = (
uint32_t
)((
RTC
->
ALRMASSR
) & 
RTC_ALRMASSR_SS
);

1430 
tmpreg
 = (
uint32_t
)((
RTC
->
ALRMBSSR
) & 
RTC_ALRMBSSR_SS
);

1433 return (
tmpreg
);

1434 
	}
}

1468 void 
	$RTC_WakeUpClockConfig
(
uint32_t
 
RTC_WakeUpClock
)

1471 
	`assert_param
(
	`IS_RTC_WAKEUP_CLOCK
(
RTC_WakeUpClock
));

1474 
RTC
->
WPR
 = 0xCA;

1475 
RTC
->
WPR
 = 0x53;

1478 
RTC
->
CR
 &= (
uint32_t
)~
RTC_CR_WUCKSEL
;

1481 
RTC
->
CR
 |= (
uint32_t
)
RTC_WakeUpClock
;

1484 
RTC
->
WPR
 = 0xFF;

1485 
	}
}

1495 void 
	$RTC_SetWakeUpCounter
(
uint32_t
 
RTC_WakeUpCounter
)

1498 
	`assert_param
(
	`IS_RTC_WAKEUP_COUNTER
(
RTC_WakeUpCounter
));

1501 
RTC
->
WPR
 = 0xCA;

1502 
RTC
->
WPR
 = 0x53;

1505 
RTC
->
WUTR
 = (
uint32_t
)
RTC_WakeUpCounter
;

1508 
RTC
->
WPR
 = 0xFF;

1509 
	}
}

1516 
uint32_t
 
	$RTC_GetWakeUpCounter
(void)

1519 return ((
uint32_t
)(
RTC
->
WUTR
 & 
RTC_WUTR_WUT
));

1520 
	}
}

1528 
ErrorStatus
 
	$RTC_WakeUpCmd
(
FunctionalState
 
NewState
)

1530 
__IO
 
uint32_t
 
wutcounter
 = 0x00;

1531 
uint32_t
 
wutwfstatus
 = 0x00;

1532 
ErrorStatus
 
status
 = 
ERROR
;

1535 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1538 
RTC
->
WPR
 = 0xCA;

1539 
RTC
->
WPR
 = 0x53;

1541 if (
NewState
 != 
DISABLE
)

1544 
RTC
->
CR
 |= (
uint32_t
)
RTC_CR_WUTE
;

1545 
status
 = 
SUCCESS
;

1550 
RTC
->
CR
 &= (
uint32_t
)~
RTC_CR_WUTE
;

1554 
wutwfstatus
 = 
RTC
->
ISR
 & 
RTC_ISR_WUTWF
;

1555 
wutcounter
++;

1556 } while((
wutcounter
 != 
INITMODE_TIMEOUT
) && (
wutwfstatus
 == 0x00));

1558 if ((
RTC
->
ISR
 & 
RTC_ISR_WUTWF
) == 
RESET
)

1560 
status
 = 
ERROR
;

1564 
status
 = 
SUCCESS
;

1569 
RTC
->
WPR
 = 0xFF;

1571 return 
status
;

1572 
	}
}

1605 void 
	$RTC_DayLightSavingConfig
(
uint32_t
 
RTC_DayLightSaving
, uint32_t 
RTC_StoreOperation
)

1608 
	`assert_param
(
	`IS_RTC_DAYLIGHT_SAVING
(
RTC_DayLightSaving
));

1609 
	`assert_param
(
	`IS_RTC_STORE_OPERATION
(
RTC_StoreOperation
));

1612 
RTC
->
WPR
 = 0xCA;

1613 
RTC
->
WPR
 = 0x53;

1616 
RTC
->
CR
 &= (
uint32_t
)~(
RTC_CR_BCK
);

1619 
RTC
->
CR
 |= (
uint32_t
)(
RTC_DayLightSaving
 | 
RTC_StoreOperation
);

1622 
RTC
->
WPR
 = 0xFF;

1623 
	}
}

1632 
uint32_t
 
	$RTC_GetStoreOperation
(void)

1634 return (
RTC
->
CR
 & 
RTC_CR_BCK
);

1635 
	}
}

1671 void 
	$RTC_OutputConfig
(
uint32_t
 
RTC_Output
, uint32_t 
RTC_OutputPolarity
)

1674 
	`assert_param
(
	`IS_RTC_OUTPUT
(
RTC_Output
));

1675 
	`assert_param
(
	`IS_RTC_OUTPUT_POL
(
RTC_OutputPolarity
));

1678 
RTC
->
WPR
 = 0xCA;

1679 
RTC
->
WPR
 = 0x53;

1682 
RTC
->
CR
 &= (
uint32_t
)~(
RTC_CR_OSEL
 | 
RTC_CR_POL
);

1685 
RTC
->
CR
 |= (
uint32_t
)(
RTC_Output
 | 
RTC_OutputPolarity
);

1688 
RTC
->
WPR
 = 0xFF;

1689 
	}
}

1725 
ErrorStatus
 
	$RTC_CoarseCalibConfig
(
uint32_t
 
RTC_CalibSign
, uint32_t 
Value
)

1727 
ErrorStatus
 
status
 = 
ERROR
;

1730 
	`assert_param
(
	`IS_RTC_CALIB_SIGN
(
RTC_CalibSign
));

1731 
	`assert_param
(
	`IS_RTC_CALIB_VALUE
(
Value
));

1734 
RTC
->
WPR
 = 0xCA;

1735 
RTC
->
WPR
 = 0x53;

1738 if (
	`RTC_EnterInitMode
() == 
ERROR
)

1740 
status
 = 
ERROR
;

1745 
RTC
->
CALIBR
 = (
uint32_t
)(
RTC_CalibSign
 | 
Value
);

1747 
	`RTC_ExitInitMode
();

1749 
status
 = 
SUCCESS
;

1753 
RTC
->
WPR
 = 0xFF;

1755 return 
status
;

1756 
	}
}

1766 
ErrorStatus
 
	$RTC_CoarseCalibCmd
(
FunctionalState
 
NewState
)

1768 
ErrorStatus
 
status
 = 
ERROR
;

1771 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1774 
RTC
->
WPR
 = 0xCA;

1775 
RTC
->
WPR
 = 0x53;

1778 if (
	`RTC_EnterInitMode
() == 
ERROR
)

1780 
status
 = 
ERROR
;

1784 if (
NewState
 != 
DISABLE
)

1787 
RTC
->
CR
 |= (
uint32_t
)
RTC_CR_DCE
;

1792 
RTC
->
CR
 &= (
uint32_t
)~
RTC_CR_DCE
;

1795 
	`RTC_ExitInitMode
();

1797 
status
 = 
SUCCESS
;

1801 
RTC
->
WPR
 = 0xFF;

1803 return 
status
;

1804 
	}
}

1812 void 
	$RTC_CalibOutputCmd
(
FunctionalState
 
NewState
)

1815 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1818 
RTC
->
WPR
 = 0xCA;

1819 
RTC
->
WPR
 = 0x53;

1821 if (
NewState
 != 
DISABLE
)

1824 
RTC
->
CR
 |= (
uint32_t
)
RTC_CR_COE
;

1829 
RTC
->
CR
 &= (
uint32_t
)~
RTC_CR_COE
;

1833 
RTC
->
WPR
 = 0xFF;

1834 
	}
}

1844 void 
	$RTC_CalibOutputConfig
(
uint32_t
 
RTC_CalibOutput
)

1847 
	`assert_param
(
	`IS_RTC_CALIB_OUTPUT
(
RTC_CalibOutput
));

1850 
RTC
->
WPR
 = 0xCA;

1851 
RTC
->
WPR
 = 0x53;

1854 
RTC
->
CR
 &= (
uint32_t
)~(
RTC_CR_COSEL
);

1857 
RTC
->
CR
 |= (
uint32_t
)
RTC_CalibOutput
;

1860 
RTC
->
WPR
 = 0xFF;

1861 
	}
}

1880 
ErrorStatus
 
	$RTC_SmoothCalibConfig
(
uint32_t
 
RTC_SmoothCalibPeriod
,

1881 
uint32_t
 
RTC_SmoothCalibPlusPulses
,

1882 
uint32_t
 
RTC_SmouthCalibMinusPulsesValue
)

1884 
ErrorStatus
 
status
 = 
ERROR
;

1885 
uint32_t
 
recalpfcount
 = 0;

1888 
	`assert_param
(
	`IS_RTC_SMOOTH_CALIB_PERIOD
(
RTC_SmoothCalibPeriod
));

1889 
	`assert_param
(
	`IS_RTC_SMOOTH_CALIB_PLUS
(
RTC_SmoothCalibPlusPulses
));

1890 
	`assert_param
(
	`IS_RTC_SMOOTH_CALIB_MINUS
(
RTC_SmouthCalibMinusPulsesValue
));

1893 
RTC
->
WPR
 = 0xCA;

1894 
RTC
->
WPR
 = 0x53;

1897 if ((
RTC
->
ISR
 & 
RTC_ISR_RECALPF
) != 
RESET
)

1900 while (((
RTC
->
ISR
 & 
RTC_ISR_RECALPF
) != 
RESET
) && (
recalpfcount
 != 
RECALPF_TIMEOUT
))

1902 
recalpfcount
++;

1907 if ((
RTC
->
ISR
 & 
RTC_ISR_RECALPF
) == 
RESET
)

1910 
RTC
->
CALR
 = (
uint32_t
)((uint32_t)
RTC_SmoothCalibPeriod
 | (uint32_t)
RTC_SmoothCalibPlusPulses
 | (uint32_t)
RTC_SmouthCalibMinusPulsesValue
);

1912 
status
 = 
SUCCESS
;

1916 
status
 = 
ERROR
;

1920 
RTC
->
WPR
 = 0xFF;

1922 return (
ErrorStatus
)(
status
);

1923 
	}
}

1956 void 
	$RTC_TimeStampCmd
(
uint32_t
 
RTC_TimeStampEdge
, 
FunctionalState
 
NewState
)

1958 
uint32_t
 
tmpreg
 = 0;

1961 
	`assert_param
(
	`IS_RTC_TIMESTAMP_EDGE
(
RTC_TimeStampEdge
));

1962 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1965 
tmpreg
 = (
uint32_t
)(
RTC
->
CR
 & (uint32_t)~(
RTC_CR_TSEDGE
 | 
RTC_CR_TSE
));

1968 if (
NewState
 != 
DISABLE
)

1970 
tmpreg
 |= (
uint32_t
)(
RTC_TimeStampEdge
 | 
RTC_CR_TSE
);

1974 
tmpreg
 |= (
uint32_t
)(
RTC_TimeStampEdge
);

1978 
RTC
->
WPR
 = 0xCA;

1979 
RTC
->
WPR
 = 0x53;

1982 
RTC
->
CR
 = (
uint32_t
)
tmpreg
;

1985 
RTC
->
WPR
 = 0xFF;

1986 
	}
}

2000 void 
	$RTC_GetTimeStamp
(
uint32_t
 
RTC_Format
, 
RTC_TimeTypeDef
* 
RTC_StampTimeStruct
,

2001 
RTC_DateTypeDef
* 
RTC_StampDateStruct
)

2003 
uint32_t
 
tmptime
 = 0, 
tmpdate
 = 0;

2006 
	`assert_param
(
	`IS_RTC_FORMAT
(
RTC_Format
));

2009 
tmptime
 = (
uint32_t
)(
RTC
->
TSTR
 & 
RTC_TR_RESERVED_MASK
);

2010 
tmpdate
 = (
uint32_t
)(
RTC
->
TSDR
 & 
RTC_DR_RESERVED_MASK
);

2013 
RTC_StampTimeStruct
->
RTC_Hours
 = (
uint8_t
)((
tmptime
 & (
RTC_TR_HT
 | 
RTC_TR_HU
)) >> 16);

2014 
RTC_StampTimeStruct
->
RTC_Minutes
 = (
uint8_t
)((
tmptime
 & (
RTC_TR_MNT
 | 
RTC_TR_MNU
)) >> 8);

2015 
RTC_StampTimeStruct
->
RTC_Seconds
 = (
uint8_t
)(
tmptime
 & (
RTC_TR_ST
 | 
RTC_TR_SU
));

2016 
RTC_StampTimeStruct
->
RTC_H12
 = (
uint8_t
)((
tmptime
 & (
RTC_TR_PM
)) >> 16);

2019 
RTC_StampDateStruct
->
RTC_Year
 = 0;

2020 
RTC_StampDateStruct
->
RTC_Month
 = (
uint8_t
)((
tmpdate
 & (
RTC_DR_MT
 | 
RTC_DR_MU
)) >> 8);

2021 
RTC_StampDateStruct
->
RTC_Date
 = (
uint8_t
)(
tmpdate
 & (
RTC_DR_DT
 | 
RTC_DR_DU
));

2022 
RTC_StampDateStruct
->
RTC_WeekDay
 = (
uint8_t
)((
tmpdate
 & (
RTC_DR_WDU
)) >> 13);

2025 if (
RTC_Format
 == 
RTC_Format_BIN
)

2028 
RTC_StampTimeStruct
->
RTC_Hours
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_StampTimeStruct->RTC_Hours);

2029 
RTC_StampTimeStruct
->
RTC_Minutes
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_StampTimeStruct->RTC_Minutes);

2030 
RTC_StampTimeStruct
->
RTC_Seconds
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_StampTimeStruct->RTC_Seconds);

2033 
RTC_StampDateStruct
->
RTC_Month
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_StampDateStruct->RTC_Month);

2034 
RTC_StampDateStruct
->
RTC_Date
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_StampDateStruct->RTC_Date);

2035 
RTC_StampDateStruct
->
RTC_WeekDay
 = (
uint8_t
)
	`RTC_Bcd2ToByte
(RTC_StampDateStruct->RTC_WeekDay);

2037 
	}
}

2044 
uint32_t
 
	$RTC_GetTimeStampSubSecond
(void)

2047 return (
uint32_t
)(
RTC
->
TSSSR
);

2048 
	}
}

2079 void 
	$RTC_TamperTriggerConfig
(
uint32_t
 
RTC_Tamper
, uint32_t 
RTC_TamperTrigger
)

2082 
	`assert_param
(
	`IS_RTC_TAMPER
(
RTC_Tamper
));

2083 
	`assert_param
(
	`IS_RTC_TAMPER_TRIGGER
(
RTC_TamperTrigger
));

2085 if (
RTC_TamperTrigger
 == 
RTC_TamperTrigger_RisingEdge
)

2088 
RTC
->
TAFCR
 &= (
uint32_t
)((uint32_t)~(
RTC_Tamper
 << 1));

2093 
RTC
->
TAFCR
 |= (
uint32_t
)(
RTC_Tamper
 << 1);

2095 
	}
}

2105 void 
	$RTC_TamperCmd
(
uint32_t
 
RTC_Tamper
, 
FunctionalState
 
NewState
)

2108 
	`assert_param
(
	`IS_RTC_TAMPER
(
RTC_Tamper
));

2109 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2111 if (
NewState
 != 
DISABLE
)

2114 
RTC
->
TAFCR
 |= (
uint32_t
)
RTC_Tamper
;

2119 
RTC
->
TAFCR
 &= (
uint32_t
)~
RTC_Tamper
;

2121 
	}
}

2136 void 
	$RTC_TamperFilterConfig
(
uint32_t
 
RTC_TamperFilter
)

2139 
	`assert_param
(
	`IS_RTC_TAMPER_FILTER
(
RTC_TamperFilter
));

2142 
RTC
->
TAFCR
 &= (
uint32_t
)~(
RTC_TAFCR_TAMPFLT
);

2145 
RTC
->
TAFCR
 |= (
uint32_t
)
RTC_TamperFilter
;

2146 
	}
}

2170 void 
	$RTC_TamperSamplingFreqConfig
(
uint32_t
 
RTC_TamperSamplingFreq
)

2173 
	`assert_param
(
	`IS_RTC_TAMPER_SAMPLING_FREQ
(
RTC_TamperSamplingFreq
));

2176 
RTC
->
TAFCR
 &= (
uint32_t
)~(
RTC_TAFCR_TAMPFREQ
);

2179 
RTC
->
TAFCR
 |= (
uint32_t
)
RTC_TamperSamplingFreq
;

2180 
	}
}

2193 void 
	$RTC_TamperPinsPrechargeDuration
(
uint32_t
 
RTC_TamperPrechargeDuration
)

2196 
	`assert_param
(
	`IS_RTC_TAMPER_PRECHARGE_DURATION
(
RTC_TamperPrechargeDuration
));

2199 
RTC
->
TAFCR
 &= (
uint32_t
)~(
RTC_TAFCR_TAMPPRCH
);

2202 
RTC
->
TAFCR
 |= (
uint32_t
)
RTC_TamperPrechargeDuration
;

2203 
	}
}

2213 void 
	$RTC_TimeStampOnTamperDetectionCmd
(
FunctionalState
 
NewState
)

2216 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2218 if (
NewState
 != 
DISABLE
)

2221 
RTC
->
TAFCR
 |= (
uint32_t
)
RTC_TAFCR_TAMPTS
;

2226 
RTC
->
TAFCR
 &= (
uint32_t
)~
RTC_TAFCR_TAMPTS
;

2228 
	}
}

2236 void 
	$RTC_TamperPullUpCmd
(
FunctionalState
 
NewState
)

2239 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2241 if (
NewState
 != 
DISABLE
)

2244 
RTC
->
TAFCR
 &= (
uint32_t
)~
RTC_TAFCR_TAMPPUDIS
;

2249 
RTC
->
TAFCR
 |= (
uint32_t
)
RTC_TAFCR_TAMPPUDIS
;

2251 
	}
}

2277 void 
	$RTC_WriteBackupRegister
(
uint32_t
 
RTC_BKP_DR
, uint32_t 
Data
)

2279 
__IO
 
uint32_t
 
tmp
 = 0;

2282 
	`assert_param
(
	`IS_RTC_BKP
(
RTC_BKP_DR
));

2284 
tmp
 = 
RTC_BASE
 + 0x50;

2285 
tmp
 += (
RTC_BKP_DR
 * 4);

2288 *(
__IO
 
uint32_t
 *)
tmp
 = (uint32_t)
Data
;

2289 
	}
}

2298 
uint32_t
 
	$RTC_ReadBackupRegister
(
uint32_t
 
RTC_BKP_DR
)

2300 
__IO
 
uint32_t
 
tmp
 = 0;

2303 
	`assert_param
(
	`IS_RTC_BKP
(
RTC_BKP_DR
));

2305 
tmp
 = 
RTC_BASE
 + 0x50;

2306 
tmp
 += (
RTC_BKP_DR
 * 4);

2309 return (*(
__IO
 
uint32_t
 *)
tmp
);

2310 
	}
}

2338 void 
	$RTC_TamperPinSelection
(
uint32_t
 
RTC_TamperPin
)

2341 
	`assert_param
(
	`IS_RTC_TAMPER_PIN
(
RTC_TamperPin
));

2343 
RTC
->
TAFCR
 &= (
uint32_t
)~(
RTC_TAFCR_TAMPINSEL
);

2344 
RTC
->
TAFCR
 |= (
uint32_t
)(
RTC_TamperPin
);

2345 
	}
}

2355 void 
	$RTC_TimeStampPinSelection
(
uint32_t
 
RTC_TimeStampPin
)

2358 
	`assert_param
(
	`IS_RTC_TIMESTAMP_PIN
(
RTC_TimeStampPin
));

2360 
RTC
->
TAFCR
 &= (
uint32_t
)~(
RTC_TAFCR_TSINSEL
);

2361 
RTC
->
TAFCR
 |= (
uint32_t
)(
RTC_TimeStampPin
);

2362 
	}
}

2374 void 
	$RTC_OutputTypeConfig
(
uint32_t
 
RTC_OutputType
)

2377 
	`assert_param
(
	`IS_RTC_OUTPUT_TYPE
(
RTC_OutputType
));

2379 
RTC
->
TAFCR
 &= (
uint32_t
)~(
RTC_TAFCR_ALARMOUTTYPE
);

2380 
RTC
->
TAFCR
 |= (
uint32_t
)(
RTC_OutputType
);

2381 
	}
}

2412 
ErrorStatus
 
	$RTC_SynchroShiftConfig
(
uint32_t
 
RTC_ShiftAdd1S
, uint32_t 
RTC_ShiftSubFS
)

2414 
ErrorStatus
 
status
 = 
ERROR
;

2415 
uint32_t
 
shpfcount
 = 0;

2418 
	`assert_param
(
	`IS_RTC_SHIFT_ADD1S
(
RTC_ShiftAdd1S
));

2419 
	`assert_param
(
	`IS_RTC_SHIFT_SUBFS
(
RTC_ShiftSubFS
));

2422 
RTC
->
WPR
 = 0xCA;

2423 
RTC
->
WPR
 = 0x53;

2426 if ((
RTC
->
ISR
 & 
RTC_ISR_SHPF
) != 
RESET
)

2429 while (((
RTC
->
ISR
 & 
RTC_ISR_SHPF
) != 
RESET
) && (
shpfcount
 != 
SHPF_TIMEOUT
))

2431 
shpfcount
++;

2436 if ((
RTC
->
ISR
 & 
RTC_ISR_SHPF
) == 
RESET
)

2439 if((
RTC
->
CR
 & 
RTC_CR_REFCKON
) == 
RESET
)

2442 
RTC
->
SHIFTR
 = (
uint32_t
)(uint32_t)(
RTC_ShiftSubFS
) | (uint32_t)(
RTC_ShiftAdd1S
);

2444 if(
	`RTC_WaitForSynchro
() == 
ERROR
)

2446 
status
 = 
ERROR
;

2450 
status
 = 
SUCCESS
;

2455 
status
 = 
ERROR
;

2460 
status
 = 
ERROR
;

2464 
RTC
->
WPR
 = 0xFF;

2466 return (
ErrorStatus
)(
status
);

2467 
	}
}

2531 void 
	$RTC_ITConfig
(
uint32_t
 
RTC_IT
, 
FunctionalState
 
NewState
)

2534 
	`assert_param
(
	`IS_RTC_CONFIG_IT
(
RTC_IT
));

2535 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2538 
RTC
->
WPR
 = 0xCA;

2539 
RTC
->
WPR
 = 0x53;

2541 if (
NewState
 != 
DISABLE
)

2544 
RTC
->
CR
 |= (
uint32_t
)(
RTC_IT
 & ~
RTC_TAFCR_TAMPIE
);

2546 
RTC
->
TAFCR
 |= (
uint32_t
)(
RTC_IT
 & 
RTC_TAFCR_TAMPIE
);

2551 
RTC
->
CR
 &= (
uint32_t
)~(
RTC_IT
 & (uint32_t)~
RTC_TAFCR_TAMPIE
);

2553 
RTC
->
TAFCR
 &= (
uint32_t
)~(
RTC_IT
 & 
RTC_TAFCR_TAMPIE
);

2556 
RTC
->
WPR
 = 0xFF;

2557 
	}
}

2577 
FlagStatus
 
	$RTC_GetFlagStatus
(
uint32_t
 
RTC_FLAG
)

2579 
FlagStatus
 
bitstatus
 = 
RESET
;

2580 
uint32_t
 
tmpreg
 = 0;

2583 
	`assert_param
(
	`IS_RTC_GET_FLAG
(
RTC_FLAG
));

2586 
tmpreg
 = (
uint32_t
)(
RTC
->
ISR
 & 
RTC_FLAGS_MASK
);

2589 if ((
tmpreg
 & 
RTC_FLAG
) != (
uint32_t
)
RESET
)

2591 
bitstatus
 = 
SET
;

2595 
bitstatus
 = 
RESET
;

2597 return 
bitstatus
;

2598 
	}
}

2613 void 
	$RTC_ClearFlag
(
uint32_t
 
RTC_FLAG
)

2616 
	`assert_param
(
	`IS_RTC_CLEAR_FLAG
(
RTC_FLAG
));

2619 
RTC
->
ISR
 = (
uint32_t
)((uint32_t)(~((
RTC_FLAG
 | 
RTC_ISR_INIT
)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));

2620 
	}
}

2633 
ITStatus
 
	$RTC_GetITStatus
(
uint32_t
 
RTC_IT
)

2635 
ITStatus
 
bitstatus
 = 
RESET
;

2636 
uint32_t
 
tmpreg
 = 0, 
enablestatus
 = 0;

2639 
	`assert_param
(
	`IS_RTC_GET_IT
(
RTC_IT
));

2642 
tmpreg
 = (
uint32_t
)(
RTC
->
TAFCR
 & (
RTC_TAFCR_TAMPIE
));

2645 
enablestatus
 = (
uint32_t
)((
RTC
->
CR
 & 
RTC_IT
) | (
tmpreg
 & (RTC_IT >> 15)));

2648 
tmpreg
 = (
uint32_t
)((
RTC
->
ISR
 & (uint32_t)(
RTC_IT
 >> 4)));

2651 if ((
enablestatus
 != (
uint32_t
)
RESET
) && ((
tmpreg
 & 0x0000FFFF) != (uint32_t)RESET))

2653 
bitstatus
 = 
SET
;

2657 
bitstatus
 = 
RESET
;

2659 return 
bitstatus
;

2660 
	}
}

2673 void 
	$RTC_ClearITPendingBit
(
uint32_t
 
RTC_IT
)

2675 
uint32_t
 
tmpreg
 = 0;

2678 
	`assert_param
(
	`IS_RTC_CLEAR_IT
(
RTC_IT
));

2681 
tmpreg
 = (
uint32_t
)(
RTC_IT
 >> 4);

2684 
RTC
->
ISR
 = (
uint32_t
)((uint32_t)(~((
tmpreg
 | 
RTC_ISR_INIT
)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));

2685 
	}
}

2696 static 
uint8_t
 
	$RTC_ByteToBcd2
(
uint8_t
 
Value
)

2698 
uint8_t
 
bcdhigh
 = 0;

2700 while (
Value
 >= 10)

2702 
bcdhigh
++;

2703 
Value
 -= 10;

2706 return ((
uint8_t
)(
bcdhigh
 << 4) | 
Value
);

2707 
	}
}

2714 static 
uint8_t
 
	$RTC_Bcd2ToByte
(
uint8_t
 
Value
)

2716 
uint8_t
 
tmp
 = 0;

2717 
tmp
 = ((
uint8_t
)(
Value
 & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;

2718 return (
tmp
 + (
Value
 & (
uint8_t
)0x0F));

2719 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sdio.c

149 #include 
	~"stm32f4xx_sdio.h
"

150 #include 
	~"stm32f4xx_rcc.h
"

165 #define 
	#SDIO_OFFSET
 (
SDIO_BASE
 - 
PERIPH_BASE
)

	)

169 #define 
	#CLKCR_OFFSET
 (
SDIO_OFFSET
 + 0x04)

	)

170 #define 
	#CLKEN_BitNumber
 0x08

	)

171 #define 
	#CLKCR_CLKEN_BB
 (
PERIPH_BB_BASE
 + (
CLKCR_OFFSET
 * 32) + (
CLKEN_BitNumber
 * 4))

	)

175 #define 
	#CMD_OFFSET
 (
SDIO_OFFSET
 + 0x0C)

	)

176 #define 
	#SDIOSUSPEND_BitNumber
 0x0B

	)

177 #define 
	#CMD_SDIOSUSPEND_BB
 (
PERIPH_BB_BASE
 + (
CMD_OFFSET
 * 32) + (
SDIOSUSPEND_BitNumber
 * 4))

	)

180 #define 
	#ENCMDCOMPL_BitNumber
 0x0C

	)

181 #define 
	#CMD_ENCMDCOMPL_BB
 (
PERIPH_BB_BASE
 + (
CMD_OFFSET
 * 32) + (
ENCMDCOMPL_BitNumber
 * 4))

	)

184 #define 
	#NIEN_BitNumber
 0x0D

	)

185 #define 
	#CMD_NIEN_BB
 (
PERIPH_BB_BASE
 + (
CMD_OFFSET
 * 32) + (
NIEN_BitNumber
 * 4))

	)

188 #define 
	#ATACMD_BitNumber
 0x0E

	)

189 #define 
	#CMD_ATACMD_BB
 (
PERIPH_BB_BASE
 + (
CMD_OFFSET
 * 32) + (
ATACMD_BitNumber
 * 4))

	)

193 #define 
	#DCTRL_OFFSET
 (
SDIO_OFFSET
 + 0x2C)

	)

194 #define 
	#DMAEN_BitNumber
 0x03

	)

195 #define 
	#DCTRL_DMAEN_BB
 (
PERIPH_BB_BASE
 + (
DCTRL_OFFSET
 * 32) + (
DMAEN_BitNumber
 * 4))

	)

198 #define 
	#RWSTART_BitNumber
 0x08

	)

199 #define 
	#DCTRL_RWSTART_BB
 (
PERIPH_BB_BASE
 + (
DCTRL_OFFSET
 * 32) + (
RWSTART_BitNumber
 * 4))

	)

202 #define 
	#RWSTOP_BitNumber
 0x09

	)

203 #define 
	#DCTRL_RWSTOP_BB
 (
PERIPH_BB_BASE
 + (
DCTRL_OFFSET
 * 32) + (
RWSTOP_BitNumber
 * 4))

	)

206 #define 
	#RWMOD_BitNumber
 0x0A

	)

207 #define 
	#DCTRL_RWMOD_BB
 (
PERIPH_BB_BASE
 + (
DCTRL_OFFSET
 * 32) + (
RWMOD_BitNumber
 * 4))

	)

210 #define 
	#SDIOEN_BitNumber
 0x0B

	)

211 #define 
	#DCTRL_SDIOEN_BB
 (
PERIPH_BB_BASE
 + (
DCTRL_OFFSET
 * 32) + (
SDIOEN_BitNumber
 * 4))

	)

216 #define 
	#CLKCR_CLEAR_MASK
 ((
uint32_t
)0xFFFF8100)

	)

220 #define 
	#PWR_PWRCTRL_MASK
 ((
uint32_t
)0xFFFFFFFC)

	)

224 #define 
	#DCTRL_CLEAR_MASK
 ((
uint32_t
)0xFFFFFF08)

	)

228 #define 
	#CMD_CLEAR_MASK
 ((
uint32_t
)0xFFFFF800)

	)

231 #define 
	#SDIO_RESP_ADDR
 ((
uint32_t
)(
SDIO_BASE
 + 0x14))

	)

259 void 
	$SDIO_DeInit
(void)

261 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_SDIO
, 
ENABLE
);

262 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_SDIO
, 
DISABLE
);

263 
	}
}

272 void 
	$SDIO_Init
(
SDIO_InitTypeDef
* 
SDIO_InitStruct
)

274 
uint32_t
 
tmpreg
 = 0;

277 
	`assert_param
(
	`IS_SDIO_CLOCK_EDGE
(
SDIO_InitStruct
->
SDIO_ClockEdge
));

278 
	`assert_param
(
	`IS_SDIO_CLOCK_BYPASS
(
SDIO_InitStruct
->
SDIO_ClockBypass
));

279 
	`assert_param
(
	`IS_SDIO_CLOCK_POWER_SAVE
(
SDIO_InitStruct
->
SDIO_ClockPowerSave
));

280 
	`assert_param
(
	`IS_SDIO_BUS_WIDE
(
SDIO_InitStruct
->
SDIO_BusWide
));

281 
	`assert_param
(
	`IS_SDIO_HARDWARE_FLOW_CONTROL
(
SDIO_InitStruct
->
SDIO_HardwareFlowControl
));

285 
tmpreg
 = 
SDIO
->
CLKCR
;

288 
tmpreg
 &= 
CLKCR_CLEAR_MASK
;

296 
tmpreg
 |= (
SDIO_InitStruct
->
SDIO_ClockDiv
 | SDIO_InitStruct->
SDIO_ClockPowerSave
 |

297 
SDIO_InitStruct
->
SDIO_ClockBypass
 | SDIO_InitStruct->
SDIO_BusWide
 |

298 
SDIO_InitStruct
->
SDIO_ClockEdge
 | SDIO_InitStruct->
SDIO_HardwareFlowControl
);

301 
SDIO
->
CLKCR
 = 
tmpreg
;

302 
	}
}

310 void 
	$SDIO_StructInit
(
SDIO_InitTypeDef
* 
SDIO_InitStruct
)

313 
SDIO_InitStruct
->
SDIO_ClockDiv
 = 0x00;

314 
SDIO_InitStruct
->
SDIO_ClockEdge
 = 
SDIO_ClockEdge_Rising
;

315 
SDIO_InitStruct
->
SDIO_ClockBypass
 = 
SDIO_ClockBypass_Disable
;

316 
SDIO_InitStruct
->
SDIO_ClockPowerSave
 = 
SDIO_ClockPowerSave_Disable
;

317 
SDIO_InitStruct
->
SDIO_BusWide
 = 
SDIO_BusWide_1b
;

318 
SDIO_InitStruct
->
SDIO_HardwareFlowControl
 = 
SDIO_HardwareFlowControl_Disable
;

319 
	}
}

327 void 
	$SDIO_ClockCmd
(
FunctionalState
 
NewState
)

330 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

332 *(
__IO
 
uint32_t
 *) 
CLKCR_CLKEN_BB
 = (uint32_t)
NewState
;

333 
	}
}

343 void 
	$SDIO_SetPowerState
(
uint32_t
 
SDIO_PowerState
)

346 
	`assert_param
(
	`IS_SDIO_POWER_STATE
(
SDIO_PowerState
));

348 
SDIO
->
POWER
 = 
SDIO_PowerState
;

349 
	}
}

360 
uint32_t
 
	$SDIO_GetPowerState
(void)

362 return (
SDIO
->
POWER
 & (~
PWR_PWRCTRL_MASK
));

363 
	}
}

392 void 
	$SDIO_SendCommand
(
SDIO_CmdInitTypeDef
 *
SDIO_CmdInitStruct
)

394 
uint32_t
 
tmpreg
 = 0;

397 
	`assert_param
(
	`IS_SDIO_CMD_INDEX
(
SDIO_CmdInitStruct
->
SDIO_CmdIndex
));

398 
	`assert_param
(
	`IS_SDIO_RESPONSE
(
SDIO_CmdInitStruct
->
SDIO_Response
));

399 
	`assert_param
(
	`IS_SDIO_WAIT
(
SDIO_CmdInitStruct
->
SDIO_Wait
));

400 
	`assert_param
(
	`IS_SDIO_CPSM
(
SDIO_CmdInitStruct
->
SDIO_CPSM
));

404 
SDIO
->
ARG
 = 
SDIO_CmdInitStruct
->
SDIO_Argument
;

408 
tmpreg
 = 
SDIO
->
CMD
;

410 
tmpreg
 &= 
CMD_CLEAR_MASK
;

415 
tmpreg
 |= (
uint32_t
)
SDIO_CmdInitStruct
->
SDIO_CmdIndex
 | SDIO_CmdInitStruct->
SDIO_Response


416 | 
SDIO_CmdInitStruct
->
SDIO_Wait
 | SDIO_CmdInitStruct->
SDIO_CPSM
;

419 
SDIO
->
CMD
 = 
tmpreg
;

420 
	}
}

428 void 
	$SDIO_CmdStructInit
(
SDIO_CmdInitTypeDef
* 
SDIO_CmdInitStruct
)

431 
SDIO_CmdInitStruct
->
SDIO_Argument
 = 0x00;

432 
SDIO_CmdInitStruct
->
SDIO_CmdIndex
 = 0x00;

433 
SDIO_CmdInitStruct
->
SDIO_Response
 = 
SDIO_Response_No
;

434 
SDIO_CmdInitStruct
->
SDIO_Wait
 = 
SDIO_Wait_No
;

435 
SDIO_CmdInitStruct
->
SDIO_CPSM
 = 
SDIO_CPSM_Disable
;

436 
	}
}

443 
uint8_t
 
	$SDIO_GetCommandResponse
(void)

445 return (
uint8_t
)(
SDIO
->
RESPCMD
);

446 
	}
}

458 
uint32_t
 
	$SDIO_GetResponse
(
uint32_t
 
SDIO_RESP
)

460 
__IO
 
uint32_t
 
tmp
 = 0;

463 
	`assert_param
(
	`IS_SDIO_RESP
(
SDIO_RESP
));

465 
tmp
 = 
SDIO_RESP_ADDR
 + 
SDIO_RESP
;

467 return (*(
__IO
 
uint32_t
 *) 
tmp
);

468 
	}
}

496 void 
	$SDIO_DataConfig
(
SDIO_DataInitTypeDef
* 
SDIO_DataInitStruct
)

498 
uint32_t
 
tmpreg
 = 0;

501 
	`assert_param
(
	`IS_SDIO_DATA_LENGTH
(
SDIO_DataInitStruct
->
SDIO_DataLength
));

502 
	`assert_param
(
	`IS_SDIO_BLOCK_SIZE
(
SDIO_DataInitStruct
->
SDIO_DataBlockSize
));

503 
	`assert_param
(
	`IS_SDIO_TRANSFER_DIR
(
SDIO_DataInitStruct
->
SDIO_TransferDir
));

504 
	`assert_param
(
	`IS_SDIO_TRANSFER_MODE
(
SDIO_DataInitStruct
->
SDIO_TransferMode
));

505 
	`assert_param
(
	`IS_SDIO_DPSM
(
SDIO_DataInitStruct
->
SDIO_DPSM
));

509 
SDIO
->
DTIMER
 = 
SDIO_DataInitStruct
->
SDIO_DataTimeOut
;

513 
SDIO
->
DLEN
 = 
SDIO_DataInitStruct
->
SDIO_DataLength
;

517 
tmpreg
 = 
SDIO
->
DCTRL
;

519 
tmpreg
 &= 
DCTRL_CLEAR_MASK
;

524 
tmpreg
 |= (
uint32_t
)
SDIO_DataInitStruct
->
SDIO_DataBlockSize
 | SDIO_DataInitStruct->
SDIO_TransferDir


525 | 
SDIO_DataInitStruct
->
SDIO_TransferMode
 | SDIO_DataInitStruct->
SDIO_DPSM
;

528 
SDIO
->
DCTRL
 = 
tmpreg
;

529 
	}
}

537 void 
	$SDIO_DataStructInit
(
SDIO_DataInitTypeDef
* 
SDIO_DataInitStruct
)

540 
SDIO_DataInitStruct
->
SDIO_DataTimeOut
 = 0xFFFFFFFF;

541 
SDIO_DataInitStruct
->
SDIO_DataLength
 = 0x00;

542 
SDIO_DataInitStruct
->
SDIO_DataBlockSize
 = 
SDIO_DataBlockSize_1b
;

543 
SDIO_DataInitStruct
->
SDIO_TransferDir
 = 
SDIO_TransferDir_ToCard
;

544 
SDIO_DataInitStruct
->
SDIO_TransferMode
 = 
SDIO_TransferMode_Block
;

545 
SDIO_DataInitStruct
->
SDIO_DPSM
 = 
SDIO_DPSM_Disable
;

546 
	}
}

553 
uint32_t
 
	$SDIO_GetDataCounter
(void)

555 return 
SDIO
->
DCOUNT
;

556 
	}
}

563 
uint32_t
 
	$SDIO_ReadData
(void)

565 return 
SDIO
->
FIFO
;

566 
	}
}

573 void 
	$SDIO_WriteData
(
uint32_t
 
Data
)

575 
SDIO
->
FIFO
 = 
Data
;

576 
	}
}

583 
uint32_t
 
	$SDIO_GetFIFOCount
(void)

585 return 
SDIO
->
FIFOCNT
;

586 
	}
}

612 void 
	$SDIO_StartSDIOReadWait
(
FunctionalState
 
NewState
)

615 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

617 *(
__IO
 
uint32_t
 *) 
DCTRL_RWSTART_BB
 = (uint32_t) 
NewState
;

618 
	}
}

626 void 
	$SDIO_StopSDIOReadWait
(
FunctionalState
 
NewState
)

629 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

631 *(
__IO
 
uint32_t
 *) 
DCTRL_RWSTOP_BB
 = (uint32_t) 
NewState
;

632 
	}
}

642 void 
	$SDIO_SetSDIOReadWaitMode
(
uint32_t
 
SDIO_ReadWaitMode
)

645 
	`assert_param
(
	`IS_SDIO_READWAIT_MODE
(
SDIO_ReadWaitMode
));

647 *(
__IO
 
uint32_t
 *) 
DCTRL_RWMOD_BB
 = 
SDIO_ReadWaitMode
;

648 
	}
}

656 void 
	$SDIO_SetSDIOOperation
(
FunctionalState
 
NewState
)

659 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

661 *(
__IO
 
uint32_t
 *) 
DCTRL_SDIOEN_BB
 = (uint32_t)
NewState
;

662 
	}
}

670 void 
	$SDIO_SendSDIOSuspendCmd
(
FunctionalState
 
NewState
)

673 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

675 *(
__IO
 
uint32_t
 *) 
CMD_SDIOSUSPEND_BB
 = (uint32_t)
NewState
;

676 
	}
}

702 void 
	$SDIO_CommandCompletionCmd
(
FunctionalState
 
NewState
)

705 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

707 *(
__IO
 
uint32_t
 *) 
CMD_ENCMDCOMPL_BB
 = (uint32_t)
NewState
;

708 
	}
}

716 void 
	$SDIO_CEATAITCmd
(
FunctionalState
 
NewState
)

719 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

721 *(
__IO
 
uint32_t
 *) 
CMD_NIEN_BB
 = (uint32_t)((~((uint32_t)
NewState
)) & ((uint32_t)0x1));

722 
	}
}

730 void 
	$SDIO_SendCEATACmd
(
FunctionalState
 
NewState
)

733 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

735 *(
__IO
 
uint32_t
 *) 
CMD_ATACMD_BB
 = (uint32_t)
NewState
;

736 
	}
}

762 void 
	$SDIO_DMACmd
(
FunctionalState
 
NewState
)

765 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

767 *(
__IO
 
uint32_t
 *) 
DCTRL_DMAEN_BB
 = (uint32_t)
NewState
;

768 
	}
}

820 void 
	$SDIO_ITConfig
(
uint32_t
 
SDIO_IT
, 
FunctionalState
 
NewState
)

823 
	`assert_param
(
	`IS_SDIO_IT
(
SDIO_IT
));

824 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

826 if (
NewState
 != 
DISABLE
)

829 
SDIO
->
MASK
 |= 
SDIO_IT
;

834 
SDIO
->
MASK
 &= ~
SDIO_IT
;

836 
	}
}

868 
FlagStatus
 
	$SDIO_GetFlagStatus
(
uint32_t
 
SDIO_FLAG
)

870 
FlagStatus
 
bitstatus
 = 
RESET
;

873 
	`assert_param
(
	`IS_SDIO_FLAG
(
SDIO_FLAG
));

875 if ((
SDIO
->
STA
 & 
SDIO_FLAG
) != (
uint32_t
)
RESET
)

877 
bitstatus
 = 
SET
;

881 
bitstatus
 = 
RESET
;

883 return 
bitstatus
;

884 
	}
}

905 void 
	$SDIO_ClearFlag
(
uint32_t
 
SDIO_FLAG
)

908 
	`assert_param
(
	`IS_SDIO_CLEAR_FLAG
(
SDIO_FLAG
));

910 
SDIO
->
ICR
 = 
SDIO_FLAG
;

911 
	}
}

944 
ITStatus
 
	$SDIO_GetITStatus
(
uint32_t
 
SDIO_IT
)

946 
ITStatus
 
bitstatus
 = 
RESET
;

949 
	`assert_param
(
	`IS_SDIO_GET_IT
(
SDIO_IT
));

950 if ((
SDIO
->
STA
 & 
SDIO_IT
) != (
uint32_t
)
RESET
)

952 
bitstatus
 = 
SET
;

956 
bitstatus
 = 
RESET
;

958 return 
bitstatus
;

959 
	}
}

980 void 
	$SDIO_ClearITPendingBit
(
uint32_t
 
SDIO_IT
)

983 
	`assert_param
(
	`IS_SDIO_CLEAR_IT
(
SDIO_IT
));

985 
SDIO
->
ICR
 = 
SDIO_IT
;

986 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_spi.c

156 #include 
	~"stm32f4xx_spi.h
"

157 #include 
	~"stm32f4xx_rcc.h
"

172 #define 
	#CR1_CLEAR_MASK
 ((
uint16_t
)0x3040)

	)

173 #define 
	#I2SCFGR_CLEAR_MASK
 ((
uint16_t
)0xF040)

	)

176 #define 
	#PLLCFGR_PPLR_MASK
 ((
uint32_t
)0x70000000)

	)

177 #define 
	#PLLCFGR_PPLN_MASK
 ((
uint32_t
)0x00007FC0)

	)

179 #define 
	#SPI_CR2_FRF
 ((
uint16_t
)0x0010)

	)

180 #define 
	#SPI_SR_TIFRFE
 ((
uint16_t
)0x0100)

	)

222 void 
	$SPI_I2S_DeInit
(
SPI_TypeDef
* 
SPIx
)

225 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

227 if (
SPIx
 == 
SPI1
)

230 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_SPI1
, 
ENABLE
);

232 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_SPI1
, 
DISABLE
);

234 else if (
SPIx
 == 
SPI2
)

237 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_SPI2
, 
ENABLE
);

239 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_SPI2
, 
DISABLE
);

243 if (
SPIx
 == 
SPI3
)

246 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_SPI3
, 
ENABLE
);

248 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_SPI3
, 
DISABLE
);

251 
	}
}

261 void 
	$SPI_Init
(
SPI_TypeDef
* 
SPIx
, 
SPI_InitTypeDef
* 
SPI_InitStruct
)

263 
uint16_t
 
tmpreg
 = 0;

266 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

269 
	`assert_param
(
	`IS_SPI_DIRECTION_MODE
(
SPI_InitStruct
->
SPI_Direction
));

270 
	`assert_param
(
	`IS_SPI_MODE
(
SPI_InitStruct
->
SPI_Mode
));

271 
	`assert_param
(
	`IS_SPI_DATASIZE
(
SPI_InitStruct
->
SPI_DataSize
));

272 
	`assert_param
(
	`IS_SPI_CPOL
(
SPI_InitStruct
->
SPI_CPOL
));

273 
	`assert_param
(
	`IS_SPI_CPHA
(
SPI_InitStruct
->
SPI_CPHA
));

274 
	`assert_param
(
	`IS_SPI_NSS
(
SPI_InitStruct
->
SPI_NSS
));

275 
	`assert_param
(
	`IS_SPI_BAUDRATE_PRESCALER
(
SPI_InitStruct
->
SPI_BaudRatePrescaler
));

276 
	`assert_param
(
	`IS_SPI_FIRST_BIT
(
SPI_InitStruct
->
SPI_FirstBit
));

277 
	`assert_param
(
	`IS_SPI_CRC_POLYNOMIAL
(
SPI_InitStruct
->
SPI_CRCPolynomial
));

281 
tmpreg
 = 
SPIx
->
CR1
;

283 
tmpreg
 &= 
CR1_CLEAR_MASK
;

292 
tmpreg
 |= (
uint16_t
)((
uint32_t
)
SPI_InitStruct
->
SPI_Direction
 | SPI_InitStruct->
SPI_Mode
 |

293 
SPI_InitStruct
->
SPI_DataSize
 | SPI_InitStruct->
SPI_CPOL
 |

294 
SPI_InitStruct
->
SPI_CPHA
 | SPI_InitStruct->
SPI_NSS
 |

295 
SPI_InitStruct
->
SPI_BaudRatePrescaler
 | SPI_InitStruct->
SPI_FirstBit
);

297 
SPIx
->
CR1
 = 
tmpreg
;

300 
SPIx
->
I2SCFGR
 &= (
uint16_t
)~((uint16_t)
SPI_I2SCFGR_I2SMOD
);

303 
SPIx
->
CRCPR
 = 
SPI_InitStruct
->
SPI_CRCPolynomial
;

304 
	}
}

325 void 
	$I2S_Init
(
SPI_TypeDef
* 
SPIx
, 
I2S_InitTypeDef
* 
I2S_InitStruct
)

327 
uint16_t
 
tmpreg
 = 0, 
i2sdiv
 = 2, 
i2sodd
 = 0, 
packetlength
 = 1;

328 
uint32_t
 
tmp
 = 0, 
i2sclk
 = 0;

329 #ifndef 
I2S_EXTERNAL_CLOCK_VAL


330 
uint32_t
 
pllm
 = 0, 
plln
 = 0, 
pllr
 = 0;

334 
	`assert_param
(
	`IS_SPI_23_PERIPH
(
SPIx
));

335 
	`assert_param
(
	`IS_I2S_MODE
(
I2S_InitStruct
->
I2S_Mode
));

336 
	`assert_param
(
	`IS_I2S_STANDARD
(
I2S_InitStruct
->
I2S_Standard
));

337 
	`assert_param
(
	`IS_I2S_DATA_FORMAT
(
I2S_InitStruct
->
I2S_DataFormat
));

338 
	`assert_param
(
	`IS_I2S_MCLK_OUTPUT
(
I2S_InitStruct
->
I2S_MCLKOutput
));

339 
	`assert_param
(
	`IS_I2S_AUDIO_FREQ
(
I2S_InitStruct
->
I2S_AudioFreq
));

340 
	`assert_param
(
	`IS_I2S_CPOL
(
I2S_InitStruct
->
I2S_CPOL
));

344 
SPIx
->
I2SCFGR
 &= 
I2SCFGR_CLEAR_MASK
;

345 
SPIx
->
I2SPR
 = 0x0002;

348 
tmpreg
 = 
SPIx
->
I2SCFGR
;

351 if(
I2S_InitStruct
->
I2S_AudioFreq
 == 
I2S_AudioFreq_Default
)

353 
i2sodd
 = (
uint16_t
)0;

354 
i2sdiv
 = (
uint16_t
)2;

360 if(
I2S_InitStruct
->
I2S_DataFormat
 == 
I2S_DataFormat_16b
)

363 
packetlength
 = 1;

368 
packetlength
 = 2;

375 #ifdef 
I2S_EXTERNAL_CLOCK_VAL


377 if ((
RCC
->
CFGR
 & 
RCC_CFGR_I2SSRC
) == 0)

379 
RCC
->
CFGR
 |= (
uint32_t
)
RCC_CFGR_I2SSRC
;

383 
i2sclk
 = 
I2S_EXTERNAL_CLOCK_VAL
;

387 if ((
RCC
->
CFGR
 & 
RCC_CFGR_I2SSRC
) != 0)

389 
RCC
->
CFGR
 &= ~(
uint32_t
)
RCC_CFGR_I2SSRC
;

393 
plln
 = (
uint32_t
)(((
RCC
->
PLLI2SCFGR
 & 
RCC_PLLI2SCFGR_PLLI2SN
) >> 6) & \

394 (
RCC_PLLI2SCFGR_PLLI2SN
 >> 6));

397 
pllr
 = (
uint32_t
)(((
RCC
->
PLLI2SCFGR
 & 
RCC_PLLI2SCFGR_PLLI2SR
) >> 28) & \

398 (
RCC_PLLI2SCFGR_PLLI2SR
 >> 28));

401 
pllm
 = (
uint32_t
)(
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLM
);

404 
i2sclk
 = (
uint32_t
)(((
HSE_VALUE
 / 
pllm
) * 
plln
) / 
pllr
);

408 if(
I2S_InitStruct
->
I2S_MCLKOutput
 == 
I2S_MCLKOutput_Enable
)

411 
tmp
 = (
uint16_t
)(((((
i2sclk
 / 256) * 10) / 
I2S_InitStruct
->
I2S_AudioFreq
)) + 5);

416 
tmp
 = (
uint16_t
)(((((
i2sclk
 / (32 * 
packetlength
)) *10 ) / 
I2S_InitStruct
->
I2S_AudioFreq
)) + 5);

420 
tmp
 = tmp / 10;

423 
i2sodd
 = (
uint16_t
)(
tmp
 & (uint16_t)0x0001);

426 
i2sdiv
 = (
uint16_t
)((
tmp
 - 
i2sodd
) / 2);

429 
i2sodd
 = (
uint16_t
) (i2sodd << 8);

433 if ((
i2sdiv
 < 2) || (i2sdiv > 0xFF))

436 
i2sdiv
 = 2;

437 
i2sodd
 = 0;

441 
SPIx
->
I2SPR
 = (
uint16_t
)((uint16_t)
i2sdiv
 | (uint16_t)(
i2sodd
 | (uint16_t)
I2S_InitStruct
->
I2S_MCLKOutput
));

444 
tmpreg
 |= (
uint16_t
)((uint16_t)
SPI_I2SCFGR_I2SMOD
 | (uint16_t)(
I2S_InitStruct
->
I2S_Mode
 | \

445 (
uint16_t
)(
I2S_InitStruct
->
I2S_Standard
 | (uint16_t)(I2S_InitStruct->
I2S_DataFormat
 | \

446 (
uint16_t
)
I2S_InitStruct
->
I2S_CPOL
))));

449 
SPIx
->
I2SCFGR
 = 
tmpreg
;

450 
	}
}

457 void 
	$SPI_StructInit
(
SPI_InitTypeDef
* 
SPI_InitStruct
)

461 
SPI_InitStruct
->
SPI_Direction
 = 
SPI_Direction_2Lines_FullDuplex
;

463 
SPI_InitStruct
->
SPI_Mode
 = 
SPI_Mode_Slave
;

465 
SPI_InitStruct
->
SPI_DataSize
 = 
SPI_DataSize_8b
;

467 
SPI_InitStruct
->
SPI_CPOL
 = 
SPI_CPOL_Low
;

469 
SPI_InitStruct
->
SPI_CPHA
 = 
SPI_CPHA_1Edge
;

471 
SPI_InitStruct
->
SPI_NSS
 = 
SPI_NSS_Hard
;

473 
SPI_InitStruct
->
SPI_BaudRatePrescaler
 = 
SPI_BaudRatePrescaler_2
;

475 
SPI_InitStruct
->
SPI_FirstBit
 = 
SPI_FirstBit_MSB
;

477 
SPI_InitStruct
->
SPI_CRCPolynomial
 = 7;

478 
	}
}

485 void 
	$I2S_StructInit
(
I2S_InitTypeDef
* 
I2S_InitStruct
)

489 
I2S_InitStruct
->
I2S_Mode
 = 
I2S_Mode_SlaveTx
;

492 
I2S_InitStruct
->
I2S_Standard
 = 
I2S_Standard_Phillips
;

495 
I2S_InitStruct
->
I2S_DataFormat
 = 
I2S_DataFormat_16b
;

498 
I2S_InitStruct
->
I2S_MCLKOutput
 = 
I2S_MCLKOutput_Disable
;

501 
I2S_InitStruct
->
I2S_AudioFreq
 = 
I2S_AudioFreq_Default
;

504 
I2S_InitStruct
->
I2S_CPOL
 = 
I2S_CPOL_Low
;

505 
	}
}

514 void 
	$SPI_Cmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
)

517 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

518 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

519 if (
NewState
 != 
DISABLE
)

522 
SPIx
->
CR1
 |= 
SPI_CR1_SPE
;

527 
SPIx
->
CR1
 &= (
uint16_t
)~((uint16_t)
SPI_CR1_SPE
);

529 
	}
}

539 void 
	$I2S_Cmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
)

542 
	`assert_param
(
	`IS_SPI_23_PERIPH_EXT
(
SPIx
));

543 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

545 if (
NewState
 != 
DISABLE
)

548 
SPIx
->
I2SCFGR
 |= 
SPI_I2SCFGR_I2SE
;

553 
SPIx
->
I2SCFGR
 &= (
uint16_t
)~((uint16_t)
SPI_I2SCFGR_I2SE
);

555 
	}
}

566 void 
	$SPI_DataSizeConfig
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_DataSize
)

569 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

570 
	`assert_param
(
	`IS_SPI_DATASIZE
(
SPI_DataSize
));

572 
SPIx
->
CR1
 &= (
uint16_t
)~
SPI_DataSize_16b
;

574 
SPIx
->
CR1
 |= 
SPI_DataSize
;

575 
	}
}

586 void 
	$SPI_BiDirectionalLineConfig
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_Direction
)

589 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

590 
	`assert_param
(
	`IS_SPI_DIRECTION
(
SPI_Direction
));

591 if (
SPI_Direction
 == 
SPI_Direction_Tx
)

594 
SPIx
->
CR1
 |= 
SPI_Direction_Tx
;

599 
SPIx
->
CR1
 &= 
SPI_Direction_Rx
;

601 
	}
}

612 void 
	$SPI_NSSInternalSoftwareConfig
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_NSSInternalSoft
)

615 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

616 
	`assert_param
(
	`IS_SPI_NSS_INTERNAL
(
SPI_NSSInternalSoft
));

617 if (
SPI_NSSInternalSoft
 != 
SPI_NSSInternalSoft_Reset
)

620 
SPIx
->
CR1
 |= 
SPI_NSSInternalSoft_Set
;

625 
SPIx
->
CR1
 &= 
SPI_NSSInternalSoft_Reset
;

627 
	}
}

636 void 
	$SPI_SSOutputCmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
)

639 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

640 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

641 if (
NewState
 != 
DISABLE
)

644 
SPIx
->
CR2
 |= (
uint16_t
)
SPI_CR2_SSOE
;

649 
SPIx
->
CR2
 &= (
uint16_t
)~((uint16_t)
SPI_CR2_SSOE
);

651 
	}
}

667 void 
	$SPI_TIModeCmd
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
)

670 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

671 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

673 if (
NewState
 != 
DISABLE
)

676 
SPIx
->
CR2
 |= 
SPI_CR2_FRF
;

681 
SPIx
->
CR2
 &= (
uint16_t
)~
SPI_CR2_FRF
;

683 
	}
}

704 void 
	$I2S_FullDuplexConfig
(
SPI_TypeDef
* 
I2Sxext
, 
I2S_InitTypeDef
* 
I2S_InitStruct
)

706 
uint16_t
 
tmpreg
 = 0, 
tmp
 = 0;

709 
	`assert_param
(
	`IS_I2S_EXT_PERIPH
(
I2Sxext
));

710 
	`assert_param
(
	`IS_I2S_MODE
(
I2S_InitStruct
->
I2S_Mode
));

711 
	`assert_param
(
	`IS_I2S_STANDARD
(
I2S_InitStruct
->
I2S_Standard
));

712 
	`assert_param
(
	`IS_I2S_DATA_FORMAT
(
I2S_InitStruct
->
I2S_DataFormat
));

713 
	`assert_param
(
	`IS_I2S_CPOL
(
I2S_InitStruct
->
I2S_CPOL
));

717 
I2Sxext
->
I2SCFGR
 &= 
I2SCFGR_CLEAR_MASK
;

718 
I2Sxext
->
I2SPR
 = 0x0002;

721 
tmpreg
 = 
I2Sxext
->
I2SCFGR
;

724 if ((
I2S_InitStruct
->
I2S_Mode
 == 
I2S_Mode_MasterTx
) || (I2S_InitStruct->I2S_Mode == 
I2S_Mode_SlaveTx
))

726 
tmp
 = 
I2S_Mode_SlaveRx
;

730 if ((
I2S_InitStruct
->
I2S_Mode
 == 
I2S_Mode_MasterRx
) || (I2S_InitStruct->I2S_Mode == 
I2S_Mode_SlaveRx
))

732 
tmp
 = 
I2S_Mode_SlaveTx
;

738 
tmpreg
 |= (
uint16_t
)((uint16_t)
SPI_I2SCFGR_I2SMOD
 | (uint16_t)(
tmp
 | \

739 (
uint16_t
)(
I2S_InitStruct
->
I2S_Standard
 | (uint16_t)(I2S_InitStruct->
I2S_DataFormat
 | \

740 (
uint16_t
)
I2S_InitStruct
->
I2S_CPOL
))));

743 
I2Sxext
->
I2SCFGR
 = 
tmpreg
;

744 
	}
}

779 
uint16_t
 
	$SPI_I2S_ReceiveData
(
SPI_TypeDef
* 
SPIx
)

782 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

785 return 
SPIx
->
DR
;

786 
	}
}

795 void 
	$SPI_I2S_SendData
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
Data
)

798 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

801 
SPIx
->
DR
 = 
Data
;

802 
	}
}

884 void 
	$SPI_CalculateCRC
(
SPI_TypeDef
* 
SPIx
, 
FunctionalState
 
NewState
)

887 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

888 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

889 if (
NewState
 != 
DISABLE
)

892 
SPIx
->
CR1
 |= 
SPI_CR1_CRCEN
;

897 
SPIx
->
CR1
 &= (
uint16_t
)~((uint16_t)
SPI_CR1_CRCEN
);

899 
	}
}

906 void 
	$SPI_TransmitCRC
(
SPI_TypeDef
* 
SPIx
)

909 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

912 
SPIx
->
CR1
 |= 
SPI_CR1_CRCNEXT
;

913 
	}
}

924 
uint16_t
 
	$SPI_GetCRC
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_CRC
)

926 
uint16_t
 
crcreg
 = 0;

928 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

929 
	`assert_param
(
	`IS_SPI_CRC
(
SPI_CRC
));

930 if (
SPI_CRC
 != 
SPI_CRC_Rx
)

933 
crcreg
 = 
SPIx
->
TXCRCR
;

938 
crcreg
 = 
SPIx
->
RXCRCR
;

941 return 
crcreg
;

942 
	}
}

949 
uint16_t
 
	$SPI_GetCRCPolynomial
(
SPI_TypeDef
* 
SPIx
)

952 
	`assert_param
(
	`IS_SPI_ALL_PERIPH
(
SPIx
));

955 return 
SPIx
->
CRCPR
;

956 
	}
}

986 void 
	$SPI_I2S_DMACmd
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_I2S_DMAReq
, 
FunctionalState
 
NewState
)

989 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

990 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

991 
	`assert_param
(
	`IS_SPI_I2S_DMAREQ
(
SPI_I2S_DMAReq
));

993 if (
NewState
 != 
DISABLE
)

996 
SPIx
->
CR2
 |= 
SPI_I2S_DMAReq
;

1001 
SPIx
->
CR2
 &= (
uint16_t
)~
SPI_I2S_DMAReq
;

1003 
	}
}

1095 void 
	$SPI_I2S_ITConfig
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_I2S_IT
, 
FunctionalState
 
NewState
)

1097 
uint16_t
 
itpos
 = 0, 
itmask
 = 0 ;

1100 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

1101 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1102 
	`assert_param
(
	`IS_SPI_I2S_CONFIG_IT
(
SPI_I2S_IT
));

1105 
itpos
 = 
SPI_I2S_IT
 >> 4;

1108 
itmask
 = (
uint16_t
)1 << (uint16_t)
itpos
;

1110 if (
NewState
 != 
DISABLE
)

1113 
SPIx
->
CR2
 |= 
itmask
;

1118 
SPIx
->
CR2
 &= (
uint16_t
)~
itmask
;

1120 
	}
}

1139 
FlagStatus
 
	$SPI_I2S_GetFlagStatus
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_I2S_FLAG
)

1141 
FlagStatus
 
bitstatus
 = 
RESET
;

1143 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

1144 
	`assert_param
(
	`IS_SPI_I2S_GET_FLAG
(
SPI_I2S_FLAG
));

1147 if ((
SPIx
->
SR
 & 
SPI_I2S_FLAG
) != (
uint16_t
)
RESET
)

1150 
bitstatus
 = 
SET
;

1155 
bitstatus
 = 
RESET
;

1158 return 
bitstatus
;

1159 
	}
}

1180 void 
	$SPI_I2S_ClearFlag
(
SPI_TypeDef
* 
SPIx
, 
uint16_t
 
SPI_I2S_FLAG
)

1183 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

1184 
	`assert_param
(
	`IS_SPI_I2S_CLEAR_FLAG
(
SPI_I2S_FLAG
));

1187 
SPIx
->
SR
 = (
uint16_t
)~
SPI_I2S_FLAG
;

1188 
	}
}

1205 
ITStatus
 
	$SPI_I2S_GetITStatus
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_I2S_IT
)

1207 
ITStatus
 
bitstatus
 = 
RESET
;

1208 
uint16_t
 
itpos
 = 0, 
itmask
 = 0, 
enablestatus
 = 0;

1211 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

1212 
	`assert_param
(
	`IS_SPI_I2S_GET_IT
(
SPI_I2S_IT
));

1215 
itpos
 = 0x01 << (
SPI_I2S_IT
 & 0x0F);

1218 
itmask
 = 
SPI_I2S_IT
 >> 4;

1221 
itmask
 = 0x01 << itmask;

1224 
enablestatus
 = (
SPIx
->
CR2
 & 
itmask
) ;

1227 if (((
SPIx
->
SR
 & 
itpos
) != (
uint16_t
)
RESET
) && 
enablestatus
)

1230 
bitstatus
 = 
SET
;

1235 
bitstatus
 = 
RESET
;

1238 return 
bitstatus
;

1239 
	}
}

1260 void 
	$SPI_I2S_ClearITPendingBit
(
SPI_TypeDef
* 
SPIx
, 
uint8_t
 
SPI_I2S_IT
)

1262 
uint16_t
 
itpos
 = 0;

1264 
	`assert_param
(
	`IS_SPI_ALL_PERIPH_EXT
(
SPIx
));

1265 
	`assert_param
(
	`IS_SPI_I2S_CLEAR_IT
(
SPI_I2S_IT
));

1268 
itpos
 = 0x01 << (
SPI_I2S_IT
 & 0x0F);

1271 
SPIx
->
SR
 = (
uint16_t
)~
itpos
;

1272 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_syscfg.c

43 #include 
	~"stm32f4xx_syscfg.h
"

44 #include 
	~"stm32f4xx_rcc.h
"

58 #define 
	#SYSCFG_OFFSET
 (
SYSCFG_BASE
 - 
PERIPH_BASE
)

	)

61 #define 
	#PMC_OFFSET
 (
SYSCFG_OFFSET
 + 0x04)

	)

62 #define 
	#MII_RMII_SEL_BitNumber
 ((
uint8_t
)0x17)

	)

63 #define 
	#PMC_MII_RMII_SEL_BB
 (
PERIPH_BB_BASE
 + (
PMC_OFFSET
 * 32) + (
MII_RMII_SEL_BitNumber
 * 4))

	)

67 #define 
	#CMPCR_OFFSET
 (
SYSCFG_OFFSET
 + 0x20)

	)

68 #define 
	#CMP_PD_BitNumber
 ((
uint8_t
)0x00)

	)

69 #define 
	#CMPCR_CMP_PD_BB
 (
PERIPH_BB_BASE
 + (
CMPCR_OFFSET
 * 32) + (
CMP_PD_BitNumber
 * 4))

	)

86 void 
	$SYSCFG_DeInit
(void)

88 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_SYSCFG
, 
ENABLE
);

89 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_SYSCFG
, 
DISABLE
);

90 
	}
}

109 void 
	$SYSCFG_MemoryRemapConfig
(
uint8_t
 
SYSCFG_MemoryRemap
)

112 
	`assert_param
(
	`IS_SYSCFG_MEMORY_REMAP_CONFING
(
SYSCFG_MemoryRemap
));

114 
SYSCFG
->
MEMRMP
 = 
SYSCFG_MemoryRemap
;

115 
	}
}

126 void 
	$SYSCFG_EXTILineConfig
(
uint8_t
 
EXTI_PortSourceGPIOx
, uint8_t 
EXTI_PinSourcex
)

128 
uint32_t
 
tmp
 = 0x00;

131 
	`assert_param
(
	`IS_EXTI_PORT_SOURCE
(
EXTI_PortSourceGPIOx
));

132 
	`assert_param
(
	`IS_EXTI_PIN_SOURCE
(
EXTI_PinSourcex
));

134 
tmp
 = ((
uint32_t
)0x0F) << (0x04 * (
EXTI_PinSourcex
 & (
uint8_t
)0x03));

135 
SYSCFG
->
EXTICR
[
EXTI_PinSourcex
 >> 0x02] &= ~
tmp
;

136 
SYSCFG
->
EXTICR
[
EXTI_PinSourcex
 >> 0x02] |= (((
uint32_t
)
EXTI_PortSourceGPIOx
) << (0x04 * (EXTI_PinSourcex & (
uint8_t
)0x03)));

137 
	}
}

147 void 
	$SYSCFG_ETH_MediaInterfaceConfig
(
uint32_t
 
SYSCFG_ETH_MediaInterface
)

149 
	`assert_param
(
	`IS_SYSCFG_ETH_MEDIA_INTERFACE
(
SYSCFG_ETH_MediaInterface
));

151 *(
__IO
 
uint32_t
 *) 
PMC_MII_RMII_SEL_BB
 = 
SYSCFG_ETH_MediaInterface
;

152 
	}
}

164 void 
	$SYSCFG_CompensationCellCmd
(
FunctionalState
 
NewState
)

167 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

169 *(
__IO
 
uint32_t
 *) 
CMPCR_CMP_PD_BB
 = (uint32_t)
NewState
;

170 
	}
}

177 
FlagStatus
 
	$SYSCFG_GetCompensationCellStatus
(void)

179 
FlagStatus
 
bitstatus
 = 
RESET
;

181 if ((
SYSCFG
->
CMPCR
 & 
SYSCFG_CMPCR_READY
 ) != (
uint32_t
)
RESET
)

183 
bitstatus
 = 
SET
;

187 
bitstatus
 = 
RESET
;

189 return 
bitstatus
;

190 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_tim.c

114 #include 
	~"stm32f4xx_tim.h
"

115 #include 
	~"stm32f4xx_rcc.h
"

130 #define 
	#SMCR_ETR_MASK
 ((
uint16_t
)0x00FF)

	)

131 #define 
	#CCMR_OFFSET
 ((
uint16_t
)0x0018)

	)

132 #define 
	#CCER_CCE_SET
 ((
uint16_t
)0x0001)

	)

133 #define 
	#CCER_CCNE_SET
 ((
uint16_t
)0x0004)

	)

134 #define 
	#CCMR_OC13M_MASK
 ((
uint16_t
)0xFF8F)

	)

135 #define 
	#CCMR_OC24M_MASK
 ((
uint16_t
)0x8FFF)

	)

140 static void 
TI1_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

141 
uint16_t
 
TIM_ICFilter
);

142 static void 
TI2_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

143 
uint16_t
 
TIM_ICFilter
);

144 static void 
TI3_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

145 
uint16_t
 
TIM_ICFilter
);

146 static void 
TI4_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

147 
uint16_t
 
TIM_ICFilter
);

194 void 
	$TIM_DeInit
(
TIM_TypeDef
* 
TIMx
)

197 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

199 if (
TIMx
 == 
TIM1
)

201 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM1
, 
ENABLE
);

202 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM1
, 
DISABLE
);

204 else if (
TIMx
 == 
TIM2
)

206 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM2
, 
ENABLE
);

207 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM2
, 
DISABLE
);

209 else if (
TIMx
 == 
TIM3
)

211 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM3
, 
ENABLE
);

212 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM3
, 
DISABLE
);

214 else if (
TIMx
 == 
TIM4
)

216 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM4
, 
ENABLE
);

217 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM4
, 
DISABLE
);

219 else if (
TIMx
 == 
TIM5
)

221 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM5
, 
ENABLE
);

222 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM5
, 
DISABLE
);

224 else if (
TIMx
 == 
TIM6
)

226 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM6
, 
ENABLE
);

227 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM6
, 
DISABLE
);

229 else if (
TIMx
 == 
TIM7
)

231 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM7
, 
ENABLE
);

232 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM7
, 
DISABLE
);

234 else if (
TIMx
 == 
TIM8
)

236 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM8
, 
ENABLE
);

237 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM8
, 
DISABLE
);

239 else if (
TIMx
 == 
TIM9
)

241 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM9
, 
ENABLE
);

242 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM9
, 
DISABLE
);

244 else if (
TIMx
 == 
TIM10
)

246 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM10
, 
ENABLE
);

247 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM10
, 
DISABLE
);

249 else if (
TIMx
 == 
TIM11
)

251 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM11
, 
ENABLE
);

252 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_TIM11
, 
DISABLE
);

254 else if (
TIMx
 == 
TIM12
)

256 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM12
, 
ENABLE
);

257 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM12
, 
DISABLE
);

259 else if (
TIMx
 == 
TIM13
)

261 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM13
, 
ENABLE
);

262 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM13
, 
DISABLE
);

266 if (
TIMx
 == 
TIM14
)

268 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM14
, 
ENABLE
);

269 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_TIM14
, 
DISABLE
);

272 
	}
}

282 void 
	$TIM_TimeBaseInit
(
TIM_TypeDef
* 
TIMx
, 
TIM_TimeBaseInitTypeDef
* 
TIM_TimeBaseInitStruct
)

284 
uint16_t
 
tmpcr1
 = 0;

287 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

288 
	`assert_param
(
	`IS_TIM_COUNTER_MODE
(
TIM_TimeBaseInitStruct
->
TIM_CounterMode
));

289 
	`assert_param
(
	`IS_TIM_CKD_DIV
(
TIM_TimeBaseInitStruct
->
TIM_ClockDivision
));

291 
tmpcr1
 = 
TIMx
->
CR1
;

293 if((
TIMx
 == 
TIM1
) || (TIMx == 
TIM8
)||

294 (
TIMx
 == 
TIM2
) || (TIMx == 
TIM3
)||

295 (
TIMx
 == 
TIM4
) || (TIMx == 
TIM5
))

298 
tmpcr1
 &= (
uint16_t
)(~(
TIM_CR1_DIR
 | 
TIM_CR1_CMS
));

299 
tmpcr1
 |= (
uint32_t
)
TIM_TimeBaseInitStruct
->
TIM_CounterMode
;

302 if((
TIMx
 != 
TIM6
) && (TIMx != 
TIM7
))

305 
tmpcr1
 &= (
uint16_t
)(~
TIM_CR1_CKD
);

306 
tmpcr1
 |= (
uint32_t
)
TIM_TimeBaseInitStruct
->
TIM_ClockDivision
;

309 
TIMx
->
CR1
 = 
tmpcr1
;

312 
TIMx
->
ARR
 = 
TIM_TimeBaseInitStruct
->
TIM_Period
 ;

315 
TIMx
->
PSC
 = 
TIM_TimeBaseInitStruct
->
TIM_Prescaler
;

317 if ((
TIMx
 == 
TIM1
) || (TIMx == 
TIM8
))

320 
TIMx
->
RCR
 = 
TIM_TimeBaseInitStruct
->
TIM_RepetitionCounter
;

325 
TIMx
->
EGR
 = 
TIM_PSCReloadMode_Immediate
;

326 
	}
}

334 void 
	$TIM_TimeBaseStructInit
(
TIM_TimeBaseInitTypeDef
* 
TIM_TimeBaseInitStruct
)

337 
TIM_TimeBaseInitStruct
->
TIM_Period
 = 0xFFFFFFFF;

338 
TIM_TimeBaseInitStruct
->
TIM_Prescaler
 = 0x0000;

339 
TIM_TimeBaseInitStruct
->
TIM_ClockDivision
 = 
TIM_CKD_DIV1
;

340 
TIM_TimeBaseInitStruct
->
TIM_CounterMode
 = 
TIM_CounterMode_Up
;

341 
TIM_TimeBaseInitStruct
->
TIM_RepetitionCounter
 = 0x0000;

342 
	}
}

354 void 
	$TIM_PrescalerConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
Prescaler
, uint16_t 
TIM_PSCReloadMode
)

357 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

358 
	`assert_param
(
	`IS_TIM_PRESCALER_RELOAD
(
TIM_PSCReloadMode
));

360 
TIMx
->
PSC
 = 
Prescaler
;

362 
TIMx
->
EGR
 = 
TIM_PSCReloadMode
;

363 
	}
}

377 void 
	$TIM_CounterModeConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_CounterMode
)

379 
uint16_t
 
tmpcr1
 = 0;

382 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

383 
	`assert_param
(
	`IS_TIM_COUNTER_MODE
(
TIM_CounterMode
));

385 
tmpcr1
 = 
TIMx
->
CR1
;

388 
tmpcr1
 &= (
uint16_t
)~(
TIM_CR1_DIR
 | 
TIM_CR1_CMS
);

391 
tmpcr1
 |= 
TIM_CounterMode
;

394 
TIMx
->
CR1
 = 
tmpcr1
;

395 
	}
}

403 void 
	$TIM_SetCounter
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Counter
)

406 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

409 
TIMx
->
CNT
 = 
Counter
;

410 
	}
}

418 void 
	$TIM_SetAutoreload
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Autoreload
)

421 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

424 
TIMx
->
ARR
 = 
Autoreload
;

425 
	}
}

432 
uint32_t
 
	$TIM_GetCounter
(
TIM_TypeDef
* 
TIMx
)

435 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

438 return 
TIMx
->
CNT
;

439 
	}
}

446 
uint16_t
 
	$TIM_GetPrescaler
(
TIM_TypeDef
* 
TIMx
)

449 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

452 return 
TIMx
->
PSC
;

453 
	}
}

462 void 
	$TIM_UpdateDisableConfig
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

465 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

466 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

468 if (
NewState
 != 
DISABLE
)

471 
TIMx
->
CR1
 |= 
TIM_CR1_UDIS
;

476 
TIMx
->
CR1
 &= (
uint16_t
)~
TIM_CR1_UDIS
;

478 
	}
}

491 void 
	$TIM_UpdateRequestConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_UpdateSource
)

494 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

495 
	`assert_param
(
	`IS_TIM_UPDATE_SOURCE
(
TIM_UpdateSource
));

497 if (
TIM_UpdateSource
 != 
TIM_UpdateSource_Global
)

500 
TIMx
->
CR1
 |= 
TIM_CR1_URS
;

505 
TIMx
->
CR1
 &= (
uint16_t
)~
TIM_CR1_URS
;

507 
	}
}

516 void 
	$TIM_ARRPreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

519 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

520 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

522 if (
NewState
 != 
DISABLE
)

525 
TIMx
->
CR1
 |= 
TIM_CR1_ARPE
;

530 
TIMx
->
CR1
 &= (
uint16_t
)~
TIM_CR1_ARPE
;

532 
	}
}

543 void 
	$TIM_SelectOnePulseMode
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OPMode
)

546 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

547 
	`assert_param
(
	`IS_TIM_OPM_MODE
(
TIM_OPMode
));

550 
TIMx
->
CR1
 &= (
uint16_t
)~
TIM_CR1_OPM
;

553 
TIMx
->
CR1
 |= 
TIM_OPMode
;

554 
	}
}

566 void 
	$TIM_SetClockDivision
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_CKD
)

569 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

570 
	`assert_param
(
	`IS_TIM_CKD_DIV
(
TIM_CKD
));

573 
TIMx
->
CR1
 &= (
uint16_t
)(~
TIM_CR1_CKD
);

576 
TIMx
->
CR1
 |= 
TIM_CKD
;

577 
	}
}

586 void 
	$TIM_Cmd
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

589 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

590 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

592 if (
NewState
 != 
DISABLE
)

595 
TIMx
->
CR1
 |= 
TIM_CR1_CEN
;

600 
TIMx
->
CR1
 &= (
uint16_t
)~
TIM_CR1_CEN
;

602 
	}
}

665 void 
	$TIM_OC1Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
)

667 
uint16_t
 
tmpccmrx
 = 0, 
tmpccer
 = 0, 
tmpcr2
 = 0;

670 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

671 
	`assert_param
(
	`IS_TIM_OC_MODE
(
TIM_OCInitStruct
->
TIM_OCMode
));

672 
	`assert_param
(
	`IS_TIM_OUTPUT_STATE
(
TIM_OCInitStruct
->
TIM_OutputState
));

673 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCInitStruct
->
TIM_OCPolarity
));

676 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC1E
;

679 
tmpccer
 = 
TIMx
->
CCER
;

681 
tmpcr2
 = 
TIMx
->
CR2
;

684 
tmpccmrx
 = 
TIMx
->
CCMR1
;

687 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR1_OC1M
;

688 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR1_CC1S
;

690 
tmpccmrx
 |= 
TIM_OCInitStruct
->
TIM_OCMode
;

693 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC1P
;

695 
tmpccer
 |= 
TIM_OCInitStruct
->
TIM_OCPolarity
;

698 
tmpccer
 |= 
TIM_OCInitStruct
->
TIM_OutputState
;

700 if((
TIMx
 == 
TIM1
) || (TIMx == 
TIM8
))

702 
	`assert_param
(
	`IS_TIM_OUTPUTN_STATE
(
TIM_OCInitStruct
->
TIM_OutputNState
));

703 
	`assert_param
(
	`IS_TIM_OCN_POLARITY
(
TIM_OCInitStruct
->
TIM_OCNPolarity
));

704 
	`assert_param
(
	`IS_TIM_OCNIDLE_STATE
(
TIM_OCInitStruct
->
TIM_OCNIdleState
));

705 
	`assert_param
(
	`IS_TIM_OCIDLE_STATE
(
TIM_OCInitStruct
->
TIM_OCIdleState
));

708 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC1NP
;

710 
tmpccer
 |= 
TIM_OCInitStruct
->
TIM_OCNPolarity
;

712 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC1NE
;

715 
tmpccer
 |= 
TIM_OCInitStruct
->
TIM_OutputNState
;

717 
tmpcr2
 &= (
uint16_t
)~
TIM_CR2_OIS1
;

718 
tmpcr2
 &= (
uint16_t
)~
TIM_CR2_OIS1N
;

720 
tmpcr2
 |= 
TIM_OCInitStruct
->
TIM_OCIdleState
;

722 
tmpcr2
 |= 
TIM_OCInitStruct
->
TIM_OCNIdleState
;

725 
TIMx
->
CR2
 = 
tmpcr2
;

728 
TIMx
->
CCMR1
 = 
tmpccmrx
;

731 
TIMx
->
CCR1
 = 
TIM_OCInitStruct
->
TIM_Pulse
;

734 
TIMx
->
CCER
 = 
tmpccer
;

735 
	}
}

746 void 
	$TIM_OC2Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
)

748 
uint16_t
 
tmpccmrx
 = 0, 
tmpccer
 = 0, 
tmpcr2
 = 0;

751 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

752 
	`assert_param
(
	`IS_TIM_OC_MODE
(
TIM_OCInitStruct
->
TIM_OCMode
));

753 
	`assert_param
(
	`IS_TIM_OUTPUT_STATE
(
TIM_OCInitStruct
->
TIM_OutputState
));

754 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCInitStruct
->
TIM_OCPolarity
));

757 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC2E
;

760 
tmpccer
 = 
TIMx
->
CCER
;

762 
tmpcr2
 = 
TIMx
->
CR2
;

765 
tmpccmrx
 = 
TIMx
->
CCMR1
;

768 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR1_OC2M
;

769 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR1_CC2S
;

772 
tmpccmrx
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCMode
 << 8);

775 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC2P
;

777 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCPolarity
 << 4);

780 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OutputState
 << 4);

782 if((
TIMx
 == 
TIM1
) || (TIMx == 
TIM8
))

784 
	`assert_param
(
	`IS_TIM_OUTPUTN_STATE
(
TIM_OCInitStruct
->
TIM_OutputNState
));

785 
	`assert_param
(
	`IS_TIM_OCN_POLARITY
(
TIM_OCInitStruct
->
TIM_OCNPolarity
));

786 
	`assert_param
(
	`IS_TIM_OCNIDLE_STATE
(
TIM_OCInitStruct
->
TIM_OCNIdleState
));

787 
	`assert_param
(
	`IS_TIM_OCIDLE_STATE
(
TIM_OCInitStruct
->
TIM_OCIdleState
));

790 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC2NP
;

792 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCNPolarity
 << 4);

794 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC2NE
;

797 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OutputNState
 << 4);

799 
tmpcr2
 &= (
uint16_t
)~
TIM_CR2_OIS2
;

800 
tmpcr2
 &= (
uint16_t
)~
TIM_CR2_OIS2N
;

802 
tmpcr2
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCIdleState
 << 2);

804 
tmpcr2
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCNIdleState
 << 2);

807 
TIMx
->
CR2
 = 
tmpcr2
;

810 
TIMx
->
CCMR1
 = 
tmpccmrx
;

813 
TIMx
->
CCR2
 = 
TIM_OCInitStruct
->
TIM_Pulse
;

816 
TIMx
->
CCER
 = 
tmpccer
;

817 
	}
}

827 void 
	$TIM_OC3Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
)

829 
uint16_t
 
tmpccmrx
 = 0, 
tmpccer
 = 0, 
tmpcr2
 = 0;

832 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

833 
	`assert_param
(
	`IS_TIM_OC_MODE
(
TIM_OCInitStruct
->
TIM_OCMode
));

834 
	`assert_param
(
	`IS_TIM_OUTPUT_STATE
(
TIM_OCInitStruct
->
TIM_OutputState
));

835 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCInitStruct
->
TIM_OCPolarity
));

838 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC3E
;

841 
tmpccer
 = 
TIMx
->
CCER
;

843 
tmpcr2
 = 
TIMx
->
CR2
;

846 
tmpccmrx
 = 
TIMx
->
CCMR2
;

849 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR2_OC3M
;

850 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR2_CC3S
;

852 
tmpccmrx
 |= 
TIM_OCInitStruct
->
TIM_OCMode
;

855 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC3P
;

857 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCPolarity
 << 8);

860 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OutputState
 << 8);

862 if((
TIMx
 == 
TIM1
) || (TIMx == 
TIM8
))

864 
	`assert_param
(
	`IS_TIM_OUTPUTN_STATE
(
TIM_OCInitStruct
->
TIM_OutputNState
));

865 
	`assert_param
(
	`IS_TIM_OCN_POLARITY
(
TIM_OCInitStruct
->
TIM_OCNPolarity
));

866 
	`assert_param
(
	`IS_TIM_OCNIDLE_STATE
(
TIM_OCInitStruct
->
TIM_OCNIdleState
));

867 
	`assert_param
(
	`IS_TIM_OCIDLE_STATE
(
TIM_OCInitStruct
->
TIM_OCIdleState
));

870 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC3NP
;

872 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCNPolarity
 << 8);

874 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC3NE
;

877 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OutputNState
 << 8);

879 
tmpcr2
 &= (
uint16_t
)~
TIM_CR2_OIS3
;

880 
tmpcr2
 &= (
uint16_t
)~
TIM_CR2_OIS3N
;

882 
tmpcr2
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCIdleState
 << 4);

884 
tmpcr2
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCNIdleState
 << 4);

887 
TIMx
->
CR2
 = 
tmpcr2
;

890 
TIMx
->
CCMR2
 = 
tmpccmrx
;

893 
TIMx
->
CCR3
 = 
TIM_OCInitStruct
->
TIM_Pulse
;

896 
TIMx
->
CCER
 = 
tmpccer
;

897 
	}
}

907 void 
	$TIM_OC4Init
(
TIM_TypeDef
* 
TIMx
, 
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
)

909 
uint16_t
 
tmpccmrx
 = 0, 
tmpccer
 = 0, 
tmpcr2
 = 0;

912 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

913 
	`assert_param
(
	`IS_TIM_OC_MODE
(
TIM_OCInitStruct
->
TIM_OCMode
));

914 
	`assert_param
(
	`IS_TIM_OUTPUT_STATE
(
TIM_OCInitStruct
->
TIM_OutputState
));

915 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCInitStruct
->
TIM_OCPolarity
));

918 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC4E
;

921 
tmpccer
 = 
TIMx
->
CCER
;

923 
tmpcr2
 = 
TIMx
->
CR2
;

926 
tmpccmrx
 = 
TIMx
->
CCMR2
;

929 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR2_OC4M
;

930 
tmpccmrx
 &= (
uint16_t
)~
TIM_CCMR2_CC4S
;

933 
tmpccmrx
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCMode
 << 8);

936 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC4P
;

938 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCPolarity
 << 12);

941 
tmpccer
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OutputState
 << 12);

943 if((
TIMx
 == 
TIM1
) || (TIMx == 
TIM8
))

945 
	`assert_param
(
	`IS_TIM_OCIDLE_STATE
(
TIM_OCInitStruct
->
TIM_OCIdleState
));

947 
tmpcr2
 &=(
uint16_t
) ~
TIM_CR2_OIS4
;

949 
tmpcr2
 |= (
uint16_t
)(
TIM_OCInitStruct
->
TIM_OCIdleState
 << 6);

952 
TIMx
->
CR2
 = 
tmpcr2
;

955 
TIMx
->
CCMR2
 = 
tmpccmrx
;

958 
TIMx
->
CCR4
 = 
TIM_OCInitStruct
->
TIM_Pulse
;

961 
TIMx
->
CCER
 = 
tmpccer
;

962 
	}
}

970 void 
	$TIM_OCStructInit
(
TIM_OCInitTypeDef
* 
TIM_OCInitStruct
)

973 
TIM_OCInitStruct
->
TIM_OCMode
 = 
TIM_OCMode_Timing
;

974 
TIM_OCInitStruct
->
TIM_OutputState
 = 
TIM_OutputState_Disable
;

975 
TIM_OCInitStruct
->
TIM_OutputNState
 = 
TIM_OutputNState_Disable
;

976 
TIM_OCInitStruct
->
TIM_Pulse
 = 0x00000000;

977 
TIM_OCInitStruct
->
TIM_OCPolarity
 = 
TIM_OCPolarity_High
;

978 
TIM_OCInitStruct
->
TIM_OCNPolarity
 = 
TIM_OCPolarity_High
;

979 
TIM_OCInitStruct
->
TIM_OCIdleState
 = 
TIM_OCIdleState_Reset
;

980 
TIM_OCInitStruct
->
TIM_OCNIdleState
 = 
TIM_OCNIdleState_Reset
;

981 
	}
}

1006 void 
	$TIM_SelectOCxM
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Channel
, uint16_t 
TIM_OCMode
)

1008 
uint32_t
 
tmp
 = 0;

1009 
uint16_t
 
tmp1
 = 0;

1012 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1013 
	`assert_param
(
	`IS_TIM_CHANNEL
(
TIM_Channel
));

1014 
	`assert_param
(
	`IS_TIM_OCM
(
TIM_OCMode
));

1016 
tmp
 = (
uint32_t
) 
TIMx
;

1017 
tmp
 += 
CCMR_OFFSET
;

1019 
tmp1
 = 
CCER_CCE_SET
 << (
uint16_t
)
TIM_Channel
;

1022 
TIMx
->
CCER
 &= (
uint16_t
) ~
tmp1
;

1024 if((
TIM_Channel
 == 
TIM_Channel_1
) ||(TIM_Channel == 
TIM_Channel_3
))

1026 
tmp
 += (
TIM_Channel
>>1);

1029 *(
__IO
 
uint32_t
 *) 
tmp
 &= 
CCMR_OC13M_MASK
;

1032 *(
__IO
 
uint32_t
 *) 
tmp
 |= 
TIM_OCMode
;

1036 
tmp
 += (
uint16_t
)(
TIM_Channel
 - (uint16_t)4)>> (uint16_t)1;

1039 *(
__IO
 
uint32_t
 *) 
tmp
 &= 
CCMR_OC24M_MASK
;

1042 *(
__IO
 
uint32_t
 *) 
tmp
 |= (
uint16_t
)(
TIM_OCMode
 << 8);

1044 
	}
}

1052 void 
	$TIM_SetCompare1
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare1
)

1055 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1058 
TIMx
->
CCR1
 = 
Compare1
;

1059 
	}
}

1068 void 
	$TIM_SetCompare2
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare2
)

1071 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

1074 
TIMx
->
CCR2
 = 
Compare2
;

1075 
	}
}

1083 void 
	$TIM_SetCompare3
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare3
)

1086 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1089 
TIMx
->
CCR3
 = 
Compare3
;

1090 
	}
}

1098 void 
	$TIM_SetCompare4
(
TIM_TypeDef
* 
TIMx
, 
uint32_t
 
Compare4
)

1101 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1104 
TIMx
->
CCR4
 = 
Compare4
;

1105 
	}
}

1116 void 
	$TIM_ForcedOC1Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
)

1118 
uint16_t
 
tmpccmr1
 = 0;

1121 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1122 
	`assert_param
(
	`IS_TIM_FORCED_ACTION
(
TIM_ForcedAction
));

1123 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1126 
tmpccmr1
 &= (
uint16_t
)~
TIM_CCMR1_OC1M
;

1129 
tmpccmr1
 |= 
TIM_ForcedAction
;

1132 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1133 
	}
}

1145 void 
	$TIM_ForcedOC2Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
)

1147 
uint16_t
 
tmpccmr1
 = 0;

1150 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

1151 
	`assert_param
(
	`IS_TIM_FORCED_ACTION
(
TIM_ForcedAction
));

1152 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1155 
tmpccmr1
 &= (
uint16_t
)~
TIM_CCMR1_OC2M
;

1158 
tmpccmr1
 |= (
uint16_t
)(
TIM_ForcedAction
 << 8);

1161 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1162 
	}
}

1173 void 
	$TIM_ForcedOC3Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
)

1175 
uint16_t
 
tmpccmr2
 = 0;

1178 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1179 
	`assert_param
(
	`IS_TIM_FORCED_ACTION
(
TIM_ForcedAction
));

1181 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1184 
tmpccmr2
 &= (
uint16_t
)~
TIM_CCMR2_OC3M
;

1187 
tmpccmr2
 |= 
TIM_ForcedAction
;

1190 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1191 
	}
}

1202 void 
	$TIM_ForcedOC4Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ForcedAction
)

1204 
uint16_t
 
tmpccmr2
 = 0;

1207 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1208 
	`assert_param
(
	`IS_TIM_FORCED_ACTION
(
TIM_ForcedAction
));

1209 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1212 
tmpccmr2
 &= (
uint16_t
)~
TIM_CCMR2_OC4M
;

1215 
tmpccmr2
 |= (
uint16_t
)(
TIM_ForcedAction
 << 8);

1218 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1219 
	}
}

1230 void 
	$TIM_OC1PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
)

1232 
uint16_t
 
tmpccmr1
 = 0;

1235 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1236 
	`assert_param
(
	`IS_TIM_OCPRELOAD_STATE
(
TIM_OCPreload
));

1238 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1241 
tmpccmr1
 &= (
uint16_t
)(~
TIM_CCMR1_OC1PE
);

1244 
tmpccmr1
 |= 
TIM_OCPreload
;

1247 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1248 
	}
}

1260 void 
	$TIM_OC2PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
)

1262 
uint16_t
 
tmpccmr1
 = 0;

1265 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

1266 
	`assert_param
(
	`IS_TIM_OCPRELOAD_STATE
(
TIM_OCPreload
));

1268 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1271 
tmpccmr1
 &= (
uint16_t
)(~
TIM_CCMR1_OC2PE
);

1274 
tmpccmr1
 |= (
uint16_t
)(
TIM_OCPreload
 << 8);

1277 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1278 
	}
}

1289 void 
	$TIM_OC3PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
)

1291 
uint16_t
 
tmpccmr2
 = 0;

1294 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1295 
	`assert_param
(
	`IS_TIM_OCPRELOAD_STATE
(
TIM_OCPreload
));

1297 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1300 
tmpccmr2
 &= (
uint16_t
)(~
TIM_CCMR2_OC3PE
);

1303 
tmpccmr2
 |= 
TIM_OCPreload
;

1306 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1307 
	}
}

1318 void 
	$TIM_OC4PreloadConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPreload
)

1320 
uint16_t
 
tmpccmr2
 = 0;

1323 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1324 
	`assert_param
(
	`IS_TIM_OCPRELOAD_STATE
(
TIM_OCPreload
));

1326 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1329 
tmpccmr2
 &= (
uint16_t
)(~
TIM_CCMR2_OC4PE
);

1332 
tmpccmr2
 |= (
uint16_t
)(
TIM_OCPreload
 << 8);

1335 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1336 
	}
}

1347 void 
	$TIM_OC1FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
)

1349 
uint16_t
 
tmpccmr1
 = 0;

1352 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1353 
	`assert_param
(
	`IS_TIM_OCFAST_STATE
(
TIM_OCFast
));

1356 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1359 
tmpccmr1
 &= (
uint16_t
)~
TIM_CCMR1_OC1FE
;

1362 
tmpccmr1
 |= 
TIM_OCFast
;

1365 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1366 
	}
}

1378 void 
	$TIM_OC2FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
)

1380 
uint16_t
 
tmpccmr1
 = 0;

1383 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

1384 
	`assert_param
(
	`IS_TIM_OCFAST_STATE
(
TIM_OCFast
));

1387 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1390 
tmpccmr1
 &= (
uint16_t
)(~
TIM_CCMR1_OC2FE
);

1393 
tmpccmr1
 |= (
uint16_t
)(
TIM_OCFast
 << 8);

1396 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1397 
	}
}

1408 void 
	$TIM_OC3FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
)

1410 
uint16_t
 
tmpccmr2
 = 0;

1413 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1414 
	`assert_param
(
	`IS_TIM_OCFAST_STATE
(
TIM_OCFast
));

1417 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1420 
tmpccmr2
 &= (
uint16_t
)~
TIM_CCMR2_OC3FE
;

1423 
tmpccmr2
 |= 
TIM_OCFast
;

1426 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1427 
	}
}

1438 void 
	$TIM_OC4FastConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCFast
)

1440 
uint16_t
 
tmpccmr2
 = 0;

1443 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1444 
	`assert_param
(
	`IS_TIM_OCFAST_STATE
(
TIM_OCFast
));

1447 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1450 
tmpccmr2
 &= (
uint16_t
)(~
TIM_CCMR2_OC4FE
);

1453 
tmpccmr2
 |= (
uint16_t
)(
TIM_OCFast
 << 8);

1456 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1457 
	}
}

1468 void 
	$TIM_ClearOC1Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
)

1470 
uint16_t
 
tmpccmr1
 = 0;

1473 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1474 
	`assert_param
(
	`IS_TIM_OCCLEAR_STATE
(
TIM_OCClear
));

1476 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1479 
tmpccmr1
 &= (
uint16_t
)~
TIM_CCMR1_OC1CE
;

1482 
tmpccmr1
 |= 
TIM_OCClear
;

1485 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1486 
	}
}

1498 void 
	$TIM_ClearOC2Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
)

1500 
uint16_t
 
tmpccmr1
 = 0;

1503 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

1504 
	`assert_param
(
	`IS_TIM_OCCLEAR_STATE
(
TIM_OCClear
));

1506 
tmpccmr1
 = 
TIMx
->
CCMR1
;

1509 
tmpccmr1
 &= (
uint16_t
)~
TIM_CCMR1_OC2CE
;

1512 
tmpccmr1
 |= (
uint16_t
)(
TIM_OCClear
 << 8);

1515 
TIMx
->
CCMR1
 = 
tmpccmr1
;

1516 
	}
}

1527 void 
	$TIM_ClearOC3Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
)

1529 
uint16_t
 
tmpccmr2
 = 0;

1532 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1533 
	`assert_param
(
	`IS_TIM_OCCLEAR_STATE
(
TIM_OCClear
));

1535 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1538 
tmpccmr2
 &= (
uint16_t
)~
TIM_CCMR2_OC3CE
;

1541 
tmpccmr2
 |= 
TIM_OCClear
;

1544 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1545 
	}
}

1556 void 
	$TIM_ClearOC4Ref
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCClear
)

1558 
uint16_t
 
tmpccmr2
 = 0;

1561 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1562 
	`assert_param
(
	`IS_TIM_OCCLEAR_STATE
(
TIM_OCClear
));

1564 
tmpccmr2
 = 
TIMx
->
CCMR2
;

1567 
tmpccmr2
 &= (
uint16_t
)~
TIM_CCMR2_OC4CE
;

1570 
tmpccmr2
 |= (
uint16_t
)(
TIM_OCClear
 << 8);

1573 
TIMx
->
CCMR2
 = 
tmpccmr2
;

1574 
	}
}

1585 void 
	$TIM_OC1PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
)

1587 
uint16_t
 
tmpccer
 = 0;

1590 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1591 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCPolarity
));

1593 
tmpccer
 = 
TIMx
->
CCER
;

1596 
tmpccer
 &= (
uint16_t
)(~
TIM_CCER_CC1P
);

1597 
tmpccer
 |= 
TIM_OCPolarity
;

1600 
TIMx
->
CCER
 = 
tmpccer
;

1601 
	}
}

1612 void 
	$TIM_OC1NPolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCNPolarity
)

1614 
uint16_t
 
tmpccer
 = 0;

1616 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

1617 
	`assert_param
(
	`IS_TIM_OCN_POLARITY
(
TIM_OCNPolarity
));

1619 
tmpccer
 = 
TIMx
->
CCER
;

1622 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC1NP
;

1623 
tmpccer
 |= 
TIM_OCNPolarity
;

1626 
TIMx
->
CCER
 = 
tmpccer
;

1627 
	}
}

1639 void 
	$TIM_OC2PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
)

1641 
uint16_t
 
tmpccer
 = 0;

1644 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

1645 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCPolarity
));

1647 
tmpccer
 = 
TIMx
->
CCER
;

1650 
tmpccer
 &= (
uint16_t
)(~
TIM_CCER_CC2P
);

1651 
tmpccer
 |= (
uint16_t
)(
TIM_OCPolarity
 << 4);

1654 
TIMx
->
CCER
 = 
tmpccer
;

1655 
	}
}

1666 void 
	$TIM_OC2NPolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCNPolarity
)

1668 
uint16_t
 
tmpccer
 = 0;

1671 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

1672 
	`assert_param
(
	`IS_TIM_OCN_POLARITY
(
TIM_OCNPolarity
));

1674 
tmpccer
 = 
TIMx
->
CCER
;

1677 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC2NP
;

1678 
tmpccer
 |= (
uint16_t
)(
TIM_OCNPolarity
 << 4);

1681 
TIMx
->
CCER
 = 
tmpccer
;

1682 
	}
}

1693 void 
	$TIM_OC3PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
)

1695 
uint16_t
 
tmpccer
 = 0;

1698 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1699 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCPolarity
));

1701 
tmpccer
 = 
TIMx
->
CCER
;

1704 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC3P
;

1705 
tmpccer
 |= (
uint16_t
)(
TIM_OCPolarity
 << 8);

1708 
TIMx
->
CCER
 = 
tmpccer
;

1709 
	}
}

1720 void 
	$TIM_OC3NPolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCNPolarity
)

1722 
uint16_t
 
tmpccer
 = 0;

1725 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

1726 
	`assert_param
(
	`IS_TIM_OCN_POLARITY
(
TIM_OCNPolarity
));

1728 
tmpccer
 = 
TIMx
->
CCER
;

1731 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC3NP
;

1732 
tmpccer
 |= (
uint16_t
)(
TIM_OCNPolarity
 << 8);

1735 
TIMx
->
CCER
 = 
tmpccer
;

1736 
	}
}

1747 void 
	$TIM_OC4PolarityConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_OCPolarity
)

1749 
uint16_t
 
tmpccer
 = 0;

1752 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

1753 
	`assert_param
(
	`IS_TIM_OC_POLARITY
(
TIM_OCPolarity
));

1755 
tmpccer
 = 
TIMx
->
CCER
;

1758 
tmpccer
 &= (
uint16_t
)~
TIM_CCER_CC4P
;

1759 
tmpccer
 |= (
uint16_t
)(
TIM_OCPolarity
 << 12);

1762 
TIMx
->
CCER
 = 
tmpccer
;

1763 
	}
}

1778 void 
	$TIM_CCxCmd
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Channel
, uint16_t 
TIM_CCx
)

1780 
uint16_t
 
tmp
 = 0;

1783 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1784 
	`assert_param
(
	`IS_TIM_CHANNEL
(
TIM_Channel
));

1785 
	`assert_param
(
	`IS_TIM_CCX
(
TIM_CCx
));

1787 
tmp
 = 
CCER_CCE_SET
 << 
TIM_Channel
;

1790 
TIMx
->
CCER
 &= (
uint16_t
)~ 
tmp
;

1793 
TIMx
->
CCER
 |= (
uint16_t
)(
TIM_CCx
 << 
TIM_Channel
);

1794 
	}
}

1808 void 
	$TIM_CCxNCmd
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Channel
, uint16_t 
TIM_CCxN
)

1810 
uint16_t
 
tmp
 = 0;

1813 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

1814 
	`assert_param
(
	`IS_TIM_COMPLEMENTARY_CHANNEL
(
TIM_Channel
));

1815 
	`assert_param
(
	`IS_TIM_CCXN
(
TIM_CCxN
));

1817 
tmp
 = 
CCER_CCNE_SET
 << 
TIM_Channel
;

1820 
TIMx
->
CCER
 &= (
uint16_t
) ~
tmp
;

1823 
TIMx
->
CCER
 |= (
uint16_t
)(
TIM_CCxN
 << 
TIM_Channel
);

1824 
	}
}

1890 void 
	$TIM_ICInit
(
TIM_TypeDef
* 
TIMx
, 
TIM_ICInitTypeDef
* 
TIM_ICInitStruct
)

1893 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

1894 
	`assert_param
(
	`IS_TIM_IC_POLARITY
(
TIM_ICInitStruct
->
TIM_ICPolarity
));

1895 
	`assert_param
(
	`IS_TIM_IC_SELECTION
(
TIM_ICInitStruct
->
TIM_ICSelection
));

1896 
	`assert_param
(
	`IS_TIM_IC_PRESCALER
(
TIM_ICInitStruct
->
TIM_ICPrescaler
));

1897 
	`assert_param
(
	`IS_TIM_IC_FILTER
(
TIM_ICInitStruct
->
TIM_ICFilter
));

1899 if (
TIM_ICInitStruct
->
TIM_Channel
 == 
TIM_Channel_1
)

1902 
	`TI1_Config
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPolarity
,

1903 
TIM_ICInitStruct
->
TIM_ICSelection
,

1904 
TIM_ICInitStruct
->
TIM_ICFilter
);

1906 
	`TIM_SetIC1Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

1908 else if (
TIM_ICInitStruct
->
TIM_Channel
 == 
TIM_Channel_2
)

1911 
	`TI2_Config
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPolarity
,

1912 
TIM_ICInitStruct
->
TIM_ICSelection
,

1913 
TIM_ICInitStruct
->
TIM_ICFilter
);

1915 
	`TIM_SetIC2Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

1917 else if (
TIM_ICInitStruct
->
TIM_Channel
 == 
TIM_Channel_3
)

1920 
	`TI3_Config
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPolarity
,

1921 
TIM_ICInitStruct
->
TIM_ICSelection
,

1922 
TIM_ICInitStruct
->
TIM_ICFilter
);

1924 
	`TIM_SetIC3Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

1929 
	`TI4_Config
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPolarity
,

1930 
TIM_ICInitStruct
->
TIM_ICSelection
,

1931 
TIM_ICInitStruct
->
TIM_ICFilter
);

1933 
	`TIM_SetIC4Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

1935 
	}
}

1943 void 
	$TIM_ICStructInit
(
TIM_ICInitTypeDef
* 
TIM_ICInitStruct
)

1946 
TIM_ICInitStruct
->
TIM_Channel
 = 
TIM_Channel_1
;

1947 
TIM_ICInitStruct
->
TIM_ICPolarity
 = 
TIM_ICPolarity_Rising
;

1948 
TIM_ICInitStruct
->
TIM_ICSelection
 = 
TIM_ICSelection_DirectTI
;

1949 
TIM_ICInitStruct
->
TIM_ICPrescaler
 = 
TIM_ICPSC_DIV1
;

1950 
TIM_ICInitStruct
->
TIM_ICFilter
 = 0x00;

1951 
	}
}

1962 void 
	$TIM_PWMIConfig
(
TIM_TypeDef
* 
TIMx
, 
TIM_ICInitTypeDef
* 
TIM_ICInitStruct
)

1964 
uint16_t
 
icoppositepolarity
 = 
TIM_ICPolarity_Rising
;

1965 
uint16_t
 
icoppositeselection
 = 
TIM_ICSelection_DirectTI
;

1968 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

1971 if (
TIM_ICInitStruct
->
TIM_ICPolarity
 == 
TIM_ICPolarity_Rising
)

1973 
icoppositepolarity
 = 
TIM_ICPolarity_Falling
;

1977 
icoppositepolarity
 = 
TIM_ICPolarity_Rising
;

1980 if (
TIM_ICInitStruct
->
TIM_ICSelection
 == 
TIM_ICSelection_DirectTI
)

1982 
icoppositeselection
 = 
TIM_ICSelection_IndirectTI
;

1986 
icoppositeselection
 = 
TIM_ICSelection_DirectTI
;

1988 if (
TIM_ICInitStruct
->
TIM_Channel
 == 
TIM_Channel_1
)

1991 
	`TI1_Config
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPolarity
, TIM_ICInitStruct->
TIM_ICSelection
,

1992 
TIM_ICInitStruct
->
TIM_ICFilter
);

1994 
	`TIM_SetIC1Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

1996 
	`TI2_Config
(
TIMx
, 
icoppositepolarity
, 
icoppositeselection
, 
TIM_ICInitStruct
->
TIM_ICFilter
);

1998 
	`TIM_SetIC2Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

2003 
	`TI2_Config
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPolarity
, TIM_ICInitStruct->
TIM_ICSelection
,

2004 
TIM_ICInitStruct
->
TIM_ICFilter
);

2006 
	`TIM_SetIC2Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

2008 
	`TI1_Config
(
TIMx
, 
icoppositepolarity
, 
icoppositeselection
, 
TIM_ICInitStruct
->
TIM_ICFilter
);

2010 
	`TIM_SetIC1Prescaler
(
TIMx
, 
TIM_ICInitStruct
->
TIM_ICPrescaler
);

2012 
	}
}

2019 
uint32_t
 
	$TIM_GetCapture1
(
TIM_TypeDef
* 
TIMx
)

2022 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

2025 return 
TIMx
->
CCR1
;

2026 
	}
}

2034 
uint32_t
 
	$TIM_GetCapture2
(
TIM_TypeDef
* 
TIMx
)

2037 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

2040 return 
TIMx
->
CCR2
;

2041 
	}
}

2048 
uint32_t
 
	$TIM_GetCapture3
(
TIM_TypeDef
* 
TIMx
)

2051 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2054 return 
TIMx
->
CCR3
;

2055 
	}
}

2062 
uint32_t
 
	$TIM_GetCapture4
(
TIM_TypeDef
* 
TIMx
)

2065 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2068 return 
TIMx
->
CCR4
;

2069 
	}
}

2082 void 
	$TIM_SetIC1Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
)

2085 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

2086 
	`assert_param
(
	`IS_TIM_IC_PRESCALER
(
TIM_ICPSC
));

2089 
TIMx
->
CCMR1
 &= (
uint16_t
)~
TIM_CCMR1_IC1PSC
;

2092 
TIMx
->
CCMR1
 |= 
TIM_ICPSC
;

2093 
	}
}

2107 void 
	$TIM_SetIC2Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
)

2110 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

2111 
	`assert_param
(
	`IS_TIM_IC_PRESCALER
(
TIM_ICPSC
));

2114 
TIMx
->
CCMR1
 &= (
uint16_t
)~
TIM_CCMR1_IC2PSC
;

2117 
TIMx
->
CCMR1
 |= (
uint16_t
)(
TIM_ICPSC
 << 8);

2118 
	}
}

2131 void 
	$TIM_SetIC3Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
)

2134 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2135 
	`assert_param
(
	`IS_TIM_IC_PRESCALER
(
TIM_ICPSC
));

2138 
TIMx
->
CCMR2
 &= (
uint16_t
)~
TIM_CCMR2_IC3PSC
;

2141 
TIMx
->
CCMR2
 |= 
TIM_ICPSC
;

2142 
	}
}

2155 void 
	$TIM_SetIC4Prescaler
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPSC
)

2158 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2159 
	`assert_param
(
	`IS_TIM_IC_PRESCALER
(
TIM_ICPSC
));

2162 
TIMx
->
CCMR2
 &= (
uint16_t
)~
TIM_CCMR2_IC4PSC
;

2165 
TIMx
->
CCMR2
 |= (
uint16_t
)(
TIM_ICPSC
 << 8);

2166 
	}
}

2208 void 
	$TIM_BDTRConfig
(
TIM_TypeDef
* 
TIMx
, 
TIM_BDTRInitTypeDef
 *
TIM_BDTRInitStruct
)

2211 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

2212 
	`assert_param
(
	`IS_TIM_OSSR_STATE
(
TIM_BDTRInitStruct
->
TIM_OSSRState
));

2213 
	`assert_param
(
	`IS_TIM_OSSI_STATE
(
TIM_BDTRInitStruct
->
TIM_OSSIState
));

2214 
	`assert_param
(
	`IS_TIM_LOCK_LEVEL
(
TIM_BDTRInitStruct
->
TIM_LOCKLevel
));

2215 
	`assert_param
(
	`IS_TIM_BREAK_STATE
(
TIM_BDTRInitStruct
->
TIM_Break
));

2216 
	`assert_param
(
	`IS_TIM_BREAK_POLARITY
(
TIM_BDTRInitStruct
->
TIM_BreakPolarity
));

2217 
	`assert_param
(
	`IS_TIM_AUTOMATIC_OUTPUT_STATE
(
TIM_BDTRInitStruct
->
TIM_AutomaticOutput
));

2221 
TIMx
->
BDTR
 = (
uint32_t
)
TIM_BDTRInitStruct
->
TIM_OSSRState
 | TIM_BDTRInitStruct->
TIM_OSSIState
 |

2222 
TIM_BDTRInitStruct
->
TIM_LOCKLevel
 | TIM_BDTRInitStruct->
TIM_DeadTime
 |

2223 
TIM_BDTRInitStruct
->
TIM_Break
 | TIM_BDTRInitStruct->
TIM_BreakPolarity
 |

2224 
TIM_BDTRInitStruct
->
TIM_AutomaticOutput
;

2225 
	}
}

2233 void 
	$TIM_BDTRStructInit
(
TIM_BDTRInitTypeDef
* 
TIM_BDTRInitStruct
)

2236 
TIM_BDTRInitStruct
->
TIM_OSSRState
 = 
TIM_OSSRState_Disable
;

2237 
TIM_BDTRInitStruct
->
TIM_OSSIState
 = 
TIM_OSSIState_Disable
;

2238 
TIM_BDTRInitStruct
->
TIM_LOCKLevel
 = 
TIM_LOCKLevel_OFF
;

2239 
TIM_BDTRInitStruct
->
TIM_DeadTime
 = 0x00;

2240 
TIM_BDTRInitStruct
->
TIM_Break
 = 
TIM_Break_Disable
;

2241 
TIM_BDTRInitStruct
->
TIM_BreakPolarity
 = 
TIM_BreakPolarity_Low
;

2242 
TIM_BDTRInitStruct
->
TIM_AutomaticOutput
 = 
TIM_AutomaticOutput_Disable
;

2243 
	}
}

2252 void 
	$TIM_CtrlPWMOutputs
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

2255 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

2256 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2258 if (
NewState
 != 
DISABLE
)

2261 
TIMx
->
BDTR
 |= 
TIM_BDTR_MOE
;

2266 
TIMx
->
BDTR
 &= (
uint16_t
)~
TIM_BDTR_MOE
;

2268 
	}
}

2277 void 
	$TIM_SelectCOM
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

2280 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

2281 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2283 if (
NewState
 != 
DISABLE
)

2286 
TIMx
->
CR2
 |= 
TIM_CR2_CCUS
;

2291 
TIMx
->
CR2
 &= (
uint16_t
)~
TIM_CR2_CCUS
;

2293 
	}
}

2302 void 
	$TIM_CCPreloadControl
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

2305 
	`assert_param
(
	`IS_TIM_LIST4_PERIPH
(
TIMx
));

2306 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2307 if (
NewState
 != 
DISABLE
)

2310 
TIMx
->
CR2
 |= 
TIM_CR2_CCPC
;

2315 
TIMx
->
CR2
 &= (
uint16_t
)~
TIM_CR2_CCPC
;

2317 
	}
}

2359 void 
	$TIM_ITConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_IT
, 
FunctionalState
 
NewState
)

2362 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

2363 
	`assert_param
(
	`IS_TIM_IT
(
TIM_IT
));

2364 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2366 if (
NewState
 != 
DISABLE
)

2369 
TIMx
->
DIER
 |= 
TIM_IT
;

2374 
TIMx
->
DIER
 &= (
uint16_t
)~
TIM_IT
;

2376 
	}
}

2397 void 
	$TIM_GenerateEvent
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_EventSource
)

2400 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

2401 
	`assert_param
(
	`IS_TIM_EVENT_SOURCE
(
TIM_EventSource
));

2404 
TIMx
->
EGR
 = 
TIM_EventSource
;

2405 
	}
}

2430 
FlagStatus
 
	$TIM_GetFlagStatus
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_FLAG
)

2432 
ITStatus
 
bitstatus
 = 
RESET
;

2434 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

2435 
	`assert_param
(
	`IS_TIM_GET_FLAG
(
TIM_FLAG
));

2438 if ((
TIMx
->
SR
 & 
TIM_FLAG
) != (
uint16_t
)
RESET
)

2440 
bitstatus
 = 
SET
;

2444 
bitstatus
 = 
RESET
;

2446 return 
bitstatus
;

2447 
	}
}

2472 void 
	$TIM_ClearFlag
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_FLAG
)

2475 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

2478 
TIMx
->
SR
 = (
uint16_t
)~
TIM_FLAG
;

2479 
	}
}

2500 
ITStatus
 
	$TIM_GetITStatus
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_IT
)

2502 
ITStatus
 
bitstatus
 = 
RESET
;

2503 
uint16_t
 
itstatus
 = 0x0, 
itenable
 = 0x0;

2505 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

2506 
	`assert_param
(
	`IS_TIM_GET_IT
(
TIM_IT
));

2508 
itstatus
 = 
TIMx
->
SR
 & 
TIM_IT
;

2510 
itenable
 = 
TIMx
->
DIER
 & 
TIM_IT
;

2511 if ((
itstatus
 != (
uint16_t
)
RESET
) && (
itenable
 != (uint16_t)RESET))

2513 
bitstatus
 = 
SET
;

2517 
bitstatus
 = 
RESET
;

2519 return 
bitstatus
;

2520 
	}
}

2541 void 
	$TIM_ClearITPendingBit
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_IT
)

2544 
	`assert_param
(
	`IS_TIM_ALL_PERIPH
(
TIMx
));

2547 
TIMx
->
SR
 = (
uint16_t
)~
TIM_IT
;

2548 
	}
}

2578 void 
	$TIM_DMAConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_DMABase
, uint16_t 
TIM_DMABurstLength
)

2581 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2582 
	`assert_param
(
	`IS_TIM_DMA_BASE
(
TIM_DMABase
));

2583 
	`assert_param
(
	`IS_TIM_DMA_LENGTH
(
TIM_DMABurstLength
));

2586 
TIMx
->
DCR
 = 
TIM_DMABase
 | 
TIM_DMABurstLength
;

2587 
	}
}

2605 void 
	$TIM_DMACmd
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_DMASource
, 
FunctionalState
 
NewState
)

2608 
	`assert_param
(
	`IS_TIM_LIST5_PERIPH
(
TIMx
));

2609 
	`assert_param
(
	`IS_TIM_DMA_SOURCE
(
TIM_DMASource
));

2610 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2612 if (
NewState
 != 
DISABLE
)

2615 
TIMx
->
DIER
 |= 
TIM_DMASource
;

2620 
TIMx
->
DIER
 &= (
uint16_t
)~
TIM_DMASource
;

2622 
	}
}

2631 void 
	$TIM_SelectCCDMA
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

2634 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2635 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

2637 if (
NewState
 != 
DISABLE
)

2640 
TIMx
->
CR2
 |= 
TIM_CR2_CCDS
;

2645 
TIMx
->
CR2
 &= (
uint16_t
)~
TIM_CR2_CCDS
;

2647 
	}
}

2670 void 
	$TIM_InternalClockConfig
(
TIM_TypeDef
* 
TIMx
)

2673 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

2676 
TIMx
->
SMCR
 &= (
uint16_t
)~
TIM_SMCR_SMS
;

2677 
	}
}

2691 void 
	$TIM_ITRxExternalClockConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_InputTriggerSource
)

2694 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

2695 
	`assert_param
(
	`IS_TIM_INTERNAL_TRIGGER_SELECTION
(
TIM_InputTriggerSource
));

2698 
	`TIM_SelectInputTrigger
(
TIMx
, 
TIM_InputTriggerSource
);

2701 
TIMx
->
SMCR
 |= 
TIM_SlaveMode_External1
;

2702 
	}
}

2721 void 
	$TIM_TIxExternalClockConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_TIxExternalCLKSource
,

2722 
uint16_t
 
TIM_ICPolarity
, uint16_t 
ICFilter
)

2725 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

2726 
	`assert_param
(
	`IS_TIM_IC_POLARITY
(
TIM_ICPolarity
));

2727 
	`assert_param
(
	`IS_TIM_IC_FILTER
(
ICFilter
));

2730 if (
TIM_TIxExternalCLKSource
 == 
TIM_TIxExternalCLK1Source_TI2
)

2732 
	`TI2_Config
(
TIMx
, 
TIM_ICPolarity
, 
TIM_ICSelection_DirectTI
, 
ICFilter
);

2736 
	`TI1_Config
(
TIMx
, 
TIM_ICPolarity
, 
TIM_ICSelection_DirectTI
, 
ICFilter
);

2739 
	`TIM_SelectInputTrigger
(
TIMx
, 
TIM_TIxExternalCLKSource
);

2741 
TIMx
->
SMCR
 |= 
TIM_SlaveMode_External1
;

2742 
	}
}

2761 void 
	$TIM_ETRClockMode1Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ExtTRGPrescaler
,

2762 
uint16_t
 
TIM_ExtTRGPolarity
, uint16_t 
ExtTRGFilter
)

2764 
uint16_t
 
tmpsmcr
 = 0;

2767 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2768 
	`assert_param
(
	`IS_TIM_EXT_PRESCALER
(
TIM_ExtTRGPrescaler
));

2769 
	`assert_param
(
	`IS_TIM_EXT_POLARITY
(
TIM_ExtTRGPolarity
));

2770 
	`assert_param
(
	`IS_TIM_EXT_FILTER
(
ExtTRGFilter
));

2772 
	`TIM_ETRConfig
(
TIMx
, 
TIM_ExtTRGPrescaler
, 
TIM_ExtTRGPolarity
, 
ExtTRGFilter
);

2775 
tmpsmcr
 = 
TIMx
->
SMCR
;

2778 
tmpsmcr
 &= (
uint16_t
)~
TIM_SMCR_SMS
;

2781 
tmpsmcr
 |= 
TIM_SlaveMode_External1
;

2784 
tmpsmcr
 &= (
uint16_t
)~
TIM_SMCR_TS
;

2785 
tmpsmcr
 |= 
TIM_TS_ETRF
;

2788 
TIMx
->
SMCR
 = 
tmpsmcr
;

2789 
	}
}

2808 void 
	$TIM_ETRClockMode2Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ExtTRGPrescaler
,

2809 
uint16_t
 
TIM_ExtTRGPolarity
, uint16_t 
ExtTRGFilter
)

2812 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

2813 
	`assert_param
(
	`IS_TIM_EXT_PRESCALER
(
TIM_ExtTRGPrescaler
));

2814 
	`assert_param
(
	`IS_TIM_EXT_POLARITY
(
TIM_ExtTRGPolarity
));

2815 
	`assert_param
(
	`IS_TIM_EXT_FILTER
(
ExtTRGFilter
));

2818 
	`TIM_ETRConfig
(
TIMx
, 
TIM_ExtTRGPrescaler
, 
TIM_ExtTRGPolarity
, 
ExtTRGFilter
);

2821 
TIMx
->
SMCR
 |= 
TIM_SMCR_ECE
;

2822 
	}
}

2876 void 
	$TIM_SelectInputTrigger
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_InputTriggerSource
)

2878 
uint16_t
 
tmpsmcr
 = 0;

2881 
	`assert_param
(
	`IS_TIM_LIST1_PERIPH
(
TIMx
));

2882 
	`assert_param
(
	`IS_TIM_TRIGGER_SELECTION
(
TIM_InputTriggerSource
));

2885 
tmpsmcr
 = 
TIMx
->
SMCR
;

2888 
tmpsmcr
 &= (
uint16_t
)~
TIM_SMCR_TS
;

2891 
tmpsmcr
 |= 
TIM_InputTriggerSource
;

2894 
TIMx
->
SMCR
 = 
tmpsmcr
;

2895 
	}
}

2919 void 
	$TIM_SelectOutputTrigger
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_TRGOSource
)

2922 
	`assert_param
(
	`IS_TIM_LIST5_PERIPH
(
TIMx
));

2923 
	`assert_param
(
	`IS_TIM_TRGO_SOURCE
(
TIM_TRGOSource
));

2926 
TIMx
->
CR2
 &= (
uint16_t
)~
TIM_CR2_MMS
;

2928 
TIMx
->
CR2
 |= 
TIM_TRGOSource
;

2929 
	}
}

2943 void 
	$TIM_SelectSlaveMode
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_SlaveMode
)

2946 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

2947 
	`assert_param
(
	`IS_TIM_SLAVE_MODE
(
TIM_SlaveMode
));

2950 
TIMx
->
SMCR
 &= (
uint16_t
)~
TIM_SMCR_SMS
;

2953 
TIMx
->
SMCR
 |= 
TIM_SlaveMode
;

2954 
	}
}

2966 void 
	$TIM_SelectMasterSlaveMode
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_MasterSlaveMode
)

2969 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

2970 
	`assert_param
(
	`IS_TIM_MSM_STATE
(
TIM_MasterSlaveMode
));

2973 
TIMx
->
SMCR
 &= (
uint16_t
)~
TIM_SMCR_MSM
;

2976 
TIMx
->
SMCR
 |= 
TIM_MasterSlaveMode
;

2977 
	}
}

2996 void 
	$TIM_ETRConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ExtTRGPrescaler
,

2997 
uint16_t
 
TIM_ExtTRGPolarity
, uint16_t 
ExtTRGFilter
)

2999 
uint16_t
 
tmpsmcr
 = 0;

3002 
	`assert_param
(
	`IS_TIM_LIST3_PERIPH
(
TIMx
));

3003 
	`assert_param
(
	`IS_TIM_EXT_PRESCALER
(
TIM_ExtTRGPrescaler
));

3004 
	`assert_param
(
	`IS_TIM_EXT_POLARITY
(
TIM_ExtTRGPolarity
));

3005 
	`assert_param
(
	`IS_TIM_EXT_FILTER
(
ExtTRGFilter
));

3007 
tmpsmcr
 = 
TIMx
->
SMCR
;

3010 
tmpsmcr
 &= 
SMCR_ETR_MASK
;

3013 
tmpsmcr
 |= (
uint16_t
)(
TIM_ExtTRGPrescaler
 | (uint16_t)(
TIM_ExtTRGPolarity
 | (uint16_t)(
ExtTRGFilter
 << (uint16_t)8)));

3016 
TIMx
->
SMCR
 = 
tmpsmcr
;

3017 
	}
}

3054 void 
	$TIM_EncoderInterfaceConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_EncoderMode
,

3055 
uint16_t
 
TIM_IC1Polarity
, uint16_t 
TIM_IC2Polarity
)

3057 
uint16_t
 
tmpsmcr
 = 0;

3058 
uint16_t
 
tmpccmr1
 = 0;

3059 
uint16_t
 
tmpccer
 = 0;

3062 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

3063 
	`assert_param
(
	`IS_TIM_ENCODER_MODE
(
TIM_EncoderMode
));

3064 
	`assert_param
(
	`IS_TIM_IC_POLARITY
(
TIM_IC1Polarity
));

3065 
	`assert_param
(
	`IS_TIM_IC_POLARITY
(
TIM_IC2Polarity
));

3068 
tmpsmcr
 = 
TIMx
->
SMCR
;

3071 
tmpccmr1
 = 
TIMx
->
CCMR1
;

3074 
tmpccer
 = 
TIMx
->
CCER
;

3077 
tmpsmcr
 &= (
uint16_t
)~
TIM_SMCR_SMS
;

3078 
tmpsmcr
 |= 
TIM_EncoderMode
;

3081 
tmpccmr1
 &= ((
uint16_t
)~
TIM_CCMR1_CC1S
) & ((uint16_t)~
TIM_CCMR1_CC2S
);

3082 
tmpccmr1
 |= 
TIM_CCMR1_CC1S_0
 | 
TIM_CCMR1_CC2S_0
;

3085 
tmpccer
 &= ((
uint16_t
)~
TIM_CCER_CC1P
) & ((uint16_t)~
TIM_CCER_CC2P
);

3086 
tmpccer
 |= (
uint16_t
)(
TIM_IC1Polarity
 | (uint16_t)(
TIM_IC2Polarity
 << (uint16_t)4));

3089 
TIMx
->
SMCR
 = 
tmpsmcr
;

3092 
TIMx
->
CCMR1
 = 
tmpccmr1
;

3095 
TIMx
->
CCER
 = 
tmpccer
;

3096 
	}
}

3106 void 
	$TIM_SelectHallSensor
(
TIM_TypeDef
* 
TIMx
, 
FunctionalState
 
NewState
)

3109 
	`assert_param
(
	`IS_TIM_LIST2_PERIPH
(
TIMx
));

3110 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

3112 if (
NewState
 != 
DISABLE
)

3115 
TIMx
->
CR2
 |= 
TIM_CR2_TI1S
;

3120 
TIMx
->
CR2
 &= (
uint16_t
)~
TIM_CR2_TI1S
;

3122 
	}
}

3157 void 
	$TIM_RemapConfig
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_Remap
)

3160 
	`assert_param
(
	`IS_TIM_LIST6_PERIPH
(
TIMx
));

3161 
	`assert_param
(
	`IS_TIM_REMAP
(
TIM_Remap
));

3164 
TIMx
->
OR
 = 
TIM_Remap
;

3165 
	}
}

3188 static void 
	$TI1_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

3189 
uint16_t
 
TIM_ICFilter
)

3191 
uint16_t
 
tmpccmr1
 = 0, 
tmpccer
 = 0;

3194 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC1E
;

3195 
tmpccmr1
 = 
TIMx
->
CCMR1
;

3196 
tmpccer
 = 
TIMx
->
CCER
;

3199 
tmpccmr1
 &= ((
uint16_t
)~
TIM_CCMR1_CC1S
) & ((uint16_t)~
TIM_CCMR1_IC1F
);

3200 
tmpccmr1
 |= (
uint16_t
)(
TIM_ICSelection
 | (uint16_t)(
TIM_ICFilter
 << (uint16_t)4));

3203 
tmpccer
 &= (
uint16_t
)~(
TIM_CCER_CC1P
 | 
TIM_CCER_CC1NP
);

3204 
tmpccer
 |= (
uint16_t
)(
TIM_ICPolarity
 | (uint16_t)
TIM_CCER_CC1E
);

3207 
TIMx
->
CCMR1
 = 
tmpccmr1
;

3208 
TIMx
->
CCER
 = 
tmpccer
;

3209 
	}
}

3229 static void 
	$TI2_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

3230 
uint16_t
 
TIM_ICFilter
)

3232 
uint16_t
 
tmpccmr1
 = 0, 
tmpccer
 = 0, 
tmp
 = 0;

3235 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC2E
;

3236 
tmpccmr1
 = 
TIMx
->
CCMR1
;

3237 
tmpccer
 = 
TIMx
->
CCER
;

3238 
tmp
 = (
uint16_t
)(
TIM_ICPolarity
 << 4);

3241 
tmpccmr1
 &= ((
uint16_t
)~
TIM_CCMR1_CC2S
) & ((uint16_t)~
TIM_CCMR1_IC2F
);

3242 
tmpccmr1
 |= (
uint16_t
)(
TIM_ICFilter
 << 12);

3243 
tmpccmr1
 |= (
uint16_t
)(
TIM_ICSelection
 << 8);

3246 
tmpccer
 &= (
uint16_t
)~(
TIM_CCER_CC2P
 | 
TIM_CCER_CC2NP
);

3247 
tmpccer
 |= (
uint16_t
)(
tmp
 | (uint16_t)
TIM_CCER_CC2E
);

3250 
TIMx
->
CCMR1
 = 
tmpccmr1
 ;

3251 
TIMx
->
CCER
 = 
tmpccer
;

3252 
	}
}

3271 static void 
	$TI3_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

3272 
uint16_t
 
TIM_ICFilter
)

3274 
uint16_t
 
tmpccmr2
 = 0, 
tmpccer
 = 0, 
tmp
 = 0;

3277 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC3E
;

3278 
tmpccmr2
 = 
TIMx
->
CCMR2
;

3279 
tmpccer
 = 
TIMx
->
CCER
;

3280 
tmp
 = (
uint16_t
)(
TIM_ICPolarity
 << 8);

3283 
tmpccmr2
 &= ((
uint16_t
)~
TIM_CCMR1_CC1S
) & ((uint16_t)~
TIM_CCMR2_IC3F
);

3284 
tmpccmr2
 |= (
uint16_t
)(
TIM_ICSelection
 | (uint16_t)(
TIM_ICFilter
 << (uint16_t)4));

3287 
tmpccer
 &= (
uint16_t
)~(
TIM_CCER_CC3P
 | 
TIM_CCER_CC3NP
);

3288 
tmpccer
 |= (
uint16_t
)(
tmp
 | (uint16_t)
TIM_CCER_CC3E
);

3291 
TIMx
->
CCMR2
 = 
tmpccmr2
;

3292 
TIMx
->
CCER
 = 
tmpccer
;

3293 
	}
}

3312 static void 
	$TI4_Config
(
TIM_TypeDef
* 
TIMx
, 
uint16_t
 
TIM_ICPolarity
, uint16_t 
TIM_ICSelection
,

3313 
uint16_t
 
TIM_ICFilter
)

3315 
uint16_t
 
tmpccmr2
 = 0, 
tmpccer
 = 0, 
tmp
 = 0;

3318 
TIMx
->
CCER
 &= (
uint16_t
)~
TIM_CCER_CC4E
;

3319 
tmpccmr2
 = 
TIMx
->
CCMR2
;

3320 
tmpccer
 = 
TIMx
->
CCER
;

3321 
tmp
 = (
uint16_t
)(
TIM_ICPolarity
 << 12);

3324 
tmpccmr2
 &= ((
uint16_t
)~
TIM_CCMR1_CC2S
) & ((uint16_t)~
TIM_CCMR1_IC2F
);

3325 
tmpccmr2
 |= (
uint16_t
)(
TIM_ICSelection
 << 8);

3326 
tmpccmr2
 |= (
uint16_t
)(
TIM_ICFilter
 << 12);

3329 
tmpccer
 &= (
uint16_t
)~(
TIM_CCER_CC4P
 | 
TIM_CCER_CC4NP
);

3330 
tmpccer
 |= (
uint16_t
)(
tmp
 | (uint16_t)
TIM_CCER_CC4E
);

3333 
TIMx
->
CCMR2
 = 
tmpccmr2
;

3334 
TIMx
->
CCER
 = 
tmpccer
 ;

3335 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c

85 #include 
	~"stm32f4xx_usart.h
"

86 #include 
	~"stm32f4xx_rcc.h
"

101 #define 
	#CR1_CLEAR_MASK
 ((
uint16_t
)(
USART_CR1_M
 | 
USART_CR1_PCE
 | \

	)

102 
	gUSART_CR1_PS
 | 
	gUSART_CR1_TE
 | \

103 
	gUSART_CR1_RE
))

106 #define 
	#CR2_CLOCK_CLEAR_MASK
 ((
uint16_t
)(
USART_CR2_CLKEN
 | 
USART_CR2_CPOL
 | \

	)

107 
	gUSART_CR2_CPHA
 | 
	gUSART_CR2_LBCL
))

110 #define 
	#CR3_CLEAR_MASK
 ((
uint16_t
)(
USART_CR3_RTSE
 | 
USART_CR3_CTSE
))

	)

113 #define 
	#IT_MASK
 ((
uint16_t
)0x001F)

	)

178 void 
	$USART_DeInit
(
USART_TypeDef
* 
USARTx
)

181 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

183 if (
USARTx
 == 
USART1
)

185 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_USART1
, 
ENABLE
);

186 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_USART1
, 
DISABLE
);

188 else if (
USARTx
 == 
USART2
)

190 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_USART2
, 
ENABLE
);

191 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_USART2
, 
DISABLE
);

193 else if (
USARTx
 == 
USART3
)

195 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_USART3
, 
ENABLE
);

196 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_USART3
, 
DISABLE
);

198 else if (
USARTx
 == 
UART4
)

200 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_UART4
, 
ENABLE
);

201 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_UART4
, 
DISABLE
);

203 else if (
USARTx
 == 
UART5
)

205 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_UART5
, 
ENABLE
);

206 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_UART5
, 
DISABLE
);

210 if (
USARTx
 == 
USART6
)

212 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_USART6
, 
ENABLE
);

213 
	`RCC_APB2PeriphResetCmd
(
RCC_APB2Periph_USART6
, 
DISABLE
);

216 
	}
}

227 void 
	$USART_Init
(
USART_TypeDef
* 
USARTx
, 
USART_InitTypeDef
* 
USART_InitStruct
)

229 
uint32_t
 
tmpreg
 = 0x00, 
apbclock
 = 0x00;

230 
uint32_t
 
integerdivider
 = 0x00;

231 
uint32_t
 
fractionaldivider
 = 0x00;

232 
RCC_ClocksTypeDef
 
RCC_ClocksStatus
;

235 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

236 
	`assert_param
(
	`IS_USART_BAUDRATE
(
USART_InitStruct
->
USART_BaudRate
));

237 
	`assert_param
(
	`IS_USART_WORD_LENGTH
(
USART_InitStruct
->
USART_WordLength
));

238 
	`assert_param
(
	`IS_USART_STOPBITS
(
USART_InitStruct
->
USART_StopBits
));

239 
	`assert_param
(
	`IS_USART_PARITY
(
USART_InitStruct
->
USART_Parity
));

240 
	`assert_param
(
	`IS_USART_MODE
(
USART_InitStruct
->
USART_Mode
));

241 
	`assert_param
(
	`IS_USART_HARDWARE_FLOW_CONTROL
(
USART_InitStruct
->
USART_HardwareFlowControl
));

244 if (
USART_InitStruct
->
USART_HardwareFlowControl
 != 
USART_HardwareFlowControl_None
)

246 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

250 
tmpreg
 = 
USARTx
->
CR2
;

253 
tmpreg
 &= (
uint32_t
)~((uint32_t)
USART_CR2_STOP
);

257 
tmpreg
 |= (
uint32_t
)
USART_InitStruct
->
USART_StopBits
;

260 
USARTx
->
CR2
 = (
uint16_t
)
tmpreg
;

263 
tmpreg
 = 
USARTx
->
CR1
;

266 
tmpreg
 &= (
uint32_t
)~((uint32_t)
CR1_CLEAR_MASK
);

272 
tmpreg
 |= (
uint32_t
)
USART_InitStruct
->
USART_WordLength
 | USART_InitStruct->
USART_Parity
 |

273 
USART_InitStruct
->
USART_Mode
;

276 
USARTx
->
CR1
 = (
uint16_t
)
tmpreg
;

279 
tmpreg
 = 
USARTx
->
CR3
;

282 
tmpreg
 &= (
uint32_t
)~((uint32_t)
CR3_CLEAR_MASK
);

286 
tmpreg
 |= 
USART_InitStruct
->
USART_HardwareFlowControl
;

289 
USARTx
->
CR3
 = (
uint16_t
)
tmpreg
;

293 
	`RCC_GetClocksFreq
(&
RCC_ClocksStatus
);

295 if ((
USARTx
 == 
USART1
) || (USARTx == 
USART6
))

297 
apbclock
 = 
RCC_ClocksStatus
.
PCLK2_Frequency
;

301 
apbclock
 = 
RCC_ClocksStatus
.
PCLK1_Frequency
;

305 if ((
USARTx
->
CR1
 & 
USART_CR1_OVER8
) != 0)

308 
integerdivider
 = ((25 * 
apbclock
) / (2 * (
USART_InitStruct
->
USART_BaudRate
)));

313 
integerdivider
 = ((25 * 
apbclock
) / (4 * (
USART_InitStruct
->
USART_BaudRate
)));

315 
tmpreg
 = (
integerdivider
 / 100) << 4;

318 
fractionaldivider
 = 
integerdivider
 - (100 * (
tmpreg
 >> 4));

321 if ((
USARTx
->
CR1
 & 
USART_CR1_OVER8
) != 0)

323 
tmpreg
 |= ((((
fractionaldivider
 * 8) + 50) / 100)) & ((
uint8_t
)0x07);

327 
tmpreg
 |= ((((
fractionaldivider
 * 16) + 50) / 100)) & ((
uint8_t
)0x0F);

331 
USARTx
->
BRR
 = (
uint16_t
)
tmpreg
;

332 
	}
}

340 void 
	$USART_StructInit
(
USART_InitTypeDef
* 
USART_InitStruct
)

343 
USART_InitStruct
->
USART_BaudRate
 = 9600;

344 
USART_InitStruct
->
USART_WordLength
 = 
USART_WordLength_8b
;

345 
USART_InitStruct
->
USART_StopBits
 = 
USART_StopBits_1
;

346 
USART_InitStruct
->
USART_Parity
 = 
USART_Parity_No
 ;

347 
USART_InitStruct
->
USART_Mode
 = 
USART_Mode_Rx
 | 
USART_Mode_Tx
;

348 
USART_InitStruct
->
USART_HardwareFlowControl
 = 
USART_HardwareFlowControl_None
;

349 
	}
}

360 void 
	$USART_ClockInit
(
USART_TypeDef
* 
USARTx
, 
USART_ClockInitTypeDef
* 
USART_ClockInitStruct
)

362 
uint32_t
 
tmpreg
 = 0x00;

364 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

365 
	`assert_param
(
	`IS_USART_CLOCK
(
USART_ClockInitStruct
->
USART_Clock
));

366 
	`assert_param
(
	`IS_USART_CPOL
(
USART_ClockInitStruct
->
USART_CPOL
));

367 
	`assert_param
(
	`IS_USART_CPHA
(
USART_ClockInitStruct
->
USART_CPHA
));

368 
	`assert_param
(
	`IS_USART_LASTBIT
(
USART_ClockInitStruct
->
USART_LastBit
));

371 
tmpreg
 = 
USARTx
->
CR2
;

373 
tmpreg
 &= (
uint32_t
)~((uint32_t)
CR2_CLOCK_CLEAR_MASK
);

379 
tmpreg
 |= (
uint32_t
)
USART_ClockInitStruct
->
USART_Clock
 | USART_ClockInitStruct->
USART_CPOL
 |

380 
USART_ClockInitStruct
->
USART_CPHA
 | USART_ClockInitStruct->
USART_LastBit
;

382 
USARTx
->
CR2
 = (
uint16_t
)
tmpreg
;

383 
	}
}

391 void 
	$USART_ClockStructInit
(
USART_ClockInitTypeDef
* 
USART_ClockInitStruct
)

394 
USART_ClockInitStruct
->
USART_Clock
 = 
USART_Clock_Disable
;

395 
USART_ClockInitStruct
->
USART_CPOL
 = 
USART_CPOL_Low
;

396 
USART_ClockInitStruct
->
USART_CPHA
 = 
USART_CPHA_1Edge
;

397 
USART_ClockInitStruct
->
USART_LastBit
 = 
USART_LastBit_Disable
;

398 
	}
}

408 void 
	$USART_Cmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

411 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

412 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

414 if (
NewState
 != 
DISABLE
)

417 
USARTx
->
CR1
 |= 
USART_CR1_UE
;

422 
USARTx
->
CR1
 &= (
uint16_t
)~((uint16_t)
USART_CR1_UE
);

424 
	}
}

434 void 
	$USART_SetPrescaler
(
USART_TypeDef
* 
USARTx
, 
uint8_t
 
USART_Prescaler
)

437 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

440 
USARTx
->
GTPR
 &= 
USART_GTPR_GT
;

442 
USARTx
->
GTPR
 |= 
USART_Prescaler
;

443 
	}
}

455 void 
	$USART_OverSampling8Cmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

458 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

459 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

461 if (
NewState
 != 
DISABLE
)

464 
USARTx
->
CR1
 |= 
USART_CR1_OVER8
;

469 
USARTx
->
CR1
 &= (
uint16_t
)~((uint16_t)
USART_CR1_OVER8
);

471 
	}
}

481 void 
	$USART_OneBitMethodCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

484 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

485 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

487 if (
NewState
 != 
DISABLE
)

490 
USARTx
->
CR3
 |= 
USART_CR3_ONEBIT
;

495 
USARTx
->
CR3
 &= (
uint16_t
)~((uint16_t)
USART_CR3_ONEBIT
);

497 
	}
}

538 void 
	$USART_SendData
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
Data
)

541 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

542 
	`assert_param
(
	`IS_USART_DATA
(
Data
));

545 
USARTx
->
DR
 = (
Data
 & (
uint16_t
)0x01FF);

546 
	}
}

554 
uint16_t
 
	$USART_ReceiveData
(
USART_TypeDef
* 
USARTx
)

557 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

560 return (
uint16_t
)(
USARTx
->
DR
 & (uint16_t)0x01FF);

561 
	}
}

605 void 
	$USART_SetAddress
(
USART_TypeDef
* 
USARTx
, 
uint8_t
 
USART_Address
)

608 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

609 
	`assert_param
(
	`IS_USART_ADDRESS
(
USART_Address
));

612 
USARTx
->
CR2
 &= (
uint16_t
)~((uint16_t)
USART_CR2_ADD
);

614 
USARTx
->
CR2
 |= 
USART_Address
;

615 
	}
}

625 void 
	$USART_ReceiverWakeUpCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

628 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

629 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

631 if (
NewState
 != 
DISABLE
)

634 
USARTx
->
CR1
 |= 
USART_CR1_RWU
;

639 
USARTx
->
CR1
 &= (
uint16_t
)~((uint16_t)
USART_CR1_RWU
);

641 
	}
}

652 void 
	$USART_WakeUpConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_WakeUp
)

655 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

656 
	`assert_param
(
	`IS_USART_WAKEUP
(
USART_WakeUp
));

658 
USARTx
->
CR1
 &= (
uint16_t
)~((uint16_t)
USART_CR1_WAKE
);

659 
USARTx
->
CR1
 |= 
USART_WakeUp
;

660 
	}
}

721 void 
	$USART_LINBreakDetectLengthConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_LINBreakDetectLength
)

724 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

725 
	`assert_param
(
	`IS_USART_LIN_BREAK_DETECT_LENGTH
(
USART_LINBreakDetectLength
));

727 
USARTx
->
CR2
 &= (
uint16_t
)~((uint16_t)
USART_CR2_LBDL
);

728 
USARTx
->
CR2
 |= 
USART_LINBreakDetectLength
;

729 
	}
}

739 void 
	$USART_LINCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

742 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

743 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

745 if (
NewState
 != 
DISABLE
)

748 
USARTx
->
CR2
 |= 
USART_CR2_LINEN
;

753 
USARTx
->
CR2
 &= (
uint16_t
)~((uint16_t)
USART_CR2_LINEN
);

755 
	}
}

763 void 
	$USART_SendBreak
(
USART_TypeDef
* 
USARTx
)

766 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

769 
USARTx
->
CR1
 |= 
USART_CR1_SBK
;

770 
	}
}

816 void 
	$USART_HalfDuplexCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

819 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

820 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

822 if (
NewState
 != 
DISABLE
)

825 
USARTx
->
CR3
 |= 
USART_CR3_HDSEL
;

830 
USARTx
->
CR3
 &= (
uint16_t
)~((uint16_t)
USART_CR3_HDSEL
);

832 
	}
}

901 void 
	$USART_SetGuardTime
(
USART_TypeDef
* 
USARTx
, 
uint8_t
 
USART_GuardTime
)

904 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

907 
USARTx
->
GTPR
 &= 
USART_GTPR_PSC
;

909 
USARTx
->
GTPR
 |= (
uint16_t
)((uint16_t)
USART_GuardTime
 << 0x08);

910 
	}
}

920 void 
	$USART_SmartCardCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

923 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

924 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

925 if (
NewState
 != 
DISABLE
)

928 
USARTx
->
CR3
 |= 
USART_CR3_SCEN
;

933 
USARTx
->
CR3
 &= (
uint16_t
)~((uint16_t)
USART_CR3_SCEN
);

935 
	}
}

945 void 
	$USART_SmartCardNACKCmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

948 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

949 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

950 if (
NewState
 != 
DISABLE
)

953 
USARTx
->
CR3
 |= 
USART_CR3_NACK
;

958 
USARTx
->
CR3
 &= (
uint16_t
)~((uint16_t)
USART_CR3_NACK
);

960 
	}
}

1016 void 
	$USART_IrDAConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IrDAMode
)

1019 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1020 
	`assert_param
(
	`IS_USART_IRDA_MODE
(
USART_IrDAMode
));

1022 
USARTx
->
CR3
 &= (
uint16_t
)~((uint16_t)
USART_CR3_IRLP
);

1023 
USARTx
->
CR3
 |= 
USART_IrDAMode
;

1024 
	}
}

1034 void 
	$USART_IrDACmd
(
USART_TypeDef
* 
USARTx
, 
FunctionalState
 
NewState
)

1037 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1038 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1040 if (
NewState
 != 
DISABLE
)

1043 
USARTx
->
CR3
 |= 
USART_CR3_IREN
;

1048 
USARTx
->
CR3
 &= (
uint16_t
)~((uint16_t)
USART_CR3_IREN
);

1050 
	}
}

1080 void 
	$USART_DMACmd
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_DMAReq
, 
FunctionalState
 
NewState
)

1083 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1084 
	`assert_param
(
	`IS_USART_DMAREQ
(
USART_DMAReq
));

1085 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1087 if (
NewState
 != 
DISABLE
)

1091 
USARTx
->
CR3
 |= 
USART_DMAReq
;

1097 
USARTx
->
CR3
 &= (
uint16_t
)~
USART_DMAReq
;

1099 
	}
}

1208 void 
	$USART_ITConfig
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IT
, 
FunctionalState
 
NewState
)

1210 
uint32_t
 
usartreg
 = 0x00, 
itpos
 = 0x00, 
itmask
 = 0x00;

1211 
uint32_t
 
usartxbase
 = 0x00;

1213 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1214 
	`assert_param
(
	`IS_USART_CONFIG_IT
(
USART_IT
));

1215 
	`assert_param
(
	`IS_FUNCTIONAL_STATE
(
NewState
));

1218 if (
USART_IT
 == 
USART_IT_CTS
)

1220 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

1223 
usartxbase
 = (
uint32_t
)
USARTx
;

1226 
usartreg
 = (((
uint8_t
)
USART_IT
) >> 0x05);

1229 
itpos
 = 
USART_IT
 & 
IT_MASK
;

1230 
itmask
 = (((
uint32_t
)0x01) << 
itpos
);

1232 if (
usartreg
 == 0x01)

1234 
usartxbase
 += 0x0C;

1236 else if (
usartreg
 == 0x02)

1238 
usartxbase
 += 0x10;

1242 
usartxbase
 += 0x14;

1244 if (
NewState
 != 
DISABLE
)

1246 *(
__IO
 
uint32_t
*)
usartxbase
 |= 
itmask
;

1250 *(
__IO
 
uint32_t
*)
usartxbase
 &= ~
itmask
;

1252 
	}
}

1272 
FlagStatus
 
	$USART_GetFlagStatus
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_FLAG
)

1274 
FlagStatus
 
bitstatus
 = 
RESET
;

1276 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1277 
	`assert_param
(
	`IS_USART_FLAG
(
USART_FLAG
));

1280 if (
USART_FLAG
 == 
USART_FLAG_CTS
)

1282 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

1285 if ((
USARTx
->
SR
 & 
USART_FLAG
) != (
uint16_t
)
RESET
)

1287 
bitstatus
 = 
SET
;

1291 
bitstatus
 = 
RESET
;

1293 return 
bitstatus
;

1294 
	}
}

1321 void 
	$USART_ClearFlag
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_FLAG
)

1324 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1325 
	`assert_param
(
	`IS_USART_CLEAR_FLAG
(
USART_FLAG
));

1328 if ((
USART_FLAG
 & 
USART_FLAG_CTS
) == USART_FLAG_CTS)

1330 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

1333 
USARTx
->
SR
 = (
uint16_t
)~
USART_FLAG
;

1334 
	}
}

1354 
ITStatus
 
	$USART_GetITStatus
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IT
)

1356 
uint32_t
 
bitpos
 = 0x00, 
itmask
 = 0x00, 
usartreg
 = 0x00;

1357 
ITStatus
 
bitstatus
 = 
RESET
;

1359 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1360 
	`assert_param
(
	`IS_USART_GET_IT
(
USART_IT
));

1363 if (
USART_IT
 == 
USART_IT_CTS
)

1365 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

1369 
usartreg
 = (((
uint8_t
)
USART_IT
) >> 0x05);

1371 
itmask
 = 
USART_IT
 & 
IT_MASK
;

1372 
itmask
 = (
uint32_t
)0x01 << itmask;

1374 if (
usartreg
 == 0x01)

1376 
itmask
 &= 
USARTx
->
CR1
;

1378 else if (
usartreg
 == 0x02)

1380 
itmask
 &= 
USARTx
->
CR2
;

1384 
itmask
 &= 
USARTx
->
CR3
;

1387 
bitpos
 = 
USART_IT
 >> 0x08;

1388 
bitpos
 = (
uint32_t
)0x01 << bitpos;

1389 
bitpos
 &= 
USARTx
->
SR
;

1390 if ((
itmask
 != (
uint16_t
)
RESET
)&&(
bitpos
 != (uint16_t)RESET))

1392 
bitstatus
 = 
SET
;

1396 
bitstatus
 = 
RESET
;

1399 return 
bitstatus
;

1400 
	}
}

1428 void 
	$USART_ClearITPendingBit
(
USART_TypeDef
* 
USARTx
, 
uint16_t
 
USART_IT
)

1430 
uint16_t
 
bitpos
 = 0x00, 
itmask
 = 0x00;

1432 
	`assert_param
(
	`IS_USART_ALL_PERIPH
(
USARTx
));

1433 
	`assert_param
(
	`IS_USART_CLEAR_IT
(
USART_IT
));

1436 if (
USART_IT
 == 
USART_IT_CTS
)

1438 
	`assert_param
(
	`IS_USART_1236_PERIPH
(
USARTx
));

1441 
bitpos
 = 
USART_IT
 >> 0x08;

1442 
itmask
 = ((
uint16_t
)0x01 << (uint16_t)
bitpos
);

1443 
USARTx
->
SR
 = (
uint16_t
)~
itmask
;

1444 
	}
}

	@Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_wwdg.c

80 #include 
	~"stm32f4xx_wwdg.h
"

81 #include 
	~"stm32f4xx_rcc.h
"

96 #define 
	#WWDG_OFFSET
 (
WWDG_BASE
 - 
PERIPH_BASE
)

	)

98 #define 
	#CFR_OFFSET
 (
WWDG_OFFSET
 + 0x04)

	)

99 #define 
	#EWI_BitNumber
 0x09

	)

100 #define 
	#CFR_EWI_BB
 (
PERIPH_BB_BASE
 + (
CFR_OFFSET
 * 32) + (
EWI_BitNumber
 * 4))

	)

104 #define 
	#CFR_WDGTB_MASK
 ((
uint32_t
)0xFFFFFE7F)

	)

105 #define 
	#CFR_W_MASK
 ((
uint32_t
)0xFFFFFF80)

	)

106 #define 
	#BIT_MASK
 ((
uint8_t
)0x7F)

	)

134 void 
	$WWDG_DeInit
(void)

136 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_WWDG
, 
ENABLE
);

137 
	`RCC_APB1PeriphResetCmd
(
RCC_APB1Periph_WWDG
, 
DISABLE
);

138 
	}
}

150 void 
	$WWDG_SetPrescaler
(
uint32_t
 
WWDG_Prescaler
)

152 
uint32_t
 
tmpreg
 = 0;

154 
	`assert_param
(
	`IS_WWDG_PRESCALER
(
WWDG_Prescaler
));

156 
tmpreg
 = 
WWDG
->
CFR
 & 
CFR_WDGTB_MASK
;

158 
tmpreg
 |= 
WWDG_Prescaler
;

160 
WWDG
->
CFR
 = 
tmpreg
;

161 
	}
}

169 void 
	$WWDG_SetWindowValue
(
uint8_t
 
WindowValue
)

171 
__IO
 
uint32_t
 
tmpreg
 = 0;

174 
	`assert_param
(
	`IS_WWDG_WINDOW_VALUE
(
WindowValue
));

177 
tmpreg
 = 
WWDG
->
CFR
 & 
CFR_W_MASK
;

180 
tmpreg
 |= 
WindowValue
 & (
uint32_t
) 
BIT_MASK
;

183 
WWDG
->
CFR
 = 
tmpreg
;

184 
	}
}

192 void 
	$WWDG_EnableIT
(void)

194 *(
__IO
 
uint32_t
 *) 
CFR_EWI_BB
 = (uint32_t)
ENABLE
;

195 
	}
}

204 void 
	$WWDG_SetCounter
(
uint8_t
 
Counter
)

207 
	`assert_param
(
	`IS_WWDG_COUNTER
(
Counter
));

210 
WWDG
->
CR
 = 
Counter
 & 
BIT_MASK
;

211 
	}
}

235 void 
	$WWDG_Enable
(
uint8_t
 
Counter
)

238 
	`assert_param
(
	`IS_WWDG_COUNTER
(
Counter
));

239 
WWDG
->
CR
 = 
WWDG_CR_WDGA
 | 
Counter
;

240 
	}
}

262 
FlagStatus
 
	$WWDG_GetFlagStatus
(void)

264 
FlagStatus
 
bitstatus
 = 
RESET
;

266 if ((
WWDG
->
SR
) != (
uint32_t
)
RESET
)

268 
bitstatus
 = 
SET
;

272 
bitstatus
 = 
RESET
;

274 return 
bitstatus
;

275 
	}
}

282 void 
	$WWDG_ClearFlag
(void)

284 
WWDG
->
SR
 = (
uint32_t
)
RESET
;

285 
	}
}

	@Utilities/stm32f4_discovery.c

24 #include 
	~"stm32f4_discovery.h
"

67 
GPIO_TypeDef
* 
	gGPIO_PORT
[
LEDn
] = {
LED4_GPIO_PORT
, 
LED3_GPIO_PORT
, 
LED5_GPIO_PORT
,

68 
LED6_GPIO_PORT
};

69 const 
uint16_t
 
	gGPIO_PIN
[
LEDn
] = {
LED4_PIN
, 
LED3_PIN
, 
LED5_PIN
,

70 
LED6_PIN
};

71 const 
uint32_t
 
	gGPIO_CLK
[
LEDn
] = {
LED4_GPIO_CLK
, 
LED3_GPIO_CLK
, 
LED5_GPIO_CLK
,

72 
LED6_GPIO_CLK
};

74 
GPIO_TypeDef
* 
	gBUTTON_PORT
[
BUTTONn
] = {
USER_BUTTON_GPIO_PORT
 };

76 const 
uint16_t
 
	gBUTTON_PIN
[
BUTTONn
] = {
USER_BUTTON_PIN
 };

78 const 
uint32_t
 
	gBUTTON_CLK
[
BUTTONn
] = {
USER_BUTTON_GPIO_CLK
 };

80 const 
uint16_t
 
	gBUTTON_EXTI_LINE
[
BUTTONn
] = {
USER_BUTTON_EXTI_LINE
 };

82 const 
uint8_t
 
	gBUTTON_PORT_SOURCE
[
BUTTONn
] = {
USER_BUTTON_EXTI_PORT_SOURCE
};

84 const 
uint8_t
 
	gBUTTON_PIN_SOURCE
[
BUTTONn
] = {
USER_BUTTON_EXTI_PIN_SOURCE
 };

85 const 
uint8_t
 
	gBUTTON_IRQn
[
BUTTONn
] = {
USER_BUTTON_EXTI_IRQn
 };

87 
NVIC_InitTypeDef
 
	gNVIC_InitStructure
;

116 void 
	$STM_EVAL_LEDInit
(
Led_TypeDef
 
Led
)

118 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

121 
	`RCC_AHB1PeriphClockCmd
(
GPIO_CLK
[
Led
], 
ENABLE
);

124 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_PIN
[
Led
];

125 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_OUT
;

126 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

127 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

128 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

129 
	`GPIO_Init
(
GPIO_PORT
[
Led
], &
GPIO_InitStructure
);

130 
	}
}

142 void 
	$STM_EVAL_LEDOn
(
Led_TypeDef
 
Led
)

144 
GPIO_PORT
[
Led
]->
BSRRL
 = 
GPIO_PIN
[Led];

145 
	}
}

157 void 
	$STM_EVAL_LEDOff
(
Led_TypeDef
 
Led
)

159 
GPIO_PORT
[
Led
]->
BSRRH
 = 
GPIO_PIN
[Led];

160 
	}
}

172 void 
	$STM_EVAL_LEDToggle
(
Led_TypeDef
 
Led
)

174 
GPIO_PORT
[
Led
]->
ODR
 ^= 
GPIO_PIN
[Led];

175 
	}
}

188 void 
	$STM_EVAL_PBInit
(
Button_TypeDef
 
Button
, 
ButtonMode_TypeDef
 
Button_Mode
)

190 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

191 
EXTI_InitTypeDef
 
EXTI_InitStructure
;

192 
NVIC_InitTypeDef
 
NVIC_InitStructure
;

195 
	`RCC_AHB1PeriphClockCmd
(
BUTTON_CLK
[
Button
], 
ENABLE
);

196 
	`RCC_APB2PeriphClockCmd
(
RCC_APB2Periph_SYSCFG
, 
ENABLE
);

199 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_IN
;

200 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

201 
GPIO_InitStructure
.
GPIO_Pin
 = 
BUTTON_PIN
[
Button
];

202 
	`GPIO_Init
(
BUTTON_PORT
[
Button
], &
GPIO_InitStructure
);

204 if (
Button_Mode
 == 
BUTTON_MODE_EXTI
)

207 
	`SYSCFG_EXTILineConfig
(
BUTTON_PORT_SOURCE
[
Button
], 
BUTTON_PIN_SOURCE
[Button]);

210 
EXTI_InitStructure
.
EXTI_Line
 = 
BUTTON_EXTI_LINE
[
Button
];

211 
EXTI_InitStructure
.
EXTI_Mode
 = 
EXTI_Mode_Interrupt
;

212 
EXTI_InitStructure
.
EXTI_Trigger
 = 
EXTI_Trigger_Rising
;

213 
EXTI_InitStructure
.
EXTI_LineCmd
 = 
ENABLE
;

214 
	`EXTI_Init
(&
EXTI_InitStructure
);

217 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
BUTTON_IRQn
[
Button
];

218 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 0x0F;

219 
NVIC_InitStructure
.
NVIC_IRQChannelSubPriority
 = 0x0F;

220 
NVIC_InitStructure
.
NVIC_IRQChannelCmd
 = 
ENABLE
;

222 
	`NVIC_Init
(&
NVIC_InitStructure
);

224 
	}
}

232 
uint32_t
 
	$STM_EVAL_PBGetState
(
Button_TypeDef
 
Button
)

234 return 
	`GPIO_ReadInputDataBit
(
BUTTON_PORT
[
Button
], 
BUTTON_PIN
[Button]);

235 
	}
}

	@Utilities/stm32f4_discovery.h

24 #ifndef 
__STM32F4_DISCOVERY_H


25 #define 
	#__STM32F4_DISCOVERY_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

51 
LED4
 = 0,

52 
LED3
 = 1,

53 
LED5
 = 2,

54 
LED6
 = 3

55 } 
	tLed_TypeDef
;

59 
BUTTON_USER
 = 0,

60 } 
	tButton_TypeDef
;

64 
BUTTON_MODE_GPIO
 = 0,

65 
BUTTON_MODE_EXTI
 = 1

66 } 
	tButtonMode_TypeDef
;

78 #define 
	#LEDn
 4

	)

80 #define 
	#LED4_PIN
 
GPIO_Pin_2


81 #define 
	#LED4_GPIO_PORT
 
GPIOC


	)

82 #define 
	#LED4_GPIO_CLK
 
RCC_AHB1Periph_GPIOC


	)

84 #define 
	#LED3_PIN
 
GPIO_Pin_3


85 #define 
	#LED3_GPIO_PORT
 
GPIOC


	)

86 #define 
	#LED3_GPIO_CLK
 
RCC_AHB1Periph_GPIOC


	)

89 #define 
	#LED5_PIN
 
GPIO_Pin_14


	)

90 #define 
	#LED5_GPIO_PORT
 
GPIOD


	)

91 #define 
	#LED5_GPIO_CLK
 
RCC_AHB1Periph_GPIOD


	)

93 #define 
	#LED6_PIN
 
GPIO_Pin_15


	)

94 #define 
	#LED6_GPIO_PORT
 
GPIOD


	)

95 #define 
	#LED6_GPIO_CLK
 
RCC_AHB1Periph_GPIOD


	)

103 #define 
	#BUTTONn
 1

	)

108 #define 
	#USER_BUTTON_PIN
 
GPIO_Pin_0


	)

109 #define 
	#USER_BUTTON_GPIO_PORT
 
GPIOA


	)

110 #define 
	#USER_BUTTON_GPIO_CLK
 
RCC_AHB1Periph_GPIOA


	)

111 #define 
	#USER_BUTTON_EXTI_LINE
 
EXTI_Line0


	)

112 #define 
	#USER_BUTTON_EXTI_PORT_SOURCE
 
EXTI_PortSourceGPIOA


	)

113 #define 
	#USER_BUTTON_EXTI_PIN_SOURCE
 
EXTI_PinSource0


	)

114 #define 
	#USER_BUTTON_EXTI_IRQn
 
EXTI0_IRQn


	)

130 void 
STM_EVAL_LEDInit
(
Led_TypeDef
 
Led
);

131 void 
STM_EVAL_LEDOn
(
Led_TypeDef
 
Led
);

132 void 
STM_EVAL_LEDOff
(
Led_TypeDef
 
Led
);

133 void 
STM_EVAL_LEDToggle
(
Led_TypeDef
 
Led
);

134 void 
STM_EVAL_PBInit
(
Button_TypeDef
 
Button
, 
ButtonMode_TypeDef
 
Button_Mode
);

135 
uint32_t
 
STM_EVAL_PBGetState
(
Button_TypeDef
 
Button
);

140 #ifdef 
__cplusplus


	@Utilities/stm32f4_discovery_lis302dl.c

24 #include 
	~"stm32f4_discovery_lis302dl.h
"

50 
__IO
 
uint32_t
 
	gLIS302DLTimeout
 = 
LIS302DL_FLAG_TIMEOUT
;

53 #define 
	#READWRITE_CMD
 ((
uint8_t
)0x80)

	)

55 #define 
	#MULTIPLEBYTE_CMD
 ((
uint8_t
)0x40)

	)

57 #define 
	#DUMMY_BYTE
 ((
uint8_t
)0x00)

	)

82 static 
uint8_t
 
LIS302DL_SendByte
(uint8_t 
byte
);

83 static void 
LIS302DL_LowLevel_Init
(void);

99 void 
	$LIS302DL_Init
(
LIS302DL_InitTypeDef
 *
LIS302DL_InitStruct
)

101 
uint8_t
 
ctrl
 = 0x00;

104 
	`LIS302DL_LowLevel_Init
();

107 
ctrl
 = (
uint8_t
) (
LIS302DL_InitStruct
->
Output_DataRate
 | LIS302DL_InitStruct->
Power_Mode
 | \

108 
LIS302DL_InitStruct
->
Full_Scale
 | LIS302DL_InitStruct->
Self_Test
 | \

109 
LIS302DL_InitStruct
->
Axes_Enable
);

112 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

113 
	}
}

121 void 
	$LIS302DL_FilterConfig
(
LIS302DL_FilterConfigTypeDef
 *
LIS302DL_FilterConfigStruct
)

123 
uint8_t
 
ctrl
 = 0x00;

126 
	`LIS302DL_Read
(&
ctrl
, 
LIS302DL_CTRL_REG2_ADDR
, 1);

129 
ctrl
 &= (
uint8_t
)~(
LIS302DL_FILTEREDDATASELECTION_OUTPUTREGISTER
 | \

130 
LIS302DL_HIGHPASSFILTER_LEVEL_3
 | \

131 
LIS302DL_HIGHPASSFILTERINTERRUPT_1_2
);

133 
ctrl
 |= (
uint8_t
)(
LIS302DL_FilterConfigStruct
->
HighPassFilter_Data_Selection
 | \

134 
LIS302DL_FilterConfigStruct
->
HighPassFilter_CutOff_Frequency
 | \

135 
LIS302DL_FilterConfigStruct
->
HighPassFilter_Interrupt
);

138 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CTRL_REG2_ADDR
, 1);

139 
	}
}

147 void 
	$LIS302DL_InterruptConfig
(
LIS302DL_InterruptConfigTypeDef
 *
LIS302DL_IntConfigStruct
)

149 
uint8_t
 
ctrl
 = 0x00;

152 
	`LIS302DL_Read
(&
ctrl
, 
LIS302DL_CLICK_CFG_REG_ADDR
, 1);

155 
ctrl
 = (
uint8_t
)(
LIS302DL_IntConfigStruct
->
Latch_Request
| \

156 
LIS302DL_IntConfigStruct
->
SingleClick_Axes
 | \

157 
LIS302DL_IntConfigStruct
->
DoubleClick_Axes
);

160 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CLICK_CFG_REG_ADDR
, 1);

161 
	}
}

171 void 
	$LIS302DL_LowpowerCmd
(
uint8_t
 
LowPowerMode
)

173 
uint8_t
 
tmpreg
;

176 
	`LIS302DL_Read
(&
tmpreg
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

179 
tmpreg
 &= (
uint8_t
)~
LIS302DL_LOWPOWERMODE_ACTIVE
;

180 
tmpreg
 |= 
LowPowerMode
;

183 
	`LIS302DL_Write
(&
tmpreg
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

184 
	}
}

194 void 
	$LIS302DL_DataRateCmd
(
uint8_t
 
DataRateValue
)

196 
uint8_t
 
tmpreg
;

199 
	`LIS302DL_Read
(&
tmpreg
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

202 
tmpreg
 &= (
uint8_t
)~
LIS302DL_DATARATE_400
;

203 
tmpreg
 |= 
DataRateValue
;

206 
	`LIS302DL_Write
(&
tmpreg
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

207 
	}
}

217 void 
	$LIS302DL_FullScaleCmd
(
uint8_t
 
FS_value
)

219 
uint8_t
 
tmpreg
;

222 
	`LIS302DL_Read
(&
tmpreg
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

225 
tmpreg
 &= (
uint8_t
)~
LIS302DL_FULLSCALE_9_2
;

226 
tmpreg
 |= 
FS_value
;

229 
	`LIS302DL_Write
(&
tmpreg
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

230 
	}
}

237 void 
	$LIS302DL_RebootCmd
(void)

239 
uint8_t
 
tmpreg
;

241 
	`LIS302DL_Read
(&
tmpreg
, 
LIS302DL_CTRL_REG2_ADDR
, 1);

244 
tmpreg
 |= 
LIS302DL_BOOT_REBOOTMEMORY
;

247 
	`LIS302DL_Write
(&
tmpreg
, 
LIS302DL_CTRL_REG2_ADDR
, 1);

248 
	}
}

257 void 
	$LIS302DL_Write
(
uint8_t
* 
pBuffer
, uint8_t 
WriteAddr
, 
uint16_t
 
NumByteToWrite
)

263 if(
NumByteToWrite
 > 0x01)

265 
WriteAddr
 |= (
uint8_t
)
MULTIPLEBYTE_CMD
;

268 
	`LIS302DL_CS_LOW
();

271 
	`LIS302DL_SendByte
(
WriteAddr
);

273 while(
NumByteToWrite
 >= 0x01)

275 
	`LIS302DL_SendByte
(*
pBuffer
);

276 
NumByteToWrite
--;

277 
pBuffer
++;

281 
	`LIS302DL_CS_HIGH
();

282 
	}
}

291 void 
	$LIS302DL_Read
(
uint8_t
* 
pBuffer
, uint8_t 
ReadAddr
, 
uint16_t
 
NumByteToRead
)

293 if(
NumByteToRead
 > 0x01)

295 
ReadAddr
 |= (
uint8_t
)(
READWRITE_CMD
 | 
MULTIPLEBYTE_CMD
);

299 
ReadAddr
 |= (
uint8_t
)
READWRITE_CMD
;

302 
	`LIS302DL_CS_LOW
();

305 
	`LIS302DL_SendByte
(
ReadAddr
);

308 while(
NumByteToRead
 > 0x00)

311 *
pBuffer
 = 
	`LIS302DL_SendByte
(
DUMMY_BYTE
);

312 
NumByteToRead
--;

313 
pBuffer
++;

317 
	`LIS302DL_CS_HIGH
();

318 
	}
}

326 void 
	$LIS302DL_ReadACC
(
int32_t
* 
out
)

328 
uint8_t
 
buffer
[6];

329 
uint8_t
 
crtl
, 
i
 = 0x00;

331 
	`LIS302DL_Read
(&
crtl
, 
LIS302DL_CTRL_REG1_ADDR
, 1);

332 
	`LIS302DL_Read
(
buffer
, 
LIS302DL_OUT_X_ADDR
, 6);

334 switch(
crtl
 & 0x20)

338 for(
i
=0; i<0x03; i++)

340 *
out
 =(
int32_t
)(
LIS302DL_SENSITIVITY_2_3G
 * (
int8_t
)
buffer
[2*
i
]);

341 
out
++;

346 for(
i
=0; i<0x03; i++)

348 *
out
 =(
int32_t
)(
LIS302DL_SENSITIVITY_9_2G
 * (
int8_t
)
buffer
[2*
i
]);

349 
out
++;

355 
	}
}

362 static void 
	$LIS302DL_LowLevel_Init
(void)

364 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

365 
SPI_InitTypeDef
 
SPI_InitStructure
;

368 
	`RCC_APB2PeriphClockCmd
(
LIS302DL_SPI_CLK
, 
ENABLE
);

371 
	`RCC_AHB1PeriphClockCmd
(
LIS302DL_SPI_SCK_GPIO_CLK
 | 
LIS302DL_SPI_MISO_GPIO_CLK
 | 
LIS302DL_SPI_MOSI_GPIO_CLK
, 
ENABLE
);

374 
	`RCC_AHB1PeriphClockCmd
(
LIS302DL_SPI_CS_GPIO_CLK
, 
ENABLE
);

377 
	`RCC_AHB1PeriphClockCmd
(
LIS302DL_SPI_INT1_GPIO_CLK
, 
ENABLE
);

380 
	`RCC_AHB1PeriphClockCmd
(
LIS302DL_SPI_INT2_GPIO_CLK
, 
ENABLE
);

382 
	`GPIO_PinAFConfig
(
LIS302DL_SPI_SCK_GPIO_PORT
, 
LIS302DL_SPI_SCK_SOURCE
, 
LIS302DL_SPI_SCK_AF
);

383 
	`GPIO_PinAFConfig
(
LIS302DL_SPI_MISO_GPIO_PORT
, 
LIS302DL_SPI_MISO_SOURCE
, 
LIS302DL_SPI_MISO_AF
);

384 
	`GPIO_PinAFConfig
(
LIS302DL_SPI_MOSI_GPIO_PORT
, 
LIS302DL_SPI_MOSI_SOURCE
, 
LIS302DL_SPI_MOSI_AF
);

386 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

387 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

388 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_DOWN
;

389 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

392 
GPIO_InitStructure
.
GPIO_Pin
 = 
LIS302DL_SPI_SCK_PIN
;

393 
	`GPIO_Init
(
LIS302DL_SPI_SCK_GPIO_PORT
, &
GPIO_InitStructure
);

396 
GPIO_InitStructure
.
GPIO_Pin
 = 
LIS302DL_SPI_MOSI_PIN
;

397 
	`GPIO_Init
(
LIS302DL_SPI_MOSI_GPIO_PORT
, &
GPIO_InitStructure
);

400 
GPIO_InitStructure
.
GPIO_Pin
 = 
LIS302DL_SPI_MISO_PIN
;

401 
	`GPIO_Init
(
LIS302DL_SPI_MISO_GPIO_PORT
, &
GPIO_InitStructure
);

404 
	`SPI_I2S_DeInit
(
LIS302DL_SPI
);

405 
SPI_InitStructure
.
SPI_Direction
 = 
SPI_Direction_2Lines_FullDuplex
;

406 
SPI_InitStructure
.
SPI_DataSize
 = 
SPI_DataSize_8b
;

407 
SPI_InitStructure
.
SPI_CPOL
 = 
SPI_CPOL_Low
;

408 
SPI_InitStructure
.
SPI_CPHA
 = 
SPI_CPHA_1Edge
;

409 
SPI_InitStructure
.
SPI_NSS
 = 
SPI_NSS_Soft
;

410 
SPI_InitStructure
.
SPI_BaudRatePrescaler
 = 
SPI_BaudRatePrescaler_4
;

411 
SPI_InitStructure
.
SPI_FirstBit
 = 
SPI_FirstBit_MSB
;

412 
SPI_InitStructure
.
SPI_CRCPolynomial
 = 7;

413 
SPI_InitStructure
.
SPI_Mode
 = 
SPI_Mode_Master
;

414 
	`SPI_Init
(
LIS302DL_SPI
, &
SPI_InitStructure
);

417 
	`SPI_Cmd
(
LIS302DL_SPI
, 
ENABLE
);

420 
GPIO_InitStructure
.
GPIO_Pin
 = 
LIS302DL_SPI_CS_PIN
;

421 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_OUT
;

422 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

423 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

424 
	`GPIO_Init
(
LIS302DL_SPI_CS_GPIO_PORT
, &
GPIO_InitStructure
);

427 
	`GPIO_SetBits
(
LIS302DL_SPI_CS_GPIO_PORT
, 
LIS302DL_SPI_CS_PIN
);

430 
GPIO_InitStructure
.
GPIO_Pin
 = 
LIS302DL_SPI_INT1_PIN
;

431 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_IN
;

432 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

433 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

434 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

435 
	`GPIO_Init
(
LIS302DL_SPI_INT1_GPIO_PORT
, &
GPIO_InitStructure
);

437 
GPIO_InitStructure
.
GPIO_Pin
 = 
LIS302DL_SPI_INT2_PIN
;

438 
	`GPIO_Init
(
LIS302DL_SPI_INT2_GPIO_PORT
, &
GPIO_InitStructure
);

439 
	}
}

447 static 
uint8_t
 
	$LIS302DL_SendByte
(
uint8_t
 
byte
)

450 
LIS302DLTimeout
 = 
LIS302DL_FLAG_TIMEOUT
;

451 while (
	`SPI_I2S_GetFlagStatus
(
LIS302DL_SPI
, 
SPI_I2S_FLAG_TXE
) == 
RESET
)

453 if((
LIS302DLTimeout
--) == 0) return 
	`LIS302DL_TIMEOUT_UserCallback
();

457 
	`SPI_I2S_SendData
(
LIS302DL_SPI
, 
byte
);

460 
LIS302DLTimeout
 = 
LIS302DL_FLAG_TIMEOUT
;

461 while (
	`SPI_I2S_GetFlagStatus
(
LIS302DL_SPI
, 
SPI_I2S_FLAG_RXNE
) == 
RESET
)

463 if((
LIS302DLTimeout
--) == 0) return 
	`LIS302DL_TIMEOUT_UserCallback
();

467 return (
uint8_t
)
	`SPI_I2S_ReceiveData
(
LIS302DL_SPI
);

468 
	}
}

470 #ifdef 
USE_DEFAULT_TIMEOUT_CALLBACK


476 
uint32_t
 
	$LIS302DL_TIMEOUT_UserCallback
(void)

482 
	}
}

	@Utilities/stm32f4_discovery_lis302dl.h

24 #ifndef 
__STM32F4_DISCOVERY_LIS302DL_H


25 #define 
	#__STM32F4_DISCOVERY_LIS302DL_H


	)

27 #ifdef 
__cplusplus


32 #include 
	~"stm32f4xx.h
"

54 
uint8_t
 
Power_Mode
;

55 
uint8_t
 
Output_DataRate
;

56 
uint8_t
 
Axes_Enable
;

57 
uint8_t
 
Full_Scale
;

58 
uint8_t
 
Self_Test
;

59 }
	tLIS302DL_InitTypeDef
;

64 
uint8_t
 
HighPassFilter_Data_Selection
;

65 
uint8_t
 
HighPassFilter_CutOff_Frequency
;

66 
uint8_t
 
HighPassFilter_Interrupt
;

67 }
	tLIS302DL_FilterConfigTypeDef
;

72 
uint8_t
 
Latch_Request
;

73 
uint8_t
 
SingleClick_Axes
;

74 
uint8_t
 
DoubleClick_Axes
;

75 }
	tLIS302DL_InterruptConfigTypeDef
;

97 #define 
	#LIS302DL_FLAG_TIMEOUT
 ((
uint32_t
)0x1000)

	)

102 #define 
	#LIS302DL_SPI
 
SPI1


	)

103 #define 
	#LIS302DL_SPI_CLK
 
RCC_APB2Periph_SPI1


	)

105 #define 
	#LIS302DL_SPI_SCK_PIN
 
GPIO_Pin_5


	)

106 #define 
	#LIS302DL_SPI_SCK_GPIO_PORT
 
GPIOA


	)

107 #define 
	#LIS302DL_SPI_SCK_GPIO_CLK
 
RCC_AHB1Periph_GPIOA


	)

108 #define 
	#LIS302DL_SPI_SCK_SOURCE
 
GPIO_PinSource5


	)

109 #define 
	#LIS302DL_SPI_SCK_AF
 
GPIO_AF_SPI1


	)

111 #define 
	#LIS302DL_SPI_MISO_PIN
 
GPIO_Pin_6


	)

112 #define 
	#LIS302DL_SPI_MISO_GPIO_PORT
 
GPIOA


	)

113 #define 
	#LIS302DL_SPI_MISO_GPIO_CLK
 
RCC_AHB1Periph_GPIOA


	)

114 #define 
	#LIS302DL_SPI_MISO_SOURCE
 
GPIO_PinSource6


	)

115 #define 
	#LIS302DL_SPI_MISO_AF
 
GPIO_AF_SPI1


	)

117 #define 
	#LIS302DL_SPI_MOSI_PIN
 
GPIO_Pin_7


	)

118 #define 
	#LIS302DL_SPI_MOSI_GPIO_PORT
 
GPIOA


	)

119 #define 
	#LIS302DL_SPI_MOSI_GPIO_CLK
 
RCC_AHB1Periph_GPIOA


	)

120 #define 
	#LIS302DL_SPI_MOSI_SOURCE
 
GPIO_PinSource7


	)

121 #define 
	#LIS302DL_SPI_MOSI_AF
 
GPIO_AF_SPI1


	)

123 #define 
	#LIS302DL_SPI_CS_PIN
 
GPIO_Pin_3


	)

124 #define 
	#LIS302DL_SPI_CS_GPIO_PORT
 
GPIOE


	)

125 #define 
	#LIS302DL_SPI_CS_GPIO_CLK
 
RCC_AHB1Periph_GPIOE


	)

127 #define 
	#LIS302DL_SPI_INT1_PIN
 
GPIO_Pin_0


	)

128 #define 
	#LIS302DL_SPI_INT1_GPIO_PORT
 
GPIOE


	)

129 #define 
	#LIS302DL_SPI_INT1_GPIO_CLK
 
RCC_AHB1Periph_GPIOE


	)

130 #define 
	#LIS302DL_SPI_INT1_EXTI_LINE
 
EXTI_Line0


	)

131 #define 
	#LIS302DL_SPI_INT1_EXTI_PORT_SOURCE
 
EXTI_PortSourceGPIOE


	)

132 #define 
	#LIS302DL_SPI_INT1_EXTI_PIN_SOURCE
 
EXTI_PinSource0


	)

133 #define 
	#LIS302DL_SPI_INT1_EXTI_IRQn
 
EXTI0_IRQn


	)

135 #define 
	#LIS302DL_SPI_INT2_PIN
 
GPIO_Pin_1


	)

136 #define 
	#LIS302DL_SPI_INT2_GPIO_PORT
 
GPIOE


	)

137 #define 
	#LIS302DL_SPI_INT2_GPIO_CLK
 
RCC_AHB1Periph_GPIOE


	)

138 #define 
	#LIS302DL_SPI_INT2_EXTI_LINE
 
EXTI_Line1


	)

139 #define 
	#LIS302DL_SPI_INT2_EXTI_PORT_SOURCE
 
EXTI_PortSourceGPIOE


	)

140 #define 
	#LIS302DL_SPI_INT2_EXTI_PIN_SOURCE
 
EXTI_PinSource1


	)

141 #define 
	#LIS302DL_SPI_INT2_EXTI_IRQn
 
EXTI1_IRQn


	)

153 #define 
	#LIS302DL_WHO_AM_I_ADDR
 0x0F

	)

184 #define 
	#LIS302DL_CTRL_REG1_ADDR
 0x20

	)

222 #define 
	#LIS302DL_CTRL_REG2_ADDR
 0x21

	)

245 #define 
	#LIS302DL_CTRL_REG3_ADDR
 0x22

	)

255 #define 
	#LIS302DL_HP_FILTER_RESET_REG_ADDR
 0x23

	)

285 #define 
	#LIS302DL_STATUS_REG_ADDR
 0x27

	)

293 #define 
	#LIS302DL_OUT_X_ADDR
 0x29

	)

301 #define 
	#LIS302DL_OUT_Y_ADDR
 0x2B

	)

309 #define 
	#LIS302DL_OUT_Z_ADDR
 0x2D

	)

340 #define 
	#LIS302DL_FF_WU_CFG1_REG_ADDR
 0x30

	)

372 #define 
	#LIS302DL_FF_WU_SRC1_REG_ADDR
 0x31

	)

383 #define 
	#LIS302DL_FF_WU_THS1_REG_ADDR
 0x32

	)

391 #define 
	#LIS302DL_FF_WU_DURATION1_REG_ADDR
 0x33

	)

422 #define 
	#LIS302DL_FF_WU_CFG2_REG_ADDR
 0x34

	)

454 #define 
	#LIS302DL_FF_WU_SRC2_REG_ADDR
 0x35

	)

465 #define 
	#LIS302DL_FF_WU_THS2_REG_ADDR
 0x36

	)

473 #define 
	#LIS302DL_FF_WU_DURATION2_REG_ADDR
 0x37

	)

502 #define 
	#LIS302DL_CLICK_CFG_REG_ADDR
 0x38

	)

531 #define 
	#LIS302DL_CLICK_SRC_REG_ADDR
 0x39

	)

540 #define 
	#LIS302DL_CLICK_THSY_X_REG_ADDR
 0x3B

	)

549 #define 
	#LIS302DL_CLICK_THSZ_REG_ADDR
 0x3C

	)

557 #define 
	#LIS302DL_CLICK_TIMELIMIT_REG_ADDR
 0x3D

	)

565 #define 
	#LIS302DL_CLICK_LATENCY_REG_ADDR
 0x3E

	)

573 #define 
	#LIS302DL_CLICK_WINDOW_REG_ADDR
 0x3F

	)

579 #define 
	#LIS302DL_SENSITIVITY_2_3G
 18

	)

580 #define 
	#LIS302DL_SENSITIVITY_9_2G
 72

	)

585 #define 
	#LIS302DL_DATARATE_100
 ((
uint8_t
)0x00)

	)

586 #define 
	#LIS302DL_DATARATE_400
 ((
uint8_t
)0x80)

	)

594 #define 
	#LIS302DL_LOWPOWERMODE_POWERDOWN
 ((
uint8_t
)0x00)

	)

595 #define 
	#LIS302DL_LOWPOWERMODE_ACTIVE
 ((
uint8_t
)0x40)

	)

603 #define 
	#LIS302DL_FULLSCALE_2_3
 ((
uint8_t
)0x00)

	)

604 #define 
	#LIS302DL_FULLSCALE_9_2
 ((
uint8_t
)0x20)

	)

612 #define 
	#LIS302DL_SELFTEST_NORMAL
 ((
uint8_t
)0x00)

	)

613 #define 
	#LIS302DL_SELFTEST_P
 ((
uint8_t
)0x10)

	)

614 #define 
	#LIS302DL_SELFTEST_M
 ((
uint8_t
)0x08)

	)

622 #define 
	#LIS302DL_X_ENABLE
 ((
uint8_t
)0x01)

	)

623 #define 
	#LIS302DL_Y_ENABLE
 ((
uint8_t
)0x02)

	)

624 #define 
	#LIS302DL_Z_ENABLE
 ((
uint8_t
)0x04)

	)

625 #define 
	#LIS302DL_XYZ_ENABLE
 ((
uint8_t
)0x07)

	)

633 #define 
	#LIS302DL_SERIALINTERFACE_4WIRE
 ((
uint8_t
)0x00)

	)

634 #define 
	#LIS302DL_SERIALINTERFACE_3WIRE
 ((
uint8_t
)0x80)

	)

642 #define 
	#LIS302DL_BOOT_NORMALMODE
 ((
uint8_t
)0x00)

	)

643 #define 
	#LIS302DL_BOOT_REBOOTMEMORY
 ((
uint8_t
)0x40)

	)

651 #define 
	#LIS302DL_FILTEREDDATASELECTION_BYPASSED
 ((
uint8_t
)0x00)

	)

652 #define 
	#LIS302DL_FILTEREDDATASELECTION_OUTPUTREGISTER
 ((
uint8_t
)0x20)

	)

660 #define 
	#LIS302DL_HIGHPASSFILTERINTERRUPT_OFF
 ((
uint8_t
)0x00)

	)

661 #define 
	#LIS302DL_HIGHPASSFILTERINTERRUPT_1
 ((
uint8_t
)0x04)

	)

662 #define 
	#LIS302DL_HIGHPASSFILTERINTERRUPT_2
 ((
uint8_t
)0x08)

	)

663 #define 
	#LIS302DL_HIGHPASSFILTERINTERRUPT_1_2
 ((
uint8_t
)0x0C)

	)

671 #define 
	#LIS302DL_HIGHPASSFILTER_LEVEL_0
 ((
uint8_t
)0x00)

	)

672 #define 
	#LIS302DL_HIGHPASSFILTER_LEVEL_1
 ((
uint8_t
)0x01)

	)

673 #define 
	#LIS302DL_HIGHPASSFILTER_LEVEL_2
 ((
uint8_t
)0x02)

	)

674 #define 
	#LIS302DL_HIGHPASSFILTER_LEVEL_3
 ((
uint8_t
)0x03)

	)

683 #define 
	#LIS302DL_INTERRUPTREQUEST_NOTLATCHED
 ((
uint8_t
)0x00)

	)

684 #define 
	#LIS302DL_INTERRUPTREQUEST_LATCHED
 ((
uint8_t
)0x40)

	)

692 #define 
	#LIS302DL_CLICKINTERRUPT_XYZ_DISABLE
 ((
uint8_t
)0x00)

	)

693 #define 
	#LIS302DL_CLICKINTERRUPT_X_ENABLE
 ((
uint8_t
)0x01)

	)

694 #define 
	#LIS302DL_CLICKINTERRUPT_Y_ENABLE
 ((
uint8_t
)0x04)

	)

695 #define 
	#LIS302DL_CLICKINTERRUPT_Z_ENABLE
 ((
uint8_t
)0x10)

	)

696 #define 
	#LIS302DL_CLICKINTERRUPT_XYZ_ENABLE
 ((
uint8_t
)0x15)

	)

704 #define 
	#LIS302DL_DOUBLECLICKINTERRUPT_XYZ_DISABLE
 ((
uint8_t
)0x00)

	)

705 #define 
	#LIS302DL_DOUBLECLICKINTERRUPT_X_ENABLE
 ((
uint8_t
)0x02)

	)

706 #define 
	#LIS302DL_DOUBLECLICKINTERRUPT_Y_ENABLE
 ((
uint8_t
)0x08)

	)

707 #define 
	#LIS302DL_DOUBLECLICKINTERRUPT_Z_ENABLE
 ((
uint8_t
)0x20)

	)

708 #define 
	#LIS302DL_DOUBLECLICKINTERRUPT_XYZ_ENABLE
 ((
uint8_t
)0x2A)

	)

719 #define 
	#LIS302DL_CS_LOW
() 
	`GPIO_ResetBits
(
LIS302DL_SPI_CS_GPIO_PORT
, 
LIS302DL_SPI_CS_PIN
)

	)

720 #define 
	#LIS302DL_CS_HIGH
() 
	`GPIO_SetBits
(
LIS302DL_SPI_CS_GPIO_PORT
, 
LIS302DL_SPI_CS_PIN
)

	)

728 void 
LIS302DL_Init
(
LIS302DL_InitTypeDef
 *
LIS302DL_InitStruct
);

729 void 
LIS302DL_InterruptConfig
(
LIS302DL_InterruptConfigTypeDef
 *
LIS302DL_InterruptConfigStruct
);

730 void 
LIS302DL_FilterConfig
(
LIS302DL_FilterConfigTypeDef
 *
LIS302DL_FilterConfigStruct
);

731 void 
LIS302DL_LowpowerCmd
(
uint8_t
 
LowPowerMode
);

732 void 
LIS302DL_FullScaleCmd
(
uint8_t
 
FS_value
);

733 void 
LIS302DL_DataRateCmd
(
uint8_t
 
DataRateValue
);

734 void 
LIS302DL_RebootCmd
(void);

735 void 
LIS302DL_ReadACC
(
int32_t
* 
out
);

736 void 
LIS302DL_Write
(
uint8_t
* 
pBuffer
, uint8_t 
WriteAddr
, 
uint16_t
 
NumByteToWrite
);

737 void 
LIS302DL_Read
(
uint8_t
* 
pBuffer
, uint8_t 
ReadAddr
, 
uint16_t
 
NumByteToRead
);

748 
uint32_t
 
LIS302DL_TIMEOUT_UserCallback
(void);

750 #ifdef 
__cplusplus


	@config/nvicconf.h

33 #ifndef 
NVIC_CONF_H_


34 #define 
	#NVIC_CONF_H_


	)

36 #define 
	#NVIC_NO_GROUPS
 
NVIC_PriorityGroup_0


	)

38 #define 
	#NVIC_I2C_PRI
 5

	)

39 #define 
	#NVIC_UART_PRI
 6

	)

40 #define 
	#NVIC_TRACE_TIM_PRI
 7

	)

41 #define 
	#NVIC_ADC_PRI
 12

	)

42 #define 
	#NVIC_RADIO_PRI
 11

	)

	@drivers/inc/adc.h

8 #ifndef 
ADC_H_


9 #define 
	#ADC_H_


	)

11 #include 
	~<stdbool.h
>

12 #include 
	~<stdint.h
>

13 #include 
	~"FreeRTOS.h
"

14 #include 
	~"semphr.h
"

15 #include 
	~"stm32f4_discovery.h
"

17 #define 
	#NBR_OF_ADC_CHANNELS
 4

	)

22 
uint16_t
 
	mdata
[
NBR_OF_ADC_CHANNELS
];

23 } 
	tadcstruct
;

25 void 
adc_init
();

26 void 
adc_init_multi
();

27 
portTASK_FUNCTION_PROTO
( 
adcTask
, 
pvParameters
 );

	@drivers/inc/exti.h

27 #ifndef 
__EXTI_H__


28 #define 
	#__EXTI_H__


	)

29 #include 
	~<stdbool.h
>

31 void 
extiInit
();

32 
bool
 
extiTest
();

34 
inline
 void 
extiInterruptHandler
(void);

	@drivers/inc/i2cdev.h

28 #ifndef 
__I2CDEV_H__


29 #define 
	#__I2CDEV_H__


	)

31 #include 
	~<stdint.h
>

32 #include 
	~<stdbool.h
>

34 #include 
	~"stm32f4xx_i2c.h
"

37 #define 
	#I2CDEV_LOOPS_PER_US
 5

	)

38 #define 
	#I2CDEV_LOOPS_PER_MS
 (1000 * 
I2CDEV_LOOPS_PER_US
)

	)

40 #define 
	#I2CDEV_I2C1_PIN_SDA
 
GPIO_Pin_7


	)

41 #define 
	#I2CDEV_I2C1_PIN_SCL
 
GPIO_Pin_6


	)

43 #define 
	#I2CDEV_NO_MEM_ADDR
 0xFF

	)

55 
bool
 
i2cdevRead
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

56 
uint16_t
 
len
, 
uint8_t
 *
data
);

63 int 
i2cdevInit
(
I2C_TypeDef
 *
I2Cx
);

74 
bool
 
i2cdevReadByte
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

75 
uint8_t
 *
data
);

87 
bool
 
i2cdevReadBit
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

88 
uint8_t
 
bitNum
, uint8_t *
data
);

100 
bool
 
i2cdevReadBits
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

101 
uint8_t
 
bitStart
, uint8_t 
length
, uint8_t *
data
);

113 
bool
 
i2cdevWrite
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

114 
uint16_t
 
len
, 
uint8_t
 *
data
);

125 
bool
 
i2cdevWriteByte
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

126 
uint8_t
 
data
);

138 
bool
 
i2cdevWriteBit
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

139 
uint8_t
 
bitNum
, uint8_t 
data
);

152 
bool
 
i2cdevWriteBits
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

153 
uint8_t
 
bitStart
, uint8_t 
length
, uint8_t 
data
);

158 void 
i2cDmaInterruptHandlerI2c1
(void);

162 void 
i2cDmaInterruptHandlerI2c2
(void);

	@drivers/inc/i2croutines.h

21 #include 
	~"stm32f4xx.h
"

23 #ifndef 
__I2CROUTINES_H


24 #define 
	#__I2CROUTINES_H


	)

30 #define 
	#CR1_PE_Set
 ((
uint16_t
)0x0001)

	)

31 #define 
	#CR1_PE_Reset
 ((
uint16_t
)0xFFFE)

	)

34 #define 
	#CR1_START_Set
 ((
uint16_t
)0x0100)

	)

35 #define 
	#CR1_START_Reset
 ((
uint16_t
)0xFEFF)

	)

37 #define 
	#CR1_POS_Set
 ((
uint16_t
)0x0800)

	)

38 #define 
	#CR1_POS_Reset
 ((
uint16_t
)0xF7FF)

	)

41 #define 
	#CR1_STOP_Set
 ((
uint16_t
)0x0200)

	)

42 #define 
	#CR1_STOP_Reset
 ((
uint16_t
)0xFDFF)

	)

45 #define 
	#CR1_ACK_Set
 ((
uint16_t
)0x0400)

	)

46 #define 
	#CR1_ACK_Reset
 ((
uint16_t
)0xFBFF)

	)

49 #define 
	#CR1_ENARP_Set
 ((
uint16_t
)0x0010)

	)

50 #define 
	#CR1_ENARP_Reset
 ((
uint16_t
)0xFFEF)

	)

53 #define 
	#CR1_NOSTRETCH_Set
 ((
uint16_t
)0x0080)

	)

54 #define 
	#CR1_NOSTRETCH_Reset
 ((
uint16_t
)0xFF7F)

	)

57 #define 
	#CR1_CLEAR_Mask
 ((
uint16_t
)0xFBF5)

	)

60 #define 
	#CR2_DMAEN_Set
 ((
uint16_t
)0x0800)

	)

61 #define 
	#CR2_DMAEN_Reset
 ((
uint16_t
)0xF7FF)

	)

64 #define 
	#CR2_LAST_Set
 ((
uint16_t
)0x1000)

	)

65 #define 
	#CR2_LAST_Reset
 ((
uint16_t
)0xEFFF)

	)

68 #define 
	#CR2_FREQ_Reset
 ((
uint16_t
)0xFFC0)

	)

71 #define 
	#OAR1_ADD0_Set
 ((
uint16_t
)0x0001)

	)

72 #define 
	#OAR1_ADD0_Reset
 ((
uint16_t
)0xFFFE)

	)

75 #define 
	#OAR2_ENDUAL_Set
 ((
uint16_t
)0x0001)

	)

76 #define 
	#OAR2_ENDUAL_Reset
 ((
uint16_t
)0xFFFE)

	)

79 #define 
	#OAR2_ADD2_Reset
 ((
uint16_t
)0xFF01)

	)

82 #define 
	#CCR_FS_Set
 ((
uint16_t
)0x8000)

	)

85 #define 
	#CCR_CCR_Set
 ((
uint16_t
)0x0FFF)

	)

88 #define 
	#FLAG_Mask
 ((
uint32_t
)0x00FFFFFF)

	)

91 #define 
	#ITEN_Mask
 ((
uint32_t
)0x07000000)

	)

94 #define 
	#I2C_IT_BUF
 ((
uint16_t
)0x0400)

	)

95 #define 
	#I2C_IT_EVT
 ((
uint16_t
)0x0200)

	)

96 #define 
	#I2C_IT_ERR
 ((
uint16_t
)0x0100)

	)

99 #define 
	#ClockSpeed
 400000

	)

101 #define 
	#I2C_DIRECTION_TX
 0

	)

102 #define 
	#I2C_DIRECTION_RX
 1

	)

104 #define 
	#OwnAddress1
 0x28

	)

105 #define 
	#OwnAddress2
 0x30

	)

108 #define 
	#I2C1_DMA_CHANNEL_TX
 
DMA1_Stream6


109 #define 
	#I2C1_DMA_CHANNEL_RX
 
DMA1_Stream5


110 

	)

111 #define 
	#I2C2_DMA_CHANNEL_TX
 
DMA1_Stream6


112 #define 
	#I2C2_DMA_CHANNEL_RX
 
DMA1_Stream5


113 

	)

114 #define 
	#I2C1_DR_Address
 0x40005410

	)

115 #define 
	#I2C2_DR_Address
 0x40005810

	)

119 
	mINTERRUPT
,

120 
	mDMA


121 } 
	tI2C_ProgrammingModel
;

125 
ErrorStatus
 
I2C_Master_BufferRead
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
* 
pBuffer
, 
uint32_t
 
NumByteToRead
,

126 
I2C_ProgrammingModel
 
Mode
, 
uint8_t
 
SlaveAddress
, 
uint32_t
 
timeoutMs
);

127 
ErrorStatus
 
I2C_Master_BufferWrite
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
* 
pBuffer
, 
uint32_t
 
NumByteToWrite
,

128 
I2C_ProgrammingModel
 
Mode
, 
uint8_t
 
SlaveAddress
, 
uint32_t
 
timeoutMs
);

129 void 
I2C_Slave_BufferReadWrite
(
I2C_TypeDef
* 
I2Cx
, 
I2C_ProgrammingModel
 
Mode
);

130 void 
I2C_LowLevel_Init
(
I2C_TypeDef
* 
I2Cx
);

131 void 
I2C_DMAConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
* 
pBuffer
, 
uint32_t
 
BufferSize
, uint32_t 
Direction
);

133 void 
i2cInterruptHandlerI2c1
(void);

134 void 
i2cInterruptHandlerI2c2
(void);

135 void 
i2cErrorInterruptHandlerI2c1
(void);

136 void 
i2cErrorInterruptHandlerI2c2
(void);

137 void 
i2cDmaInterruptHandlerI2c1
(void);

	@drivers/inc/motors.h

33 #ifndef 
__MOTORS_H__


34 #define 
	#__MOTORS_H__


	)

36 #include 
	~<stdint.h
>

37 #include 
	~<stdbool.h
>

43 #define 
	#MOTORS_PWM_BITS
 16

44 #define 
	#MOTORS_PWM_PERIOD
 2000

45 #define 
	#MOTORS_PWM_PRESCALE
 80

46 

	)

50 #define 
	#MOTOR_LEFT
 0

	)

51 #define 
	#MOTOR_REAR
 1

	)

52 #define 
	#MOTOR_RIGHT
 2

	)

53 #define 
	#MOTOR_FRONT
 3

	)

55 #define 
	#MOTOR_LEFTFRONT
 0

	)

56 #define 
	#MOTOR_LEFTREAR
 1

	)

57 #define 
	#MOTOR_RIGHTFRONT
 2

	)

58 #define 
	#MOTOR_RIGHTREAR
 3

	)

60 #define 
	#MOTOR_LEFTMOTOR
 0

	)

61 #define 
	#MOTOR_RIGHTMOTOR
 1

	)

62 #define 
	#MOTOR_LEFTSERVO
 2

	)

63 #define 
	#MOTOR_RIGHTSERVO
 3

	)

64 #define 
	#MOTOR_TAIL
 4

	)

68 #define 
	#MOTORS_TEST_RATIO
 (
uint16_t
)(0.5*(1<<16))

	)

69 #define 
	#MOTORS_TEST_ON_TIME
 10

	)

70 #define 
	#MOTORS_TEST_DELAY_TIME
 50

	)

77 void 
motorsInit
();

83 
bool
 
motorsTest
(void);

88 void 
motorsSetRatio
(int 
id
, 
uint16_t
 
ratio
);

93 int 
motorsGetRatio
(int 
id
);

98 void 
motorsTestTask
(void* 
params
);

	@drivers/inc/mpu6050.h

31 #ifndef 
_MPU6050_H_


32 #define 
	#_MPU6050_H_


	)

34 #include 
	~"i2cdev.h
"

36 #define 
	#MPU6050_ADDRESS_AD0_LOW
 0x68

37 #define 
	#MPU6050_ADDRESS_AD0_HIGH
 0x69

38 #define 
	#MPU6050_DEFAULT_ADDRESS
 
MPU6050_ADDRESS_AD0_LOW


	)

39 #define 
	#MPU6050_SELF_TEST_DELAY_MS
 10

	)

43 #define 
	#MPU6050_REV_C4_ES
 0x14

44 #define 
	#MPU6050_REV_C5_ES
 0x15

45 #define 
	#MPU6050_REV_D6_ES
 0x16

46 #define 
	#MPU6050_REV_D7_ES
 0x17

47 #define 
	#MPU6050_REV_D8_ES
 0x18

48 #define 
	#MPU6050_REV_C4
 0x54

49 #define 
	#MPU6050_REV_C5
 0x55

50 #define 
	#MPU6050_REV_D6
 0x56

51 #define 
	#MPU6050_REV_D7
 0x57

52 #define 
	#MPU6050_REV_D8
 0x58

53 #define 
	#MPU6050_REV_D9
 0x59

54 

	)

55 #define 
	#MPU6050_RA_XG_OFFS_TC
 0x00

56 #define 
	#MPU6050_RA_YG_OFFS_TC
 0x01

57 #define 
	#MPU6050_RA_ZG_OFFS_TC
 0x02

58 #define 
	#MPU6050_RA_X_FINE_GAIN
 0x03

59 #define 
	#MPU6050_RA_Y_FINE_GAIN
 0x04

60 #define 
	#MPU6050_RA_Z_FINE_GAIN
 0x05

61 #define 
	#MPU6050_RA_XA_OFFS_H
 0x06

62 #define 
	#MPU6050_RA_XA_OFFS_L_TC
 0x07

	)

63 #define 
	#MPU6050_RA_YA_OFFS_H
 0x08

64 #define 
	#MPU6050_RA_YA_OFFS_L_TC
 0x09

	)

65 #define 
	#MPU6050_RA_ZA_OFFS_H
 0x0A

66 #define 
	#MPU6050_RA_ZA_OFFS_L_TC
 0x0B

	)

67 #define 
	#MPU6050_RA_PRODUCT_ID
 0x0C

	)

68 #define 
	#MPU6050_RA_XG_OFFS_USRH
 0x13

69 #define 
	#MPU6050_RA_XG_OFFS_USRL
 0x14

	)

70 #define 
	#MPU6050_RA_YG_OFFS_USRH
 0x15

71 #define 
	#MPU6050_RA_YG_OFFS_USRL
 0x16

	)

72 #define 
	#MPU6050_RA_ZG_OFFS_USRH
 0x17

73 #define 
	#MPU6050_RA_ZG_OFFS_USRL
 0x18

	)

74 #define 
	#MPU6050_RA_SMPLRT_DIV
 0x19

	)

75 #define 
	#MPU6050_RA_CONFIG
 0x1A

	)

76 #define 
	#MPU6050_RA_GYRO_CONFIG
 0x1B

	)

77 #define 
	#MPU6050_RA_ACCEL_CONFIG
 0x1C

	)

78 #define 
	#MPU6050_RA_FF_THR
 0x1D

	)

79 #define 
	#MPU6050_RA_FF_DUR
 0x1E

	)

80 #define 
	#MPU6050_RA_MOT_THR
 0x1F

	)

81 #define 
	#MPU6050_RA_MOT_DUR
 0x20

	)

82 #define 
	#MPU6050_RA_ZRMOT_THR
 0x21

	)

83 #define 
	#MPU6050_RA_ZRMOT_DUR
 0x22

	)

84 #define 
	#MPU6050_RA_FIFO_EN
 0x23

	)

85 #define 
	#MPU6050_RA_I2C_MST_CTRL
 0x24

	)

86 #define 
	#MPU6050_RA_I2C_SLV0_ADDR
 0x25

	)

87 #define 
	#MPU6050_RA_I2C_SLV0_REG
 0x26

	)

88 #define 
	#MPU6050_RA_I2C_SLV0_CTRL
 0x27

	)

89 #define 
	#MPU6050_RA_I2C_SLV1_ADDR
 0x28

	)

90 #define 
	#MPU6050_RA_I2C_SLV1_REG
 0x29

	)

91 #define 
	#MPU6050_RA_I2C_SLV1_CTRL
 0x2A

	)

92 #define 
	#MPU6050_RA_I2C_SLV2_ADDR
 0x2B

	)

93 #define 
	#MPU6050_RA_I2C_SLV2_REG
 0x2C

	)

94 #define 
	#MPU6050_RA_I2C_SLV2_CTRL
 0x2D

	)

95 #define 
	#MPU6050_RA_I2C_SLV3_ADDR
 0x2E

	)

96 #define 
	#MPU6050_RA_I2C_SLV3_REG
 0x2F

	)

97 #define 
	#MPU6050_RA_I2C_SLV3_CTRL
 0x30

	)

98 #define 
	#MPU6050_RA_I2C_SLV4_ADDR
 0x31

	)

99 #define 
	#MPU6050_RA_I2C_SLV4_REG
 0x32

	)

100 #define 
	#MPU6050_RA_I2C_SLV4_DO
 0x33

	)

101 #define 
	#MPU6050_RA_I2C_SLV4_CTRL
 0x34

	)

102 #define 
	#MPU6050_RA_I2C_SLV4_DI
 0x35

	)

103 #define 
	#MPU6050_RA_I2C_MST_STATUS
 0x36

	)

104 #define 
	#MPU6050_RA_INT_PIN_CFG
 0x37

	)

105 #define 
	#MPU6050_RA_INT_ENABLE
 0x38

	)

106 #define 
	#MPU6050_RA_DMP_INT_STATUS
 0x39

	)

107 #define 
	#MPU6050_RA_INT_STATUS
 0x3A

	)

108 #define 
	#MPU6050_RA_ACCEL_XOUT_H
 0x3B

	)

109 #define 
	#MPU6050_RA_ACCEL_XOUT_L
 0x3C

	)

110 #define 
	#MPU6050_RA_ACCEL_YOUT_H
 0x3D

	)

111 #define 
	#MPU6050_RA_ACCEL_YOUT_L
 0x3E

	)

112 #define 
	#MPU6050_RA_ACCEL_ZOUT_H
 0x3F

	)

113 #define 
	#MPU6050_RA_ACCEL_ZOUT_L
 0x40

	)

114 #define 
	#MPU6050_RA_TEMP_OUT_H
 0x41

	)

115 #define 
	#MPU6050_RA_TEMP_OUT_L
 0x42

	)

116 #define 
	#MPU6050_RA_GYRO_XOUT_H
 0x43

	)

117 #define 
	#MPU6050_RA_GYRO_XOUT_L
 0x44

	)

118 #define 
	#MPU6050_RA_GYRO_YOUT_H
 0x45

	)

119 #define 
	#MPU6050_RA_GYRO_YOUT_L
 0x46

	)

120 #define 
	#MPU6050_RA_GYRO_ZOUT_H
 0x47

	)

121 #define 
	#MPU6050_RA_GYRO_ZOUT_L
 0x48

	)

122 #define 
	#MPU6050_RA_EXT_SENS_DATA_00
 0x49

	)

123 #define 
	#MPU6050_RA_EXT_SENS_DATA_01
 0x4A

	)

124 #define 
	#MPU6050_RA_EXT_SENS_DATA_02
 0x4B

	)

125 #define 
	#MPU6050_RA_EXT_SENS_DATA_03
 0x4C

	)

126 #define 
	#MPU6050_RA_EXT_SENS_DATA_04
 0x4D

	)

127 #define 
	#MPU6050_RA_EXT_SENS_DATA_05
 0x4E

	)

128 #define 
	#MPU6050_RA_EXT_SENS_DATA_06
 0x4F

	)

129 #define 
	#MPU6050_RA_EXT_SENS_DATA_07
 0x50

	)

130 #define 
	#MPU6050_RA_EXT_SENS_DATA_08
 0x51

	)

131 #define 
	#MPU6050_RA_EXT_SENS_DATA_09
 0x52

	)

132 #define 
	#MPU6050_RA_EXT_SENS_DATA_10
 0x53

	)

133 #define 
	#MPU6050_RA_EXT_SENS_DATA_11
 0x54

	)

134 #define 
	#MPU6050_RA_EXT_SENS_DATA_12
 0x55

	)

135 #define 
	#MPU6050_RA_EXT_SENS_DATA_13
 0x56

	)

136 #define 
	#MPU6050_RA_EXT_SENS_DATA_14
 0x57

	)

137 #define 
	#MPU6050_RA_EXT_SENS_DATA_15
 0x58

	)

138 #define 
	#MPU6050_RA_EXT_SENS_DATA_16
 0x59

	)

139 #define 
	#MPU6050_RA_EXT_SENS_DATA_17
 0x5A

	)

140 #define 
	#MPU6050_RA_EXT_SENS_DATA_18
 0x5B

	)

141 #define 
	#MPU6050_RA_EXT_SENS_DATA_19
 0x5C

	)

142 #define 
	#MPU6050_RA_EXT_SENS_DATA_20
 0x5D

	)

143 #define 
	#MPU6050_RA_EXT_SENS_DATA_21
 0x5E

	)

144 #define 
	#MPU6050_RA_EXT_SENS_DATA_22
 0x5F

	)

145 #define 
	#MPU6050_RA_EXT_SENS_DATA_23
 0x60

	)

146 #define 
	#MPU6050_RA_MOT_DETECT_STATUS
 0x61

	)

147 #define 
	#MPU6050_RA_I2C_SLV0_DO
 0x63

	)

148 #define 
	#MPU6050_RA_I2C_SLV1_DO
 0x64

	)

149 #define 
	#MPU6050_RA_I2C_SLV2_DO
 0x65

	)

150 #define 
	#MPU6050_RA_I2C_SLV3_DO
 0x66

	)

151 #define 
	#MPU6050_RA_I2C_MST_DELAY_CTRL
 0x67

	)

152 #define 
	#MPU6050_RA_SIGNAL_PATH_RESET
 0x68

	)

153 #define 
	#MPU6050_RA_MOT_DETECT_CTRL
 0x69

	)

154 #define 
	#MPU6050_RA_USER_CTRL
 0x6A

	)

155 #define 
	#MPU6050_RA_PWR_MGMT_1
 0x6B

	)

156 #define 
	#MPU6050_RA_PWR_MGMT_2
 0x6C

	)

157 #define 
	#MPU6050_RA_BANK_SEL
 0x6D

	)

158 #define 
	#MPU6050_RA_MEM_START_ADDR
 0x6E

	)

159 #define 
	#MPU6050_RA_MEM_R_W
 0x6F

	)

160 #define 
	#MPU6050_RA_DMP_CFG_1
 0x70

	)

161 #define 
	#MPU6050_RA_DMP_CFG_2
 0x71

	)

162 #define 
	#MPU6050_RA_FIFO_COUNTH
 0x72

	)

163 #define 
	#MPU6050_RA_FIFO_COUNTL
 0x73

	)

164 #define 
	#MPU6050_RA_FIFO_R_W
 0x74

	)

165 #define 
	#MPU6050_RA_WHO_AM_I
 0x75

	)

167 #define 
	#MPU6050_TC_PWR_MODE_BIT
 7

	)

168 #define 
	#MPU6050_TC_OFFSET_BIT
 6

	)

169 #define 
	#MPU6050_TC_OFFSET_LENGTH
 6

	)

170 #define 
	#MPU6050_TC_OTP_BNK_VLD_BIT
 0

	)

172 #define 
	#MPU6050_VDDIO_LEVEL_VLOGIC
 0

	)

173 #define 
	#MPU6050_VDDIO_LEVEL_VDD
 1

	)

175 #define 
	#MPU6050_CFG_EXT_SYNC_SET_BIT
 5

	)

176 #define 
	#MPU6050_CFG_EXT_SYNC_SET_LENGTH
 3

	)

177 #define 
	#MPU6050_CFG_DLPF_CFG_BIT
 2

	)

178 #define 
	#MPU6050_CFG_DLPF_CFG_LENGTH
 3

	)

180 #define 
	#MPU6050_EXT_SYNC_DISABLED
 0x0

	)

181 #define 
	#MPU6050_EXT_SYNC_TEMP_OUT_L
 0x1

	)

182 #define 
	#MPU6050_EXT_SYNC_GYRO_XOUT_L
 0x2

	)

183 #define 
	#MPU6050_EXT_SYNC_GYRO_YOUT_L
 0x3

	)

184 #define 
	#MPU6050_EXT_SYNC_GYRO_ZOUT_L
 0x4

	)

185 #define 
	#MPU6050_EXT_SYNC_ACCEL_XOUT_L
 0x5

	)

186 #define 
	#MPU6050_EXT_SYNC_ACCEL_YOUT_L
 0x6

	)

187 #define 
	#MPU6050_EXT_SYNC_ACCEL_ZOUT_L
 0x7

	)

189 #define 
	#MPU6050_DLPF_BW_256
 0x00

	)

190 #define 
	#MPU6050_DLPF_BW_188
 0x01

	)

191 #define 
	#MPU6050_DLPF_BW_98
 0x02

	)

192 #define 
	#MPU6050_DLPF_BW_42
 0x03

	)

193 #define 
	#MPU6050_DLPF_BW_20
 0x04

	)

194 #define 
	#MPU6050_DLPF_BW_10
 0x05

	)

195 #define 
	#MPU6050_DLPF_BW_5
 0x06

	)

197 #define 
	#MPU6050_GCONFIG_XG_ST_BIT
 7

	)

198 #define 
	#MPU6050_GCONFIG_YG_ST_BIT
 6

	)

199 #define 
	#MPU6050_GCONFIG_ZG_ST_BIT
 5

	)

200 #define 
	#MPU6050_GCONFIG_FS_SEL_BIT
 4

	)

201 #define 
	#MPU6050_GCONFIG_FS_SEL_LENGTH
 2

	)

204 #define 
	#MPU6050_GYRO_FS_250
 0x00

	)

205 #define 
	#MPU6050_GYRO_FS_500
 0x01

	)

206 #define 
	#MPU6050_GYRO_FS_1000
 0x02

	)

207 #define 
	#MPU6050_GYRO_FS_2000
 0x03

	)

209 #define 
	#MPU6050_ACONFIG_XA_ST_BIT
 7

	)

210 #define 
	#MPU6050_ACONFIG_YA_ST_BIT
 6

	)

211 #define 
	#MPU6050_ACONFIG_ZA_ST_BIT
 5

	)

212 #define 
	#MPU6050_ACONFIG_AFS_SEL_BIT
 4

	)

213 #define 
	#MPU6050_ACONFIG_AFS_SEL_LENGTH
 2

	)

214 #define 
	#MPU6050_ACONFIG_ACCEL_HPF_BIT
 2

	)

215 #define 
	#MPU6050_ACONFIG_ACCEL_HPF_LENGTH
 3

	)

217 #define 
	#MPU6050_ACCEL_FS_2
 0x00

	)

218 #define 
	#MPU6050_ACCEL_FS_4
 0x01

	)

219 #define 
	#MPU6050_ACCEL_FS_8
 0x02

	)

220 #define 
	#MPU6050_ACCEL_FS_16
 0x03

	)

222 #define 
	#MPU6050_DHPF_RESET
 0x00

	)

223 #define 
	#MPU6050_DHPF_5
 0x01

	)

224 #define 
	#MPU6050_DHPF_2P5
 0x02

	)

225 #define 
	#MPU6050_DHPF_1P25
 0x03

	)

226 #define 
	#MPU6050_DHPF_0P63
 0x04

	)

227 #define 
	#MPU6050_DHPF_HOLD
 0x07

	)

229 #define 
	#MPU6050_TEMP_FIFO_EN_BIT
 7

	)

230 #define 
	#MPU6050_XG_FIFO_EN_BIT
 6

	)

231 #define 
	#MPU6050_YG_FIFO_EN_BIT
 5

	)

232 #define 
	#MPU6050_ZG_FIFO_EN_BIT
 4

	)

233 #define 
	#MPU6050_ACCEL_FIFO_EN_BIT
 3

	)

234 #define 
	#MPU6050_SLV2_FIFO_EN_BIT
 2

	)

235 #define 
	#MPU6050_SLV1_FIFO_EN_BIT
 1

	)

236 #define 
	#MPU6050_SLV0_FIFO_EN_BIT
 0

	)

238 #define 
	#MPU6050_MULT_MST_EN_BIT
 7

	)

239 #define 
	#MPU6050_WAIT_FOR_ES_BIT
 6

	)

240 #define 
	#MPU6050_SLV_3_FIFO_EN_BIT
 5

	)

241 #define 
	#MPU6050_I2C_MST_P_NSR_BIT
 4

	)

242 #define 
	#MPU6050_I2C_MST_CLK_BIT
 3

	)

243 #define 
	#MPU6050_I2C_MST_CLK_LENGTH
 4

	)

245 #define 
	#MPU6050_CLOCK_DIV_348
 0x0

	)

246 #define 
	#MPU6050_CLOCK_DIV_333
 0x1

	)

247 #define 
	#MPU6050_CLOCK_DIV_320
 0x2

	)

248 #define 
	#MPU6050_CLOCK_DIV_308
 0x3

	)

249 #define 
	#MPU6050_CLOCK_DIV_296
 0x4

	)

250 #define 
	#MPU6050_CLOCK_DIV_286
 0x5

	)

251 #define 
	#MPU6050_CLOCK_DIV_276
 0x6

	)

252 #define 
	#MPU6050_CLOCK_DIV_267
 0x7

	)

253 #define 
	#MPU6050_CLOCK_DIV_258
 0x8

	)

254 #define 
	#MPU6050_CLOCK_DIV_500
 0x9

	)

255 #define 
	#MPU6050_CLOCK_DIV_471
 0xA

	)

256 #define 
	#MPU6050_CLOCK_DIV_444
 0xB

	)

257 #define 
	#MPU6050_CLOCK_DIV_421
 0xC

	)

258 #define 
	#MPU6050_CLOCK_DIV_400
 0xD

	)

259 #define 
	#MPU6050_CLOCK_DIV_381
 0xE

	)

260 #define 
	#MPU6050_CLOCK_DIV_364
 0xF

	)

262 #define 
	#MPU6050_I2C_SLV_RW_BIT
 7

	)

263 #define 
	#MPU6050_I2C_SLV_ADDR_BIT
 6

	)

264 #define 
	#MPU6050_I2C_SLV_ADDR_LENGTH
 7

	)

265 #define 
	#MPU6050_I2C_SLV_EN_BIT
 7

	)

266 #define 
	#MPU6050_I2C_SLV_BYTE_SW_BIT
 6

	)

267 #define 
	#MPU6050_I2C_SLV_REG_DIS_BIT
 5

	)

268 #define 
	#MPU6050_I2C_SLV_GRP_BIT
 4

	)

269 #define 
	#MPU6050_I2C_SLV_LEN_BIT
 3

	)

270 #define 
	#MPU6050_I2C_SLV_LEN_LENGTH
 4

	)

272 #define 
	#MPU6050_I2C_SLV4_RW_BIT
 7

	)

273 #define 
	#MPU6050_I2C_SLV4_ADDR_BIT
 6

	)

274 #define 
	#MPU6050_I2C_SLV4_ADDR_LENGTH
 7

	)

275 #define 
	#MPU6050_I2C_SLV4_EN_BIT
 7

	)

276 #define 
	#MPU6050_I2C_SLV4_INT_EN_BIT
 6

	)

277 #define 
	#MPU6050_I2C_SLV4_REG_DIS_BIT
 5

	)

278 #define 
	#MPU6050_I2C_SLV4_MST_DLY_BIT
 4

	)

279 #define 
	#MPU6050_I2C_SLV4_MST_DLY_LENGTH
 5

	)

281 #define 
	#MPU6050_MST_PASS_THROUGH_BIT
 7

	)

282 #define 
	#MPU6050_MST_I2C_SLV4_DONE_BIT
 6

	)

283 #define 
	#MPU6050_MST_I2C_LOST_ARB_BIT
 5

	)

284 #define 
	#MPU6050_MST_I2C_SLV4_NACK_BIT
 4

	)

285 #define 
	#MPU6050_MST_I2C_SLV3_NACK_BIT
 3

	)

286 #define 
	#MPU6050_MST_I2C_SLV2_NACK_BIT
 2

	)

287 #define 
	#MPU6050_MST_I2C_SLV1_NACK_BIT
 1

	)

288 #define 
	#MPU6050_MST_I2C_SLV0_NACK_BIT
 0

	)

290 #define 
	#MPU6050_INTCFG_INT_LEVEL_BIT
 7

	)

291 #define 
	#MPU6050_INTCFG_INT_OPEN_BIT
 6

	)

292 #define 
	#MPU6050_INTCFG_LATCH_INT_EN_BIT
 5

	)

293 #define 
	#MPU6050_INTCFG_INT_RD_CLEAR_BIT
 4

	)

294 #define 
	#MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT
 3

	)

295 #define 
	#MPU6050_INTCFG_FSYNC_INT_EN_BIT
 2

	)

296 #define 
	#MPU6050_INTCFG_I2C_BYPASS_EN_BIT
 1

	)

297 #define 
	#MPU6050_INTCFG_CLKOUT_EN_BIT
 0

	)

299 #define 
	#MPU6050_INTMODE_ACTIVEHIGH
 0x00

	)

300 #define 
	#MPU6050_INTMODE_ACTIVELOW
 0x01

	)

302 #define 
	#MPU6050_INTDRV_PUSHPULL
 0x00

	)

303 #define 
	#MPU6050_INTDRV_OPENDRAIN
 0x01

	)

305 #define 
	#MPU6050_INTLATCH_50USPULSE
 0x00

	)

306 #define 
	#MPU6050_INTLATCH_WAITCLEAR
 0x01

	)

308 #define 
	#MPU6050_INTCLEAR_STATUSREAD
 0x00

	)

309 #define 
	#MPU6050_INTCLEAR_ANYREAD
 0x01

	)

311 #define 
	#MPU6050_INTERRUPT_FF_BIT
 7

	)

312 #define 
	#MPU6050_INTERRUPT_MOT_BIT
 6

	)

313 #define 
	#MPU6050_INTERRUPT_ZMOT_BIT
 5

	)

314 #define 
	#MPU6050_INTERRUPT_FIFO_OFLOW_BIT
 4

	)

315 #define 
	#MPU6050_INTERRUPT_I2C_MST_INT_BIT
 3

	)

316 #define 
	#MPU6050_INTERRUPT_PLL_RDY_INT_BIT
 2

	)

317 #define 
	#MPU6050_INTERRUPT_DMP_INT_BIT
 1

	)

318 #define 
	#MPU6050_INTERRUPT_DATA_RDY_BIT
 0

	)

322 #define 
	#MPU6050_DMPINT_5_BIT
 5

	)

323 #define 
	#MPU6050_DMPINT_4_BIT
 4

	)

324 #define 
	#MPU6050_DMPINT_3_BIT
 3

	)

325 #define 
	#MPU6050_DMPINT_2_BIT
 2

	)

326 #define 
	#MPU6050_DMPINT_1_BIT
 1

	)

327 #define 
	#MPU6050_DMPINT_0_BIT
 0

	)

329 #define 
	#MPU6050_MOTION_MOT_XNEG_BIT
 7

	)

330 #define 
	#MPU6050_MOTION_MOT_XPOS_BIT
 6

	)

331 #define 
	#MPU6050_MOTION_MOT_YNEG_BIT
 5

	)

332 #define 
	#MPU6050_MOTION_MOT_YPOS_BIT
 4

	)

333 #define 
	#MPU6050_MOTION_MOT_ZNEG_BIT
 3

	)

334 #define 
	#MPU6050_MOTION_MOT_ZPOS_BIT
 2

	)

335 #define 
	#MPU6050_MOTION_MOT_ZRMOT_BIT
 0

	)

337 #define 
	#MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT
 7

	)

338 #define 
	#MPU6050_DELAYCTRL_I2C_SLV4_DLY_EN_BIT
 4

	)

339 #define 
	#MPU6050_DELAYCTRL_I2C_SLV3_DLY_EN_BIT
 3

	)

340 #define 
	#MPU6050_DELAYCTRL_I2C_SLV2_DLY_EN_BIT
 2

	)

341 #define 
	#MPU6050_DELAYCTRL_I2C_SLV1_DLY_EN_BIT
 1

	)

342 #define 
	#MPU6050_DELAYCTRL_I2C_SLV0_DLY_EN_BIT
 0

	)

344 #define 
	#MPU6050_PATHRESET_GYRO_RESET_BIT
 2

	)

345 #define 
	#MPU6050_PATHRESET_ACCEL_RESET_BIT
 1

	)

346 #define 
	#MPU6050_PATHRESET_TEMP_RESET_BIT
 0

	)

348 #define 
	#MPU6050_DETECT_ACCEL_ON_DELAY_BIT
 5

	)

349 #define 
	#MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH
 2

	)

350 #define 
	#MPU6050_DETECT_FF_COUNT_BIT
 3

	)

351 #define 
	#MPU6050_DETECT_FF_COUNT_LENGTH
 2

	)

352 #define 
	#MPU6050_DETECT_MOT_COUNT_BIT
 1

	)

353 #define 
	#MPU6050_DETECT_MOT_COUNT_LENGTH
 2

	)

355 #define 
	#MPU6050_DETECT_DECREMENT_RESET
 0x0

	)

356 #define 
	#MPU6050_DETECT_DECREMENT_1
 0x1

	)

357 #define 
	#MPU6050_DETECT_DECREMENT_2
 0x2

	)

358 #define 
	#MPU6050_DETECT_DECREMENT_4
 0x3

	)

360 #define 
	#MPU6050_USERCTRL_DMP_EN_BIT
 7

	)

361 #define 
	#MPU6050_USERCTRL_FIFO_EN_BIT
 6

	)

362 #define 
	#MPU6050_USERCTRL_I2C_MST_EN_BIT
 5

	)

363 #define 
	#MPU6050_USERCTRL_I2C_IF_DIS_BIT
 4

	)

364 #define 
	#MPU6050_USERCTRL_DMP_RESET_BIT
 3

	)

365 #define 
	#MPU6050_USERCTRL_FIFO_RESET_BIT
 2

	)

366 #define 
	#MPU6050_USERCTRL_I2C_MST_RESET_BIT
 1

	)

367 #define 
	#MPU6050_USERCTRL_SIG_COND_RESET_BIT
 0

	)

369 #define 
	#MPU6050_PWR1_DEVICE_RESET_BIT
 7

	)

370 #define 
	#MPU6050_PWR1_SLEEP_BIT
 6

	)

371 #define 
	#MPU6050_PWR1_CYCLE_BIT
 5

	)

372 #define 
	#MPU6050_PWR1_TEMP_DIS_BIT
 3

	)

373 #define 
	#MPU6050_PWR1_CLKSEL_BIT
 2

	)

374 #define 
	#MPU6050_PWR1_CLKSEL_LENGTH
 3

	)

376 #define 
	#MPU6050_CLOCK_INTERNAL
 0x00

	)

377 #define 
	#MPU6050_CLOCK_PLL_XGYRO
 0x01

	)

378 #define 
	#MPU6050_CLOCK_PLL_YGYRO
 0x02

	)

379 #define 
	#MPU6050_CLOCK_PLL_ZGYRO
 0x03

	)

380 #define 
	#MPU6050_CLOCK_PLL_EXT32K
 0x04

	)

381 #define 
	#MPU6050_CLOCK_PLL_EXT19M
 0x05

	)

382 #define 
	#MPU6050_CLOCK_KEEP_RESET
 0x07

	)

384 #define 
	#MPU6050_PWR2_LP_WAKE_CTRL_BIT
 7

	)

385 #define 
	#MPU6050_PWR2_LP_WAKE_CTRL_LENGTH
 2

	)

386 #define 
	#MPU6050_PWR2_STBY_XA_BIT
 5

	)

387 #define 
	#MPU6050_PWR2_STBY_YA_BIT
 4

	)

388 #define 
	#MPU6050_PWR2_STBY_ZA_BIT
 3

	)

389 #define 
	#MPU6050_PWR2_STBY_XG_BIT
 2

	)

390 #define 
	#MPU6050_PWR2_STBY_YG_BIT
 1

	)

391 #define 
	#MPU6050_PWR2_STBY_ZG_BIT
 0

	)

393 #define 
	#MPU6050_WAKE_FREQ_1P25
 0x0

	)

394 #define 
	#MPU6050_WAKE_FREQ_2P5
 0x1

	)

395 #define 
	#MPU6050_WAKE_FREQ_5
 0x2

	)

396 #define 
	#MPU6050_WAKE_FREQ_10
 0x3

	)

398 #define 
	#MPU6050_BANKSEL_PRFTCH_EN_BIT
 6

	)

399 #define 
	#MPU6050_BANKSEL_CFG_USER_BANK_BIT
 5

	)

400 #define 
	#MPU6050_BANKSEL_MEM_SEL_BIT
 4

	)

401 #define 
	#MPU6050_BANKSEL_MEM_SEL_LENGTH
 5

	)

403 #define 
	#MPU6050_WHO_AM_I_BIT
 6

	)

404 #define 
	#MPU6050_WHO_AM_I_LENGTH
 6

	)

406 #define 
	#MPU6050_DMP_MEMORY_BANKS
 8

	)

407 #define 
	#MPU6050_DMP_MEMORY_BANK_SIZE
 256

	)

408 #define 
	#MPU6050_DMP_MEMORY_CHUNK_SIZE
 16

	)

410 #define 
	#MPU6050_DEG_PER_LSB_250
 (float)((2 * 250.0) / 65536.0)

	)

411 #define 
	#MPU6050_DEG_PER_LSB_500
 (float)((2 * 500.0) / 65536.0)

	)

412 #define 
	#MPU6050_DEG_PER_LSB_1000
 (float)((2 * 1000.0) / 65536.0)

	)

413 #define 
	#MPU6050_DEG_PER_LSB_2000
 (float)((2 * 2000.0) / 65536.0)

	)

415 #define 
	#MPU6050_G_PER_LSB_2
 (float)((2 * 2) / 65536.0)

	)

416 #define 
	#MPU6050_G_PER_LSB_4
 (float)((2 * 4) / 65536.0)

	)

417 #define 
	#MPU6050_G_PER_LSB_8
 (float)((2 * 8) / 65536.0)

	)

418 #define 
	#MPU6050_G_PER_LSB_16
 (float)((2 * 16) / 65536.0)

	)

420 #define 
	#MPU6050_ST_GYRO_LOW
 -10.0

421 #define 
	#MPU6050_ST_GYRO_HIGH
 105.0

422 #define 
	#MPU6050_ST_ACCEL_LOW
 -0.1

423 #define 
	#MPU6050_ST_ACCEL_HIGH
 1.05

424 

	)

427 void 
mpu6050Init
(
I2C_TypeDef
 *
i2cPort
);

428 
bool
 
mpu6050Test
(void);

430 
bool
 
mpu6050TestConnection
();

431 
bool
 
mpu6050EvaluateSelfTest
(float 
low
, float 
high
, float 
value
, char* 
string
);

432 
bool
 
mpu6050SelfTest
();

436 
uint8_t
 
mpu6050GetAuxVDDIOLevel
();

437 void 
mpu6050SetAuxVDDIOLevel
(
uint8_t
 
level
);

440 
uint8_t
 
mpu6050GetRate
();

441 void 
mpu6050SetRate
(
uint8_t
 
rate
);

444 
uint8_t
 
mpu6050GetExternalFrameSync
();

445 void 
mpu6050SetExternalFrameSync
(
uint8_t
 
sync
);

446 
uint8_t
 
mpu6050GetDLPFMode
();

447 void 
mpu6050SetDLPFMode
(
uint8_t
 
bandwidth
);

450 void 
mpu6050SetGyroXSelfTest
(
bool
 
enabled
);

451 void 
mpu6050SetGyroYSelfTest
(
bool
 
enabled
);

452 void 
mpu6050SetGyroZSelfTest
(
bool
 
enabled
);

453 
uint8_t
 
mpu6050GetFullScaleGyroRangeId
();

454 float 
mpu6050GetFullScaleGyroDPL
();

455 void 
mpu6050SetFullScaleGyroRange
(
uint8_t
 
range
);

458 
bool
 
mpu6050GetAccelXSelfTest
();

459 void 
mpu6050SetAccelXSelfTest
(
bool
 
enabled
);

460 
bool
 
mpu6050GetAccelYSelfTest
();

461 void 
mpu6050SetAccelYSelfTest
(
bool
 
enabled
);

462 
bool
 
mpu6050GetAccelZSelfTest
();

463 void 
mpu6050SetAccelZSelfTest
(
bool
 
enabled
);

464 
uint8_t
 
mpu6050GetFullScaleAccelRangeId
();

465 void 
mpu6050SetFullScaleAccelRange
(
uint8_t
 
range
);

466 float 
mpu6050GetFullScaleAccelGPL
();

467 
uint8_t
 
mpu6050GetDHPFMode
();

468 void 
mpu6050SetDHPFMode
(
uint8_t
 
mode
);

471 
uint8_t
 
mpu6050GetFreefallDetectionThreshold
();

472 void 
mpu6050SetFreefallDetectionThreshold
(
uint8_t
 
threshold
);

475 
uint8_t
 
mpu6050GetFreefallDetectionDuration
();

476 void 
mpu6050SetFreefallDetectionDuration
(
uint8_t
 
duration
);

479 
uint8_t
 
mpu6050GetMotionDetectionThreshold
();

480 void 
mpu6050SetMotionDetectionThreshold
(
uint8_t
 
threshold
);

483 
uint8_t
 
mpu6050GetMotionDetectionDuration
();

484 void 
mpu6050SetMotionDetectionDuration
(
uint8_t
 
duration
);

487 
uint8_t
 
mpu6050GetZeroMotionDetectionThreshold
();

488 void 
mpu6050SetZeroMotionDetectionThreshold
(
uint8_t
 
threshold
);

491 
uint8_t
 
mpu6050GetZeroMotionDetectionDuration
();

492 void 
mpu6050SetZeroMotionDetectionDuration
(
uint8_t
 
duration
);

495 
bool
 
mpu6050GetTempFIFOEnabled
();

496 void 
mpu6050SetTempFIFOEnabled
(
bool
 
enabled
);

497 
bool
 
mpu6050GetXGyroFIFOEnabled
();

498 void 
mpu6050SetXGyroFIFOEnabled
(
bool
 
enabled
);

499 
bool
 
mpu6050GetYGyroFIFOEnabled
();

500 void 
mpu6050SetYGyroFIFOEnabled
(
bool
 
enabled
);

501 
bool
 
mpu6050GetZGyroFIFOEnabled
();

502 void 
mpu6050SetZGyroFIFOEnabled
(
bool
 
enabled
);

503 
bool
 
mpu6050GetAccelFIFOEnabled
();

504 void 
mpu6050SetAccelFIFOEnabled
(
bool
 
enabled
);

505 
bool
 
mpu6050GetSlave2FIFOEnabled
();

506 void 
mpu6050SetSlave2FIFOEnabled
(
bool
 
enabled
);

507 
bool
 
mpu6050GetSlave1FIFOEnabled
();

508 void 
mpu6050SetSlave1FIFOEnabled
(
bool
 
enabled
);

509 
bool
 
mpu6050GetSlave0FIFOEnabled
();

510 void 
mpu6050SetSlave0FIFOEnabled
(
bool
 
enabled
);

513 
bool
 
mpu6050GetMultiMasterEnabled
();

514 void 
mpu6050SetMultiMasterEnabled
(
bool
 
enabled
);

515 
bool
 
mpu6050GetWaitForExternalSensorEnabled
();

516 void 
mpu6050SetWaitForExternalSensorEnabled
(
bool
 
enabled
);

517 
bool
 
mpu6050GetSlave3FIFOEnabled
();

518 void 
mpu6050SetSlave3FIFOEnabled
(
bool
 
enabled
);

519 
bool
 
mpu6050GetSlaveReadWriteTransitionEnabled
();

520 void 
mpu6050SetSlaveReadWriteTransitionEnabled
(
bool
 
enabled
);

521 
uint8_t
 
mpu6050GetMasterClockSpeed
();

522 void 
mpu6050SetMasterClockSpeed
(
uint8_t
 
speed
);

525 
uint8_t
 
mpu6050GetSlaveAddress
(uint8_t 
num
);

526 void 
mpu6050SetSlaveAddress
(
uint8_t
 
num
, uint8_t 
address
);

527 
uint8_t
 
mpu6050GetSlaveRegister
(uint8_t 
num
);

528 void 
mpu6050SetSlaveRegister
(
uint8_t
 
num
, uint8_t 
reg
);

529 
bool
 
mpu6050GetSlaveEnabled
(
uint8_t
 
num
);

530 void 
mpu6050SetSlaveEnabled
(
uint8_t
 
num
, 
bool
 
enabled
);

531 
bool
 
mpu6050GetSlaveWordByteSwap
(
uint8_t
 
num
);

532 void 
mpu6050SetSlaveWordByteSwap
(
uint8_t
 
num
, 
bool
 
enabled
);

533 
bool
 
mpu6050GetSlaveWriteMode
(
uint8_t
 
num
);

534 void 
mpu6050SetSlaveWriteMode
(
uint8_t
 
num
, 
bool
 
mode
);

535 
bool
 
mpu6050GetSlaveWordGroupOffmpu6050Set
(
uint8_t
 
num
);

536 void 
setSlaveWordGroupOffset
(
uint8_t
 
num
, 
bool
 
enabled
);

537 
uint8_t
 
mpu6050GetSlaveDataLength
(uint8_t 
num
);

538 void 
mpu6050SetSlaveDataLempu6050Seth
(
uint8_t
 
num
, uint8_t 
length
);

541 
uint8_t
 
mpu6050GetSlave4Address
();

542 void 
mpu6050SetSlave4Address
(
uint8_t
 
address
);

543 
uint8_t
 
mpu6050GetSlave4Register
();

544 void 
mpu6050SetSlave4Register
(
uint8_t
 
reg
);

545 void 
mpu6050SetSlave4OutputByte
(
uint8_t
 
data
);

546 
bool
 
mpu6050GetSlave4Enabled
();

547 void 
mpu6050SetSlave4Enabled
(
bool
 
enabled
);

548 
bool
 
mpu6050GetSlave4InterruptEnabled
();

549 void 
mpu6050SetSlave4InterruptEnabled
(
bool
 
enabled
);

550 
bool
 
mpu6050GetSlave4WriteMode
();

551 void 
mpu6050SetSlave4WriteMode
(
bool
 
mode
);

552 
uint8_t
 
mpu6050GetSlave4MasterDelay
();

553 void 
mpu6050SetSlave4MasterDelay
(
uint8_t
 
delay
);

554 
uint8_t
 
mpu6050GetSlate4InputByte
();

557 
bool
 
mpu6050GetPassthroughStatus
();

558 
bool
 
mpu6050GetSlave4IsDone
();

559 
bool
 
mpu6050GetLostArbitration
();

560 
bool
 
mpu6050GetSlave4Nack
();

561 
bool
 
mpu6050GetSlave3Nack
();

562 
bool
 
mpu6050GetSlave2Nack
();

563 
bool
 
mpu6050GetSlave1Nack
();

564 
bool
 
mpu6050GetSlave0Nack
();

567 
bool
 
mpu6050GetInterruptMode
();

568 void 
mpu6050SetInterruptMode
(
bool
 
mode
);

569 
bool
 
mpu6050GetInterruptDrive
();

570 void 
mpu6050SetInterruptDrive
(
bool
 
drive
);

571 
bool
 
mpu6050GetInterruptLatch
();

572 void 
mpu6050SetInterruptLatch
(
bool
 
latch
);

573 
bool
 
mpu6050GetInterruptLatchClear
();

574 void 
mpu6050SetInterruptLatchClear
(
bool
 
clear
);

575 
bool
 
mpu6050GetFSyncInterruptLevel
();

576 void 
mpu6050SetFSyncInterruptLevel
(
bool
 
level
);

577 
bool
 
mpu6050GetFSyncInterruptEnabled
();

578 void 
mpu6050SetFSyncInterruptEnabled
(
bool
 
enabled
);

579 
bool
 
mpu6050GetI2CBypassEnabled
();

580 void 
mpu6050SetI2CBypassEnabled
(
bool
 
enabled
);

581 
bool
 
mpu6050GetClockOutputEnabled
();

582 void 
mpu6050SetClockOutputEnabled
(
bool
 
enabled
);

585 
uint8_t
 
mpu6050GetIntEnabled
();

586 void 
mpu6050SetIntEnabled
(
uint8_t
 
enabled
);

587 
bool
 
mpu6050GetIntFreefallEnabled
();

588 void 
mpu6050SetIntFreefallEnabled
(
bool
 
enabled
);

589 
bool
 
mpu6050GetIntMotionEnabled
();

590 void 
mpu6050SetIntMotionEnabled
(
bool
 
enabled
);

591 
bool
 
mpu6050GetIntZeroMotionEnabled
();

592 void 
mpu6050SetIntZeroMotionEnabled
(
bool
 
enabled
);

593 
bool
 
mpu6050GetIntFIFOBufferOverflowEnabled
();

594 void 
mpu6050SetIntFIFOBufferOverflowEnabled
(
bool
 
enabled
);

595 
bool
 
mpu6050GetIntI2CMasterEnabled
();

596 void 
mpu6050SetIntI2CMasterEnabled
(
bool
 
enabled
);

597 
bool
 
mpu6050GetIntDataReadyEnabled
();

598 void 
mpu6050SetIntDataReadyEnabled
(
bool
 
enabled
);

601 
uint8_t
 
mpu6050GetIntStatus
();

602 
bool
 
mpu6050GetIntFreefallStatus
();

603 
bool
 
mpu6050GetIntMotionStatus
();

604 
bool
 
mpu6050GetIntZeroMotionStatus
();

605 
bool
 
mpu6050GetIntFIFOBufferOverflowStatus
();

606 
bool
 
mpu6050GetIntI2CMasterStatus
();

607 
bool
 
mpu6050GetIntDataReadyStatus
();

610 void 
mpu6050GetMotion9
(
int16_t
* 
ax
, int16_t* 
ay
, int16_t* 
az
, int16_t* 
gx
, int16_t* 
gy
, int16_t* 
gz
, int16_t* 
mx
, int16_t* 
my
, int16_t* 
mz
);

611 void 
mpu6050GetMotion6
(
int16_t
* 
ax
, int16_t* 
ay
, int16_t* 
az
, int16_t* 
gx
, int16_t* 
gy
, int16_t* 
gz
);

612 void 
mpu6050GetAcceleration
(
int16_t
* 
x
, int16_t* 
y
, int16_t* 
z
);

613 
int16_t
 
mpu6050GetAccelerationX
();

614 
int16_t
 
mpu6050GetAccelerationY
();

615 
int16_t
 
mpu6050GetAccelerationZ
();

618 
int16_t
 
mpu6050GetTemperature
();

621 void 
mpu6050GetRotation
(
int16_t
* 
x
, int16_t* 
y
, int16_t* 
z
);

622 
int16_t
 
mpu6050GetRotationX
();

623 
int16_t
 
mpu6050GetRotationY
();

624 
int16_t
 
mpu6050GetRotationZ
();

627 
uint8_t
 
mpu6050GetExternalSensorByte
(int 
position
);

628 
uint16_t
 
mpu6050GetExternalSensorWord
(int 
position
);

629 
uint32_t
 
mpu6050GetExternalSensorDWord
(int 
position
);

632 
bool
 
mpu6050GetXNegMotionDetected
();

633 
bool
 
mpu6050GetXPosMotionDetected
();

634 
bool
 
mpu6050GetYNegMotionDetected
();

635 
bool
 
mpu6050GetYPosMotionDetected
();

636 
bool
 
mpu6050GetZNegMotionDetected
();

637 
bool
 
mpu6050GetZPosMotionDetected
();

638 
bool
 
mpu6050GetZeroMotionDetected
();

641 void 
mpu6050SetSlaveOutputByte
(
uint8_t
 
num
, uint8_t 
data
);

644 
bool
 
mpu6050GetExternalShadowDelayEnabled
();

645 void 
mpu6050SetExternalShadowDelayEnabled
(
bool
 
enabled
);

646 
bool
 
mpu6050GetSlaveDelayEnabled
(
uint8_t
 
num
);

647 void 
mpu6050SetSlaveDelayEnabled
(
uint8_t
 
num
, 
bool
 
enabled
);

650 void 
rempu6050SetGyroscopePath
();

651 void 
rempu6050SetAccelerometerPath
();

652 void 
rempu6050SetTemperaturePath
();

655 
uint8_t
 
mpu6050GetAccelerometerPowerOnDelay
();

656 void 
mpu6050SetAccelerometerPowerOnDelay
(
uint8_t
 
delay
);

657 
uint8_t
 
mpu6050GetFreefallDetectionCounterDecrement
();

658 void 
mpu6050SetFreefallDetectionCounterDecrement
(
uint8_t
 
decrement
);

659 
uint8_t
 
mpu6050GetMotionDetectionCounterDecrement
();

660 void 
mpu6050SetMotionDetectionCounterDecrement
(
uint8_t
 
decrement
);

663 
bool
 
mpu6050GetFIFOEnabled
();

664 void 
mpu6050SetFIFOEnabled
(
bool
 
enabled
);

665 
bool
 
mpu6050GetI2CMasterModeEnabled
();

666 void 
mpu6050SetI2CMasterModeEnabled
(
bool
 
enabled
);

667 void 
mpu6050SwitchSPIEnabled
(
bool
 
enabled
);

668 void 
mpu6050ResetFIFO
();

669 void 
mpu6050ResetI2CMaster
();

670 void 
mpu6050ResetSensors
();

673 void 
mpu6050Reset
();

674 
bool
 
mpu6050GetSleepEnabled
();

675 void 
mpu6050SetSleepEnabled
(
bool
 
enabled
);

676 
bool
 
mpu6050GetWakeCycleEnabled
();

677 void 
mpu6050SetWakeCycleEnabled
(
bool
 
enabled
);

678 
bool
 
mpu6050GetTempSensorEnabled
();

679 void 
mpu6050SetTempSensorEnabled
(
bool
 
enabled
);

680 
uint8_t
 
mpu6050GetClockSource
();

681 void 
mpu6050SetClockSource
(
uint8_t
 
source
);

684 
uint8_t
 
mpu6050GetWakeFrequency
();

685 void 
mpu6050SetWakeFrequency
(
uint8_t
 
frequency
);

686 
bool
 
mpu6050GetStandbyXAccelEnabled
();

687 void 
mpu6050SetStandbyXAccelEnabled
(
bool
 
enabled
);

688 
bool
 
mpu6050GetStandbyYAccelEnabled
();

689 void 
mpu6050SetStandbyYAccelEnabled
(
bool
 
enabled
);

690 
bool
 
mpu6050GetStandbyZAccelEnabled
();

691 void 
mpu6050SetStandbyZAccelEnabled
(
bool
 
enabled
);

692 
bool
 
mpu6050GetStandbyXGyroEnabled
();

693 void 
mpu6050SetStandbyXGyroEnabled
(
bool
 
enabled
);

694 
bool
 
mpu6050GetStandbyYGyroEnabled
();

695 void 
mpu6050SetStandbyYGyroEnabled
(
bool
 
enabled
);

696 
bool
 
mpu6050GetStandbyZGyroEnabled
();

697 void 
mpu6050SetStandbyZGyroEnabled
(
bool
 
enabled
);

700 
uint16_t
 
mpu6050GetFIFOCount
();

703 
uint8_t
 
mpu6050GetFIFOByte
();

704 void 
mpu6050SetFIFOByte
(
uint8_t
 
data
);

705 void 
mpu6050GetFIFOBytes
(
uint8_t
 *
data
, uint8_t 
length
);

708 
uint8_t
 
mpu6050GetDeviceID
();

709 void 
mpu6050SetDeviceID
(
uint8_t
 
id
);

714 
uint8_t
 
mpu6050GetOTPBankValid
();

715 void 
mpu6050SetOTPBankValid
(
bool
 
enabled
);

716 
int8_t
 
mpu6050GetXGyroOffset
();

717 void 
mpu6050SetXGyroOffset
(
int8_t
 
offset
);

720 
int8_t
 
mpu6050GetYGyroOffset
();

721 void 
mpu6050SetYGyroOffset
(
int8_t
 
offset
);

724 
int8_t
 
mpu6050GetZGyroOffset
();

725 void 
mpu6050SetGyroOffset
(
int8_t
 
offset
);

728 
int8_t
 
mpu6050GetXFineGain
();

729 void 
mpu6050SetXFineGain
(
int8_t
 
gain
);

732 
int8_t
 
mpu6050GetYFineGain
();

733 void 
mpu6050SetYFineGain
(
int8_t
 
gain
);

736 
int8_t
 
mpu6050GetZFineGain
();

737 void 
mpu6050SetZFineGain
(
int8_t
 
gain
);

740 
int16_t
 
mpu6050GetXAccelOffset
();

741 void 
mpu6050SetXAccelOffset
(
int16_t
 
offset
);

744 
int16_t
 
mpu6050GetYAccelOffset
();

745 void 
mpu6050SetYAccelOffset
(
int16_t
 
offset
);

748 
int16_t
 
mpu6050GetZAccelOffset
();

749 void 
mpu6050SetZAccelOffset
(
int16_t
 
offset
);

752 
int16_t
 
mpu6050GetXGyroOffsetUser
();

753 void 
mpu6050SetXGyroOffsetUser
(
int16_t
 
offset
);

756 
int16_t
 
mpu6050GetYGyroOffsetUser
();

757 void 
mpu6050SetYGyroOffsetUser
(
int16_t
 
offset
);

760 
int16_t
 
mpu6050GetZGyroOffsetUser
();

761 void 
mpu6050SetZGyroOffsetUser
(
int16_t
 
offset
);

764 
bool
 
mpu6050GetIntPLLReadyEnabled
();

765 void 
mpu6050SetIntPLLReadyEnabled
(
bool
 
enabled
);

766 
bool
 
mpu6050GetIntDMPEnabled
();

767 void 
mpu6050SetIntDMPEnabled
(
bool
 
enabled
);

770 
bool
 
mpu6050GetDMPInt5Status
();

771 
bool
 
mpu6050GetDMPInt4Status
();

772 
bool
 
mpu6050GetDMPInt3Status
();

773 
bool
 
mpu6050GetDMPInt2Status
();

774 
bool
 
mpu6050GetDMPInt1Status
();

775 
bool
 
mpu6050GetDMPInt0Status
();

778 
bool
 
mpu6050GetIntPLLReadyStatus
();

779 
bool
 
mpu6050GetIntDMPStatus
();

782 
bool
 
mpu6050GetDMPEnabled
();

783 void 
mpu6050SetDMPEnabled
(
bool
 
enabled
);

784 void 
mpu6050ResetDMP
();

787 void 
mpu6050SetMemoryBank
(
uint8_t
 
bank
, 
bool
 
prefetchEnabled
, bool 
userBank
);

790 void 
mpu6050SetMemoryStartAddress
(
uint8_t
 
address
);

793 
uint8_t
 
mpu6050ReadMemoryByte
();

794 void 
mpu6050WriteMemoryByte
(
uint8_t
 
data
);

795 void 
mpu6050ReadMemoryBlock
(
uint8_t
 *
data
, 
uint16_t
 
dataSize
, uint8_t 
bank
, uint8_t 
address
);

796 
bool
 
mpu6050WriteMemoryBlock
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
, uint8_t 
bank
, uint8_t 
address
, bool 
verify
);

797 
bool
 
mpu6050WriteProgMemoryBlock
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
, uint8_t 
bank
, uint8_t 
address
, bool 
verify
);

799 
bool
 
mpu6050WriteDMPConfigurationSet
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
);

800 
bool
 
mpu6050WiteProgDMPConfigurationSet
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
);

803 
uint8_t
 
mpu6050GetDMPConfig1
();

804 void 
mpu6050SetDMPConfig1
(
uint8_t
 
config
);

807 
uint8_t
 
mpu6050GetDMPConfig2
();

808 void 
mpu6050SetDMPConfig2
(
uint8_t
 
config
);

811 #ifdef 
MPU6050_INCLUDE_DMP_MOTIONAPPS20


825 #define 
	#MPU6050_DMP_CODE_SIZE
 1929

	)

830 const 
prog_uchar
 
	gdmpMemory
[
MPU6050_DMP_CODE_SIZE
] 
	gPROGMEM
 = {

969 #define 
	#MPU6050_DMP_CONFIG_SIZE
 192

	)

972 const 
prog_uchar
 
	gdmpConfig
[
MPU6050_DMP_CONFIG_SIZE
] 
	gPROGMEM
 = {

	@drivers/inc/nRF24L01reg.h

26 #ifndef 
__NRF24L01REG_H__


27 #define 
	#__NRF24L01REG_H__


	)

30 #define 
	#REG_CONFIG
 0x00

	)

31 #define 
	#REG_EN_AA
 0x01

	)

32 #define 
	#REG_EN_RXADDR
 0x02

	)

33 #define 
	#REG_SETUP_AW
 0x03

	)

34 #define 
	#REG_SETUP_RETR
 0x04

	)

35 #define 
	#REG_RF_CH
 0x05

	)

36 #define 
	#REG_RF_SETUP
 0x06

	)

37 #define 
	#REG_STATUS
 0x07

	)

38 #define 
	#REG_OBSERVE_TX
 0x08

	)

39 #define 
	#REG_RPD
 0x09

	)

40 #define 
	#REG_RX_ADDR_P0
 0x0A

	)

41 #define 
	#REG_RX_ADDR_P1
 0x0B

	)

42 #define 
	#REG_RX_ADDR_P2
 0x0C

	)

43 #define 
	#REG_RX_ADDR_P3
 0x0D

	)

44 #define 
	#REG_RX_ADDR_P4
 0x0E

	)

45 #define 
	#REG_RX_ADDR_P5
 0x0F

	)

46 #define 
	#REG_TX_ADDR
 0x10

	)

47 #define 
	#REG_RX_PW_P0
 0x11

	)

48 #define 
	#REG_RX_PW_P1
 0x12

	)

49 #define 
	#REG_RX_PW_P2
 0x13

	)

50 #define 
	#REG_RX_PW_P3
 0x14

	)

51 #define 
	#REG_RX_PW_P4
 0x15

	)

52 #define 
	#REG_RX_PW_P5
 0x16

	)

53 #define 
	#REG_FIFO_STATUS
 0x17

	)

54 #define 
	#REG_DYNPD
 0x1C

	)

55 #define 
	#REG_FEATURE
 0x1D

	)

57 #define 
	#VAL_RF_SETUP_250K
 0x26

	)

58 #define 
	#VAL_RF_SETUP_1M
 0x06

	)

59 #define 
	#VAL_RF_SETUP_2M
 0x0E

	)

61 #define 
	#VAL_SETUP_AW_3B
 1

	)

62 #define 
	#VAL_SETUP_AW_4B
 2

	)

63 #define 
	#VAL_SETUP_AW_5B
 3

	)

	@drivers/inc/nrf24l01.h

27 #ifndef 
__NRF24L01_H__


28 #define 
	#__NRF24L01_H__


	)

30 #include 
	~<stdbool.h
>

32 #include 
	~"nRF24L01reg.h
"

35 void 
nrfInit
(void);

36 
bool
 
nrfTest
(void);

39 void 
nrfIsr
();

42 #define 
	#RADIO_RATE_250K
 0

	)

43 #define 
	#RADIO_RATE_1M
 1

	)

44 #define 
	#RADIO_RATE_2M
 2

	)

45 #define 
	#TX_PAYLOAD_WIDTH
 24

	)

50 unsigned char 
nrfReadReg
(unsigned char 
address
, char *
buffer
, int 
len
);

51 unsigned char 
nrfRead1Reg
(unsigned char 
address
);

52 unsigned char 
nrfWriteReg
(unsigned char 
address
, char *
buffer
, int 
len
);

53 unsigned char 
nrfWrite1Reg
(unsigned char 
address
, char 
byte
);

56 void 
nrfSetInterruptCallback
(void (*
cb
)(void));

59 unsigned char 
	`nrfNop
();

60 unsigned char 
	`nrfFlushRx
();

61 unsigned char 
	`nrfFlushTx
();

62 unsigned char 
	`nrfRxLength
(unsigned int 
pipe
);

63 unsigned char 
	`nrfActivate
();

64 unsigned char 
	`nrfWriteAck
(unsigned int 
pipe
, char *
buffer
, int 
len
);

65 unsigned char 
	`nrfReadRX
(char *
buffer
, int 
len
);

66 void 
	`nrfSetChannel
(unsigned int 
channel
);

67 void 
	`nrfSetDatarate
(int 
datarate
);

68 void 
	`nrfSetAddress
(unsigned int 
pipe
, char* 
address
);

69 void 
	`nrfSetEnable
(
bool
 
enable
);

70 unsigned char 
	`nrfGetStatus
();

	@drivers/inc/nvic.h

26 #ifndef 
NVIC_H_


27 #define 
	#NVIC_H_


	)

32 void 
nvicInit
(void);

	@drivers/inc/px4flow.h

9 #include 
	~"stm32f4xx.h
"

10 #include 
	~"stm32f4_discovery.h
"

12 #ifndef 
PX4FLOW_H_


13 #define 
	#PX4FLOW_H_


	)

15 void 
init_I2C2
();

16 void 
init_I2C1
();

17 void 
init_I2C1_new
();

18 void 
init_I2C2_new
();

19 #define 
	#PX4_ADDRESS
 0x42

20 void 
	`I2C_start
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
address
, uint8_t 
direction
);

	)

21 void 
I2C_write
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
data
);

22 
uint8_t
 
I2C_startslave1
(
I2C_TypeDef
* 
I2Cx
, uint8_t 
address
);

23 void 
I2C_startslave
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
address
);

24 void 
I2C_send
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
data
);

25 
uint8_t
 
I2C_read
(
I2C_TypeDef
* 
I2Cx
);

26 void 
I2C_startsign
(
I2C_TypeDef
* 
I2Cx
);

27 void 
I2C_setreceiver
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
address
);

28 void 
I2C_stop
(
I2C_TypeDef
* 
I2Cx
);

29 #define 
	#NVIC_I2C_PRI
 5

	)

36 typedef struct 
	si2c_frame


38 
uint16_t
 
	mframe_count
;

39 
int16_t
 
	mpixel_flow_x_sum
;

40 
int16_t
 
	mpixel_flow_y_sum
;

41 
int16_t
 
	mflow_comp_m_x
;

42 
int16_t
 
	mflow_comp_m_y
;

43 
int16_t
 
	mqual
;

44 
int16_t
 
	mgyro_x_rate
;

45 
int16_t
 
	mgyro_y_rate
;

46 
int16_t
 
	mgyro_z_rate
;

47 
uint8_t
 
	mgyro_range
;

48 
uint8_t
 
	msonar_timestamp
;

49 
int16_t
 
	mground_distance
;

50 } 
	ti2c_frame
;

52 typedef struct 
	si2c_integral_frame


54 
uint16_t
 
	mframe_count_since_last_readout
;

55 
int16_t
 
	mpixel_flow_x_integral
;

56 
int16_t
 
	mpixel_flow_y_integral
;

57 
int16_t
 
	mgyro_x_rate_integral
;

58 
int16_t
 
	mgyro_y_rate_integral
;

59 
int16_t
 
	mgyro_z_rate_integral
;

60 
uint32_t
 
	mintegration_timespan
;

61 
uint32_t
 
	msonar_timestamp
;

62 
int16_t
 
	mground_distance
;

63 
int16_t
 
	mgyro_temperature
;

64 
uint8_t
 
	mquality
;

65 } 
	t__attribute__
((
	tpacked
)) 
	ti2c_integral_frame
;

67 void 
readx1
(
I2C_TypeDef
* 
I2Cx
, 
i2c_frame
* 
px4data
, 
uint8_t
 
address
,uint8_t 
status
);

68 void 
readx
(
I2C_TypeDef
* 
I2Cx
, 
i2c_frame
* 
px4data
, 
uint8_t
 
address
);

	@drivers/src/adc.c

8 #include 
	~"stm32f4xx.h
"

9 #include 
	~"stm32f4xx_conf.h
"

10 #include 
	~"FreeRTOS.h
"

11 #include 
	~"task.h
"

12 #include 
	~"semphr.h
"

13 #include 
	~"adc.h
"

16 volatile 
uint16_t
 
	gADCConvertedValues
[
NBR_OF_ADC_CHANNELS
];

17 
xQueueHandle
 
	gadcQueue
, 
	gadctransferQueue
;

19 int 
	gk
 = 1;

21 void 
	$adc_init
()

23 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

25 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOA
, 
ENABLE
);

28 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_3
 | 
GPIO_Pin_5
;

29 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AN
;

30 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

31 
	`GPIO_Init
(
GPIOA
, &
GPIO_InitStructure
);

33 
ADC_InitTypeDef
 
ADC_InitStructure
;

34 
ADC_CommonInitTypeDef
 
ADC_CommonInitStructure
;

35 
DMA_InitTypeDef
 
DMA_InitStructure
;

38 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_DMA2
, 
ENABLE
);

39 
	`RCC_APB2PeriphClockCmd
(
RCC_APB2Periph_ADC1
, 
ENABLE
);

42 
	`DMA_DeInit
(
DMA2_Stream0
);

43 
DMA_InitStructure
.
DMA_Channel
 = 
DMA_Channel_0
;

44 
DMA_InitStructure
.
DMA_PeripheralBaseAddr
 = (
uint32_t
)&
ADC1
->
DR
;

45 
DMA_InitStructure
.
DMA_Memory0BaseAddr
 = (
uint32_t
)&
ADCConvertedValues
[0];

46 
DMA_InitStructure
.
DMA_DIR
 = 
DMA_DIR_PeripheralToMemory
;

47 
DMA_InitStructure
.
DMA_BufferSize
 = 2;

48 
DMA_InitStructure
.
DMA_PeripheralInc
 = 
DMA_PeripheralInc_Disable
;

49 
DMA_InitStructure
.
DMA_MemoryInc
 = 
DMA_MemoryInc_Enable
;

50 
DMA_InitStructure
.
DMA_PeripheralDataSize
 = 
DMA_PeripheralDataSize_HalfWord
;

51 
DMA_InitStructure
.
DMA_MemoryDataSize
 = 
DMA_MemoryDataSize_HalfWord
;

52 
DMA_InitStructure
.
DMA_Mode
 = 
DMA_Mode_Circular
;

53 
DMA_InitStructure
.
DMA_Priority
 = 
DMA_Priority_High
;

54 
DMA_InitStructure
.
DMA_FIFOMode
 = 
DMA_FIFOMode_Disable
;

55 
DMA_InitStructure
.
DMA_FIFOThreshold
 = 
DMA_FIFOThreshold_HalfFull
;

56 
DMA_InitStructure
.
DMA_MemoryBurst
 = 
DMA_MemoryBurst_Single
;

57 
DMA_InitStructure
.
DMA_PeripheralBurst
 = 
DMA_PeripheralBurst_Single
;

58 
	`DMA_Init
(
DMA2_Stream0
, &
DMA_InitStructure
);

60 
	`DMA_Cmd
(
DMA2_Stream0
, 
ENABLE
);

63 
ADC_CommonInitStructure
.
ADC_Mode
 = 
ADC_Mode_Independent
;

64 
ADC_CommonInitStructure
.
ADC_Prescaler
 = 
ADC_Prescaler_Div2
;

65 
ADC_CommonInitStructure
.
ADC_DMAAccessMode
 = 
ADC_DMAAccessMode_Disabled
;

66 
ADC_CommonInitStructure
.
ADC_TwoSamplingDelay
 = 
ADC_TwoSamplingDelay_5Cycles
;

67 
	`ADC_CommonInit
(&
ADC_CommonInitStructure
);

70 
ADC_InitStructure
.
ADC_Resolution
 = 
ADC_Resolution_12b
;

71 
ADC_InitStructure
.
ADC_ScanConvMode
 = 
ENABLE
;

72 
ADC_InitStructure
.
ADC_ContinuousConvMode
 = 
ENABLE
;

73 
ADC_InitStructure
.
ADC_ExternalTrigConvEdge
 = 
ADC_ExternalTrigConvEdge_None
;

74 
ADC_InitStructure
.
ADC_ExternalTrigConv
 = 
ADC_ExternalTrigConv_T1_CC1
;

75 
ADC_InitStructure
.
ADC_DataAlign
 = 
ADC_DataAlign_Right
;

76 
ADC_InitStructure
.
ADC_NbrOfConversion
 = 2;

77 
	`ADC_Init
(
ADC1
, &
ADC_InitStructure
);

80 
	`ADC_RegularChannelConfig
(
ADC1
, 
ADC_Channel_3
, 1, 
ADC_SampleTime_480Cycles
);

81 
	`ADC_RegularChannelConfig
(
ADC1
, 
ADC_Channel_5
, 2, 
ADC_SampleTime_480Cycles
);

84 
	`ADC_DMARequestAfterLastTransferCmd
(
ADC1
, 
ENABLE
);

87 
	`ADC_DMACmd
(
ADC1
, 
ENABLE
);

90 
	`ADC_Cmd
(
ADC1
, 
ENABLE
);

93 
	`ADC_SoftwareStartConv
(
ADC1
);

95 
	`xTaskCreate
(
adcTask
, (const signed char * const)"ADC",

96 
configMINIMAL_STACK_SIZE
, 
NULL
, 3, NULL);

97 
	}
}

99 void 
	$adc_init_multi
()

101 
k
 = 1;

102 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

104 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOA
, 
ENABLE
);

107 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_6
|
GPIO_Pin_7
|
GPIO_Pin_3
 | 
GPIO_Pin_5
;

108 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AN
;

109 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

110 
	`GPIO_Init
(
GPIOA
, &
GPIO_InitStructure
);

112 
ADC_InitTypeDef
 
ADC_InitStructure
;

113 
ADC_CommonInitTypeDef
 
ADC_CommonInitStructure
;

114 
DMA_InitTypeDef
 
DMA_InitStructure
;

117 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_DMA2
, 
ENABLE
);

118 
	`RCC_APB2PeriphClockCmd
(
RCC_APB2Periph_ADC1
, 
ENABLE
);

121 
	`DMA_DeInit
(
DMA2_Stream0
);

122 
DMA_InitStructure
.
DMA_Channel
 = 
DMA_Channel_0
;

123 
DMA_InitStructure
.
DMA_PeripheralBaseAddr
 = (
uint32_t
)&
ADC1
->
DR
;

124 
DMA_InitStructure
.
DMA_Memory0BaseAddr
 = (
uint32_t
)&
ADCConvertedValues
[0];

125 
DMA_InitStructure
.
DMA_DIR
 = 
DMA_DIR_PeripheralToMemory
;

126 
DMA_InitStructure
.
DMA_BufferSize
 = 
NBR_OF_ADC_CHANNELS
*2;

127 
DMA_InitStructure
.
DMA_PeripheralInc
 = 
DMA_PeripheralInc_Disable
;

128 
DMA_InitStructure
.
DMA_MemoryInc
 = 
DMA_MemoryInc_Enable
;

129 
DMA_InitStructure
.
DMA_PeripheralDataSize
 = 
DMA_PeripheralDataSize_HalfWord
;

130 
DMA_InitStructure
.
DMA_MemoryDataSize
 = 
DMA_MemoryDataSize_HalfWord
;

131 
DMA_InitStructure
.
DMA_Mode
 = 
DMA_Mode_Circular
;

132 
DMA_InitStructure
.
DMA_Priority
 = 
DMA_Priority_High
;

133 
DMA_InitStructure
.
DMA_FIFOMode
 = 
DMA_FIFOMode_Disable
;

134 
DMA_InitStructure
.
DMA_FIFOThreshold
 = 
DMA_FIFOThreshold_HalfFull
;

135 
DMA_InitStructure
.
DMA_MemoryBurst
 = 
DMA_MemoryBurst_Single
;

136 
DMA_InitStructure
.
DMA_PeripheralBurst
 = 
DMA_PeripheralBurst_Single
;

137 
	`DMA_Init
(
DMA2_Stream0
, &
DMA_InitStructure
);

139 
	`DMA_Cmd
(
DMA2_Stream0
, 
ENABLE
);

142 
ADC_CommonInitStructure
.
ADC_Mode
 = 
ADC_Mode_Independent
;

143 
ADC_CommonInitStructure
.
ADC_Prescaler
 = 
ADC_Prescaler_Div2
;

144 
ADC_CommonInitStructure
.
ADC_DMAAccessMode
 = 
ADC_DMAAccessMode_Disabled
;

145 
ADC_CommonInitStructure
.
ADC_TwoSamplingDelay
 = 
ADC_TwoSamplingDelay_5Cycles
;

146 
	`ADC_CommonInit
(&
ADC_CommonInitStructure
);

149 
ADC_InitStructure
.
ADC_Resolution
 = 
ADC_Resolution_12b
;

150 
ADC_InitStructure
.
ADC_ScanConvMode
 = 
ENABLE
;

151 
ADC_InitStructure
.
ADC_ContinuousConvMode
 = 
ENABLE
;

152 
ADC_InitStructure
.
ADC_ExternalTrigConvEdge
 = 
ADC_ExternalTrigConvEdge_None
;

153 
ADC_InitStructure
.
ADC_ExternalTrigConv
 = 
ADC_ExternalTrigConv_T1_CC1
;

154 
ADC_InitStructure
.
ADC_DataAlign
 = 
ADC_DataAlign_Right
;

155 
ADC_InitStructure
.
ADC_NbrOfConversion
 = 
NBR_OF_ADC_CHANNELS
;

156 
	`ADC_Init
(
ADC1
, &
ADC_InitStructure
);

159 
	`ADC_RegularChannelConfig
(
ADC1
, 
ADC_Channel_3
, 1, 
ADC_SampleTime_480Cycles
);

160 
	`ADC_RegularChannelConfig
(
ADC1
, 
ADC_Channel_5
, 2, 
ADC_SampleTime_480Cycles
);

161 
	`ADC_RegularChannelConfig
(
ADC1
, 
ADC_Channel_6
, 3, 
ADC_SampleTime_480Cycles
);

162 
	`ADC_RegularChannelConfig
(
ADC1
, 
ADC_Channel_7
, 4, 
ADC_SampleTime_480Cycles
);

165 
	`ADC_DMARequestAfterLastTransferCmd
(
ADC1
, 
ENABLE
);

168 
	`ADC_DMACmd
(
ADC1
, 
ENABLE
);

171 
	`ADC_Cmd
(
ADC1
, 
ENABLE
);

174 
	`ADC_SoftwareStartConv
(
ADC1
);

175 
adctransferQueue
 = 
	`xQueueCreate
(1, sizeof(
adcstruct
));

176 
	`xTaskCreate
(
adcTask
, (const signed char * const)"ADC",

177 
configMINIMAL_STACK_SIZE
, 
NULL
, 3, NULL);

178 
	}
}

180 void 
	$adcTask
(void *
param
)

182 
portTickType
 
xLastWakeTime
;

183 
xLastWakeTime
 = 
	`xTaskGetTickCount
();

186 
adcstruct
 
dummy
;

195 
dummy
.
data
[0] = 
ADCConvertedValues
[0];

196 
dummy
.
data
[1] = 
ADCConvertedValues
[1];

197 
dummy
.
data
[2] = 
ADCConvertedValues
[2];

198 
dummy
.
data
[3] = 
ADCConvertedValues
[3];

203 
	`xQueueSend
(
adctransferQueue
,&
dummy
,0);

206 
	`STM_EVAL_LEDToggle
(
LED4
);

207 
	`vTaskDelayUntil
( &
xLastWakeTime
, 20 );

211 
	}
}

	@drivers/src/exti.c

26 #include 
	~<stdbool.h
>

28 #include 
	~"stm32f4xx_conf.h
"

29 #include 
	~"stm32f4xx_exti.h
"

31 #include 
	~"nvicconf.h
"

32 #include 
	~"nrf24l01.h
"

34 #define 
	#RADIO_GPIO_IRQ_LINE
 
EXTI_Line6


	)

36 static 
bool
 
	gisInit
;

39 void 
	$extiInit
()

41 if (
isInit
)

44 
NVIC_InitTypeDef
 
NVIC_InitStructure
;

46 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
EXTI9_5_IRQn
;

47 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 
NVIC_RADIO_PRI
;

48 
NVIC_InitStructure
.
NVIC_IRQChannelSubPriority
 = 0;

49 
NVIC_InitStructure
.
NVIC_IRQChannelCmd
 = 
ENABLE
;

50 
	`NVIC_Init
(&
NVIC_InitStructure
);

52 
isInit
 = 
true
;

53 
	}
}

55 
bool
 
	$extiTest
(void)

57 return 
isInit
;

58 
	}
}

60 void 
	$extiInterruptHandler
(void)

62 if (
	`EXTI_GetITStatus
(
RADIO_GPIO_IRQ_LINE
)==
SET
)

64 
	`nrfIsr
();

65 
	`EXTI_ClearITPendingBit
(
RADIO_GPIO_IRQ_LINE
);

67 
	}
}

	@drivers/src/i2cdev.c

28 #include 
	~<stdint.h
>

29 #include 
	~<stdbool.h
>

30 #define 
	#TRUE
 1

	)

31 #define 
	#FALSE
 0

	)

33 #include 
	~"i2cdev.h
"

35 #include 
	~"nvicconf.h
"

37 #include 
	~"FreeRTOS.h
"

38 #include 
	~"semphr.h
"

39 #include 
	~"task.h
"

41 #include 
	~"stm32f4xx.h
"

43 #include 
	~"i2croutines.h
"

45 #define 
	#I2C_TIMEOUT
 5

	)

46 #define 
	#I2CDEV_CLK_TS
 (1000000 / 100000)

	)

48 #define 
	#GPIO_WAIT_LOW
(
gpio
, 
pin
, 
timeoutcycles
)\

50 int 
i
 = 
timeoutcycles
;\

51 while(
	`GPIO_ReadInputDataBit
(
gpio
, 
pin
) == 
Bit_RESET
 && 
i
--);\

52 }

	)

54 #define 
	#GPIO_WAIT_HIGH
(
gpio
, 
pin
, 
timeoutcycles
) \

56 int 
i
 = 
timeoutcycles
;\

57 while(
	`GPIO_ReadInputDataBit
(
gpio
, 
pin
) == 
Bit_SET
 && 
i
--);\

58 }

	)

60 
xSemaphoreHandle
 
	gi2cdevDmaEventI2c1
;

61 
xSemaphoreHandle
 
	gi2cdevDmaEventI2c2
;

63 
uint8_t
* 
	gBuffer_Rx1
;

65 
uint8_t
* 
	gBuffer_Tx1
;

67 
__IO
 
uint32_t
 
	gI2CDirection
;

69 static void 
i2cdevResetBusI2c1
(void);

70 static void 
i2cdevResetBusI2c2
(void);

71 static 
inline
 void 
i2cdevRuffLoopDelay
(
uint32_t
 
us
);

74 int 
	$i2cdevInit
(
I2C_TypeDef
 *
I2Cx
)

76 
NVIC_InitTypeDef
 
NVIC_InitStructure
;

78 if (
I2Cx
 == 
I2C1
)

80 
	`i2cdevResetBusI2c1
();

106 else if (
I2Cx
 == 
I2C2
)

108 
	`i2cdevResetBusI2c2
();

136 return 
FALSE
;

139 return 
TRUE
;

140 
	}
}

142 
bool
 
	$i2cdevReadByte
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

143 
uint8_t
 *
data
)

145 return 
	`i2cdevRead
(
I2Cx
, 
devAddress
, 
memAddress
, 1, 
data
);

146 
	}
}

148 
bool
 
	$i2cdevReadBit
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

149 
uint8_t
 
bitNum
, uint8_t *
data
)

151 
uint8_t
 
byte
;

152 
bool
 
status
;

154 
status
 = 
	`i2cdevRead
(
I2Cx
, 
devAddress
, 
memAddress
, 1, &
byte
);

155 *
data
 = 
byte
 & (1 << 
bitNum
);

157 return 
status
;

158 
	}
}

160 
bool
 
	$i2cdevReadBits
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

161 
uint8_t
 
bitStart
, uint8_t 
length
, uint8_t *
data
)

163 
bool
 
status
;

164 
uint8_t
 
byte
;

166 if ((
status
 = 
	`i2cdevReadByte
(
I2Cx
, 
devAddress
, 
memAddress
, &
byte
)) == 
TRUE
)

168 
uint8_t
 
mask
 = ((1 << 
length
) - 1) << (
bitStart
 - length + 1);

169 
byte
 &= 
mask
;

170 
byte
 >>= (
bitStart
 - 
length
 + 1);

171 *
data
 = 
byte
;

173 return 
status
;

174 
	}
}

176 
bool
 
	$i2cdevRead
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

177 
uint16_t
 
len
, 
uint8_t
 *
data
)

179 
bool
 
status
 = 
TRUE
;

181 if (
memAddress
 != 
I2CDEV_NO_MEM_ADDR
)

183 
status
 = 
	`I2C_Master_BufferWrite
(
I2Cx
, &
memAddress
, 1, 
INTERRUPT
, 
devAddress
 << 1, 
I2C_TIMEOUT
);

185 if (
status
)

188 
status
 = 
	`I2C_Master_BufferRead
(
I2Cx
, (
uint8_t
*)
data
, 
len
, 
INTERRUPT
, 
devAddress
 << 1, 
I2C_TIMEOUT
);

191 return 
status
;

192 
	}
}

194 
bool
 
	$i2cdevWriteByte
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

195 
uint8_t
 
data
)

197 return 
	`i2cdevWrite
(
I2Cx
, 
devAddress
, 
memAddress
, 1, &
data
);

198 
	}
}

200 
bool
 
	$i2cdevWriteBit
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

201 
uint8_t
 
bitNum
, uint8_t 
data
)

203 
uint8_t
 
byte
;

204 
	`i2cdevReadByte
(
I2Cx
, 
devAddress
, 
memAddress
, &
byte
);

205 
byte
 = (
data
 != 0) ? (byte | (1 << 
bitNum
)) : (byte & ~(1 << bitNum));

206 return 
	`i2cdevWriteByte
(
I2Cx
, 
devAddress
, 
memAddress
, 
byte
);

207 
	}
}

209 
bool
 
	$i2cdevWriteBits
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

210 
uint8_t
 
bitStart
, uint8_t 
length
, uint8_t 
data
)

212 
bool
 
status
;

213 
uint8_t
 
byte
;

215 if ((
status
 = 
	`i2cdevReadByte
(
I2Cx
, 
devAddress
, 
memAddress
, &
byte
)) == 
TRUE
)

217 
uint8_t
 
mask
 = ((1 << 
length
) - 1) << (
bitStart
 - length + 1);

218 
data
 <<= (
bitStart
 - 
length
 + 1);

219 
data
 &= 
mask
;

220 
byte
 &= ~(
mask
);

221 
byte
 |= 
data
;

222 
status
 = 
	`i2cdevWriteByte
(
I2Cx
, 
devAddress
, 
memAddress
, 
byte
);

225 return 
status
;

226 
	}
}

228 
bool
 
	$i2cdevWrite
(
I2C_TypeDef
 *
I2Cx
, 
uint8_t
 
devAddress
, uint8_t 
memAddress
,

229 
uint16_t
 
len
, 
uint8_t
 *
data
)

231 
bool
 
status
;

232 static 
uint8_t
 
buffer
[17];

233 int 
i
;

235 if (
memAddress
 != 
I2CDEV_NO_MEM_ADDR
)

238 if (
len
 > 16) len = 16;

240 if(
len
 == 0) return 0;

242 
buffer
[0] = 
memAddress
;

243 for(
i
 = 0; i < 
len
 ; i++)

244 
buffer
[
i
 + 1] = 
data
[i];

246 
status
 = 
	`I2C_Master_BufferWrite
(
I2Cx
, 
buffer
, 
len
 + 1, 
INTERRUPT
, 
devAddress
 << 1, 
I2C_TIMEOUT
);

250 
status
 = 
	`I2C_Master_BufferWrite
(
I2Cx
, 
data
, 
len
, 
INTERRUPT
, 
devAddress
 << 1, 
I2C_TIMEOUT
);

253 return 
status
;

254 
	}
}

256 static 
inline
 void 
	$i2cdevRuffLoopDelay
(
uint32_t
 
us
)

258 volatile 
uint32_t
 
delay
;

260 for(
delay
 = 
I2CDEV_LOOPS_PER_US
 * 
us
; delay > 0; delay--);

261 
	}
}

264 static void 
	$i2cdevResetBusI2c1
(void)

267 
	`I2C_DeInit
(
I2C1
);

270 
	`I2C_LowLevel_Init
(
I2C1
);

272 #define 
	#I2C_BUSY
 0x20

	)

273 if (
I2C1
->
SR2
 & 
I2C_BUSY
)

276 
	`I2C_SoftwareResetCmd
(
I2C1
, 
ENABLE
);

277 
	`I2C_SoftwareResetCmd
(
I2C1
, 
DISABLE
);

279 
	}
}

281 static void 
	$i2cdevResetBusI2c2
(void)

284 
	`I2C_DeInit
(
I2C2
);

287 
	`I2C_LowLevel_Init
(
I2C2
);

289 #define 
	#I2C_BUSY
 0x20

	)

290 if (
I2C2
->
SR2
 & 
I2C_BUSY
)

293 
	`I2C_SoftwareResetCmd
(
I2C2
, 
ENABLE
);

294 
	`I2C_SoftwareResetCmd
(
I2C2
, 
DISABLE
);

296 
	}
}

298 void 
	$i2cDmaInterruptHandlerI2c1
(void)

300 if(
	`DMA_GetITStatus
(
I2C1_DMA_CHANNEL_TX
,
DMA_FLAG_TCIF6
))

302 
	`DMA_ClearITPendingBit
(
I2C1_DMA_CHANNEL_TX
,
DMA_FLAG_TCIF6
);

304 
	`xSemaphoreGive
(
i2cdevDmaEventI2c1
);

306 if(
	`DMA_GetITStatus
(
I2C1_DMA_CHANNEL_RX
,
DMA_FLAG_TCIF5
))

308 
	`DMA_ClearITPendingBit
(
I2C1_DMA_CHANNEL_RX
,
DMA_FLAG_TCIF5
);

310 
	`xSemaphoreGive
(
i2cdevDmaEventI2c1
);

312 
	}
}

314 void 
	$i2cDmaInterruptHandlerI2c2
(void)

317 
	}
}

	@drivers/src/i2croutines.c

22 #include 
	~"stm32f4xx_dma.h
"

23 #include 
	~"stm32f4xx_rcc.h
"

24 #include 
	~"stm32f4xx_gpio.h
"

25 #include 
	~<i2croutines.h
>

27 #include 
	~"FreeRTOS.h
"

28 #include 
	~"semphr.h
"

30 #include 
	~"i2cdev.h
"

31 #include 
	~"nvicconf.h
"

33 extern 
xSemaphoreHandle
 
i2cdevDmaEventI2c1
;

34 extern 
xSemaphoreHandle
 
i2cdevDmaEventI2c2
;

35 extern 
uint8_t
* 
Buffer_Rx1
;

36 extern 
uint8_t
* 
Buffer_Tx1
;

42 
DMA_InitTypeDef
 
	gI2CDMA_InitStructure
;

43 
__IO
 
uint32_t
 
	gI2CDirection
 = 
I2C_DIRECTION_TX
;

44 
__IO
 
uint32_t
 
	gNumbOfBytes1
;

45 
__IO
 
uint32_t
 
	gNumbOfBytes2
;

46 
__IO
 
uint8_t
 
	gAddress
;

47 
__IO
 
uint8_t
 
	gTx_Idx1
 = 0, 
	gRx_Idx1
 = 0;

48 
__IO
 
uint8_t
 
	gTx_Idx2
 = 0, 
	gRx_Idx2
 = 0;

60 
ErrorStatus
 
	$I2C_Master_BufferRead
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
* 
pBuffer
,

61 
uint32_t
 
NumByteToRead
, 
I2C_ProgrammingModel
 
Mode
, 
uint8_t
 
SlaveAddress
,

62 
uint32_t
 
timeoutMs
)

65 
__IO
 
uint32_t
 
temp
 = 0;

66 
__IO
 
uint32_t
 
Timeout
 = 0;

69 
I2Cx
->
CR2
 |= 
I2C_IT_ERR
;

71 if (
Mode
 == 
DMA
)

76 
I2Cx
->
CR2
 |= 
CR2_LAST_Set
;

78 
I2Cx
->
CR2
 |= 
CR2_DMAEN_Set
;

79 
Timeout
 = 0xFFFF;

81 
I2Cx
->
CR1
 |= 
CR1_START_Set
;

83 while ((
I2Cx
->
SR1
 & 0x0001) != 0x0001)

85 if (
Timeout
-- == 0)

86 return 
ERROR
;

88 
Timeout
 = 0xFFFF;

91 
SlaveAddress
 |= 
OAR1_ADD0_Set
;

92 
Address
 = 
SlaveAddress
;

94 
I2Cx
->
DR
 = 
Address
;

96 while ((
I2Cx
->
SR1
 & 0x0002) != 0x0002)

98 if (
Timeout
-- == 0)

99 return 
ERROR
;

102 
temp
 = 
I2Cx
->
SR2
;

103 if (
I2Cx
 == 
I2C1
)

107 
	`xSemaphoreTake
(
i2cdevDmaEventI2c1
, 
timeoutMs
);

109 
	`DMA_Cmd
(
I2C1_DMA_CHANNEL_RX
, 
DISABLE
);

111 
	`DMA_ClearFlag
(
I2C1_DMA_CHANNEL_RX
, 
DMA_FLAG_TCIF5
);

118 
I2Cx
->
CR1
 |= 
CR1_STOP_Set
;

120 while ((
I2Cx
->
CR1
 & 0x200) == 0x200)

127 
I2Cx
->
CR2
 |= 
I2C_IT_EVT
;

129 
I2Cx
->
CR2
 |= 
I2C_IT_BUF
;

131 
I2CDirection
 = 
I2C_DIRECTION_RX
;

132 
Buffer_Rx1
 = 
pBuffer
;

133 
SlaveAddress
 |= 
OAR1_ADD0_Set
;

134 
Address
 = 
SlaveAddress
;

135 if (
I2Cx
 == 
I2C1
)

136 
NumbOfBytes1
 = 
NumByteToRead
;

137 if (
I2Cx
 == 
I2C2
)

138 
NumbOfBytes2
 = 
NumByteToRead
;

140 
I2Cx
->
CR1
 |= 
CR1_START_Set
;

141 
Timeout
 = 
timeoutMs
 * 
I2CDEV_LOOPS_PER_MS
;

143 while ((
I2Cx
->
CR1
 & 0x100) == 0x100 && 
Timeout
)

145 
Timeout
--;

148 while ((
I2Cx
->
SR2
 & 0x0002) == 0x0002 && 
Timeout
)

150 
Timeout
--;

153 
I2Cx
->
CR1
 |= 
CR1_ACK_Set
;

155 if (
Timeout
 == 0)

156 return 
ERROR
;

159 return 
SUCCESS
;

161 
temp
++;

162 
	}
}

172 
ErrorStatus
 
	$I2C_Master_BufferWrite
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
* 
pBuffer
,

173 
uint32_t
 
NumByteToWrite
, 
I2C_ProgrammingModel
 
Mode
, 
uint8_t
 
SlaveAddress
,

174 
uint32_t
 
timeoutMs
)

177 
__IO
 
uint32_t
 
temp
 = 0;

178 
__IO
 
uint32_t
 
Timeout
 = 0;

181 
I2Cx
->
CR2
 |= 
I2C_IT_ERR
;

182 if (
Mode
 == 
DMA
)

184 
Timeout
 = 0xFFFF;

186 
	`I2C_DMAConfig
(
I2Cx
, 
pBuffer
, 
NumByteToWrite
, 
I2C_DIRECTION_TX
);

188 
I2Cx
->
CR2
 |= 
CR2_DMAEN_Set
;

190 
I2Cx
->
CR1
 |= 
CR1_START_Set
;

192 while ((
I2Cx
->
SR1
 & 0x0001) != 0x0001)

194 if (
Timeout
-- == 0)

195 return 
ERROR
;

197 
Timeout
 = 0xFFFF;

200 
SlaveAddress
 &= 
OAR1_ADD0_Reset
;

201 
Address
 = 
SlaveAddress
;

203 
I2Cx
->
DR
 = 
Address
;

205 while ((
I2Cx
->
SR1
 & 0x0002) != 0x0002)

207 if (
Timeout
-- == 0)

208 return 
ERROR
;

212 
temp
 = 
I2Cx
->
SR2
;

213 if (
I2Cx
 == 
I2C1
)

217 
	`xSemaphoreTake
(
i2cdevDmaEventI2c1
, 5);

219 
	`DMA_Cmd
(
I2C1_DMA_CHANNEL_TX
, 
DISABLE
);

221 
	`DMA_ClearFlag
(
I2C1_DMA_CHANNEL_TX
,
DMA_FLAG_TCIF6
);

223 else if (
I2Cx
 == 
I2C1
)

227 
	`xSemaphoreTake
(
i2cdevDmaEventI2c2
, 5);

229 
	`DMA_Cmd
(
I2C2_DMA_CHANNEL_TX
, 
DISABLE
);

231 
	`DMA_ClearFlag
(
I2C2_DMA_CHANNEL_TX
,
DMA_FLAG_TCIF6
);

236 while ((
I2Cx
->
SR1
 & 0x00004) != 0x000004)

239 
I2Cx
->
CR1
 |= 
CR1_STOP_Set
;

241 while ((
I2Cx
->
CR1
 & 0x200) == 0x200)

248 
I2Cx
->
CR2
 |= 
I2C_IT_EVT
;

250 
I2Cx
->
CR2
 |= 
I2C_IT_BUF
;

252 
I2CDirection
 = 
I2C_DIRECTION_TX
;

253 
Buffer_Tx1
 = 
pBuffer
;

254 
SlaveAddress
 &= 
OAR1_ADD0_Reset
;

255 
Address
 = 
SlaveAddress
;

256 if (
I2Cx
 == 
I2C1
)

257 
NumbOfBytes1
 = 
NumByteToWrite
;

258 if (
I2Cx
 == 
I2C2
)

259 
NumbOfBytes2
 = 
NumByteToWrite
;

261 
I2Cx
->
CR1
 |= 
CR1_START_Set
;

262 
Timeout
 = 
timeoutMs
 * 
I2CDEV_LOOPS_PER_MS
;

264 while ((
I2Cx
->
CR1
 & 0x100) == 0x100 && 
Timeout
)

266 
Timeout
--;

270 while ((
I2Cx
->
SR2
 & 0x0002) == 0x0002 && 
Timeout
)

272 
Timeout
--;

275 if (
Timeout
 == 0)

276 return 
ERROR
;

278 return 
SUCCESS
;

280 
temp
++;

281 
	}
}

289 void 
	$I2C_Slave_BufferReadWrite
(
I2C_TypeDef
* 
I2Cx
, 
I2C_ProgrammingModel
 
Mode
)

293 
I2Cx
->
CR2
 |= 
I2C_IT_EVT
;

295 
I2Cx
->
CR2
 |= 
I2C_IT_ERR
;

297 if (
Mode
 == 
DMA
)

300 
I2Cx
->
CR2
 |= 
CR2_DMAEN_Set
;

305 
I2Cx
->
CR2
 |= 
I2C_IT_BUF
;

307 
	}
}

314 void 
	$I2C_LowLevel_Init
(
I2C_TypeDef
* 
I2Cx
)

316 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

317 
I2C_InitTypeDef
 
I2C_InitStructure
;

318 
NVIC_InitTypeDef
 
NVIC_InitStructure
;

321 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOB
, 
ENABLE
);

324 if (
I2Cx
 == 
I2C1
)

327 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_I2C1
, 
ENABLE
);

331 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_6
 | 
GPIO_Pin_7
;

332 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

333 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

334 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_OD
;

335 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

336 
	`GPIO_Init
(
GPIOB
, &
GPIO_InitStructure
);

338 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource6
, 
GPIO_AF_I2C1
);

339 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource7
, 
GPIO_AF_I2C1
);

346 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
I2C1_EV_IRQn
;

347 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 
NVIC_I2C_PRI
;

348 
NVIC_InitStructure
.
NVIC_IRQChannelSubPriority
 = 0;

349 
NVIC_InitStructure
.
NVIC_IRQChannelCmd
 = 
ENABLE
;

350 
	`NVIC_Init
(&
NVIC_InitStructure
);

351 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
I2C1_ER_IRQn
;

352 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 
NVIC_I2C_PRI
 + 1;

353 
	`NVIC_Init
(&
NVIC_InitStructure
);

356 if (
I2Cx
 == 
I2C2
)

359 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_I2C2
, 
ENABLE
);

363 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_10
 | 
GPIO_Pin_11
;

364 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

365 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

366 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_OD
;

367 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

368 
	`GPIO_Init
(
GPIOB
, &
GPIO_InitStructure
);

370 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource10
, 
GPIO_AF_I2C2
);

371 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource11
, 
GPIO_AF_I2C2
);

378 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
I2C2_EV_IRQn
;

379 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 
NVIC_I2C_PRI
;

380 
NVIC_InitStructure
.
NVIC_IRQChannelSubPriority
 = 0;

381 
NVIC_InitStructure
.
NVIC_IRQChannelCmd
 = 
ENABLE
;

382 
	`NVIC_Init
(&
NVIC_InitStructure
);

383 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
I2C2_ER_IRQn
;

384 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 
NVIC_I2C_PRI
+1;

385 
	`NVIC_Init
(&
NVIC_InitStructure
);

390 
I2C_InitStructure
.
I2C_Mode
 = 
I2C_Mode_I2C
;

391 
I2C_InitStructure
.
I2C_DutyCycle
 = 
I2C_DutyCycle_2
;

392 
I2C_InitStructure
.
I2C_OwnAddress1
 = 
OwnAddress1
;

393 
I2C_InitStructure
.
I2C_Ack
 = 
I2C_Ack_Enable
;

394 
I2C_InitStructure
.
I2C_AcknowledgedAddress
 = 
I2C_AcknowledgedAddress_7bit
;

395 
I2C_InitStructure
.
I2C_ClockSpeed
 = 
ClockSpeed
;

396 
	`I2C_Init
(
I2C1
, &
I2C_InitStructure
);

397 
I2C_InitStructure
.
I2C_Mode
 = 
I2C_Mode_I2C
;

398 
I2C_InitStructure
.
I2C_DutyCycle
 = 
I2C_DutyCycle_2
;

399 
I2C_InitStructure
.
I2C_OwnAddress1
 = 
OwnAddress1
;

400 
I2C_InitStructure
.
I2C_Ack
 = 
I2C_Ack_Enable
;

401 
I2C_InitStructure
.
I2C_AcknowledgedAddress
 = 
I2C_AcknowledgedAddress_7bit
;

402 
I2C_InitStructure
.
I2C_ClockSpeed
 = 100000;

403 
I2C_InitStructure
.
I2C_OwnAddress1
 = 
OwnAddress2
;

404 
	`I2C_Init
(
I2C2
, &
I2C_InitStructure
);

406 
	}
}

413 void 
	$I2C_DMAConfig
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
* 
pBuffer
, 
uint32_t
 
BufferSize
,

414 
uint32_t
 
Direction
)

417 if (
Direction
 == 
I2C_DIRECTION_TX
)

420 
I2CDMA_InitStructure
.
DMA_Memory0BaseAddr
 = (
uint32_t
) 
pBuffer
;

421 
I2CDMA_InitStructure
.
DMA_DIR
 = 
DMA_DIR_MemoryToPeripheral
;

422 
I2CDMA_InitStructure
.
DMA_BufferSize
 = (
uint32_t
) 
BufferSize
;

424 if (
I2Cx
 == 
I2C1
)

426 
I2CDMA_InitStructure
.
DMA_PeripheralBaseAddr
 = (
uint32_t
) 
I2C1_DR_Address
;

427 
	`DMA_Cmd
(
I2C1_DMA_CHANNEL_TX
, 
DISABLE
);

428 
	`DMA_Init
(
I2C1_DMA_CHANNEL_TX
, &
I2CDMA_InitStructure
);

429 
	`DMA_Cmd
(
I2C1_DMA_CHANNEL_TX
, 
ENABLE
);

439 
I2CDMA_InitStructure
.
DMA_Memory0BaseAddr
 = (
uint32_t
) 
pBuffer
;

440 
I2CDMA_InitStructure
.
DMA_DIR
 = 
DMA_DIR_PeripheralToMemory
;

441 
I2CDMA_InitStructure
.
DMA_BufferSize
 = (
uint32_t
) 
BufferSize
;

442 if (
I2Cx
 == 
I2C1
)

445 
I2CDMA_InitStructure
.
DMA_PeripheralBaseAddr
 = (
uint32_t
) 
I2C1_DR_Address
;

446 
	`DMA_Cmd
(
I2C1_DMA_CHANNEL_RX
, 
DISABLE
);

447 
	`DMA_Init
(
I2C1_DMA_CHANNEL_RX
, &
I2CDMA_InitStructure
);

448 
	`DMA_Cmd
(
I2C1_DMA_CHANNEL_RX
, 
ENABLE
);

457 
	}
}

464 void 
	$i2cInterruptHandlerI2c1
(void)

467 
__IO
 
uint32_t
 
SR1Register
 = 0;

468 
__IO
 
uint32_t
 
SR2Register
 = 0;

471 
SR1Register
 = 
I2C1
->
SR1
;

472 
SR2Register
 = 
I2C1
->
SR2
;

475 if ((
SR1Register
 & 0x0001) == 0x0001)

479 
I2C1
->
DR
 = 
Address
;

480 
SR1Register
 = 0;

481 
SR2Register
 = 0;

485 if ((
SR2Register
 & 0x0001) == 0x0001)

488 if ((
SR1Register
 & 0x0002) == 0x0002)

491 if (
I2CDirection
 == 
I2C_DIRECTION_TX
)

494 
Tx_Idx1
 = 0;

495  
I2C1
->
DR
 =

496 
Buffer_Tx1
[
Tx_Idx1
++];

498 
NumbOfBytes1
--;

501 if (
NumbOfBytes1
 == 0)

503 
I2C1
->
CR2
 &= (
uint16_t
) ~
I2C_IT_BUF
;

510 
Rx_Idx1
 = 0;

514 if (
NumbOfBytes1
 == 1)

517 
I2C1
->
CR1
 &= 
CR1_ACK_Reset
;

519 
I2C1
->
CR1
 |= 
CR1_STOP_Set
;

522 
SR1Register
 = 0;

523 
SR2Register
 = 0;

527 if ((
SR1Register
 & 0x0084) == 0x0080)

530 if (
NumbOfBytes1
 != 0)

533 
I2C1
->
DR
 = 
Buffer_Tx1
[
Tx_Idx1
++];

535 
NumbOfBytes1
--;

538 if (
NumbOfBytes1
 == 0)

541 
I2C1
->
CR2
 &= (
uint16_t
) ~
I2C_IT_BUF
;

544 
SR1Register
 = 0;

545 
SR2Register
 = 0;

548 if ((
SR1Register
 & 0x0084) == 0x0084)

551 
I2C1
->
CR1
 |= 
CR1_STOP_Set
;

553 
I2C1
->
CR2
 &= (
uint16_t
) ~
I2C_IT_EVT
;

554 
SR1Register
 = 0;

555 
SR2Register
 = 0;

558 if ((
SR1Register
 & 0x0040) == 0x0040)

561 
Buffer_Rx1
[
Rx_Idx1
++] = 
I2C1
->
DR
;

563 
NumbOfBytes1
--;

565 if (
NumbOfBytes1
 == 1)

568 
I2C1
->
CR1
 &= 
CR1_ACK_Reset
;

570 
I2C1
->
CR1
 |= 
CR1_STOP_Set
;

572 
SR1Register
 = 0;

573 
SR2Register
 = 0;

576 
	}
}

578 void 
	$i2cInterruptHandlerI2c2
(void)

581 
__IO
 
uint32_t
 
SR1Register
 = 0;

582 
__IO
 
uint32_t
 
SR2Register
 = 0;

585 
SR1Register
 = 
I2C2
->
SR1
;

586 
SR2Register
 = 
I2C2
->
SR2
;

589 if ((
SR1Register
 & 0x0001) == 0x0001)

593 
I2C2
->
DR
 = 
Address
;

594 
SR1Register
 = 0;

595 
SR2Register
 = 0;

599 if ((
SR2Register
 & 0x0001) == 0x0001)

602 if ((
SR1Register
 & 0x0002) == 0x0002)

605 if (
I2CDirection
 == 
I2C_DIRECTION_TX
)

608 
Tx_Idx1
 = 0;

609  
I2C2
->
DR
 =

610 
Buffer_Tx1
[
Tx_Idx1
++];

612 
NumbOfBytes2
--;

615 if (
NumbOfBytes2
 == 0)

617 
I2C2
->
CR2
 &= (
uint16_t
) ~
I2C_IT_BUF
;

624 
Rx_Idx1
 = 0;

628 if (
NumbOfBytes2
 == 1)

631 
I2C2
->
CR1
 &= 
CR1_ACK_Reset
;

633 
I2C2
->
CR1
 |= 
CR1_STOP_Set
;

636 
SR1Register
 = 0;

637 
SR2Register
 = 0;

641 if ((
SR1Register
 & 0x0084) == 0x0080)

644 if (
NumbOfBytes2
 != 0)

647 
I2C2
->
DR
 = 
Buffer_Tx1
[
Tx_Idx1
++];

649 
NumbOfBytes2
--;

652 if (
NumbOfBytes2
 == 0)

655 
I2C2
->
CR2
 &= (
uint16_t
) ~
I2C_IT_BUF
;

658 
SR1Register
 = 0;

659 
SR2Register
 = 0;

662 if ((
SR1Register
 & 0x0084) == 0x0084)

665 
I2C2
->
CR1
 |= 
CR1_STOP_Set
;

667 
I2C2
->
CR2
 &= (
uint16_t
) ~
I2C_IT_EVT
;

668 
SR1Register
 = 0;

669 
SR2Register
 = 0;

672 if ((
SR1Register
 & 0x0040) == 0x0040)

675 
Buffer_Rx1
[
Rx_Idx1
++] = 
I2C2
->
DR
;

677 
NumbOfBytes2
--;

679 if (
NumbOfBytes2
 == 1)

682 
I2C2
->
CR1
 &= 
CR1_ACK_Reset
;

684 
I2C2
->
CR1
 |= 
CR1_STOP_Set
;

686 
SR1Register
 = 0;

687 
SR2Register
 = 0;

690 
	}
}

697 void 
	$i2cErrorInterruptHandlerI2c1
(void)

700 
__IO
 
uint32_t
 
SR1Register
 = 0;

703 
SR1Register
 = 
I2C1
->
SR1
;

705 if ((
SR1Register
 & 0x0400) == 0x0400)

707 
I2C1
->
SR1
 &= 0xFBFF;

708 
SR1Register
 = 0;

711 if ((
SR1Register
 & 0x0200) == 0x0200)

713 
I2C1
->
SR1
 &= 0xFBFF;

714 
SR1Register
 = 0;

717 if ((
SR1Register
 & 0x0100) == 0x0100)

719 
I2C1
->
SR1
 &= 0xFEFF;

720 
SR1Register
 = 0;

723 if ((
SR1Register
 & 0x0800) == 0x0800)

725 
I2C1
->
SR1
 &= 0xF7FF;

726 
SR1Register
 = 0;

728 
	}
}

730 void 
	$i2cErrorInterruptHandlerI2c2
(void)

733 
__IO
 
uint32_t
 
SR1Register
 = 0;

736 
SR1Register
 = 
I2C2
->
SR1
;

738 if ((
SR1Register
 & 0x0400) == 0x0400)

740 
I2C2
->
SR1
 &= 0xFBFF;

741 
SR1Register
 = 0;

744 if ((
SR1Register
 & 0x0200) == 0x0200)

746 
I2C2
->
SR1
 &= 0xFBFF;

747 
SR1Register
 = 0;

750 if ((
SR1Register
 & 0x0100) == 0x0100)

752 
I2C2
->
SR1
 &= 0xFEFF;

753 
SR1Register
 = 0;

756 if ((
SR1Register
 & 0x0800) == 0x0800)

758 
I2C2
->
SR1
 &= 0xF7FF;

759 
SR1Register
 = 0;

761 
	}
}

	@drivers/src/motors.c

5 #include 
	~<stdbool.h
>

7 #include 
	~"motors.h
"

10 #include 
	~"stm32f4xx_conf.h
"

13 #include 
	~"FreeRTOS.h
"

14 #include 
	~"task.h
"

42 #define 
	#C_BITS_TO_16
(
X
) ((X)<<(16-
MOTORS_PWM_BITS
))

	)

43 #define 
	#C_16_TO_BITS
(
X
) ((X)>>(16-
MOTORS_PWM_BITS
)&((1<<MOTORS_PWM_BITS)-1))

	)

45 static 
bool
 
	gisInit
=
false
;

50 void 
	$motorsInit
()

61 
uint16_t
 
PrescalerValue
 = 0;

63 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

64 
TIM_TimeBaseInitTypeDef
 
TIM_TimeBaseStructure
;

65 
TIM_OCInitTypeDef
 
TIM_OCInitStructure
;

66 
TIM_BDTRInitTypeDef
 
TIM_BDTRInitStructure
;

69 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_TIM2
 | 
RCC_APB1Periph_TIM3
 , 
ENABLE
);

71 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOA
, 
ENABLE
);

74 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_10
 | 
GPIO_Pin_11
 ;

75 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

76 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_100MHz
;

77 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

78 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
 ;

79 
	`GPIO_Init
(
GPIOB
, &
GPIO_InitStructure
);

82 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_6
 | 
GPIO_Pin_7
;

83 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

84 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_100MHz
;

85 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

86 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
 ;

87 
	`GPIO_Init
(
GPIOA
, &
GPIO_InitStructure
);

90 
	`GPIO_PinAFConfig
(
GPIOA
, 
GPIO_PinSource6
, 
GPIO_AF_TIM3
);

91 
	`GPIO_PinAFConfig
(
GPIOA
, 
GPIO_PinSource7
, 
GPIO_AF_TIM3
);

92 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource10
, 
GPIO_AF_TIM2
);

93 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource11
, 
GPIO_AF_TIM2
);

95 
PrescalerValue
 = (
uint16_t
) ((
SystemCoreClock
) / 2 / 1000000) - 1;

98 
TIM_TimeBaseStructure
.
TIM_Period
 = 2000;

99 
TIM_TimeBaseStructure
.
TIM_Prescaler
 = 
PrescalerValue
;

100 
TIM_TimeBaseStructure
.
TIM_ClockDivision
 = 0;

101 
TIM_TimeBaseStructure
.
TIM_CounterMode
 = 
TIM_CounterMode_Up
;

102 
	`TIM_TimeBaseInit
(
TIM2
, &
TIM_TimeBaseStructure
);

104 
TIM_TimeBaseStructure
.
TIM_Period
 = 2000;

105 
TIM_TimeBaseStructure
.
TIM_Prescaler
 = 
PrescalerValue
;

106 
TIM_TimeBaseStructure
.
TIM_ClockDivision
 = 0;

107 
TIM_TimeBaseStructure
.
TIM_CounterMode
 = 
TIM_CounterMode_Up
;

108 
	`TIM_TimeBaseInit
(
TIM3
, &
TIM_TimeBaseStructure
);

113 
TIM_OCInitStructure
.
TIM_OCMode
 = 
TIM_OCMode_PWM1
;

114 
TIM_OCInitStructure
.
TIM_OutputState
 = 
TIM_OutputState_Enable
;

115 
TIM_OCInitStructure
.
TIM_Pulse
 = 0;

116 
TIM_OCInitStructure
.
TIM_OCPolarity
 = 
TIM_OCPolarity_High
;

117 
	`TIM_OC3Init
(
TIM2
, &
TIM_OCInitStructure
);

118 
	`TIM_OC3PreloadConfig
(
TIM2
, 
TIM_OCPreload_Enable
);

119 
TIM_OCInitStructure
.
TIM_OutputState
 = 
TIM_OutputState_Enable
;

120 
TIM_OCInitStructure
.
TIM_Pulse
 = 0;

121 
	`TIM_OC4Init
(
TIM2
, &
TIM_OCInitStructure
);

122 
	`TIM_OC4PreloadConfig
(
TIM2
, 
TIM_OCPreload_Enable
);

126 
TIM_OCInitStructure
.
TIM_OCMode
 = 
TIM_OCMode_PWM1
;

127 
TIM_OCInitStructure
.
TIM_OutputState
 = 
TIM_OutputState_Enable
;

128 
TIM_OCInitStructure
.
TIM_Pulse
 = 0;

129 
TIM_OCInitStructure
.
TIM_OCPolarity
 = 
TIM_OCPolarity_High
;

130 
	`TIM_OC1Init
(
TIM3
, &
TIM_OCInitStructure
);

131 
	`TIM_OC1PreloadConfig
(
TIM3
, 
TIM_OCPreload_Enable
);

132 
TIM_OCInitStructure
.
TIM_OutputState
 = 
TIM_OutputState_Enable
;

133 
TIM_OCInitStructure
.
TIM_Pulse
 = 0;

134 
	`TIM_OC2Init
(
TIM3
, &
TIM_OCInitStructure
);

135 
	`TIM_OC2PreloadConfig
(
TIM3
, 
TIM_OCPreload_Enable
);

138 
	`TIM_ARRPreloadConfig
(
TIM2
, 
ENABLE
);

139 
	`TIM_ARRPreloadConfig
(
TIM3
, 
ENABLE
);

142 
	`TIM_Cmd
(
TIM2
, 
ENABLE
);

143 
	`TIM_Cmd
(
TIM3
, 
ENABLE
);

145 
isInit
 = 
true
;

146 
	}
}

148 void 
	$motorsSetRatio
(int 
id
, 
uint16_t
 
ratio
)

158 switch(
id
) {

160 case 
MOTOR_LEFTFRONT
:

161 
	`TIM_SetCompare1
(
TIM3
, 
	`C_16_TO_BITS
(
ratio
));

163 case 
MOTOR_LEFTREAR
:

164 
	`TIM_SetCompare2
(
TIM3
, 
	`C_16_TO_BITS
(
ratio
));

166 case 
MOTOR_RIGHTREAR
:

167 
	`TIM_SetCompare3
(
TIM2
, 
	`C_16_TO_BITS
(
ratio
));

169 case 
MOTOR_RIGHTFRONT
:

170 
	`TIM_SetCompare4
(
TIM2
, 
	`C_16_TO_BITS
(
ratio
));

175 
	}
}

181 #ifdef 
MOTOR_RAMPUP_TEST


183 void 
	$motorsTestTask
(void* 
params
)

185 int 
step
=0;

186 float 
rampup
 = 0.01;

188 
	`motorsSetupMinMaxPos
();

189 
	`motorsSetRatio
(
MOTOR_LEFT
, 1*(1<<16) * 0.0);

190 
	`motorsSetRatio
(
MOTOR_REAR
, 1*(1<<16) * 0.0);

191 
	`motorsSetRatio
(
MOTOR_RIGHT
, 1*(1<<16) * 0.0);

192 
	`motorsSetRatio
(
MOTOR_FRONT
, 1*(1<<16) * 0.0);

193 
	`vTaskDelay
(
	`M2T
(1000));

197 
	`vTaskDelay
(
	`M2T
(100));

199 
	`motorsSetRatio
(
MOTOR_LEFT
, 1*(1<<16) * 
rampup
);

200 
	`motorsSetRatio
(
MOTOR_REAR
, 1*(1<<16) * 
rampup
);

201 
	`motorsSetRatio
(
MOTOR_RIGHT
, 1*(1<<16) * 
rampup
);

202 
	`motorsSetRatio
(
MOTOR_FRONT
, 1*(1<<16) * 
rampup
);

204 
rampup
 += 0.001;

205 if (
rampup
 >= 0.1)

207 if(++
step
>3) step=0;

208 
rampup
 = 0.01;

211 
	}
}

214 void 
	$motorsTestTask
(void* 
params
)

216 static const int 
sequence
[] = {0.1*(1<<16), 0.15*(1<<16), 0.2*(1<<16), 0.25*(1<<16)};

217 int 
step
=0;

220 
	`vTaskDelay
(3000);

223 
	`motorsSetRatio
(
MOTOR_LEFT
, 
sequence
[
step
%4]);

224 
	`motorsSetRatio
(
MOTOR_REAR
, 
sequence
[(
step
+1)%4]);

225 
	`motorsSetRatio
(
MOTOR_RIGHT
, 
sequence
[(
step
+2)%4]);

226 
	`motorsSetRatio
(
MOTOR_FRONT
, 
sequence
[(
step
+3)%4]);

228 if(++
step
>3) step=0;

230 
	`vTaskDelay
(1000);

232 
	}
}

	@drivers/src/mpu6050.c

30 #define 
	#DEBUG_MODULE
 "MPU6050"

	)

32 #include 
	~"stm32f4xx_conf.h
"

33 #include 
	~"FreeRTOS.h
"

34 #include 
	~"task.h
"

35 #include 
	~"i2cdev.h
"

37 #include 
	~"mpu6050.h
"

38 #include 
	~<stdbool.h
>

40 #define 
	#TRUE
 1

	)

41 #define 
	#FALSE
 0

	)

43 static 
uint8_t
 
	gdevAddr
;

44 static 
I2C_TypeDef
 *
	gI2Cx
;

45 static 
uint8_t
 
	gbuffer
[14];

46 static 
bool
 
	gisInit
;

51 void 
	$mpu6050Init
(
I2C_TypeDef
 *
i2cPort
)

53 if (
isInit
)

56 
I2Cx
 = 
i2cPort
;

57 
devAddr
 = 
MPU6050_ADDRESS_AD0_HIGH
;

59 
isInit
 = 
TRUE
;

60 
	}
}

62 
bool
 
	$mpu6050Test
(void)

64 
bool
 
testStatus
;

66 if (!
isInit
)

67 return 
FALSE
;

69 
testStatus
 = 
	`mpu6050TestConnection
();

71 return 
testStatus
;

72 
	}
}

78 
bool
 
	$mpu6050TestConnection
()

80 return 
	`mpu6050GetDeviceID
() == 0b110100;

81 
	}
}

86 
bool
 
	$mpu6050SelfTest
()

88 
bool
 
testStatus
 = 
TRUE
;

89 
int16_t
 
axi16
, 
ayi16
, 
azi16
;

90 
int16_t
 
gxi16
, 
gyi16
, 
gzi16
;

91 float 
axf
, 
ayf
, 
azf
;

92 float 
gxf
, 
gyf
, 
gzf
;

93 float 
axfTst
, 
ayfTst
, 
azfTst
;

94 float 
gxfTst
, 
gyfTst
, 
gzfTst
;

95 float 
axfDiff
, 
ayfDiff
, 
azfDiff
;

96 float 
gxfDiff
, 
gyfDiff
, 
gzfDiff
;

97 float 
gRange
, 
aRange
;

98 
uint32_t
 
scrap
;

100 
aRange
 = 
	`mpu6050GetFullScaleAccelGPL
();

101 
gRange
 = 
	`mpu6050GetFullScaleGyroDPL
();

105 for (
scrap
 = 0; scrap < 5; scrap++)

107 
	`mpu6050GetMotion6
(&
axi16
, &
ayi16
, &
azi16
, &
gxi16
, &
gyi16
, &
gzi16
);

112 
gxf
 = 
gxi16
 * 
gRange
;

113 
gyf
 = 
gyi16
 * 
gRange
;

114 
gzf
 = 
gzi16
 * 
gRange
;

115 
axf
 = 
axi16
 * 
aRange
;

116 
ayf
 = 
ayi16
 * 
aRange
;

117 
azf
 = 
azi16
 * 
aRange
;

120 
	`mpu6050SetGyroXSelfTest
(
TRUE
);

121 
	`mpu6050SetGyroYSelfTest
(
TRUE
);

122 
	`mpu6050SetGyroZSelfTest
(
TRUE
);

123 
	`mpu6050SetAccelXSelfTest
(
TRUE
);

124 
	`mpu6050SetAccelYSelfTest
(
TRUE
);

125 
	`mpu6050SetAccelZSelfTest
(
TRUE
);

132 for (
scrap
 = 0; scrap < 5; scrap++)

134 
	`mpu6050GetMotion6
(&
axi16
, &
ayi16
, &
azi16
, &
gxi16
, &
gyi16
, &
gzi16
);

142 for (
scrap
 = 0; scrap < 2; scrap++)

146 
gxfTst
 = 
gxi16
 * 
gRange
;

147 
gyfTst
 = 
gyi16
 * 
gRange
;

148 
gzfTst
 = 
gzi16
 * 
gRange
;

149 
axfTst
 = 
axi16
 * 
aRange
;

150 
ayfTst
 = 
ayi16
 * 
aRange
;

151 
azfTst
 = 
azi16
 * 
aRange
;

154 
	`mpu6050SetGyroXSelfTest
(
FALSE
);

155 
	`mpu6050SetGyroYSelfTest
(
FALSE
);

156 
	`mpu6050SetGyroZSelfTest
(
FALSE
);

157 
	`mpu6050SetAccelXSelfTest
(
FALSE
);

158 
	`mpu6050SetAccelYSelfTest
(
FALSE
);

159 
	`mpu6050SetAccelZSelfTest
(
FALSE
);

164 
gxfDiff
 = 
gxfTst
 - 
gxf
;

165 
gyfDiff
 = 
gyfTst
 - 
gyf
;

166 
gzfDiff
 = 
gzfTst
 - 
gzf
;

167 
axfDiff
 = 
axfTst
 - 
axf
;

168 
ayfDiff
 = 
ayfTst
 - 
ayf
;

169 
azfDiff
 = 
azfTst
 - 
azf
;

172 if (
	`mpu6050EvaluateSelfTest
(
MPU6050_ST_GYRO_LOW
, 
MPU6050_ST_GYRO_HIGH
, 
gxfDiff
, "gyro X") &&

173 
	`mpu6050EvaluateSelfTest
(-
MPU6050_ST_GYRO_HIGH
,-
MPU6050_ST_GYRO_LOW
, 
gyfDiff
, "gyro Y")&&

174 
	`mpu6050EvaluateSelfTest
(
MPU6050_ST_GYRO_LOW
, 
MPU6050_ST_GYRO_HIGH
, 
gzfDiff
, "gyro Z")&&

175 
	`mpu6050EvaluateSelfTest
(
MPU6050_ST_ACCEL_LOW
, 
MPU6050_ST_ACCEL_HIGH
, 
axfDiff
, "acc X") &&

176 
	`mpu6050EvaluateSelfTest
(
MPU6050_ST_ACCEL_LOW
, 
MPU6050_ST_ACCEL_HIGH
, 
ayfDiff
, "acc Y") &&

177 
	`mpu6050EvaluateSelfTest
(-
MPU6050_ST_ACCEL_HIGH
, -
MPU6050_ST_ACCEL_LOW
, 
azfDiff
, "acc Z"))

185 
testStatus
 = 
FALSE
;

190 return 
testStatus
;

191 
	}
}

200 
bool
 
	$mpu6050EvaluateSelfTest
(float 
low
, float 
high
, float 
value
, char* 
string
)

202 if (
value
 < 
low
 || value > 
high
)

206 return 
FALSE
;

208 return 
TRUE
;

209 
	}
}

219 
uint8_t
 
	$mpu6050GetAuxVDDIOLevel
()

221 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YG_OFFS_TC
, 
MPU6050_TC_PWR_MODE_BIT
, 
buffer
);

222 return 
buffer
[0];

223 
	}
}

230 void 
	$mpu6050SetAuxVDDIOLevel
(
uint8_t
 
level
)

232 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YG_OFFS_TC
, 
MPU6050_TC_PWR_MODE_BIT
, 
level
);

233 
	}
}

258 
uint8_t
 
	$mpu6050GetRate
()

260 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_SMPLRT_DIV
, 
buffer
);

261 return 
buffer
[0];

262 
	}
}

268 void 
	$mpu6050SetRate
(
uint8_t
 
rate
)

270 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_SMPLRT_DIV
, 
rate
);

271 
	}
}

302 
uint8_t
 
	$mpu6050GetExternalFrameSync
()

304 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_CONFIG
, 
MPU6050_CFG_EXT_SYNC_SET_BIT
,

305 
MPU6050_CFG_EXT_SYNC_SET_LENGTH
, 
buffer
);

306 return 
buffer
[0];

307 
	}
}

313 void 
	$mpu6050SetExternalFrameSync
(
uint8_t
 
sync
)

315 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_CONFIG
, 
MPU6050_CFG_EXT_SYNC_SET_BIT
,

316 
MPU6050_CFG_EXT_SYNC_SET_LENGTH
, 
sync
);

317 
	}
}

346 
uint8_t
 
	$mpu6050GetDLPFMode
()

348 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_CONFIG
, 
MPU6050_CFG_DLPF_CFG_BIT
,

349 
MPU6050_CFG_DLPF_CFG_LENGTH
, 
buffer
);

350 return 
buffer
[0];

351 
	}
}

360 void 
	$mpu6050SetDLPFMode
(
uint8_t
 
mode
)

362 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_CONFIG
, 
MPU6050_CFG_DLPF_CFG_BIT
,

363 
MPU6050_CFG_DLPF_CFG_LENGTH
, 
mode
);

364 
	}
}

385 
uint8_t
 
	$mpu6050GetFullScaleGyroRangeId
()

387 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_CONFIG
, 
MPU6050_GCONFIG_FS_SEL_BIT
,

388 
MPU6050_GCONFIG_FS_SEL_LENGTH
, 
buffer
);

389 return 
buffer
[0];

390 
	}
}

400 float 
	$mpu6050GetFullScaleGyroDPL
()

402 
int32_t
 
rangeId
;

403 float 
range
;

405 
rangeId
 = 
	`mpu6050GetFullScaleGyroRangeId
();

406 switch (
rangeId
)

408 case 
MPU6050_GYRO_FS_250
:

409 
range
 = 
MPU6050_DEG_PER_LSB_250
;

411 case 
MPU6050_GYRO_FS_500
:

412 
range
 = 
MPU6050_DEG_PER_LSB_500
;

414 case 
MPU6050_GYRO_FS_1000
:

415 
range
 = 
MPU6050_DEG_PER_LSB_1000
;

417 case 
MPU6050_GYRO_FS_2000
:

418 
range
 = 
MPU6050_DEG_PER_LSB_2000
;

421 
range
 = 
MPU6050_DEG_PER_LSB_1000
;

425 return 
range
;

426 
	}
}

436 void 
	$mpu6050SetFullScaleGyroRange
(
uint8_t
 
range
)

438 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_CONFIG
, 
MPU6050_GCONFIG_FS_SEL_BIT
,

439 
MPU6050_GCONFIG_FS_SEL_LENGTH
, 
range
);

440 
	}
}

442 void 
	$mpu6050SetGyroXSelfTest
(
bool
 
enabled
)

444 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_CONFIG
, 
MPU6050_GCONFIG_XG_ST_BIT
, 
enabled
);

445 
	}
}

447 void 
	$mpu6050SetGyroYSelfTest
(
bool
 
enabled
)

449 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_CONFIG
, 
MPU6050_GCONFIG_YG_ST_BIT
, 
enabled
);

450 
	}
}

452 void 
	$mpu6050SetGyroZSelfTest
(
bool
 
enabled
)

454 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_CONFIG
, 
MPU6050_GCONFIG_ZG_ST_BIT
, 
enabled
);

455 
	}
}

463 
bool
 
	$mpu6050GetAccelXSelfTest
()

465 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_XA_ST_BIT
, 
buffer
);

466 return 
buffer
[0];

467 
	}
}

472 void 
	$mpu6050SetAccelXSelfTest
(
bool
 
enabled
)

474 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_XA_ST_BIT
, 
enabled
);

475 
	}
}

480 
bool
 
	$mpu6050GetAccelYSelfTest
()

482 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_YA_ST_BIT
, 
buffer
);

483 return 
buffer
[0];

484 
	}
}

489 void 
	$mpu6050SetAccelYSelfTest
(
bool
 
enabled
)

491 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_YA_ST_BIT
, 
enabled
);

492 
	}
}

497 
bool
 
	$mpu6050GetAccelZSelfTest
()

499 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_ZA_ST_BIT
, 
buffer
);

500 return 
buffer
[0];

501 
	}
}

506 void 
	$mpu6050SetAccelZSelfTest
(
bool
 
enabled
)

508 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_ZA_ST_BIT
, 
enabled
);

509 
	}
}

527 
uint8_t
 
	$mpu6050GetFullScaleAccelRangeId
()

529 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_AFS_SEL_BIT
,

530 
MPU6050_ACONFIG_AFS_SEL_LENGTH
, 
buffer
);

531 return 
buffer
[0];

532 
	}
}

542 float 
	$mpu6050GetFullScaleAccelGPL
()

544 
int32_t
 
rangeId
;

545 float 
range
;

547 
rangeId
 = 
	`mpu6050GetFullScaleAccelRangeId
();

548 switch (
rangeId
)

550 case 
MPU6050_ACCEL_FS_2
:

551 
range
 = 
MPU6050_G_PER_LSB_2
;

553 case 
MPU6050_ACCEL_FS_4
:

554 
range
 = 
MPU6050_G_PER_LSB_4
;

556 case 
MPU6050_ACCEL_FS_8
:

557 
range
 = 
MPU6050_G_PER_LSB_8
;

559 case 
MPU6050_ACCEL_FS_16
:

560 
range
 = 
MPU6050_G_PER_LSB_16
;

563 
range
 = 
MPU6050_DEG_PER_LSB_1000
;

567 return 
range
;

568 
	}
}

574 void 
	$mpu6050SetFullScaleAccelRange
(
uint8_t
 
range
)

576 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_AFS_SEL_BIT
,

577 
MPU6050_ACONFIG_AFS_SEL_LENGTH
, 
range
);

578 
	}
}

614 
uint8_t
 
	$mpu6050GetDHPFMode
()

616 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_ACCEL_HPF_BIT
,

617 
MPU6050_ACONFIG_ACCEL_HPF_LENGTH
, 
buffer
);

618 return 
buffer
[0];

619 
	}
}

626 void 
	$mpu6050SetDHPFMode
(
uint8_t
 
bandwidth
)

628 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_CONFIG
, 
MPU6050_ACONFIG_ACCEL_HPF_BIT
,

629 
MPU6050_ACONFIG_ACCEL_HPF_LENGTH
, 
bandwidth
);

630 
	}
}

649 
uint8_t
 
	$mpu6050GetFreefallDetectionThreshold
()

651 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FF_THR
, 
buffer
);

652 return 
buffer
[0];

653 
	}
}

659 void 
	$mpu6050SetFreefallDetectionThreshold
(
uint8_t
 
threshold
)

661 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FF_THR
, 
threshold
);

662 
	}
}

683 
uint8_t
 
	$mpu6050GetFreefallDetectionDuration
()

685 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FF_DUR
, 
buffer
);

686 return 
buffer
[0];

687 
	}
}

693 void 
	$mpu6050SetFreefallDetectionDuration
(
uint8_t
 
duration
)

695 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FF_DUR
, 
duration
);

696 
	}
}

719 
uint8_t
 
	$mpu6050GetMotionDetectionThreshold
()

721 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_THR
, 
buffer
);

722 return 
buffer
[0];

723 
	}
}

729 void 
	$mpu6050SetMotionDetectionThreshold
(
uint8_t
 
threshold
)

731 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_THR
, 
threshold
);

732 
	}
}

751 
uint8_t
 
	$mpu6050GetMotionDetectionDuration
()

753 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DUR
, 
buffer
);

754 return 
buffer
[0];

755 
	}
}

761 void 
	$mpu6050SetMotionDetectionDuration
(
uint8_t
 
duration
)

763 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DUR
, 
duration
);

764 
	}
}

793 
uint8_t
 
	$mpu6050GetZeroMotionDetectionThreshold
()

795 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZRMOT_THR
, 
buffer
);

796 return 
buffer
[0];

797 
	}
}

803 void 
	$mpu6050SetZeroMotionDetectionThreshold
(
uint8_t
 
threshold
)

805 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZRMOT_THR
, 
threshold
);

806 
	}
}

826 
uint8_t
 
	$mpu6050GetZeroMotionDetectionDuration
()

828 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZRMOT_DUR
, 
buffer
);

829 return 
buffer
[0];

830 
	}
}

836 void 
	$mpu6050SetZeroMotionDetectionDuration
(
uint8_t
 
duration
)

838 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZRMOT_DUR
, 
duration
);

839 
	}
}

849 
bool
 
	$mpu6050GetTempFIFOEnabled
()

851 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_TEMP_FIFO_EN_BIT
, 
buffer
);

852 return 
buffer
[0];

853 
	}
}

859 void 
	$mpu6050SetTempFIFOEnabled
(
bool
 
enabled
)

861 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_TEMP_FIFO_EN_BIT
, 
enabled
);

862 
	}
}

869 
bool
 
	$mpu6050GetXGyroFIFOEnabled
()

871 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_XG_FIFO_EN_BIT
, 
buffer
);

872 return 
buffer
[0];

873 
	}
}

879 void 
	$mpu6050SetXGyroFIFOEnabled
(
bool
 
enabled
)

881 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_XG_FIFO_EN_BIT
, 
enabled
);

882 
	}
}

889 
bool
 
	$mpu6050GetYGyroFIFOEnabled
()

891 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_YG_FIFO_EN_BIT
, 
buffer
);

892 return 
buffer
[0];

893 
	}
}

899 void 
	$mpu6050SetYGyroFIFOEnabled
(
bool
 
enabled
)

901 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_YG_FIFO_EN_BIT
, 
enabled
);

902 
	}
}

909 
bool
 
	$mpu6050GetZGyroFIFOEnabled
()

911 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_ZG_FIFO_EN_BIT
, 
buffer
);

912 return 
buffer
[0];

913 
	}
}

919 void 
	$mpu6050SetZGyroFIFOEnabled
(
bool
 
enabled
)

921 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_ZG_FIFO_EN_BIT
, 
enabled
);

922 
	}
}

930 
bool
 
	$mpu6050GetAccelFIFOEnabled
()

932 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_ACCEL_FIFO_EN_BIT
, 
buffer
);

933 return 
buffer
[0];

934 
	}
}

940 void 
	$mpu6050SetAccelFIFOEnabled
(
bool
 
enabled
)

942 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_ACCEL_FIFO_EN_BIT
, 
enabled
);

943 
	}
}

950 
bool
 
	$mpu6050GetSlave2FIFOEnabled
()

952 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_SLV2_FIFO_EN_BIT
, 
buffer
);

953 return 
buffer
[0];

954 
	}
}

960 void 
	$mpu6050SetSlave2FIFOEnabled
(
bool
 
enabled
)

962 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_SLV2_FIFO_EN_BIT
, 
enabled
);

963 
	}
}

970 
bool
 
	$mpu6050GetSlave1FIFOEnabled
()

972 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_SLV1_FIFO_EN_BIT
, 
buffer
);

973 return 
buffer
[0];

974 
	}
}

980 void 
	$mpu6050SetSlave1FIFOEnabled
(
bool
 
enabled
)

982 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_SLV1_FIFO_EN_BIT
, 
enabled
);

983 
	}
}

990 
bool
 
	$mpu6050GetSlave0FIFOEnabled
()

992 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_SLV0_FIFO_EN_BIT
, 
buffer
);

993 return 
buffer
[0];

994 
	}
}

1000 void 
	$mpu6050SetSlave0FIFOEnabled
(
bool
 
enabled
)

1002 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_EN
, 
MPU6050_SLV0_FIFO_EN_BIT
, 
enabled
);

1003 
	}
}

1022 
bool
 
	$mpu6050GetMultiMasterEnabled
()

1024 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_MULT_MST_EN_BIT
, 
buffer
);

1025 return 
buffer
[0];

1026 
	}
}

1032 void 
	$mpu6050SetMultiMasterEnabled
(
bool
 
enabled
)

1034 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_MULT_MST_EN_BIT
, 
enabled
);

1035 
	}
}

1047 
bool
 
	$mpu6050GetWaitForExternalSensorEnabled
()

1049 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_WAIT_FOR_ES_BIT
, 
buffer
);

1050 return 
buffer
[0];

1051 
	}
}

1057 void 
	$mpu6050SetWaitForExternalSensorEnabled
(
bool
 
enabled
)

1059 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_WAIT_FOR_ES_BIT
, 
enabled
);

1060 
	}
}

1067 
bool
 
	$mpu6050GetSlave3FIFOEnabled
()

1069 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_SLV_3_FIFO_EN_BIT
, 
buffer
);

1070 return 
buffer
[0];

1071 
	}
}

1077 void 
	$mpu6050SetSlave3FIFOEnabled
(
bool
 
enabled
)

1079 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_SLV_3_FIFO_EN_BIT
, 
enabled
);

1080 
	}
}

1091 
bool
 
	$mpu6050GetSlaveReadWriteTransitionEnabled
()

1093 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_I2C_MST_P_NSR_BIT
, 
buffer
);

1094 return 
buffer
[0];

1095 
	}
}

1101 void 
	$mpu6050SetSlaveReadWriteTransitionEnabled
(
bool
 
enabled
)

1103 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_I2C_MST_P_NSR_BIT
, 
enabled
);

1104 
	}
}

1134 
uint8_t
 
	$mpu6050GetMasterClockSpeed
()

1136 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_I2C_MST_CLK_BIT
,

1137 
MPU6050_I2C_MST_CLK_LENGTH
, 
buffer
);

1138 return 
buffer
[0];

1139 
	}
}

1144 void 
	$mpu6050SetMasterClockSpeed
(
uint8_t
 
speed
)

1146 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_CTRL
, 
MPU6050_I2C_MST_CLK_BIT
,

1147 
MPU6050_I2C_MST_CLK_LENGTH
, 
speed
);

1148 
	}
}

1193 
uint8_t
 
	$mpu6050GetSlaveAddress
(
uint8_t
 
num
)

1195 if (
num
 > 3)

1197 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_ADDR
 + 
num
 * 3, 
buffer
);

1198 return 
buffer
[0];

1199 
	}
}

1206 void 
	$mpu6050SetSlaveAddress
(
uint8_t
 
num
, uint8_t 
address
)

1208 if (
num
 > 3)

1210 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_ADDR
 + 
num
 * 3, 
address
);

1211 
	}
}

1223 
uint8_t
 
	$mpu6050GetSlaveRegister
(
uint8_t
 
num
)

1225 if (
num
 > 3)

1227 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_REG
 + 
num
 * 3, 
buffer
);

1228 return 
buffer
[0];

1229 
	}
}

1236 void 
	$mpu6050SetSlaveRegister
(
uint8_t
 
num
, uint8_t 
reg
)

1238 if (
num
 > 3)

1240 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_REG
 + 
num
 * 3, 
reg
);

1241 
	}
}

1249 
bool
 
	$mpu6050GetSlaveEnabled
(
uint8_t
 
num
)

1251 if (
num
 > 3)

1253 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_EN_BIT
, 
buffer
);

1254 return 
buffer
[0];

1255 
	}
}

1262 void 
	$mpu6050SetSlaveEnabled
(
uint8_t
 
num
, 
bool
 
enabled
)

1264 if (
num
 > 3)

1266 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_EN_BIT
,

1267 
enabled
);

1268 
	}
}

1280 
bool
 
	$mpu6050GetSlaveWordByteSwap
(
uint8_t
 
num
)

1282 if (
num
 > 3)

1284 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_BYTE_SW_BIT
,

1285 
buffer
);

1286 return 
buffer
[0];

1287 
	}
}

1294 void 
	$mpu6050SetSlaveWordByteSwap
(
uint8_t
 
num
, 
bool
 
enabled
)

1296 if (
num
 > 3)

1298 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_BYTE_SW_BIT
,

1299 
enabled
);

1300 
	}
}

1311 
bool
 
	$mpu6050GetSlaveWriteMode
(
uint8_t
 
num
)

1313 if (
num
 > 3)

1315 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_REG_DIS_BIT
,

1316 
buffer
);

1317 return 
buffer
[0];

1318 
	}
}

1325 void 
	$mpu6050SetSlaveWriteMode
(
uint8_t
 
num
, 
bool
 
mode
)

1327 if (
num
 > 3)

1329 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_REG_DIS_BIT
,

1330 
mode
);

1331 
	}
}

1343 
bool
 
	$mpu6050GetSlaveWordGroupOffset
(
uint8_t
 
num
)

1345 if (
num
 > 3)

1347 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_GRP_BIT
, 
buffer
);

1348 return 
buffer
[0];

1349 
	}
}

1356 void 
	$mpu6050SetSlaveWordGroupOffset
(
uint8_t
 
num
, 
bool
 
enabled
)

1358 if (
num
 > 3)

1360 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_GRP_BIT
,

1361 
enabled
);

1362 
	}
}

1370 
uint8_t
 
	$mpu6050GetSlaveDataLength
(
uint8_t
 
num
)

1372 if (
num
 > 3)

1374 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_LEN_BIT
,

1375 
MPU6050_I2C_SLV_LEN_LENGTH
, 
buffer
);

1376 return 
buffer
[0];

1377 
	}
}

1384 void 
	$mpu6050SetSlaveDataLength
(
uint8_t
 
num
, uint8_t 
length
)

1386 if (
num
 > 3)

1388 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_CTRL
 + 
num
 * 3, 
MPU6050_I2C_SLV_LEN_BIT
,

1389 
MPU6050_I2C_SLV_LEN_LENGTH
, 
length
);

1390 
	}
}

1403 
uint8_t
 
	$mpu6050GetSlave4Address
()

1405 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_ADDR
, 
buffer
);

1406 return 
buffer
[0];

1407 
	}
}

1413 void 
	$mpu6050SetSlave4Address
(
uint8_t
 
address
)

1415 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_ADDR
, 
address
);

1416 
	}
}

1424 
uint8_t
 
	$mpu6050GetSlave4Register
()

1426 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_REG
, 
buffer
);

1427 return 
buffer
[0];

1428 
	}
}

1434 void 
	$mpu6050SetSlave4Register
(
uint8_t
 
reg
)

1436 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_REG
, 
reg
);

1437 
	}
}

1444 void 
	$mpu6050SetSlave4OutputByte
(
uint8_t
 
data
)

1446 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_DO
, 
data
);

1447 
	}
}

1454 
bool
 
	$mpu6050GetSlave4Enabled
()

1456 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_EN_BIT
, 
buffer
);

1457 return 
buffer
[0];

1458 
	}
}

1464 void 
	$mpu6050SetSlave4Enabled
(
bool
 
enabled
)

1466 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_EN_BIT
, 
enabled
);

1467 
	}
}

1477 
bool
 
	$mpu6050GetSlave4InterruptEnabled
()

1479 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_INT_EN_BIT
, 
buffer
);

1480 return 
buffer
[0];

1481 
	}
}

1487 void 
	$mpu6050SetSlave4InterruptEnabled
(
bool
 
enabled
)

1489 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_INT_EN_BIT
, 
enabled
);

1490 
	}
}

1500 
bool
 
	$mpu6050GetSlave4WriteMode
()

1502 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_REG_DIS_BIT
, 
buffer
);

1503 return 
buffer
[0];

1504 
	}
}

1510 void 
	$mpu6050SetSlave4WriteMode
(
bool
 
mode
)

1512 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_REG_DIS_BIT
, 
mode
);

1513 
	}
}

1529 
uint8_t
 
	$mpu6050GetSlave4MasterDelay
()

1531 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_MST_DLY_BIT
,

1532 
MPU6050_I2C_SLV4_MST_DLY_LENGTH
, 
buffer
);

1533 return 
buffer
[0];

1534 
	}
}

1540 void 
	$mpu6050SetSlave4MasterDelay
(
uint8_t
 
delay
)

1542 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_CTRL
, 
MPU6050_I2C_SLV4_MST_DLY_BIT
,

1543 
MPU6050_I2C_SLV4_MST_DLY_LENGTH
, 
delay
);

1544 
	}
}

1551 
uint8_t
 
	$mpu6050GetSlate4InputByte
()

1553 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV4_DI
, 
buffer
);

1554 return 
buffer
[0];

1555 
	}
}

1568 
bool
 
	$mpu6050GetPassthroughStatus
()

1570 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_PASS_THROUGH_BIT
, 
buffer
);

1571 return 
buffer
[0];

1572 
	}
}

1581 
bool
 
	$mpu6050GetSlave4IsDone
()

1583 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_I2C_SLV4_DONE_BIT
, 
buffer
);

1584 return 
buffer
[0];

1585 
	}
}

1593 
bool
 
	$mpu6050GetLostArbitration
()

1595 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_I2C_LOST_ARB_BIT
, 
buffer
);

1596 return 
buffer
[0];

1597 
	}
}

1605 
bool
 
	$mpu6050GetSlave4Nack
()

1607 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_I2C_SLV4_NACK_BIT
, 
buffer
);

1608 return 
buffer
[0];

1609 
	}
}

1617 
bool
 
	$mpu6050GetSlave3Nack
()

1619 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_I2C_SLV3_NACK_BIT
, 
buffer
);

1620 return 
buffer
[0];

1621 
	}
}

1629 
bool
 
	$mpu6050GetSlave2Nack
()

1631 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_I2C_SLV2_NACK_BIT
, 
buffer
);

1632 return 
buffer
[0];

1633 
	}
}

1641 
bool
 
	$mpu6050GetSlave1Nack
()

1643 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_I2C_SLV1_NACK_BIT
, 
buffer
);

1644 return 
buffer
[0];

1645 
	}
}

1653 
bool
 
	$mpu6050GetSlave0Nack
()

1655 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_STATUS
, 
MPU6050_MST_I2C_SLV0_NACK_BIT
, 
buffer
);

1656 return 
buffer
[0];

1657 
	}
}

1667 
bool
 
	$mpu6050GetInterruptMode
()

1669 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_INT_LEVEL_BIT
, 
buffer
);

1670 return 
buffer
[0];

1671 
	}
}

1678 void 
	$mpu6050SetInterruptMode
(
bool
 
mode
)

1680 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_INT_LEVEL_BIT
, 
mode
);

1681 
	}
}

1688 
bool
 
	$mpu6050GetInterruptDrive
()

1690 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_INT_OPEN_BIT
, 
buffer
);

1691 return 
buffer
[0];

1692 
	}
}

1699 void 
	$mpu6050SetInterruptDrive
(
bool
 
drive
)

1701 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_INT_OPEN_BIT
, 
drive
);

1702 
	}
}

1709 
bool
 
	$mpu6050GetInterruptLatch
()

1711 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_LATCH_INT_EN_BIT
, 
buffer
);

1712 return 
buffer
[0];

1713 
	}
}

1720 void 
	$mpu6050SetInterruptLatch
(
bool
 
latch
)

1722 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_LATCH_INT_EN_BIT
, 
latch
);

1723 
	}
}

1730 
bool
 
	$mpu6050GetInterruptLatchClear
()

1732 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_INT_RD_CLEAR_BIT
, 
buffer
);

1733 return 
buffer
[0];

1734 
	}
}

1741 void 
	$mpu6050SetInterruptLatchClear
(
bool
 
clear
)

1743 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_INT_RD_CLEAR_BIT
, 
clear
);

1744 
	}
}

1751 
bool
 
	$mpu6050GetFSyncInterruptLevel
()

1753 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT
, 
buffer
);

1754 return 
buffer
[0];

1755 
	}
}

1762 void 
	$mpu6050SetFSyncInterruptLevel
(
bool
 
level
)

1764 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_FSYNC_INT_LEVEL_BIT
, 
level
);

1765 
	}
}

1772 
bool
 
	$mpu6050GetFSyncInterruptEnabled
()

1774 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_FSYNC_INT_EN_BIT
, 
buffer
);

1775 return 
buffer
[0];

1776 
	}
}

1783 void 
	$mpu6050SetFSyncInterruptEnabled
(
bool
 
enabled
)

1785 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_FSYNC_INT_EN_BIT
, 
enabled
);

1786 
	}
}

1798 
bool
 
	$mpu6050GetI2CBypassEnabled
()

1800 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_I2C_BYPASS_EN_BIT
, 
buffer
);

1801 return 
buffer
[0];

1802 
	}
}

1814 void 
	$mpu6050SetI2CBypassEnabled
(
bool
 
enabled
)

1816 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_I2C_BYPASS_EN_BIT
, 
enabled
);

1817 
	}
}

1827 
bool
 
	$mpu6050GetClockOutputEnabled
()

1829 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_CLKOUT_EN_BIT
, 
buffer
);

1830 return 
buffer
[0];

1831 
	}
}

1841 void 
	$mpu6050SetClockOutputEnabled
(
bool
 
enabled
)

1843 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_PIN_CFG
, 
MPU6050_INTCFG_CLKOUT_EN_BIT
, 
enabled
);

1844 
	}
}

1855 
uint8_t
 
	$mpu6050GetIntEnabled
()

1857 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
buffer
);

1858 return 
buffer
[0];

1859 
	}
}

1868 void 
	$mpu6050SetIntEnabled
(
uint8_t
 
enabled
)

1870 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
enabled
);

1871 
	}
}

1878 
bool
 
	$mpu6050GetIntFreefallEnabled
()

1880 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_FF_BIT
, 
buffer
);

1881 return 
buffer
[0];

1882 
	}
}

1889 void 
	$mpu6050SetIntFreefallEnabled
(
bool
 
enabled
)

1891 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_FF_BIT
, 
enabled
);

1892 
	}
}

1899 
bool
 
	$mpu6050GetIntMotionEnabled
()

1901 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_MOT_BIT
, 
buffer
);

1902 return 
buffer
[0];

1903 
	}
}

1910 void 
	$mpu6050SetIntMotionEnabled
(
bool
 
enabled
)

1912 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_MOT_BIT
, 
enabled
);

1913 
	}
}

1920 
bool
 
	$mpu6050GetIntZeroMotionEnabled
()

1922 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_ZMOT_BIT
, 
buffer
);

1923 return 
buffer
[0];

1924 
	}
}

1931 void 
	$mpu6050SetIntZeroMotionEnabled
(
bool
 
enabled
)

1933 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_ZMOT_BIT
, 
enabled
);

1934 
	}
}

1941 
bool
 
	$mpu6050GetIntFIFOBufferOverflowEnabled
()

1943 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_FIFO_OFLOW_BIT
, 
buffer
);

1944 return 
buffer
[0];

1945 
	}
}

1952 void 
	$mpu6050SetIntFIFOBufferOverflowEnabled
(
bool
 
enabled
)

1954 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_FIFO_OFLOW_BIT
, 
enabled
);

1955 
	}
}

1963 
bool
 
	$mpu6050GetIntI2CMasterEnabled
()

1965 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_I2C_MST_INT_BIT
, 
buffer
);

1966 return 
buffer
[0];

1967 
	}
}

1974 void 
	$mpu6050SetIntI2CMasterEnabled
(
bool
 
enabled
)

1976 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_I2C_MST_INT_BIT
, 
enabled
);

1977 
	}
}

1985 
bool
 
	$mpu6050GetIntDataReadyEnabled
()

1987 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_DATA_RDY_BIT
, 
buffer
);

1988 return 
buffer
[0];

1989 
	}
}

1996 void 
	$mpu6050SetIntDataReadyEnabled
(
bool
 
enabled
)

1998 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_DATA_RDY_BIT
, 
enabled
);

1999 
	}
}

2010 
uint8_t
 
	$mpu6050GetIntStatus
()

2012 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
buffer
);

2013 return 
buffer
[0];

2014 
	}
}

2022 
bool
 
	$mpu6050GetIntFreefallStatus
()

2024 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_FF_BIT
, 
buffer
);

2025 return 
buffer
[0];

2026 
	}
}

2034 
bool
 
	$mpu6050GetIntMotionStatus
()

2036 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_MOT_BIT
, 
buffer
);

2037 return 
buffer
[0];

2038 
	}
}

2046 
bool
 
	$mpu6050GetIntZeroMotionStatus
()

2048 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_ZMOT_BIT
, 
buffer
);

2049 return 
buffer
[0];

2050 
	}
}

2058 
bool
 
	$mpu6050GetIntFIFOBufferOverflowStatus
()

2060 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_FIFO_OFLOW_BIT
, 
buffer
);

2061 return 
buffer
[0];

2062 
	}
}

2071 
bool
 
	$mpu6050GetIntI2CMasterStatus
()

2073 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_I2C_MST_INT_BIT
, 
buffer
);

2074 return 
buffer
[0];

2075 
	}
}

2083 
bool
 
	$mpu6050GetIntDataReadyStatus
()

2085 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_DATA_RDY_BIT
, 
buffer
);

2086 return 
buffer
[0];

2087 
	}
}

2107 void 
	$mpu6050GetMotion9
(
int16_t
* 
ax
, int16_t* 
ay
, int16_t* 
az
, int16_t* 
gx
, int16_t* 
gy
, int16_t* 
gz
,

2108 
int16_t
* 
mx
, int16_t* 
my
, int16_t* 
mz
)

2110 
	`mpu6050GetMotion6
(
ax
, 
ay
, 
az
, 
gx
, 
gy
, 
gz
);

2112 
	}
}

2125 void 
	$mpu6050GetMotion6
(
int16_t
* 
ax
, int16_t* 
ay
, int16_t* 
az
, int16_t* 
gx
, int16_t* 
gy
, int16_t* 
gz
)

2127 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_XOUT_H
, 14, 
buffer
);

2128 *
ax
 = (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2129 *
ay
 = (((
int16_t
) 
buffer
[2]) << 8) | buffer[3];

2130 *
az
 = (((
int16_t
) 
buffer
[4]) << 8) | buffer[5];

2131 *
gx
 = (((
int16_t
) 
buffer
[8]) << 8) | buffer[9];

2132 *
gy
 = (((
int16_t
) 
buffer
[10]) << 8) | buffer[11];

2133 *
gz
 = (((
int16_t
) 
buffer
[12]) << 8) | buffer[13];

2134 
	}
}

2171 void 
	$mpu6050GetAcceleration
(
int16_t
* 
x
, int16_t* 
y
, int16_t* 
z
)

2173 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_XOUT_H
, 6, 
buffer
);

2174 *
x
 = (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2175 *
y
 = (((
int16_t
) 
buffer
[2]) << 8) | buffer[3];

2176 *
z
 = (((
int16_t
) 
buffer
[4]) << 8) | buffer[5];

2177 
	}
}

2183 
int16_t
 
	$mpu6050GetAccelerationX
()

2185 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_XOUT_H
, 2, 
buffer
);

2186 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2187 
	}
}

2193 
int16_t
 
	$mpu6050GetAccelerationY
()

2195 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_YOUT_H
, 2, 
buffer
);

2196 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2197 
	}
}

2203 
int16_t
 
	$mpu6050GetAccelerationZ
()

2205 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ACCEL_ZOUT_H
, 2, 
buffer
);

2206 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2207 
	}
}

2215 
int16_t
 
	$mpu6050GetTemperature
()

2217 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_TEMP_OUT_H
, 2, 
buffer
);

2218 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2219 
	}
}

2255 void 
	$mpu6050GetRotation
(
int16_t
* 
x
, int16_t* 
y
, int16_t* 
z
)

2257 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_XOUT_H
, 6, 
buffer
);

2258 *
x
 = (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2259 *
y
 = (((
int16_t
) 
buffer
[2]) << 8) | buffer[3];

2260 *
z
 = (((
int16_t
) 
buffer
[4]) << 8) | buffer[5];

2261 
	}
}

2267 
int16_t
 
	$mpu6050GetRotationX
()

2269 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_XOUT_H
, 2, 
buffer
);

2270 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2271 
	}
}

2277 
int16_t
 
	$mpu6050GetRotationY
()

2279 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_YOUT_H
, 2, 
buffer
);

2280 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2281 
	}
}

2287 
int16_t
 
	$mpu6050GetRotationZ
()

2289 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_GYRO_ZOUT_H
, 2, 
buffer
);

2290 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

2291 
	}
}

2369 
uint8_t
 
	$mpu6050GetExternalSensorByte
(int 
position
)

2371 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_EXT_SENS_DATA_00
 + 
position
, 
buffer
);

2372 return 
buffer
[0];

2373 
	}
}

2379 
uint16_t
 
	$mpu6050GetExternalSensorWord
(int 
position
)

2381 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_EXT_SENS_DATA_00
 + 
position
, 2, 
buffer
);

2382 return (((
uint16_t
) 
buffer
[0]) << 8) | buffer[1];

2383 
	}
}

2389 
uint32_t
 
	$mpu6050GetExternalSensorDWord
(int 
position
)

2391 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_EXT_SENS_DATA_00
 + 
position
, 4, 
buffer
);

2392 return (((
uint32_t
) 
buffer
[0]) << 24) | (((uint32_t) buffer[1]) << 16)

2393 | (((
uint16_t
) 
buffer
[2]) << 8) | buffer[3];

2394 
	}
}

2403 
bool
 
	$mpu6050GetXNegMotionDetected
()

2405 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_STATUS
, 
MPU6050_MOTION_MOT_XNEG_BIT
, 
buffer
);

2406 return 
buffer
[0];

2407 
	}
}

2413 
bool
 
	$mpu6050GetXPosMotionDetected
()

2415 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_STATUS
, 
MPU6050_MOTION_MOT_XPOS_BIT
, 
buffer
);

2416 return 
buffer
[0];

2417 
	}
}

2423 
bool
 
	$mpu6050GetYNegMotionDetected
()

2425 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_STATUS
, 
MPU6050_MOTION_MOT_YNEG_BIT
, 
buffer
);

2426 return 
buffer
[0];

2427 
	}
}

2433 
bool
 
	$mpu6050GetYPosMotionDetected
()

2435 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_STATUS
, 
MPU6050_MOTION_MOT_YPOS_BIT
, 
buffer
);

2436 return 
buffer
[0];

2437 
	}
}

2443 
bool
 
	$mpu6050GetZNegMotionDetected
()

2445 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_STATUS
, 
MPU6050_MOTION_MOT_ZNEG_BIT
, 
buffer
);

2446 return 
buffer
[0];

2447 
	}
}

2453 
bool
 
	$mpu6050GetZPosMotionDetected
()

2455 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_STATUS
, 
MPU6050_MOTION_MOT_ZPOS_BIT
, 
buffer
);

2456 return 
buffer
[0];

2457 
	}
}

2463 
bool
 
	$mpu6050GetZeroMotionDetected
()

2465 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_STATUS
, 
MPU6050_MOTION_MOT_ZRMOT_BIT
, 
buffer
);

2466 return 
buffer
[0];

2467 
	}
}

2479 void 
	$mpu6050SetSlaveOutputByte
(
uint8_t
 
num
, uint8_t 
data
)

2481 if (
num
 > 3)

2483 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_SLV0_DO
 + 
num
, 
data
);

2484 
	}
}

2496 
bool
 
	$mpu6050GetExternalShadowDelayEnabled
()

2498 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_DELAY_CTRL
, 
MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT
,

2499 
buffer
);

2500 return 
buffer
[0];

2501 
	}
}

2508 void 
	$mpu6050SetExternalShadowDelayEnabled
(
bool
 
enabled
)

2510 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_DELAY_CTRL
,

2511 
MPU6050_DELAYCTRL_DELAY_ES_SHADOW_BIT
, 
enabled
);

2512 
	}
}

2531 
bool
 
	$mpu6050GetSlaveDelayEnabled
(
uint8_t
 
num
)

2534 if (
num
 > 4)

2536 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_DELAY_CTRL
, 
num
, 
buffer
);

2537 return 
buffer
[0];

2538 
	}
}

2545 void 
	$mpu6050SetSlaveDelayEnabled
(
uint8_t
 
num
, 
bool
 
enabled
)

2547 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_I2C_MST_DELAY_CTRL
, 
num
, 
enabled
);

2548 
	}
}

2558 void 
	$mpu6050ResetGyroscopePath
()

2560 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_SIGNAL_PATH_RESET
, 
MPU6050_PATHRESET_GYRO_RESET_BIT
, 1);

2561 
	}
}

2568 void 
	$mpu6050ResetAccelerometerPath
()

2570 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_SIGNAL_PATH_RESET
, 
MPU6050_PATHRESET_ACCEL_RESET_BIT
, 1);

2571 
	}
}

2578 void 
	$mpu6050ResetTemperaturePath
()

2580 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_SIGNAL_PATH_RESET
, 
MPU6050_PATHRESET_TEMP_RESET_BIT
, 1);

2581 
	}
}

2599 
uint8_t
 
	$mpu6050GetAccelerometerPowerOnDelay
()

2601 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_CTRL
, 
MPU6050_DETECT_ACCEL_ON_DELAY_BIT
,

2602 
MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH
, 
buffer
);

2603 return 
buffer
[0];

2604 
	}
}

2611 void 
	$mpu6050SetAccelerometerPowerOnDelay
(
uint8_t
 
delay
)

2613 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_CTRL
, 
MPU6050_DETECT_ACCEL_ON_DELAY_BIT
,

2614 
MPU6050_DETECT_ACCEL_ON_DELAY_LENGTH
, 
delay
);

2615 
	}
}

2642 
uint8_t
 
	$mpu6050GetFreefallDetectionCounterDecrement
()

2644 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_CTRL
, 
MPU6050_DETECT_FF_COUNT_BIT
,

2645 
MPU6050_DETECT_FF_COUNT_LENGTH
, 
buffer
);

2646 return 
buffer
[0];

2647 
	}
}

2654 void 
	$mpu6050SetFreefallDetectionCounterDecrement
(
uint8_t
 
decrement
)

2656 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_CTRL
, 
MPU6050_DETECT_FF_COUNT_BIT
,

2657 
MPU6050_DETECT_FF_COUNT_LENGTH
, 
decrement
);

2658 
	}
}

2682 
uint8_t
 
	$mpu6050GetMotionDetectionCounterDecrement
()

2684 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_CTRL
, 
MPU6050_DETECT_MOT_COUNT_BIT
,

2685 
MPU6050_DETECT_MOT_COUNT_LENGTH
, 
buffer
);

2686 return 
buffer
[0];

2687 
	}
}

2694 void 
	$mpu6050SetMotionDetectionCounterDecrement
(
uint8_t
 
decrement
)

2696 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MOT_DETECT_CTRL
, 
MPU6050_DETECT_MOT_COUNT_BIT
,

2697 
MPU6050_DETECT_MOT_COUNT_LENGTH
, 
decrement
);

2698 
	}
}

2710 
bool
 
	$mpu6050GetFIFOEnabled
()

2712 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_FIFO_EN_BIT
, 
buffer
);

2713 return 
buffer
[0];

2714 
	}
}

2721 void 
	$mpu6050SetFIFOEnabled
(
bool
 
enabled
)

2723 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_FIFO_EN_BIT
, 
enabled
);

2724 
	}
}

2736 
bool
 
	$mpu6050GetI2CMasterModeEnabled
()

2738 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_I2C_MST_EN_BIT
, 
buffer
);

2739 return 
buffer
[0];

2740 
	}
}

2747 void 
	$mpu6050SetI2CMasterModeEnabled
(
bool
 
enabled
)

2749 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_I2C_MST_EN_BIT
, 
enabled
);

2750 
	}
}

2755 void 
	$mpu6050SwitchSPIEnabled
(
bool
 
enabled
)

2757 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_I2C_IF_DIS_BIT
, 
enabled
);

2758 
	}
}

2765 void 
	$mpu6050ResetFIFO
()

2767 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_FIFO_RESET_BIT
, 1);

2768 
	}
}

2775 void 
	$mpu6050ResetI2CMaster
()

2777 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_I2C_MST_RESET_BIT
, 1);

2778 
	}
}

2791 void 
	$mpu6050ResetSensors
()

2793 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_SIG_COND_RESET_BIT
, 1);

2794 
	}
}

2803 void 
	$mpu6050Reset
()

2805 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_DEVICE_RESET_BIT
, 1);

2806 
	}
}

2818 
bool
 
	$mpu6050GetSleepEnabled
()

2820 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_SLEEP_BIT
, 
buffer
);

2821 return 
buffer
[0];

2822 
	}
}

2829 void 
	$mpu6050SetSleepEnabled
(
bool
 
enabled
)

2831 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_SLEEP_BIT
, 
enabled
);

2832 
	}
}

2841 
bool
 
	$mpu6050GetWakeCycleEnabled
()

2843 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_CYCLE_BIT
, 
buffer
);

2844 return 
buffer
[0];

2845 
	}
}

2852 void 
	$mpu6050SetWakeCycleEnabled
(
bool
 
enabled
)

2854 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_CYCLE_BIT
, 
enabled
);

2855 
	}
}

2867 
bool
 
	$mpu6050GetTempSensorEnabled
()

2869 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_TEMP_DIS_BIT
, 
buffer
);

2870 return 
buffer
[0] == 0;

2871 
	}
}

2882 void 
	$mpu6050SetTempSensorEnabled
(
bool
 
enabled
)

2885 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_TEMP_DIS_BIT
, !
enabled
);

2886 
	}
}

2893 
uint8_t
 
	$mpu6050GetClockSource
()

2895 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_CLKSEL_BIT
,

2896 
MPU6050_PWR1_CLKSEL_LENGTH
, 
buffer
);

2897 return 
buffer
[0];

2898 
	}
}

2929 void 
	$mpu6050SetClockSource
(
uint8_t
 
source
)

2931 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_1
, 
MPU6050_PWR1_CLKSEL_BIT
,

2932 
MPU6050_PWR1_CLKSEL_LENGTH
, 
source
);

2933 
	}
}

2960 
uint8_t
 
	$mpu6050GetWakeFrequency
()

2962 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_LP_WAKE_CTRL_BIT
,

2963 
MPU6050_PWR2_LP_WAKE_CTRL_LENGTH
, 
buffer
);

2964 return 
buffer
[0];

2965 
	}
}

2970 void 
	$mpu6050SetWakeFrequency
(
uint8_t
 
frequency
)

2972 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_LP_WAKE_CTRL_BIT
,

2973 
MPU6050_PWR2_LP_WAKE_CTRL_LENGTH
, 
frequency
);

2974 
	}
}

2982 
bool
 
	$mpu6050GetStandbyXAccelEnabled
()

2984 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_XA_BIT
, 
buffer
);

2985 return 
buffer
[0];

2986 
	}
}

2993 void 
	$mpu6050SetStandbyXAccelEnabled
(
bool
 
enabled
)

2995 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_XA_BIT
, 
enabled
);

2996 
	}
}

3003 
bool
 
	$mpu6050GetStandbyYAccelEnabled
()

3005 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_YA_BIT
, 
buffer
);

3006 return 
buffer
[0];

3007 
	}
}

3014 void 
	$mpu6050SetStandbyYAccelEnabled
(
bool
 
enabled
)

3016 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_YA_BIT
, 
enabled
);

3017 
	}
}

3024 
bool
 
	$mpu6050GetStandbyZAccelEnabled
()

3026 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_ZA_BIT
, 
buffer
);

3027 return 
buffer
[0];

3028 
	}
}

3035 void 
	$mpu6050SetStandbyZAccelEnabled
(
bool
 
enabled
)

3037 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_ZA_BIT
, 
enabled
);

3038 
	}
}

3045 
bool
 
	$mpu6050GetStandbyXGyroEnabled
()

3047 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_XG_BIT
, 
buffer
);

3048 return 
buffer
[0];

3049 
	}
}

3056 void 
	$mpu6050SetStandbyXGyroEnabled
(
bool
 
enabled
)

3058 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_XG_BIT
, 
enabled
);

3059 
	}
}

3066 
bool
 
	$mpu6050GetStandbyYGyroEnabled
()

3068 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_YG_BIT
, 
buffer
);

3069 return 
buffer
[0];

3070 
	}
}

3077 void 
	$mpu6050SetStandbyYGyroEnabled
(
bool
 
enabled
)

3079 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_YG_BIT
, 
enabled
);

3080 
	}
}

3087 
bool
 
	$mpu6050GetStandbyZGyroEnabled
()

3089 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_ZG_BIT
, 
buffer
);

3090 return 
buffer
[0];

3091 
	}
}

3098 void 
	$mpu6050SetStandbyZGyroEnabled
(
bool
 
enabled
)

3100 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_PWR_MGMT_2
, 
MPU6050_PWR2_STBY_ZG_BIT
, 
enabled
);

3101 
	}
}

3112 
uint16_t
 
	$mpu6050GetFIFOCount
()

3114 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_COUNTH
, 2, 
buffer
);

3115 return (((
uint16_t
) 
buffer
[0]) << 8) | buffer[1];

3116 
	}
}

3145 
uint8_t
 
	$mpu6050GetFIFOByte
()

3147 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_R_W
, 
buffer
);

3148 return 
buffer
[0];

3149 
	}
}

3150 void 
	$mpu6050GetFIFOBytes
(
uint8_t
 *
data
, uint8_t 
length
)

3152 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_R_W
, 
length
, 
data
);

3153 
	}
}

3158 void 
	$mpu6050SetFIFOByte
(
uint8_t
 
data
)

3160 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_FIFO_R_W
, 
data
);

3161 
	}
}

3172 
uint8_t
 
	$mpu6050GetDeviceID
()

3174 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_WHO_AM_I
, 
MPU6050_WHO_AM_I_BIT
, 
MPU6050_WHO_AM_I_LENGTH
,

3175 
buffer
);

3176 return 
buffer
[0];

3177 
	}
}

3187 void 
	$mpu6050SetDeviceID
(
uint8_t
 
id
)

3189 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_WHO_AM_I
, 
MPU6050_WHO_AM_I_BIT
, 
MPU6050_WHO_AM_I_LENGTH
,

3190 
id
);

3191 
	}
}

3197 
uint8_t
 
	$mpu6050GetOTPBankValid
()

3199 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XG_OFFS_TC
, 
MPU6050_TC_OTP_BNK_VLD_BIT
, 
buffer
);

3200 return 
buffer
[0];

3201 
	}
}

3202 void 
	$mpu6050SetOTPBankValid
(
bool
 
enabled
)

3204 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XG_OFFS_TC
, 
MPU6050_TC_OTP_BNK_VLD_BIT
, 
enabled
);

3205 
	}
}

3206 
int8_t
 
	$mpu6050GetXGyroOffset
()

3208 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XG_OFFS_TC
, 
MPU6050_TC_OFFSET_BIT
,

3209 
MPU6050_TC_OFFSET_LENGTH
, 
buffer
);

3210 return 
buffer
[0];

3211 
	}
}

3212 void 
	$mpu6050SetXGyroOffset
(
int8_t
 
offset
)

3214 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XG_OFFS_TC
, 
MPU6050_TC_OFFSET_BIT
,

3215 
MPU6050_TC_OFFSET_LENGTH
, 
offset
);

3216 
	}
}

3220 
int8_t
 
	$mpu6050GetYGyroOffset
()

3222 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YG_OFFS_TC
, 
MPU6050_TC_OFFSET_BIT
,

3223 
MPU6050_TC_OFFSET_LENGTH
, 
buffer
);

3224 return 
buffer
[0];

3225 
	}
}

3226 void 
	$mpu6050SetYGyroOffset
(
int8_t
 
offset
)

3228 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YG_OFFS_TC
, 
MPU6050_TC_OFFSET_BIT
,

3229 
MPU6050_TC_OFFSET_LENGTH
, 
offset
);

3230 
	}
}

3234 
int8_t
 
	$mpu6050GetZGyroOffset
()

3236 
	`i2cdevReadBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZG_OFFS_TC
, 
MPU6050_TC_OFFSET_BIT
,

3237 
MPU6050_TC_OFFSET_LENGTH
, 
buffer
);

3238 return 
buffer
[0];

3239 
	}
}

3240 void 
	$mpu6050SetZGyroOffset
(
int8_t
 
offset
)

3242 
	`i2cdevWriteBits
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZG_OFFS_TC
, 
MPU6050_TC_OFFSET_BIT
,

3243 
MPU6050_TC_OFFSET_LENGTH
, 
offset
);

3244 
	}
}

3248 
int8_t
 
	$mpu6050GetXFineGain
()

3250 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_X_FINE_GAIN
, 
buffer
);

3251 return 
buffer
[0];

3252 
	}
}

3253 void 
	$mpu6050SetXFineGain
(
int8_t
 
gain
)

3255 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_X_FINE_GAIN
, 
gain
);

3256 
	}
}

3260 
int8_t
 
	$mpu6050GetYFineGain
()

3262 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_Y_FINE_GAIN
, 
buffer
);

3263 return 
buffer
[0];

3264 
	}
}

3265 void 
	$mpu6050SetYFineGain
(
int8_t
 
gain
)

3267 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_Y_FINE_GAIN
, 
gain
);

3268 
	}
}

3272 
int8_t
 
	$mpu6050GetZFineGain
()

3274 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_Z_FINE_GAIN
, 
buffer
);

3275 return 
buffer
[0];

3276 
	}
}

3277 void 
	$mpu6050SetZFineGain
(
int8_t
 
gain
)

3279 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_Z_FINE_GAIN
, 
gain
);

3280 
	}
}

3284 
int16_t
 
	$mpu6050GetXAccelOffset
()

3286 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XA_OFFS_H
, 2, 
buffer
);

3287 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

3288 
	}
}

3289 void 
	$mpu6050SetXAccelOffset
(
int16_t
 
offset
)

3291 
	`i2cdevWrite
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XA_OFFS_H
, 2, (
uint8_t
 *)&
offset
);

3292 
	}
}

3296 
int16_t
 
	$mpu6050GetYAccelOffset
()

3298 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YA_OFFS_H
, 2, 
buffer
);

3299 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

3300 
	}
}

3301 void 
	$mpu6050SetYAccelOffset
(
int16_t
 
offset
)

3303 
	`i2cdevWrite
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YA_OFFS_H
, 2, (
uint8_t
 *)&
offset
);

3304 
	}
}

3308 
int16_t
 
	$mpu6050GetZAccelOffset
()

3310 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZA_OFFS_H
, 2, 
buffer
);

3311 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

3312 
	}
}

3313 void 
	$mpu6050SetZAccelOffset
(
int16_t
 
offset
)

3315 
	`i2cdevWrite
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZA_OFFS_H
, 2, (
uint8_t
 *)&
offset
);

3316 
	}
}

3320 
int16_t
 
	$mpu6050GetXGyroOffsetUser
()

3322 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XG_OFFS_USRH
, 2, 
buffer
);

3323 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

3324 
	}
}

3325 void 
	$mpu6050SetXGyroOffsetUser
(
int16_t
 
offset
)

3327 
	`i2cdevWrite
(
I2Cx
, 
devAddr
, 
MPU6050_RA_XG_OFFS_USRH
, 2, (
uint8_t
 *)&
offset
);

3328 
	}
}

3332 
int16_t
 
	$mpu6050GetYGyroOffsetUser
()

3334 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YG_OFFS_USRH
, 2, 
buffer
);

3335 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

3336 
	}
}

3337 void 
	$mpu6050SetYGyroOffsetUser
(
int16_t
 
offset
)

3339 
	`i2cdevWrite
(
I2Cx
, 
devAddr
, 
MPU6050_RA_YG_OFFS_USRH
, 2, (
uint8_t
 *)&
offset
);

3340 
	}
}

3344 
int16_t
 
	$mpu6050GetZGyroOffsetUser
()

3346 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZG_OFFS_USRH
, 2, 
buffer
);

3347 return (((
int16_t
) 
buffer
[0]) << 8) | buffer[1];

3348 
	}
}

3349 void 
	$mpu6050SetZGyroOffsetUser
(
int16_t
 
offset
)

3351 
	`i2cdevWrite
(
I2Cx
, 
devAddr
, 
MPU6050_RA_ZG_OFFS_USRH
, 2, (
uint8_t
 *)&
offset
);

3352 
	}
}

3356 
bool
 
	$mpu6050GetIntPLLReadyEnabled
()

3358 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_PLL_RDY_INT_BIT
, 
buffer
);

3359 return 
buffer
[0];

3360 
	}
}

3361 void 
	$mpu6050SetIntPLLReadyEnabled
(
bool
 
enabled
)

3363 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_PLL_RDY_INT_BIT
, 
enabled
);

3364 
	}
}

3365 
bool
 
	$mpu6050GetIntDMPEnabled
()

3367 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_DMP_INT_BIT
, 
buffer
);

3368 return 
buffer
[0];

3369 
	}
}

3370 void 
	$mpu6050SetIntDMPEnabled
(
bool
 
enabled
)

3372 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_ENABLE
, 
MPU6050_INTERRUPT_DMP_INT_BIT
, 
enabled
);

3373 
	}
}

3377 
bool
 
	$mpu6050GetDMPInt5Status
()

3379 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_INT_STATUS
, 
MPU6050_DMPINT_5_BIT
, 
buffer
);

3380 return 
buffer
[0];

3381 
	}
}

3382 
bool
 
	$mpu6050GetDMPInt4Status
()

3384 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_INT_STATUS
, 
MPU6050_DMPINT_4_BIT
, 
buffer
);

3385 return 
buffer
[0];

3386 
	}
}

3387 
bool
 
	$mpu6050GetDMPInt3Status
()

3389 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_INT_STATUS
, 
MPU6050_DMPINT_3_BIT
, 
buffer
);

3390 return 
buffer
[0];

3391 
	}
}

3392 
bool
 
	$mpu6050GetDMPInt2Status
()

3394 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_INT_STATUS
, 
MPU6050_DMPINT_2_BIT
, 
buffer
);

3395 return 
buffer
[0];

3396 
	}
}

3397 
bool
 
	$mpu6050GetDMPInt1Status
()

3399 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_INT_STATUS
, 
MPU6050_DMPINT_1_BIT
, 
buffer
);

3400 return 
buffer
[0];

3401 
	}
}

3402 
bool
 
	$mpu6050GetDMPInt0Status
()

3404 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_INT_STATUS
, 
MPU6050_DMPINT_0_BIT
, 
buffer
);

3405 return 
buffer
[0];

3406 
	}
}

3410 
bool
 
	$mpu6050GetIntPLLReadyStatus
()

3412 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_PLL_RDY_INT_BIT
, 
buffer
);

3413 return 
buffer
[0];

3414 
	}
}

3415 
bool
 
	$mpu6050GetIntDMPStatus
()

3417 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_INT_STATUS
, 
MPU6050_INTERRUPT_DMP_INT_BIT
, 
buffer
);

3418 return 
buffer
[0];

3419 
	}
}

3423 
bool
 
	$mpu6050GetDMPEnabled
()

3425 
	`i2cdevReadBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_DMP_EN_BIT
, 
buffer
);

3426 return 
buffer
[0];

3427 
	}
}

3428 void 
	$mpu6050SetDMPEnabled
(
bool
 
enabled
)

3430 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_DMP_EN_BIT
, 
enabled
);

3431 
	}
}

3432 void 
	$mpu6050ResetDMP
()

3434 
	`i2cdevWriteBit
(
I2Cx
, 
devAddr
, 
MPU6050_RA_USER_CTRL
, 
MPU6050_USERCTRL_DMP_RESET_BIT
, 1);

3435 
	}
}

3439 void 
	$mpu6050SetMemoryBank
(
uint8_t
 
bank
, 
bool
 
prefetchEnabled
, bool 
userBank
)

3441 
bank
 &= 0x1F;

3442 if (
userBank
)

3443 
bank
 |= 0x20;

3444 if (
prefetchEnabled
)

3445 
bank
 |= 0x40;

3446 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_BANK_SEL
, 
bank
);

3447 
	}
}

3451 void 
	$mpu6050SetMemoryStartAddress
(
uint8_t
 
address
)

3453 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MEM_START_ADDR
, 
address
);

3454 
	}
}

3458 
uint8_t
 
	$mpu6050ReadMemoryByte
()

3460 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MEM_R_W
, 
buffer
);

3461 return 
buffer
[0];

3462 
	}
}

3463 void 
	$mpu6050WriteMemoryByte
(
uint8_t
 
data
)

3465 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MEM_R_W
, 
data
);

3466 
	}
}

3467 void 
	$mpu6050ReadMemoryBlock
(
uint8_t
 *
data
, 
uint16_t
 
dataSize
, uint8_t 
bank
, uint8_t 
address
)

3469 
	`mpu6050SetMemoryBank
(
bank
, 
TRUE
, TRUE);

3470 
	`mpu6050SetMemoryStartAddress
(
address
);

3471 
uint8_t
 
chunkSize
;

3472 
uint16_t
 
i
;

3474 for (
i
 = 0; i < 
dataSize
;)

3477 
chunkSize
 = 
MPU6050_DMP_MEMORY_CHUNK_SIZE
;

3480 if (
i
 + 
chunkSize
 > 
dataSize
)

3481 
chunkSize
 = 
dataSize
 - 
i
;

3484 if (
chunkSize
 > 256 - 
address
)

3485 
chunkSize
 = 256 - 
address
;

3488 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MEM_R_W
, 
chunkSize
, 
data
 + 
i
);

3491 
i
 += 
chunkSize
;

3494 
address
 += 
chunkSize
;

3497 if (
i
 < 
dataSize
)

3499 if (
address
 == 0)

3500 
bank
++;

3501 
	`mpu6050SetMemoryBank
(
bank
, 
TRUE
, TRUE);

3502 
	`mpu6050SetMemoryStartAddress
(
address
);

3505 
	}
}

3506 
bool
 
	$mpu6050WriteMemoryBlock
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
, uint8_t 
bank
, uint8_t 
address
,

3507 
bool
 
verify
)

3509 static 
uint8_t
 
verifyBuffer
[
MPU6050_DMP_MEMORY_CHUNK_SIZE
];

3510 
uint8_t
 
chunkSize
;

3511 
uint8_t
 *
progBuffer
;

3512 
uint16_t
 
i
;

3514 
	`mpu6050SetMemoryBank
(
bank
, 
TRUE
, TRUE);

3515 
	`mpu6050SetMemoryStartAddress
(
address
);

3517 for (
i
 = 0; i < 
dataSize
;)

3520 
chunkSize
 = 
MPU6050_DMP_MEMORY_CHUNK_SIZE
;

3523 if (
i
 + 
chunkSize
 > 
dataSize
)

3524 
chunkSize
 = 
dataSize
 - 
i
;

3527 if (
chunkSize
 > 256 - 
address
)

3528 
chunkSize
 = 256 - 
address
;

3531 
progBuffer
 = (
uint8_t
 *) 
data
 + 
i
;

3533 
	`i2cdevWrite
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MEM_R_W
, 
chunkSize
, 
progBuffer
);

3536 if (
verify
)

3538 
uint32_t
 
j
;

3539 
	`mpu6050SetMemoryBank
(
bank
, 
TRUE
, TRUE);

3540 
	`mpu6050SetMemoryStartAddress
(
address
);

3541 
	`i2cdevRead
(
I2Cx
, 
devAddr
, 
MPU6050_RA_MEM_R_W
, 
chunkSize
, 
verifyBuffer
);

3543 for (
j
 = 0; j < 
chunkSize
; j++)

3545 if (
progBuffer
[
j
] != 
verifyBuffer
[j])

3564 return 
FALSE
;

3570 
i
 += 
chunkSize
;

3573 
address
 += 
chunkSize
;

3576 if (
i
 < 
dataSize
)

3578 if (
address
 == 0)

3579 
bank
++;

3580 
	`mpu6050SetMemoryBank
(
bank
, 
TRUE
, TRUE);

3581 
	`mpu6050SetMemoryStartAddress
(
address
);

3584 return 
TRUE
;

3585 
	}
}

3586 
bool
 
	$mpu6050WriteProgMemoryBlock
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
, uint8_t 
bank
,

3587 
uint8_t
 
address
, 
bool
 
verify
)

3589 return 
	`mpu6050WriteMemoryBlock
(
data
, 
dataSize
, 
bank
, 
address
, 
verify
);

3590 
	}
}

3591 #define 
	#MPU6050_DMP_CONFIG_BLOCK_SIZE
 6

	)

3592 
bool
 
	$mpu6050WriteDMPConfigurationSet
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
)

3594 
uint8_t
 *
progBuffer
, 
success
, 
special
;

3595 
uint16_t
 
i
;

3599 
uint8_t
 
bank
=0;

3600 
uint8_t
 
offset
=0;

3601 
uint8_t
 
length
=0;

3602 for (
i
 = 0; i < 
dataSize
;)

3604 
bank
 = 
data
[
i
++];

3605 
offset
 = 
data
[
i
++];

3606 
length
 = 
data
[
i
++];

3610 if (
length
 > 0)

3619 
progBuffer
 = (
uint8_t
 *) 
data
 + 
i
;

3620 
success
 = 
	`mpu6050WriteMemoryBlock
(
progBuffer
, 
length
, 
bank
, 
offset
, 
TRUE
);

3621 
i
 += 
length
;

3630 
special
 = 
data
[
i
++];

3634 if (
special
 == 0x01)

3637 
	`mpu6050SetIntZeroMotionEnabled
(
TRUE
);

3638 
	`mpu6050SetIntFIFOBufferOverflowEnabled
(
TRUE
);

3639 
	`mpu6050SetIntDMPEnabled
(
TRUE
);

3641 
success
 = 
TRUE
;

3646 
success
 = 
FALSE
;

3650 if (!
success
)

3652 return 
FALSE
;

3654 return 
TRUE
;

3655 
	}
}

3657 
bool
 
	$mpu6050WriteProgDMPConfigurationSet
(const 
uint8_t
 *
data
, 
uint16_t
 
dataSize
)

3659 return 
	`mpu6050WriteDMPConfigurationSet
(
data
, 
dataSize
);

3660 
	}
}

3664 
uint8_t
 
	$mpu6050GetDMPConfig1
()

3666 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_CFG_1
, 
buffer
);

3667 return 
buffer
[0];

3668 
	}
}

3669 void 
	$mpu6050SetDMPConfig1
(
uint8_t
 
config
)

3671 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_CFG_1
, 
config
);

3672 
	}
}

3676 
uint8_t
 
	$mpu6050GetDMPConfig2
()

3678 
	`i2cdevReadByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_CFG_2
, 
buffer
);

3679 return 
buffer
[0];

3680 
	}
}

3681 void 
	$mpu6050SetDMPConfig2
(
uint8_t
 
config
)

3683 
	`i2cdevWriteByte
(
I2Cx
, 
devAddr
, 
MPU6050_RA_DMP_CFG_2
, 
config
);

3684 
	}
}

	@drivers/src/nrf24l01.c

32 #include 
	~"nrf24l01.h
"

34 #include 
	~<stdbool.h
>

35 #include 
	~<string.h
>

37 #include 
	~"cfassert.h
"

39 #include 
	~"stm32f4xx_conf.h
"

40 #include 
	~"stm32f4xx_rcc.h
"

41 #include 
	~"stm32f4xx_spi.h
"

42 #include 
	~"stm32f4xx_exti.h
"

44 #include 
	~"exti.h
"

46 #include 
	~"nRF24L01reg.h
"

49 #define 
	#RADIO_GPIO_CS
 
GPIO_Pin_8


	)

50 #define 
	#RADIO_GPIO_CS_PORT
 
GPIOC


	)

51 #define 
	#RADIO_GPIO_CS_PERIF
 
RCC_AHB1Periph_GPIOC


	)

54 #define 
	#RADIO_GPIO_CE
 
GPIO_Pin_7


	)

55 #define 
	#RADIO_GPIO_CE_PORT
 
GPIOC


	)

56 #define 
	#RADIO_GPIO_CE_PERIF
 
RCC_AHB1Periph_GPIOC


	)

58 #define 
	#RADIO_GPIO_IRQ
 
GPIO_Pin_6


	)

59 #define 
	#RADIO_GPIO_IRQ_PORT
 
GPIOC


	)

60 #define 
	#RADIO_GPIO_IRQ_PERIF
 
RCC_AHB1Periph_GPIOC


	)

61 #define 
	#RADIO_GPIO_IRQ_SRC_PORT
 
EXTI_PortSourceGPIOC


	)

62 #define 
	#RADIO_GPIO_IRQ_SRC
 
EXTI_PinSource6


	)

63 #define 
	#RADIO_GPIO_IRQ_LINE
 
EXTI_Line6


	)

65 #define 
	#RADIO_SPI
 
SPI2


	)

66 #define 
	#RADIO_SPI_CLK
 
RCC_APB1Periph_SPI2


	)

67 #define 
	#RADIO_GPIO_SPI_PORT
 
GPIOB


	)

68 #define 
	#RADIO_GPIO_SPI_CLK
 
RCC_AHB1Periph_GPIOB


	)

69 #define 
	#RADIO_GPIO_SPI_SCK
 
GPIO_Pin_13


	)

70 #define 
	#RADIO_GPIO_SPI_MISO
 
GPIO_Pin_14


	)

71 #define 
	#RADIO_GPIO_SPI_MOSI
 
GPIO_Pin_15


	)

73 #define 
	#DUMMY_BYTE
 0xA5

	)

76 #define 
	#CMD_R_REG
 0x00

	)

77 #define 
	#CMD_W_REG
 0x20

	)

78 #define 
	#CMD_R_RX_PAYLOAD
 0x61

	)

79 #define 
	#CMD_W_TX_PAYLOAD
 0xA0

	)

80 #define 
	#CMD_FLUSH_TX
 0xE1

	)

81 #define 
	#CMD_FLUSH_RX
 0xE2

	)

82 #define 
	#CMD_REUSE_TX_PL
 0xE3

	)

83 #define 
	#CMD_ACTIVATE
 0x50

	)

84 #define 
	#CMD_RX_PL_WID
 0x60

	)

85 #define 
	#CMD_W_ACK_PAYLOAD
(
P
) (0xA8|(P&0x0F))

	)

86 #define 
	#CMD_W_PAYLOAD_NO_ACK
 0xD0

	)

87 #define 
	#CMD_NOP
 0xFF

	)

90 #define 
	#RADIO_EN_CS
() 
	`GPIO_ResetBits
(
RADIO_GPIO_CS_PORT
, 
RADIO_GPIO_CS
)

	)

91 #define 
	#RADIO_DIS_CS
() 
	`GPIO_SetBits
(
RADIO_GPIO_CS_PORT
, 
RADIO_GPIO_CS
)

	)

92 #define 
	#RADIO_DIS_CE
() 
	`GPIO_ResetBits
(
RADIO_GPIO_CE_PORT
, 
RADIO_GPIO_CE
)

	)

93 #define 
	#RADIO_EN_CE
() 
	`GPIO_SetBits
(
RADIO_GPIO_CE_PORT
, 
RADIO_GPIO_CE
)

	)

94 #define 
	#ACTIVATE_DATA
 0x73

	)

97 static 
bool
 
	gisInit
;

98 static void (*
interruptCb
)(void) = 
NULL
;

103 static char 
	$spiSendByte
(char 
byte
)

106 while (
	`SPI_I2S_GetFlagStatus
(
RADIO_SPI
, 
SPI_I2S_FLAG_TXE
) == 
RESET
);

109 
	`SPI_I2S_SendData
(
RADIO_SPI
, 
byte
);

112 while (
	`SPI_I2S_GetFlagStatus
(
RADIO_SPI
, 
SPI_I2S_FLAG_RXNE
) == 
RESET
);

115 return 
	`SPI_I2S_ReceiveData
(
RADIO_SPI
);

116 
	}
}

118 static char 
	$spiReceiveByte
()

120 return 
	`spiSendByte
(
DUMMY_BYTE
);

121 
	}
}

128 unsigned char 
	$nrfReadReg
(unsigned char 
address
, char *
buffer
, int 
len
)

130 unsigned char 
status
;

131 int 
i
;

133 
	`RADIO_EN_CS
();

136 
status
 = 
	`spiSendByte
( 
CMD_R_REG
 | (
address
&0x1F));

138 for(
i
=0; i<
len
; i++)

139 
buffer
[
i
]=
	`spiReceiveByte
();

141 
	`RADIO_DIS_CS
();

143 return 
status
;

144 
	}
}

147 unsigned char 
	$nrfWriteReg
(unsigned char 
address
, char *
buffer
, int 
len
)

149 unsigned char 
status
;

150 int 
i
;

152 
	`RADIO_EN_CS
();

155 
status
 = 
	`spiSendByte
( 
CMD_W_REG
 | (
address
&0x1F) );

157 for(
i
=0; i<
len
; i++)

158 
	`spiSendByte
(
buffer
[
i
]);

160 
	`RADIO_DIS_CS
();

162 return 
status
;

163 
	}
}

166 unsigned char 
	$nrfWrite1Reg
(unsigned char 
address
, char 
byte
)

168 return 
	`nrfWriteReg
(
address
, &
byte
, 1);

169 
	}
}

172 unsigned char 
	$nrfRead1Reg
(unsigned char 
address
) {

173 char 
byte
;

175 
	`nrfReadReg
(
address
, &
byte
, 1);

177 return 
byte
;

178 
	}
}

181 unsigned char 
	$nrfNop
()

183 unsigned char 
status
;

185 
	`RADIO_EN_CS
();

186 
status
 = 
	`spiSendByte
(
CMD_NOP
);

187 
	`RADIO_DIS_CS
();

189 return 
status
;

190 
	}
}

192 unsigned char 
	$nrfFlushRx
()

194 unsigned char 
status
;

196 
	`RADIO_EN_CS
();

197 
status
 = 
	`spiSendByte
(
CMD_FLUSH_RX
);

198 
	`RADIO_DIS_CS
();

200 return 
status
;

201 
	}
}

203 unsigned char 
	$nrfFlushTx
()

205 unsigned char 
status
;

207 
	`RADIO_EN_CS
();

208 
status
 = 
	`spiSendByte
(
CMD_FLUSH_TX
);

209 
	`RADIO_DIS_CS
();

211 return 
status
;

212 
	}
}

215 unsigned char 
	$nrfRxLength
(unsigned int 
pipe
)

217 unsigned char 
length
;

219 
	`RADIO_EN_CS
();

220 
	`spiSendByte
(
CMD_RX_PL_WID
);

221 
length
 = 
	`spiReceiveByte
();

222 
	`RADIO_DIS_CS
();

224 return 
length
;

225 
	}
}

227 unsigned char 
	$nrfActivate
()

229 unsigned char 
status
;

231 
	`RADIO_EN_CS
();

232 
status
 = 
	`spiSendByte
(
CMD_ACTIVATE
);

233 
	`spiSendByte
(
ACTIVATE_DATA
);

234 
	`RADIO_DIS_CS
();

236 return 
status
;

237 
	}
}

240 unsigned char 
	$nrfWriteAck
(unsigned int 
pipe
, char *
buffer
, int 
len
)

242 unsigned char 
status
;

243 int 
i
;

245 
	`ASSERT
(
pipe
<6);

247 
	`RADIO_EN_CS
();

250 
status
 = 
	`spiSendByte
(
	`CMD_W_ACK_PAYLOAD
(
pipe
));

252 for(
i
=0; i<
len
; i++)

253 
	`spiSendByte
(
buffer
[
i
]);

255 
	`RADIO_DIS_CS
();

257 return 
status
;

258 
	}
}

261 unsigned char 
	$nrfReadRX
(char *
buffer
, int 
len
)

263 unsigned char 
status
;

264 int 
i
;

266 
	`RADIO_EN_CS
();

269 
status
 = 
	`spiSendByte
(
CMD_R_RX_PAYLOAD
);

271 for(
i
=0; i<
len
; i++)

272 
buffer
[
i
]=
	`spiReceiveByte
();

274 
	`RADIO_DIS_CS
();

276 return 
status
;

277 
	}
}

281 void 
	$nrfIsr
()

283 if (
interruptCb
)

284 
	`interruptCb
();

287 
	}
}

289 void 
nrfSetInterruptCallback
(void (*
cb
)(void))

291 
interruptCb
 = 
cb
;

292 
	}
}

294 void 
	$nrfSetChannel
(unsigned int 
channel
)

296 if (
channel
<126)

297 
	`nrfWrite1Reg
(
REG_RF_CH
, 
channel
);

298 
	}
}

300 void 
	$nrfSetDatarate
(int 
datarate
)

302 switch(
datarate
)

304 case 
RADIO_RATE_250K
:

305 
	`nrfWrite1Reg
(
REG_RF_SETUP
, 
VAL_RF_SETUP_250K
);

307 case 
RADIO_RATE_1M
:

308 
	`nrfWrite1Reg
(
REG_RF_SETUP
, 
VAL_RF_SETUP_1M
);

310 case 
RADIO_RATE_2M
:

311 
	`nrfWrite1Reg
(
REG_RF_SETUP
, 
VAL_RF_SETUP_2M
);

314 
	}
}

316 void 
	$nrfSetAddress
(unsigned int 
pipe
, char* 
address
)

318 int 
len
 = 5;

320 
	`ASSERT
(
pipe
<6);

322 if (
pipe
 > 1)

323 
len
 = 1;

325 
	`nrfWriteReg
(
REG_RX_ADDR_P0
 + 
pipe
, 
address
, 
len
);

326 
	}
}

328 void 
	$nrfSetEnable
(
bool
 
enable
)

330 if (
enable
)

332 
	`RADIO_EN_CE
();

336 
	`RADIO_DIS_CE
();

338 
	}
}

340 unsigned char 
	$nrfGetStatus
()

342 return 
	`nrfNop
();

343 
	}
}

346 void 
	$nrfInit
(void)

348 
SPI_InitTypeDef
 
SPI_InitStructure
;

349 
EXTI_InitTypeDef
 
EXTI_InitStructure
;

350 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

352 if (
isInit
)

356 
	`extiInit
();

359 
	`RCC_AHB1PeriphClockCmd
(
RADIO_GPIO_SPI_CLK
 | 
RADIO_GPIO_CS_PERIF
 |

360 
RADIO_GPIO_CE_PERIF
 | 
RADIO_GPIO_IRQ_PERIF
, 
ENABLE
);

363 
	`RCC_APB1PeriphClockCmd
(
RADIO_SPI_CLK
, 
ENABLE
);

365 
	`RCC_APB2PeriphClockCmd
(
RCC_APB2Periph_SYSCFG
, 
ENABLE
);

370 
GPIO_InitStructure
.
GPIO_Pin
 = 
RADIO_GPIO_SPI_SCK
 | 
RADIO_GPIO_SPI_MOSI
 | 
RADIO_GPIO_SPI_MISO
;

371 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

372 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

373 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

374 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

375 
	`GPIO_Init
(
RADIO_GPIO_SPI_PORT
, &
GPIO_InitStructure
);

377 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource13
, 
GPIO_AF_SPI2
);

378 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource14
, 
GPIO_AF_SPI2
);

379 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource15
, 
GPIO_AF_SPI2
);

383 
GPIO_InitStructure
.
GPIO_Pin
 = 
RADIO_GPIO_CS
 ;

384 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_OUT
;

385 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

386 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

387 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

388 
	`GPIO_Init
(
RADIO_GPIO_CS_PORT
, &
GPIO_InitStructure
);

391 
GPIO_InitStructure
.
GPIO_Pin
 = 
RADIO_GPIO_IRQ
;

392 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_IN
;

393 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

394 
	`GPIO_Init
(
RADIO_GPIO_IRQ_PORT
, &
GPIO_InitStructure
);

396 
	`SYSCFG_EXTILineConfig
(
RADIO_GPIO_IRQ_SRC_PORT
, 
RADIO_GPIO_IRQ_SRC
);

397 
EXTI_InitStructure
.
EXTI_Line
 = 
RADIO_GPIO_IRQ_LINE
;

398 
EXTI_InitStructure
.
EXTI_Mode
 = 
EXTI_Mode_Interrupt
;

399 
EXTI_InitStructure
.
EXTI_Trigger
 = 
EXTI_Trigger_Falling
;

400 
EXTI_InitStructure
.
EXTI_LineCmd
 = 
ENABLE
;

401 
	`EXTI_Init
(&
EXTI_InitStructure
);

406 
	`RADIO_DIS_CS
();

409 
GPIO_InitStructure
.
GPIO_Pin
 = 
RADIO_GPIO_CE
;

410 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_OUT
;

411 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

412 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

413 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

414 
	`GPIO_Init
(
RADIO_GPIO_CE_PORT
, &
GPIO_InitStructure
);

417 
	`RADIO_DIS_CE
();

420 
SPI_InitStructure
.
SPI_Direction
 = 
SPI_Direction_2Lines_FullDuplex
;

421 
SPI_InitStructure
.
SPI_Mode
 = 
SPI_Mode_Master
;

422 
SPI_InitStructure
.
SPI_DataSize
 = 
SPI_DataSize_8b
;

423 
SPI_InitStructure
.
SPI_CPOL
 = 
SPI_CPOL_Low
;

424 
SPI_InitStructure
.
SPI_CPHA
 = 
SPI_CPHA_1Edge
;

425 
SPI_InitStructure
.
SPI_NSS
 = 
SPI_NSS_Soft
;

426 
SPI_InitStructure
.
SPI_BaudRatePrescaler
 = 
SPI_BaudRatePrescaler_8
;

427 
SPI_InitStructure
.
SPI_FirstBit
 = 
SPI_FirstBit_MSB
;

428 
SPI_InitStructure
.
SPI_CRCPolynomial
 = 7;

429 
	`SPI_Init
(
RADIO_SPI
, &
SPI_InitStructure
);

432 
	`SPI_Cmd
(
RADIO_SPI
, 
ENABLE
);

434 
isInit
 = 
true
;

435 
	}
}

437 
bool
 
	$nrfTest
(void)

440 return 
isInit
 & 
	`extiTest
();

441 
	}
}

	@drivers/src/nvic.c

26 #include 
	~"exti.h
"

27 #include 
	~"i2croutines.h
"

28 #include 
	~"i2cdev.h
"

29 #include 
	~"nvic.h
"

31 void 
	$nvicInit
(void)

33 
	`NVIC_PriorityGroupConfig
(
NVIC_PriorityGroup_4
);

34 
	}
}

36 #ifdef 
NVIC_NOT_USED_BY_FREERTOS


40 void 
	$SysTick_Handler
(void)

42 
	}
}

47 void 
	$SVC_Handler
(void)

49 
	}
}

54 void 
	$PendSV_Handler
(void)

56 
	}
}

126 void 
	$DMA1_Channel1_IRQHandler
(void)

129 
	}
}

131 void 
	$DMA1_Channel2_IRQHandler
(void)

133 #if 
	`defined
(
UART_OUTPUT_TRACE_DATA
) || defined(
ADC_OUTPUT_RAW_DATA
)

134 
	`uartDmaIsr
();

136 
	}
}

138 void 
	$DMA1_Channel4_IRQHandler
(void)

140 
	`i2cDmaInterruptHandlerI2c2
();

141 
	}
}

143 void 
	$DMA1_Channel5_IRQHandler
(void)

145 
	`i2cDmaInterruptHandlerI2c2
();

146 
	}
}

148 void 
	$DMA1_Channel6_IRQHandler
(void)

151 
	}
}

153 void 
	$DMA1_Channel7_IRQHandler
(void)

156 
	}
}

159 void 
	$EXTI9_5_IRQHandler
(void)

161 
	`extiInterruptHandler
();

162 
	}
}

171 void 
	$TIM1_UP_IRQHandler
(void)

177 
	}
}

179 void 
	$I2C1_EV_IRQHandler
(void)

181 
	`i2cInterruptHandlerI2c1
();

182 
	}
}

184 void 
	$I2C1_ER_IRQHandler
(void)

186 
	`i2cErrorInterruptHandlerI2c1
();

187 
	}
}

189 void 
	$I2C2_EV_IRQHandler
(void)

191 
	`i2cInterruptHandlerI2c2
();

192 
	}
}

194 void 
	$I2C2_ER_IRQHandler
(void)

197 
	`i2cErrorInterruptHandlerI2c2
();

198 
	}
}

	@drivers/src/px4flow.c

7 #include 
	~"px4flow.h
"

8 #include 
	~"i2croutines.h
"

9 #include 
	~"i2cdev.h
"

11 void 
	$init_I2C2
()

13 
GPIO_InitTypeDef
 
GPIO_InitStruct
;

14 
I2C_InitTypeDef
 
I2C_InitStruct
;

15 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOB
, 
ENABLE
);

16 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_I2C2
 , 
ENABLE
);

17 
RCC
->
APB1RSTR
 &= 0xFFBFFFFF;

18 
	`GPIO_StructInit
(&
GPIO_InitStruct
);

21 
GPIO_InitStruct
.
GPIO_Pin
 = 
GPIO_Pin_10
 | 
GPIO_Pin_11
;

22 
GPIO_InitStruct
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

23 
GPIO_InitStruct
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

24 
GPIO_InitStruct
.
GPIO_OType
 = 
GPIO_OType_OD
;

25 
GPIO_InitStruct
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

26 
	`GPIO_Init
(
GPIOB
, &
GPIO_InitStruct
);

29 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource10
, 
GPIO_AF_I2C2
);

30 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource11
, 
GPIO_AF_I2C2
);

33 
	`I2C_DeInit
(
I2C2
);

34 
I2C_InitStruct
.
I2C_ClockSpeed
 = 400000;

35 
I2C_InitStruct
.
I2C_Mode
 = 
I2C_Mode_I2C
;

36 
I2C_InitStruct
.
I2C_DutyCycle
 = 
I2C_DutyCycle_2
;

37 
I2C_InitStruct
.
I2C_OwnAddress1
 = 0x00;

38 
I2C_InitStruct
.
I2C_Ack
 = 
I2C_Ack_Enable
;

39 
I2C_InitStruct
.
I2C_AcknowledgedAddress
 = 
I2C_AcknowledgedAddress_7bit
;

40 
	`I2C_Init
(
I2C2
, &
I2C_InitStruct
);

43 
	`I2C_Cmd
(
I2C2
, 
ENABLE
);

44 
	}
}

47 
uint8_t
 
	$I2C_startslave1
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
address
){

48 
uint32_t
 
Timeout
 = 10000;

49 
uint8_t
 
status
=1;

50 
	`I2C_AcknowledgeConfig
(
I2Cx
, 
ENABLE
);

53 while(
	`I2C_GetFlagStatus
(
I2Cx
, 
I2C_FLAG_BUSY
)){

54 if(
Timeout
--==0){

55 
Timeout
 = 10000;

56 
status
 = 0;

57 return 
ERROR
;

61 
status
=1;

67 
	`I2C_GenerateSTART
(
I2Cx
, 
ENABLE
);

70 while(!
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_MODE_SELECT
)){

72 if(
Timeout
--==0){

73 
Timeout
 = 10000;

74 
status
 = 0;

75 return 
ERROR
;

79 
status
=1;

85 
	`I2C_Send7bitAddress
(
I2Cx
, 
address
, 
I2C_Direction_Transmitter
);

87 while(!
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED
)){

89 if(
Timeout
--==0){

90 
Timeout
 = 10000;

91 
status
 = 0;

92 return 
ERROR
;

97 
status
 = 1;

103 return 
status
;

105 
	}
}

107 void 
	$I2C_startslave
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
address
){

108 
	`I2C_AcknowledgeConfig
(
I2Cx
, 
ENABLE
);

111 while(
	`I2C_GetFlagStatus
(
I2Cx
, 
I2C_FLAG_BUSY
));

115 
	`I2C_GenerateSTART
(
I2Cx
, 
ENABLE
);

118 while(!
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_MODE_SELECT
));

121 
	`I2C_Send7bitAddress
(
I2Cx
, 
address
, 
I2C_Direction_Transmitter
);

123 while(!
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED
));

125 
	`I2C_Cmd
(
I2Cx
, 
ENABLE
);

127 
	}
}

129 void 
	$I2C_send
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
data
){

130 
	`I2C_SendData
(
I2Cx
, 
data
);

132 while(!
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_BYTE_TRANSMITTED
));

133 
	}
}

136 
uint8_t
 
	$I2C_read
(
I2C_TypeDef
* 
I2Cx
){

138 while( !
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_BYTE_RECEIVED
) );

140 
uint8_t
 
data
 = 
	`I2C_ReceiveData
(
I2Cx
);

141 return 
data
;

142 
	}
}

145 void 
	$I2C_startsign
(
I2C_TypeDef
* 
I2Cx
){

147 
	`I2C_GenerateSTART
(
I2Cx
, 
ENABLE
);

148 while(!
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_MODE_SELECT
));

149 
	}
}

151 void 
	$I2C_setreceiver
(
I2C_TypeDef
* 
I2Cx
, 
uint8_t
 
address
){

152 
	`I2C_Send7bitAddress
(
I2Cx
, 
address
, 
I2C_Direction_Receiver
);

154 while(!
	`I2C_CheckEvent
(
I2Cx
, 
I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED
));

156 
	}
}

158 void 
	$I2C_stop
(
I2C_TypeDef
* 
I2Cx
){

159 
	`I2C_AcknowledgeConfig
(
I2Cx
, 
DISABLE
);

160 
	`I2C_GenerateSTOP
(
I2Cx
, 
ENABLE
);

161 
	}
}

163 void 
	$readx1
(
I2C_TypeDef
* 
I2Cx
, 
i2c_frame
* 
px4data
, 
uint8_t
 
address
,uint8_t 
status
)

165 static 
uint8_t
 
id
[22];

186 
	`i2cdevRead
(
I2C2
, 
address
, 0x00, 22, 
id
);

187 
px4data
->
frame_count
 = (
id
[1]<<8)|id[0];

188 
px4data
->
pixel_flow_x_sum
 = (
id
[3]<<8)|id[2];

189 
px4data
->
pixel_flow_y_sum
 = (
id
[5]<<8)|id[4];

190 
px4data
->
flow_comp_m_x
 = (
id
[7]<<8)|id[6];

191 
px4data
->
flow_comp_m_y
 = (
id
[9]<<8)|id[8];

192 
px4data
->
qual
 = (
id
[11]<<8)|id[10];

193 
px4data
->
gyro_x_rate
 = (
id
[13]<<8)|id[12];

194 
px4data
->
gyro_y_rate
 = (
id
[15]<<8)|id[14];

195 
px4data
->
gyro_z_rate
 = (
id
[17]<<8)|id[16];

196 
px4data
->
gyro_range
 = (
id
[18]);

197 
px4data
->
sonar_timestamp
 = (
id
[19]);

198 
px4data
->
ground_distance
 = (
id
[21]<<8)|id[20];

200 
	}
}

202 void 
	$readx
(
I2C_TypeDef
* 
I2Cx
, 
i2c_frame
* 
px4data
, 
uint8_t
 
address
)

204 static 
uint8_t
 
id
[22];

205 
	`I2C_startslave
(
I2Cx
,
address
);

206 
	`I2C_send
(
I2Cx
, 0x00);

207 
	`I2C_startsign
(
I2Cx
);

208 
	`I2C_setreceiver
(
I2Cx
, 
address
);

209 
id
[0] = 
	`I2C_read
(
I2Cx
); id[1] = I2C_read(I2Cx);

210 
id
[2] = 
	`I2C_read
(
I2Cx
); id[3] = I2C_read(I2Cx);

211 
id
[4] = 
	`I2C_read
(
I2Cx
); id[5] = I2C_read(I2Cx);

212 
id
[6] = 
	`I2C_read
(
I2Cx
); id[7] = I2C_read(I2Cx);

213 
id
[8] = 
	`I2C_read
(
I2Cx
); id[9] = I2C_read(I2Cx);

214 
id
[10] = 
	`I2C_read
(
I2Cx
); id[11] = I2C_read(I2Cx);

215 
id
[12] = 
	`I2C_read
(
I2Cx
); id[13] = I2C_read(I2Cx);

216 
id
[14] = 
	`I2C_read
(
I2Cx
); id[15] = I2C_read(I2Cx);

217 
id
[16] = 
	`I2C_read
(
I2Cx
); id[17] = I2C_read(I2Cx);

218 
id
[18] = 
	`I2C_read
(
I2Cx
); id[19] = I2C_read(I2Cx);

219 
id
[20] = 
	`I2C_read
(
I2Cx
); id[21] = I2C_read(I2Cx);

222 
	`I2C_stop
(
I2Cx
);

223 
px4data
->
frame_count
 = (
id
[1]<<8)|id[0];

224 
px4data
->
pixel_flow_x_sum
 = (
id
[3]<<8)|id[2];

225 
px4data
->
pixel_flow_y_sum
 = (
id
[5]<<8)|id[4];

226 
px4data
->
flow_comp_m_x
 = (
id
[7]<<8)|id[6];

227 
px4data
->
flow_comp_m_y
 = (
id
[9]<<8)|id[8];

228 
px4data
->
qual
 = (
id
[11]<<8)|id[10];

229 
px4data
->
gyro_x_rate
 = (
id
[13]<<8)|id[12];

230 
px4data
->
gyro_y_rate
 = (
id
[15]<<8)|id[14];

231 
px4data
->
gyro_z_rate
 = (
id
[17]<<8)|id[16];

232 
px4data
->
gyro_range
 = (
id
[18]);

233 
px4data
->
sonar_timestamp
 = (
id
[19]);

234 
px4data
->
ground_distance
 = (
id
[21]<<8)|id[20];

236 
	}
}

238 void 
	$init_I2C1
(void){

240 
GPIO_InitTypeDef
 
GPIO_InitStruct
;

241 
I2C_InitTypeDef
 
I2C_InitStruct
;

242 
NVIC_InitTypeDef
 
NVIC_InitStructure
;

247 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOB
, 
ENABLE
);

255 
GPIO_InitStruct
.
GPIO_Pin
 = 
GPIO_Pin_6
 | 
GPIO_Pin_7
;

256 
GPIO_InitStruct
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

257 
GPIO_InitStruct
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

258 
GPIO_InitStruct
.
GPIO_OType
 = 
GPIO_OType_OD
;

259 
GPIO_InitStruct
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

260 
	`GPIO_Init
(
GPIOB
, &
GPIO_InitStruct
);

263 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource6
, 
GPIO_AF_I2C1
);

264 
	`GPIO_PinAFConfig
(
GPIOB
, 
GPIO_PinSource7
, 
GPIO_AF_I2C1
);

265 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_I2C1
, 
ENABLE
);

267 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
I2C1_EV_IRQn
;

268 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 
NVIC_I2C_PRI
;

269 
NVIC_InitStructure
.
NVIC_IRQChannelSubPriority
 = 0;

270 
NVIC_InitStructure
.
NVIC_IRQChannelCmd
 = 
ENABLE
;

271 
	`NVIC_Init
(&
NVIC_InitStructure
);

272 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
I2C1_ER_IRQn
;

273 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 
NVIC_I2C_PRI
 + 1;

274 
	`NVIC_Init
(&
NVIC_InitStructure
);

276 
	`I2C_DeInit
(
I2C1
);

277 
I2C_InitStruct
.
I2C_ClockSpeed
 = 100000;

278 
I2C_InitStruct
.
I2C_Mode
 = 
I2C_Mode_I2C
;

279 
I2C_InitStruct
.
I2C_DutyCycle
 = 
I2C_DutyCycle_2
;

280 
I2C_InitStruct
.
I2C_OwnAddress1
 = 0x00;

281 
I2C_InitStruct
.
I2C_Ack
 = 
I2C_Ack_Enable
;

282 
I2C_InitStruct
.
I2C_AcknowledgedAddress
 = 
I2C_AcknowledgedAddress_7bit
;

283 
	`I2C_Init
(
I2C1
, &
I2C_InitStruct
);

287 #define 
	#I2C_BUSY
 0x20

	)

288 if (
I2C1
->
SR2
 & 
I2C_BUSY
)

291 
	`I2C_SoftwareResetCmd
(
I2C1
, 
ENABLE
);

292 
	`I2C_SoftwareResetCmd
(
I2C1
, 
DISABLE
);

294 
	}
}

296 void 
	$init_I2C1_new
()

298 
	`i2cdevInit
(
I2C1
);

299 
	}
}

301 void 
	$init_I2C2_new
()

303 
	`i2cdevInit
(
I2C2
);

304 
	}
}

	@hal/interface/imu.h

27 #ifndef 
IMU_H_


28 #define 
	#IMU_H_


	)

29 #include 
	~<stdbool.h
>

30 #include 
	~"filter.h
"

34 
int16_t
 
	mx
;

35 
int16_t
 
	my
;

36 
int16_t
 
	mz
;

37 } 
	tAxis3i16
;

41 
int32_t
 
	mx
;

42 
int32_t
 
	my
;

43 
int32_t
 
	mz
;

44 } 
	tAxis3i32
;

48 float 
	mx
;

49 float 
	my
;

50 float 
	mz
;

51 } 
	tAxis3f
;

56 #define 
	#IMU_UPDATE_FREQ
 1000

	)

57 #define 
	#IMU_UPDATE_DT
 (float)(1.0/
IMU_UPDATE_FREQ
)

	)

64 #define 
	#IMU_ACC_WANTED_LPF_CUTOFF_HZ
 10

	)

71 #define 
	#IMU_ACC_IIR_LPF_ATTENUATION
 (
IMU_UPDATE_FREQ
 / (2 * 3.1415 * 
IMU_ACC_WANTED_LPF_CUTOFF_HZ
))

	)

72 #define 
	#IMU_ACC_IIR_LPF_ATT_FACTOR
 (int)(((1<<
IIR_SHIFT
) / 
IMU_ACC_IIR_LPF_ATTENUATION
) + 0.5)

	)

74 void 
imu6Init
(void);

75 
bool
 
imu6Test
(void);

76 void 
imu6Read
(
Axis3f
* 
gyro
, Axis3f* 
acc
);

77 
bool
 
imu6IsCalibrated
(void);

	@hal/src/imu.c

28 #include 
	~<math.h
>

30 #include 
	~"stm32f4xx_conf.h
"

31 #include 
	~"FreeRTOS.h
"

32 #include 
	~"task.h
"

36 #include 
	~"imu.h
"

37 #include 
	~"i2cdev.h
"

38 #include 
	~"mpu6050.h
"

40 #define 
	#TRUE
 1

	)

41 #define 
	#FALSE
 0

	)

46 #define 
	#IMU_GYRO_FS_CFG
 0x03

47 #define 
	#IMU_DEG_PER_LSB_CFG
 (float)((2 * 2000.0) / 65536.0)

	)

48 #define 
	#IMU_ACCEL_FS_CFG
 0x02

	)

49 #define 
	#IMU_G_PER_LSB_CFG
 (float)((2 * 8) / 65536.0)

	)

50 #define 
	#IMU_1G_RAW
 (
int16_t
)(1.0 / (float)((2 * 8) / 65536.0))

	)

52 #define 
	#IMU_STARTUP_TIME_MS
 1000

	)

54 #define 
	#GYRO_NBR_OF_AXES
 3

	)

55 #define 
	#GYRO_X_SIGN
 (-1)

	)

56 #define 
	#GYRO_Y_SIGN
 (-1)

	)

57 #define 
	#GYRO_Z_SIGN
 (-1)

	)

58 #define 
	#GYRO_NBR_OF_AXES
 3

	)

59 #define 
	#GYRO_MIN_BIAS_TIMEOUT_MS
 1*1000

	)

61 #define 
	#IMU_NBR_OF_BIAS_SAMPLES
 128

	)

63 #define 
	#GYRO_VARIANCE_BASE
 4000

	)

64 #define 
	#GYRO_VARIANCE_THRESHOLD_X
 (
GYRO_VARIANCE_BASE
)

	)

65 #define 
	#GYRO_VARIANCE_THRESHOLD_Y
 (
GYRO_VARIANCE_BASE
)

	)

66 #define 
	#GYRO_VARIANCE_THRESHOLD_Z
 (
GYRO_VARIANCE_BASE
)

	)

70 
Axis3i16
 
	mbias
;

71 
bool
 
	misBiasValueFound
;

72 
bool
 
	misBufferFilled
;

73 
Axis3i16
* 
	mbufHead
;

74 
Axis3i16
 
	mbuffer
[
IMU_NBR_OF_BIAS_SAMPLES
];

75 } 
	tBiasObj
;

77 
BiasObj
 
	ggyroBias
;

78 
BiasObj
 
	gaccelBias
;

79 
int32_t
 
	gvarianceSampleTime
;

80 
Axis3i16
 
	ggyroMpu
;

81 
Axis3i16
 
	gaccelMpu
;

82 
Axis3i16
 
	gaccelLPF
;

83 
Axis3i16
 
	gaccelLPFAligned
;

84 
Axis3i16
 
	gmag
;

85 
Axis3i32
 
	gaccelStoredFilterValues
;

86 
uint8_t
 
	gimuAccLpfAttFactor
;

87 static 
bool
 
	gisHmc5883lPresent
;

88 static 
bool
 
	gisMs5611Present
;

96 static void 
imuBiasInit
(
BiasObj
* 
bias
);

97 static void 
imuCalculateBiasMean
(
BiasObj
* 
bias
, 
Axis3i32
* 
meanOut
);

98 static void 
imuCalculateVarianceAndMean
(
BiasObj
* 
bias
, 
Axis3i32
* 
varOut
, Axis3i32* 
meanOut
);

99 static 
bool
 
imuFindBiasValue
(
BiasObj
* 
bias
);

100 static void 
imuAddBiasValue
(
BiasObj
* 
bias
, 
Axis3i16
* 
dVal
);

101 static void 
imuAccIIRLPFilter
(
Axis3i16
* 
in
, Axis3i16* 
out
,

102 
Axis3i32
* 
storedValues
, 
int32_t
 
attenuation
);

105 int 
	g__errno
;

107 static 
bool
 
	gisInit
;

109 void 
	$imu6Init
(void)

117 int 
i
;

118 for (
i
=0; i<10000; i++);

120 
	`i2cdevInit
(
I2C1
);

121 
	`mpu6050Init
(
I2C1
);

123 if (
	`mpu6050TestConnection
() == 
TRUE
)

136 
	`mpu6050SetSleepEnabled
(
FALSE
);

138 
	`mpu6050SetTempSensorEnabled
(
TRUE
);

140 
	`mpu6050SetIntEnabled
(
FALSE
);

142 
	`mpu6050SetI2CBypassEnabled
(
TRUE
);

144 
	`mpu6050SetClockSource
(
MPU6050_CLOCK_PLL_XGYRO
);

146 
	`mpu6050SetFullScaleGyroRange
(
IMU_GYRO_FS_CFG
);

148 
	`mpu6050SetFullScaleAccelRange
(
IMU_ACCEL_FS_CFG
);

152 
	`mpu6050SetRate
(0);

154 
	`mpu6050SetDLPFMode
(
MPU6050_DLPF_BW_98
);

156 
	`imuBiasInit
(&
gyroBias
);

157 
	`imuBiasInit
(&
accelBias
);

158 
varianceSampleTime
 = -
GYRO_MIN_BIAS_TIMEOUT_MS
 + 1;

159 
imuAccLpfAttFactor
 = 
IMU_ACC_IIR_LPF_ATT_FACTOR
;

161 
isInit
 = 
TRUE
;

163 
	}
}

166 void 
	$imu6Read
(
Axis3f
* 
gyroOut
, Axis3f* 
accOut
)

168 
	`mpu6050GetMotion6
(&
accelMpu
.
x
, &accelMpu.
y
, &accelMpu.
z
, &
gyroMpu
.x, &gyroMpu.y, &gyroMpu.z);

170 
	`imuAddBiasValue
(&
gyroBias
, &
gyroMpu
);

172 if (!
accelBias
.
isBiasValueFound
)

174 
	`imuAddBiasValue
(&
accelBias
, &
accelMpu
);

177 if (!
gyroBias
.
isBiasValueFound
)

179 
	`imuFindBiasValue
(&
gyroBias
);

186 
	`imuAccIIRLPFilter
(&
accelMpu
, &
accelLPF
, &
accelStoredFilterValues
,

187 (
int32_t
)
imuAccLpfAttFactor
);

194 
gyroOut
->
x
 = (
gyroMpu
.x - 
gyroBias
.
bias
.x) * 
IMU_DEG_PER_LSB_CFG
;

195 
gyroOut
->
y
 = (
gyroMpu
.y - 
gyroBias
.
bias
.y) * 
IMU_DEG_PER_LSB_CFG
;

196 
gyroOut
->
z
 = (
gyroMpu
.z - 
gyroBias
.
bias
.z) * 
IMU_DEG_PER_LSB_CFG
;

197 
accOut
->
x
 = (
accelLPF
.x - 
accelBias
.
bias
.x) * 
IMU_G_PER_LSB_CFG
;

198 
accOut
->
y
 = (
accelLPF
.y - 
accelBias
.
bias
.y) * 
IMU_G_PER_LSB_CFG
;

199 
accOut
->
z
 = (
accelLPF
.z - 
accelBias
.
bias
.z) * 
IMU_G_PER_LSB_CFG
;

201 
	}
}

203 
bool
 
	$imu6IsCalibrated
(void)

205 
bool
 
status
;

207 
status
 = 
gyroBias
.
isBiasValueFound
;

209 return 
status
;

210 
	}
}

212 static void 
	$imuBiasInit
(
BiasObj
* 
bias
)

214 
bias
->
isBufferFilled
 = 
FALSE
;

215 
bias
->
bufHead
 = bias->
buffer
;

216 
	}
}

221 static void 
	$imuCalculateVarianceAndMean
(
BiasObj
* 
bias
, 
Axis3i32
* 
varOut
, Axis3i32* 
meanOut
)

223 
uint32_t
 
i
;

224 
int32_t
 
sum
[
GYRO_NBR_OF_AXES
] = {0};

225 
int64_t
 
sumSq
[
GYRO_NBR_OF_AXES
] = {0};

227 for (
i
 = 0; i < 
IMU_NBR_OF_BIAS_SAMPLES
; i++)

229 
sum
[0] += 
bias
->
buffer
[
i
].
x
;

230 
sum
[1] += 
bias
->
buffer
[
i
].
y
;

231 
sum
[2] += 
bias
->
buffer
[
i
].
z
;

232 
sumSq
[0] += 
bias
->
buffer
[
i
].
x
 * bias->buffer[i].x;

233 
sumSq
[1] += 
bias
->
buffer
[
i
].
y
 * bias->buffer[i].y;

234 
sumSq
[2] += 
bias
->
buffer
[
i
].
z
 * bias->buffer[i].z;

237 
varOut
->
x
 = (
sumSq
[0] - ((
int64_t
)
sum
[0] * sum[0]) / 
IMU_NBR_OF_BIAS_SAMPLES
);

238 
varOut
->
y
 = (
sumSq
[1] - ((
int64_t
)
sum
[1] * sum[1]) / 
IMU_NBR_OF_BIAS_SAMPLES
);

239 
varOut
->
z
 = (
sumSq
[2] - ((
int64_t
)
sum
[2] * sum[2]) / 
IMU_NBR_OF_BIAS_SAMPLES
);

241 
meanOut
->
x
 = 
sum
[0] / 
IMU_NBR_OF_BIAS_SAMPLES
;

242 
meanOut
->
y
 = 
sum
[1] / 
IMU_NBR_OF_BIAS_SAMPLES
;

243 
meanOut
->
z
 = 
sum
[2] / 
IMU_NBR_OF_BIAS_SAMPLES
;

245 
isInit
 = 
TRUE
;

246 
	}
}

251 static void 
__attribute__
((
used
)) 
	$imuCalculateBiasMean
(
BiasObj
* 
bias
, 
Axis3i32
* 
meanOut
)

253 
uint32_t
 
i
;

254 
int32_t
 
sum
[
GYRO_NBR_OF_AXES
] = {0};

256 for (
i
 = 0; i < 
IMU_NBR_OF_BIAS_SAMPLES
; i++)

258 
sum
[0] += 
bias
->
buffer
[
i
].
x
;

259 
sum
[1] += 
bias
->
buffer
[
i
].
y
;

260 
sum
[2] += 
bias
->
buffer
[
i
].
z
;

263 
meanOut
->
x
 = 
sum
[0] / 
IMU_NBR_OF_BIAS_SAMPLES
;

264 
meanOut
->
y
 = 
sum
[1] / 
IMU_NBR_OF_BIAS_SAMPLES
;

265 
meanOut
->
z
 = 
sum
[2] / 
IMU_NBR_OF_BIAS_SAMPLES
;

267 
	}
}

273 static void 
	$imuAddBiasValue
(
BiasObj
* 
bias
, 
Axis3i16
* 
dVal
)

275 
bias
->
bufHead
->
x
 = 
dVal
->x;

276 
bias
->
bufHead
->
y
 = 
dVal
->y;

277 
bias
->
bufHead
->
z
 = 
dVal
->z;

278 
bias
->
bufHead
++;

280 if (
bias
->
bufHead
 >= &bias->
buffer
[
IMU_NBR_OF_BIAS_SAMPLES
])

282 
bias
->
bufHead
 = bias->
buffer
;

283 
bias
->
isBufferFilled
 = 
TRUE
;

285 
	}
}

292 static 
bool
 
	$imuFindBiasValue
(
BiasObj
* 
bias
)

294 
bool
 
foundBias
 = 
FALSE
;

296 if (
bias
->
isBufferFilled
)

298 
Axis3i32
 
variance
;

299 
Axis3i32
 
mean
;

301 
	`imuCalculateVarianceAndMean
(
bias
, &
variance
, &
mean
);

304 if (
variance
.
x
 < 
GYRO_VARIANCE_THRESHOLD_X
 &&

305 
variance
.
y
 < 
GYRO_VARIANCE_THRESHOLD_Y
 &&

306 
variance
.
z
 < 
GYRO_VARIANCE_THRESHOLD_Z
 &&

307 (
varianceSampleTime
 + 
GYRO_MIN_BIAS_TIMEOUT_MS
 < 
	`xTaskGetTickCount
()))

309 
varianceSampleTime
 = 
	`xTaskGetTickCount
();

310 
bias
->bias.
x
 = 
mean
.x;

311 
bias
->bias.
y
 = 
mean
.y;

312 
bias
->bias.
z
 = 
mean
.z;

313 
foundBias
 = 
TRUE
;

314 
bias
->
isBiasValueFound
 = 
TRUE
;

318 return 
foundBias
;

319 
	}
}

321 static void 
	$imuAccIIRLPFilter
(
Axis3i16
* 
in
, Axis3i16* 
out
, 
Axis3i32
* 
storedValues
, 
int32_t
 
attenuation
)

323 
out
->
x
 = 
	`iirLPFilterSingle
(
in
->x, 
attenuation
, &
storedValues
->x);

324 
out
->
y
 = 
	`iirLPFilterSingle
(
in
->y, 
attenuation
, &
storedValues
->y);

325 
out
->
z
 = 
	`iirLPFilterSingle
(
in
->z, 
attenuation
, &
storedValues
->z);

326 
	}
}

	@modules/interface/sensfusion6.h

26 #ifndef 
SENSORFUSION6_H_


27 #define 
	#SENSORFUSION6_H_


	)

28 #include 
	~<stdbool.h
>

30 void 
sensfusion6Init
(void);

31 
bool
 
sensfusion6Test
(void);

33 void 
sensfusion6UpdateQ
(float 
gx
, float 
gy
, float 
gz
, float 
ax
, float 
ay
, float 
az
, float 
dt
);

34 void 
sensfusion6GetEulerRPY
(float* 
roll
, float* 
pitch
, float* 
yaw
);

37 void 
altitude_propogate
(float 
az
, float 
dt
, float 
sacc
);

38 void 
sonar_kf_correction
(float* 
alt_z
, float* 
vel_z
, float 
s_sonar
, float 
sonar_raw
);

39 void 
mult_mat
(float 
a
[][2],float 
b
[][2],float 
mult
[][2],float 
r1
,float 
c1
,float 
r2
,float 
c2
);

40 void 
add_mat
(float 
a
[][2],float 
b
[][2],float 
mult
[][2],float 
row
,float 
col
);

	@modules/interface/stabilizer.h

26 #ifndef 
STABALIZER_H_


27 #define 
	#STABALIZER_H_


	)

29 #include 
	~<stdbool.h
>

31 #include 
	~"px4flow.h
"

33 void 
stabilizerInit
(void);

35 
bool
 
stabilizerTest
(void);

38 float 
	mk
[6];

39 } 
	tgains_s
;

43 
uint8_t
 
	mdata
[24];

44 } 
	trxpacket
;

48 
int16_t
 
	mdata
[15];

49 } 
	teulerstruct
;

51 
uint16_t
 
	gspektrumchannel
[7];

52 
i2c_frame
 
	gpx4_test
;

53 
int16_t
 
	gsnapCh
[4];

55 
eulerstruct
 
	geuler
;

57 #define 
	#ATTITUDE_UPDATE_RATE_DIVIDER
 1

	)

58 #define 
	#FUSION_UPDATE_DT
 (float)(1.0 / (
IMU_UPDATE_FREQ
 / 
ATTITUDE_UPDATE_RATE_DIVIDER
))

59 #define 
	#PID_GAINS
 1

	)

60 #define 
	#SENSITIVITY
 2

	)

61 #define 
	#TRIM
 3

	)

62 #define 
	#SNAPDRAGON
 4

	)

	@modules/src/sensfusion6.c

26 #include 
	~"stm32f4xx_conf.h
"

27 #include 
	~<math.h
>

29 #include 
	~"sensfusion6.h
"

30 #include 
	~"imu.h
"

31 #include 
	~<stdbool.h
>

35 #ifdef 
MADWICK_QUATERNION_IMU


36 #define 
	#BETA_DEF
 0.01f

37 #else // MAHONY_QUATERNION_IMU

	)

38 #define 
	#TWO_KP_DEF
 (2.0f * 0.4f)

39 #define 
	#TWO_KI_DEF
 (2.0f * 0.001f)

41 

	)

42 #ifdef 
MADWICK_QUATERNION_IMU


43 float 
	gbeta
 = 
BETA_DEF
;

45 float 
	gtwoKp
 = 
TWO_KP_DEF
;

46 float 
	gtwoKi
 = 
TWO_KI_DEF
;

47 float 
	gintegralFBx
 = 0.0f;

48 float 
	gintegralFBy
 = 0.0f;

49 float 
	gintegralFBz
 = 0.0f;

52 float 
	gq0
 = 1.0f;

53 float 
	gq1
 = 0.0f;

54 float 
	gq2
 = 0.0f;

55 float 
	gq3
 = 0.0f;

57 static 
bool
 
	gisInit
;

59 static float 
invSqrt
(float 
x
);

62 float 
	gfilt_z
 = 0;

63 float 
	gfilt_w
 = 0;

64 float 
	gP
[2][2];

65 float 
	gk11
 = 0.0;

66 float 
	gk21
 = 0.0;

70 void 
	$sensfusion6Init
()

72 if(
isInit
)

75 
isInit
 = 
TRUE
;

76 
	}
}

78 
bool
 
	$sensfusion6Test
(void)

80 return 
isInit
;

81 
	}
}

84 #ifdef 
MADWICK_QUATERNION_IMU


91 void 
	$sensfusion6UpdateQ
(float 
gx
, float 
gy
, float 
gz
, float 
ax
, float 
ay
, float 
az
, float 
dt
)

93 float 
recipNorm
;

94 float 
s0
, 
s1
, 
s2
, 
s3
;

95 float 
qDot1
, 
qDot2
, 
qDot3
, 
qDot4
;

96 float 
_2q0
, 
_2q1
, 
_2q2
, 
_2q3
, 
_4q0
, 
_4q1
, 
_4q2
 ,
_8q1
, 
_8q2
, 
q0q0
, 
q1q1
, 
q2q2
, 
q3q3
;

99 
qDot1
 = 0.5f * (-
q1
 * 
gx
 - 
q2
 * 
gy
 - 
q3
 * 
gz
);

100 
qDot2
 = 0.5f * (
q0
 * 
gx
 + 
q2
 * 
gz
 - 
q3
 * 
gy
);

101 
qDot3
 = 0.5f * (
q0
 * 
gy
 - 
q1
 * 
gz
 + 
q3
 * 
gx
);

102 
qDot4
 = 0.5f * (
q0
 * 
gz
 + 
q1
 * 
gy
 - 
q2
 * 
gx
);

105 if(!((
ax
 == 0.0f) && (
ay
 == 0.0f) && (
az
 == 0.0f)))

108 
recipNorm
 = 
	`invSqrt
(
ax
 * ax + 
ay
 * ay + 
az
 * az);

109 
ax
 *= 
recipNorm
;

110 
ay
 *= 
recipNorm
;

111 
az
 *= 
recipNorm
;

114 
_2q0
 = 2.0f * 
q0
;

115 
_2q1
 = 2.0f * 
q1
;

116 
_2q2
 = 2.0f * 
q2
;

117 
_2q3
 = 2.0f * 
q3
;

118 
_4q0
 = 4.0f * 
q0
;

119 
_4q1
 = 4.0f * 
q1
;

120 
_4q2
 = 4.0f * 
q2
;

121 
_8q1
 = 8.0f * 
q1
;

122 
_8q2
 = 8.0f * 
q2
;

123 
q0q0
 = 
q0
 * q0;

124 
q1q1
 = 
q1
 * q1;

125 
q2q2
 = 
q2
 * q2;

126 
q3q3
 = 
q3
 * q3;

129 
s0
 = 
_4q0
 * 
q2q2
 + 
_2q2
 * 
ax
 + _4q0 * 
q1q1
 - 
_2q1
 * 
ay
;

130 
s1
 = 
_4q1
 * 
q3q3
 - 
_2q3
 * 
ax
 + 4.0f * 
q0q0
 * 
q1
 - 
_2q0
 * 
ay
 - _4q1 + 
_8q1
 * 
q1q1
 + _8q1 * 
q2q2
 + _4q1 * 
az
;

131 
s2
 = 4.0f * 
q0q0
 * 
q2
 + 
_2q0
 * 
ax
 + 
_4q2
 * 
q3q3
 - 
_2q3
 * 
ay
 - _4q2 + 
_8q2
 * 
q1q1
 + _8q2 * 
q2q2
 + _4q2 * 
az
;

132 
s3
 = 4.0f * 
q1q1
 * 
q3
 - 
_2q1
 * 
ax
 + 4.0f * 
q2q2
 * q3 - 
_2q2
 * 
ay
;

133 
recipNorm
 = 
	`invSqrt
(
s0
 * s0 + 
s1
 * s1 + 
s2
 * s2 + 
s3
 * s3);

134 
s0
 *= 
recipNorm
;

135 
s1
 *= 
recipNorm
;

136 
s2
 *= 
recipNorm
;

137 
s3
 *= 
recipNorm
;

140 
qDot1
 -= 
beta
 * 
s0
;

141 
qDot2
 -= 
beta
 * 
s1
;

142 
qDot3
 -= 
beta
 * 
s2
;

143 
qDot4
 -= 
beta
 * 
s3
;

147 
q0
 += 
qDot1
 * 
dt
;

148 
q1
 += 
qDot2
 * 
dt
;

149 
q2
 += 
qDot3
 * 
dt
;

150 
q3
 += 
qDot4
 * 
dt
;

153 
recipNorm
 = 
	`invSqrt
(
q0
*q0 + 
q1
*q1 + 
q2
*q2 + 
q3
*q3);

154 
q0
 *= 
recipNorm
;

155 
q1
 *= 
recipNorm
;

156 
q2
 *= 
recipNorm
;

157 
q3
 *= 
recipNorm
;

158 
	}
}

166 void 
	$sensfusion6UpdateQ
(float 
gx
, float 
gy
, float 
gz
, float 
ax
, float 
ay
, float 
az
, float 
dt
)

168 float 
recipNorm
;

169 float 
halfvx
, 
halfvy
, 
halfvz
;

170 float 
halfex
, 
halfey
, 
halfez
;

171 float 
qa
, 
qb
, 
qc
;

173 
gx
 = gx * 
M_PI
 / 180;

174 
gy
 = gy * 
M_PI
 / 180;

175 
gz
 = gz * 
M_PI
 / 180;

178 if(!((
ax
 == 0.0f) && (
ay
 == 0.0f) && (
az
 == 0.0f)))

181 
recipNorm
 = 
	`invSqrt
(
ax
 * ax + 
ay
 * ay + 
az
 * az);

182 
ax
 *= 
recipNorm
;

183 
ay
 *= 
recipNorm
;

184 
az
 *= 
recipNorm
;

187 
halfvx
 = 
q1
 * 
q3
 - 
q0
 * 
q2
;

188 
halfvy
 = 
q0
 * 
q1
 + 
q2
 * 
q3
;

189 
halfvz
 = 
q0
 * q0 - 0.5f + 
q3
 * q3;

192 
halfex
 = (
ay
 * 
halfvz
 - 
az
 * 
halfvy
);

193 
halfey
 = (
az
 * 
halfvx
 - 
ax
 * 
halfvz
);

194 
halfez
 = (
ax
 * 
halfvy
 - 
ay
 * 
halfvx
);

197 if(
twoKi
 > 0.0f)

199 
integralFBx
 += 
twoKi
 * 
halfex
 * 
dt
;

200 
integralFBy
 += 
twoKi
 * 
halfey
 * 
dt
;

201 
integralFBz
 += 
twoKi
 * 
halfez
 * 
dt
;

202 
gx
 += 
integralFBx
;

203 
gy
 += 
integralFBy
;

204 
gz
 += 
integralFBz
;

208 
integralFBx
 = 0.0f;

209 
integralFBy
 = 0.0f;

210 
integralFBz
 = 0.0f;

214 
gx
 += 
twoKp
 * 
halfex
;

215 
gy
 += 
twoKp
 * 
halfey
;

216 
gz
 += 
twoKp
 * 
halfez
;

220 
gx
 *= (0.5f * 
dt
);

221 
gy
 *= (0.5f * 
dt
);

222 
gz
 *= (0.5f * 
dt
);

223 
qa
 = 
q0
;

224 
qb
 = 
q1
;

225 
qc
 = 
q2
;

226 
q0
 += (-
qb
 * 
gx
 - 
qc
 * 
gy
 - 
q3
 * 
gz
);

227 
q1
 += (
qa
 * 
gx
 + 
qc
 * 
gz
 - 
q3
 * 
gy
);

228 
q2
 += (
qa
 * 
gy
 - 
qb
 * 
gz
 + 
q3
 * 
gx
);

229 
q3
 += (
qa
 * 
gz
 + 
qb
 * 
gy
 - 
qc
 * 
gx
);

232 
recipNorm
 = 
	`invSqrt
(
q0
 * q0 + 
q1
 * q1 + 
q2
 * q2 + 
q3
 * q3);

233 
q0
 *= 
recipNorm
;

234 
q1
 *= 
recipNorm
;

235 
q2
 *= 
recipNorm
;

236 
q3
 *= 
recipNorm
;

237 
	}
}

240 void 
	$sensfusion6GetEulerRPY
(float* 
roll
, float* 
pitch
, float* 
yaw
)

242 float 
gx
, 
gy
, 
gz
;

244 
gx
 = 2 * (
q1
*
q3
 - 
q0
*
q2
);

245 
gy
 = 2 * (
q0
*
q1
 + 
q2
*
q3
);

246 
gz
 = 
q0
*q0 - 
q1
*q1 - 
q2
*q2 + 
q3
*q3;

248 *
yaw
 = 
	`atan2
(2*
q1
*
q2
 - 2*
q0
*
q3
, 2*q0*q0 + 2*q1*q1 - 1) * 180 / 
M_PI
;

249 *
pitch
 = 
	`atan
(
gx
 / 
	`sqrt
(
gy
*gy + 
gz
*gz)) * 180 / 
M_PI
;

250 *
roll
 = 
	`atan
(
gy
 / 
	`sqrt
(
gx
*gx + 
gz
*gz)) * 180 / 
M_PI
;

254 
	}
}

259 float 
	$invSqrt
(float 
x
)

261 float 
halfx
 = 0.5f * 
x
;

262 float 
y
 = 
x
;

263 long 
i
 = *(long*)&
y
;

264 
i
 = 0x5f3759df - (i>>1);

265 
y
 = *(float*)&
i
;

266 
y
 = y * (1.5f - (
halfx
 * y * y));

267 return 
y
;

268 
	}
}

272 void 
	$altitude_propogate
(float 
az
, float 
dt
, float 
sacc
)

274 float 
a11
 = 1.0;

275 float 
a12
 = 
dt
;

276 float 
a21
 = 0.0;

277 float 
a22
 = 1.0;

278 float 
b11
 = 
dt
*dt*0.5;

279 float 
b21
 = 
dt
;

280 float 
A
[2][2] = {{
a11
,
a12
},{
a21
,
a22
}};

281 float 
A_T
[2][2]={{
a11
,
a21
},{
a12
,
a22
}};

282 float 
acc_z
 = (1-
az
)*9.8;

283 float 
AP
[2][2];

284 float 
APA
[2][2];

285 float 
S_2
 = 
	`pow
(
sacc
,2);

286 float 
Q11
 = 
S_2
*
	`pow
(
dt
,4)*0.25;

287 float 
Q12
 = 
S_2
*
	`pow
(
dt
,3)*0.5;

288 float 
Q21
 = 
Q12
;

289 float 
Q22
 = 
S_2
*
dt
;

290 float 
Q
[2][2] = {{
Q11
, 
Q12
},{
Q21
, 
Q22
}};

292 
filt_z
 = 
a11
*filt_z + 
a12
*
filt_w
 + 
b11
*
acc_z
;

293 
filt_w
 = 
a21
*
filt_z
 + 
a22
*filt_w + 
b21
*
acc_z
;

295 
	`mult_mat
(
A
,
P
,
AP
,2,2,2,2);

296 
	`mult_mat
(
AP
,
A_T
,
APA
,2,2,2,2);

297 
	`add_mat
(
APA
,
Q
,
P
,2,2);

302 
	}
}

304 void 
	$sonar_kf_correction
(float* 
alt_z
, float* 
vel_z
, float 
s_sonar
, float 
sonar_raw
)

307 float 
R
 = 
	`pow
(
s_sonar
,2);

308 float 
P_temp
[2][2];

309 float 
L
[2][2] = {{(1-
k11
),0},{-
k21
,1}};

310 int 
i
,
j
;

311 
k11
 = 
P
[0][0]/(P[0][0]+
R
);

312 
k21
 = 
P
[1][0]/(P[0][0]+
R
);

313 
filt_z
 = filt_z+
k11
*(
sonar_raw
-filt_z);

314 
filt_w
 = filt_w+
k21
*(
sonar_raw
-
filt_z
);

315 
	`mult_mat
(
L
,
P
,
P_temp
,2,2,2,2);

316 for (
i
=0;i<2;i++)

318 for (
j
=0;j<2;j++)

320 
P
[
i
][
j
]=
P_temp
[i][j];

323 *
alt_z
 = 
filt_z
;

324 *
vel_z
 = 
filt_w
;

325 
	}
}

327 void 
	$mult_mat
(float 
a
[][2],float 
b
[][2],float 
mult
[][2],float 
r1
,float 
c1
,float 
r2
,float 
c2
)

329 int 
i
,
j
,
k
;

331 for(
i
=0; i<
r1
; ++i)

332 for(
j
=0; j<
c2
; ++j)

334 
mult
[
i
][
j
]=0;

337 for(
i
=0; i<
r1
; ++i)

338 for(
j
=0; j<
c2
; ++j)

339 for(
k
=0; k<
c1
; ++k)

341 
mult
[
i
][
j
]+=
a
[i][
k
]*
b
[k][j];

343 
	}
}

345 void 
	$add_mat
(float 
m1
[][2],float 
m2
[][2],float 
m3
[][2],float 
row
,float 
col
)

347 int 
i
,
j
;

348 for(
i
=0;i<
row
;i++)

350 for(
j
=0;j<
col
;j++)

352 
m3
[
i
][
j
] = (
m1
[i][j] + 
m2
[i][j]);

355 
	}
}

	@modules/src/stabilizer.c

6 #include 
	~<inttypes.h
>

7 #include 
	~<stdint.h
>

8 #include 
	~<string.h
>

10 #include 
	~"stm32f4xx_conf.h
"

11 #include 
	~"FreeRTOS.h
"

12 #include 
	~"FreeRTOSConfig.h
"

13 #include 
	~"task.h
"

14 #include 
	~"math.h
"

15 #include 
	~"semphr.h
"

17 #include 
	~"stabilizer.h
"

18 #include 
	~"sensfusion6.h
"

19 #include 
	~"imu.h
"

20 #include 
	~"motors.h
"

21 #include 
	~<stdbool.h
>

22 #include 
	~"queue.h
"

23 #include 
	~"hw_config.h
"

24 #include 
	~"mpu6050.h
"

25 #include 
	~"serial_tasks.h
"

35 #define 
	#NUM_JOYSTICK_CHANNELS
 4

	)

37 #define 
	#SPEKTRUM_KILL_CHANNEL
 5

	)

39 #define 
	#SPEKTRUM_CONTROL_CHANNEL
 6

	)

41 #define 
	#POSITION_OFFSET
 
UINT32_MAX
/2

	)

43 #define 
	#POSITION_EPSILON
 0.1

	)

44 #define 
	#VELOCITY_EPSILON
 0.1

	)

45 #define 
	#ANGLE_ERROR_EPSILON
 0.1

	)

46 #define 
	#POSITION_ERROR_DEFAULT
 0.5

	)

47 #define 
	#VELOCITY_ERROR_DEFAULT
 0.5

	)

48 #define 
	#ANGLE_ERROR_DEFAULT
 0.5

	)

50 #define 
	#POSITION_MULTIPLIER_POS_RAW
 10000

	)

51 #define 
	#VELOCITY_MULTIPLIER_VEL_RAW
 10000

	)

52 #define 
	#ANGLE_MULTIPLIER_ANG_RAW
 10000

	)

53 #define 
	#POSITION_MULTIPLIER_MM_RAW
 100

	)

54 #define 
	#VELOCITY_MULTIPLIER_MM_RAW
 100

	)

55 #define 
	#ANGLE_MULTIPLIER_MRAD_RAW
 100

	)

58 #define 
	#FLOAT_CMP_EPS
 1e-7f

	)

61 #define 
	#POS_FB_LIM
 75.0f

	)

64 #define 
	#POSE_SERIAL
 0

	)

65 #define 
	#POSE_MILLIUNITS
 1

	)

67 #define 
	#CONVERT_ERR_RAW
 0

	)

68 #define 
	#CONVERT_DESIRED_RAW
 1

	)

70 #define 
	#SERIAL_STATE_NONE
 0

	)

71 #define 
	#SERIAL_STATE_KILL
 1

	)

72 #define 
	#SERIAL_STATE_SPEKTRUM
 2

	)

73 #define 
	#SERIAL_STATE_VISION_POS
 3

	)

74 #define 
	#SERIAL_STATE_LOCAL_POS
 4

	)

75 #define 
	#SERIAL_STATE_SETPOINT
 5

	)

76 #define 
	#SERIAL_STATE_THRUST
 6

	)

77 #define 
	#RAW_ROLL_BASELINE
 1500

	)

78 #define 
	#RAW_PITCH_BASELINE
 1500

	)

80 #define 
	#RAW_THRUST_BASELINE
 0

	)

81 #define 
	#RAW_YAW_BASELINE
 1500

	)

84 
uint16_t
 
	mglobal_msg_len
;

85 
int16_t
 
	mmsg_type
[10];

88 
uint16_t
 
	mlen
[10];

89 } 
	tmsg_specs_s
;

92 
int16_t
 
	mspektrum_roll
,
	mspektrum_pitch
,

93 
	mspektrum_thrust
,
	mspektrum_yaw
;

94 
int16_t
 
	mspektrum_roll_trim
,
	mspektrum_pitch_trim
,

95 
	mspektrum_thrust_trim
,
	mspektrum_yaw_trim
;

97 
int32_t
 
	mraw_x_e
,
	mraw_y_e
,
	mraw_z_e
;

99 
int32_t
 
	mraw_vx_e
,
	mraw_vy_e
,
	mraw_vz_e
;

101 
int32_t
 
	mraw_yaw_e
, 
	mraw_yawd_e
;

102 
gains_s
 
	mgains
;

103 } 
	tsnap_cmd_s
;

107 
int16_t
 
	mspektrum_roll
,
	mspektrum_pitch
,

108 
	mspektrum_thrust
,
	mspektrum_yaw
;

109 
int16_t
 
	mspektrum_roll_trim
,
	mspektrum_pitch_trim
,

110 
	mspektrum_thrust_trim
,
	mspektrum_yaw_trim
;

112 float 
	mf_roll_d
,
	mf_pitch_d
,
	mf_yaw_d
;

114 
int32_t
 
	mx_e
,
	my_e
,
	mz_e
,

115 
	mvx_e
,
	mvy_e
,
	mvz_e
,

116 
	myaw_e
,
	myawd_e
;

118 
gains_s
 
	mgains
;

119 } 
	tpose_s
;

122 float 
	mf_thrust
, 
	mf_roll
, 
	mf_pitch
, 
	mf_yaw
;

123 int 
	mthrust
, 
	mroll
, 
	mpitch
, 
	myaw
;

124 } 
	tactuator_ctl_s
;

126 #define 
	#PRIVATE


	)

128 
Axis3f
 
	ggyro
;

129 
Axis3f
 
	gacc
;

130 
Axis3i16
 
	ggyroMpu
;

131 
Axis3i16
 
	gaccelMpu
;

132 
int8_t
 
	gpitchkp
 = -2;

133 
int8_t
 
	gpitchkd
 = 40;

134 
int8_t
 
	grollkp
 = 2;

135 
int8_t
 
	grollkd
 = 40;

136 
int8_t
 
	gyawkp
 = 80;

137 
int8_t
 
	gpitchki
, 
	grollki
;

138 float 
	gf_actuatorThrust
, 
	gf_actuatorRoll
, 
	gf_actuatorPitch
, 
	gf_actuatorYaw
;

140 
PRIVATE
 float 
	geulerRollActual
;

141 
PRIVATE
 float 
	geulerPitchActual
;

142 
PRIVATE
 float 
	geulerYawActual
;

143 
PRIVATE
 float 
	geulerRollDesired
;

144 
PRIVATE
 float 
	geulerPitchDesired
;

145 
PRIVATE
 float 
	geulerYawDesired
;

146 
PRIVATE
 float 
	grollRateDesired
;

147 
PRIVATE
 float 
	gpitchRateDesired
;

148 
PRIVATE
 float 
	gyawRateDesired
;

149 
PRIVATE
 float 
	gfusionDt
;

151 
int16_t
 
	gactuatorThrust
 = 1000;

152 
int16_t
 
	gactuatorRoll
 = 0;

153 
int16_t
 
	gactuatorPitch
 = 0;

154 
int16_t
 
	gactuatorYaw
 =0;

155 
int16_t
 
	gactuatorLeftServo
 = 1500;

156 
int16_t
 
	gactuatorRightServo
 = 1500;

157 
int16_t
 
	gbaseline
 = 1000;

159 
int16_t
 
	gtrimThrust
 = 900;

160 
int16_t
 
	gtempThrust
 = 900;

161 
int16_t
 
	gtrimRoll
 = 0;

162 
int16_t
 
	gtrimPitch
 = 0;

163 
int16_t
 
	gtrimYaw
 = 0;

164 
int16_t
 
	gtrimLeftServo
 = 1500;

165 
int16_t
 
	gtrimRightServo
 = 1500;

166 float 
	geulerPitchDesired
 = 0.0;

167 
int8_t
 
	gt_sens
 = 10;

168 
int8_t
 
	gr_sens
 = 2;

169 
int8_t
 
	gp_sens
 = 2;

170 
int8_t
 
	gy_sens
 = -10;

171 float 
	gthrust_sens
 = 1.0;

172 float 
	groll_sens
 = 1.0;

173 float 
	gyaw_sens
 = 1.0;

174 float 
	gpitch_sens
 = 1.0;

177 float 
	g_pos_sens
 = 1e-4;

178 float 
	g_vel_sens
 = 1e-3;

180 
uint32_t
 
	gleftmotor
;

181 
uint32_t
 
	grightmotor
;

182 
uint32_t
 
	gtail
;

183 
uint32_t
 
	gls
;

184 
uint32_t
 
	grs
;

186 
int32_t
 
	gmotorPowerLeftfront
;

187 
int32_t
 
	gmotorPowerRightfront
;

188 
int32_t
 
	gmotorPowerLeftrear
;

189 
int32_t
 
	gmotorPowerRightrear
;

191 float 
	ggyro_x_filt
;

192 float 
	ggyro_y_filt
;

193 float 
	ggyro_z_filt
;

195 float 
	gtheta
;

197 static 
bool
 
	gisInit
;

199 float 
	g_pos_x_fb
, 
	g_pos_y_fb
;

201 float 
	g_pitch_flow
, 
	g_roll_flow
;

203 
uint8_t
 
	g_snap_serial_state
;

205 static void 
distributePower
(const 
uint16_t
 
thrust
, const 
int16_t
 
roll
,

206 const 
int16_t
 
pitch
, const int16_t 
yaw
, const int16_t 
lefts
, const int16_t 
rights
);

207 static 
uint16_t
 
limitThrust
(
int32_t
 
value
);

208 static void 
stabilizerTask
(void* 
param
);

209 static void 
imuinit
();

211 void 
snap_cmd_parse
(

212 
snap_cmd_s
 *
cmd
,

213 
msg_specs_s
 *
specs
,

214 
rx_xbee
 *
snap_buf_rx
);

215 void 
convert_position
(
snap_cmd_s
 *
cmd
,

216 
uint8_t
 
conversion_type
,

217 
int16_t
 
units
);

218 void 
rotate_pose
(
pose_s
 *
init
,

219 
pose_s
 *
rot
);

220 
inline
 void 
rotate_pose_yaw
(

221 
pose_s
 *
init
,

222 
pose_s
 *
rot
,

223 
int32_t
 
yaw
);

224 void 
copy_pose_cmds
(
pose_s
 *
src
,

225 
pose_s
 *
dst
);

226 void 
form_actuator_ctl_cmd
(

227 
msg_specs_s
 *
msg_specs
,

228 
pose_s
 *
pose_desired
,

229 
actuator_ctl_s
 *
actuator_ctl
);

230 void 
check_header
(

231 
rx_xbee
 *
snap_buf_rx
,

232 
msg_specs_s
 *
specs
,

233 
uint16_t
 
idx
,

234 
uint16_t
 
msg_num
);

235 void 
combine_bytes
(

236 void *
ret
,

237 char *
bytes
,

238 
uint8_t
 
len
,

239 
bool
 
sig_byte_first
,

240 
bool
 
signed_int
);

241 static void 
actuator_ftoi
(
actuator_ctl_s
 *
ctl
);

242 static void 
actuator_itof
(
actuator_ctl_s
 *
ctl
);

244 
xQueueHandle
 
	gtx1Queue
, 
	geulerqueue
,
	gspektrumqueue
;

245 
xSemaphoreHandle
 
	gqueuewritten
;

248 
int16_t
 
	gsnapCh1
, 
	gsnapCh2
, 
	gsnapCh3
, 
	gsnapCh4
;

252 void 
	$stabilizerInit
(void)

257 
	`motorsInit
();

258 
	`imu6Init
();

259 
	`sensfusion6Init
();

260 int 
i
;

261 for (
i
=0; i<100000; i++);

263 
rollRateDesired
 = 0;

264 
pitchRateDesired
 = 0;

265 
yawRateDesired
 = 0;

269 
	`xTaskCreate
(
stabilizerTask
, (const signed char * const)"STABILIZER",

270 
configMINIMAL_STACK_SIZE
, 
NULL
, 
tskIDLE_PRIORITY
, NULL);

273 
	}
}

275 static void 
	$stabilizerTask
(void* 
param
)

277 int 
i
;

278 
uint16_t
 
ratio
;

279 
uint8_t
 
data
;

280 
uint8_t
 
buffer
[14];

281 
	`imuinit
();

282 
int16_t
 
ax
,
ay
,
az
,
gx
,
gy
,
gz
;

283 
uint32_t
 
lastWakeTime
;

284 
lastWakeTime
 = 
	`xTaskGetTickCount
 ();

285 
uint32_t
 
attitudeCounter
 = 0;

286 int 
helicnt
 = 0;

287 
uint16_t
 
start
 = 0;

288 
int16_t
 
delay
 = 0;

289 
uint16_t
 
delay_temp
 = 0;

291 
rxpacket
 
test
;

292 static int 
k
=0;

293 int 
counter
=0,
kay
=0;

294 int 
initialize
=0;

295 int 
actuatorThrusttemp
, 
actuatorPitchtemp
, 
actuatorRolltemp
, 
actuatorYawtemp
;

296 int 
spektrumchanneltemp
[6];

299 
uint8_t
 
status
 = 1;

300 
int16_t
 
sonar
 = 0;

301 float 
flow_comp_x
=0.0;

302 float 
flow_comp_y
=0.0;

303 float 
px4_gx
 = 0.0, 
px4_gy
=0.0, 
px4_gz
=0.0;

304 float 
flow_comp_x_filt
=0.0;

305 float 
flow_comp_y_filt
=0.0;

306 float 
x
 = 0.0;

307 float 
y
 = 0.0;

308 int 
PX4_UPDATE
 = 10;

309 float 
PX4_UPDATE_DT
 = 0.01;

310 
int16_t
 
kp_flow_x
 = -8;

311 
int16_t
 
kp_flow_y
 = -8;

312 
int16_t
 
correction_x
 = 7;

313 
int16_t
 
correction_y
 = 5;

317 float 
sonar_raw
;

318 float 
sacc
 = 0.3;

319 float 
s_sonar
 = 0.003;

320 float 
alt_filt
;

321 float 
vel_filt
;

322 int 
alt_predict_counter
 = 0;

323 int 
sonar_correction_counter
 = 0;

324 int 
alt_predict_cnt_limit
 = 20;

325 int 
sonar_correction_cnt_limit
 = 20;

326 float 
altkp
 = 0;

327 float 
altkd
 = 0;

328 
int16_t
 
alt_kp
 = -8;

329 
int16_t
 
alt_kd
 = -8;

330 float 
altitude_fb
;

331 
int16_t
 
alt_error
;

332 
int16_t
 
alt_desired
;

333 
uint8_t
 
flag
 = 0;

337 int 
bias
 = 0;

338 int 
biascount
 = 0;

339 
int16_t
 
spektrumbias
[4]={0,0,0,0};

340 
int16_t
 
snapChBias
[4]={0,0,0,0};

341 
int16_t
 
snapCh
[4]={0,0,0,0};

342 
int16_t
 
pos_kp
, 
pos_kd
, 
pos_x
, 
pos_y
, 
pos_z
;

343 
uint8_t
 
pos_flag
 = 0;

344 
int16_t
 
pos_x_desired
, 
pos_y_desired
,
pos_x_error
, 
pos_y_error
;

345 int 
ii
=0;

347 float 
new_pos_gains
[2];

348 
bool
 
new_pos_gains_flag
;

349 
snap_cmd_s
 
snap_cmd
;

350 
	`memset
(&
snap_cmd
, 0, sizeof(snap_cmd));

351 
msg_specs_s
 
snap_msg_specs
;

352 
	`memset
(&
snap_msg_specs
, 0, sizeof(snap_msg_specs));

353 
pose_s
 
pose_desired
;

354 
	`memset
(&
pose_desired
, 0, sizeof(pose_desired));

355 
actuator_ctl_s
 
actuator_ctl
;

356 
	`memset
(&
actuator_ctl
, 0, sizeof(actuator_ctl));

358 
_roll_flow
 = 0;

359 
_pitch_flow
 = 0;

361 
_pos_x_fb
 = 0;

362 
_pos_y_fb
 = 0;

364 
pose_desired
.
gains
.
k
[0]=2.1;

365 
pose_desired
.
gains
.
k
[1]=2.1;

366 
pose_desired
.
gains
.
k
[2]=2.1;

367 
pose_desired
.
gains
.
k
[3]=350;

368 
pose_desired
.
gains
.
k
[4]=350;

369 
pose_desired
.
gains
.
k
[5]=350;

370 
pose_desired
.
spektrum_roll_trim
 = 
RAW_ROLL_BASELINE
;

371 
pose_desired
.
spektrum_pitch_trim
 = 
RAW_PITCH_BASELINE
;

372 
pose_desired
.
spektrum_thrust_trim
 = 
RAW_THRUST_BASELINE
;

373 
pose_desired
.
spektrum_yaw_trim
 = 
RAW_YAW_BASELINE
;

375 
int16_t
 
snap_parse_ret
 = -1;

376 
uint16_t
 
snap_parse_len
;

377 
uint16_t
 
snap_parse_num
;

382 for(
i
=0;i<1000;i++)

384 if (
spektrumchannel
[5]>0)

386 if(
initialize
==0)

388 for (
i
=0;i<5;i++)

390 
spektrumchanneltemp
[
i
] = 
spektrumchannel
[i];

395 
initialize
=1;

399 
	`vTaskDelayUntil
(&
lastWakeTime
,
	`F2T
(
IMU_UPDATE_FREQ
));

401 
	`imu6Read
(&
gyro
, &
acc
);

403 if (++
attitudeCounter
 >= 
ATTITUDE_UPDATE_RATE_DIVIDER
)

405 
	`sensfusion6UpdateQ
(
gyro
.
x
, gyro.
y
, gyro.
z
, 
acc
.x, acc.y, acc.z, 
FUSION_UPDATE_DT
);

406 
	`sensfusion6GetEulerRPY
(&
eulerRollActual
, &
eulerPitchActual
, &
eulerYawActual
);

407 
attitudeCounter
 = 0;

408 
euler
.
data
[0] = (int)(
eulerRollActual
*100);

409 
euler
.
data
[1] = (int)((
eulerPitchActual
)*100);

410 
euler
.
data
[2] = (int)(
eulerPitchDesired
*100);

417 if (
rx_buf
.
data
[1]==
PID_GAINS
 && rx_buf.data[2]==255 && rx_buf.data[3] == 255)

420 
pitchkp
 = (
rx_buf
.
data
[4]<<8)+rx_buf.data[5];

421 
pitchki
 = (
rx_buf
.
data
[6]<<8)+rx_buf.data[7];

422 
pitchkd
 = (
rx_buf
.
data
[8]<<8)+rx_buf.data[9];

423 
rollkp
 = (
rx_buf
.
data
[10]<<8)+rx_buf.data[11];

424 
rollki
 = (
rx_buf
.
data
[12]<<8)+rx_buf.data[13];

425 
rollkd
 = (
rx_buf
.
data
[14]<<8)+rx_buf.data[15];

426 
yawkp
 = (
rx_buf
.
data
[16]<<8)+rx_buf.data[17];

433 
new_pos_gains
[0] = (float)((
rx_buf
.
data
[18]<<8)+rx_buf.data[19])*

434 
_pos_sens
;

435 
new_pos_gains
[1] = (float)((
rx_buf
.
data
[20]<<8)+rx_buf.data[21])*

436 
_vel_sens
;

438 if (
	`fabs
(
pose_desired
.
gains
.
k
[0]-
new_pos_gains
[0])>
FLOAT_CMP_EPS
) {

439 
pose_desired
.
gains
.
k
[0]=
new_pos_gains
[0];

440 
new_pos_gains_flag
=
true
;

442 if (
	`fabs
(
pose_desired
.
gains
.
k
[1]-
new_pos_gains
[0])>
FLOAT_CMP_EPS
) {

443 
pose_desired
.
gains
.
k
[1]=
new_pos_gains
[0];

444 
new_pos_gains_flag
=
true
;

446 if (
	`fabs
(
pose_desired
.
gains
.
k
[2]-
new_pos_gains
[0])>
FLOAT_CMP_EPS
) {

447 
pose_desired
.
gains
.
k
[2]=
new_pos_gains
[0];

448 
new_pos_gains_flag
=
true
;

451 if (
	`fabs
(
pose_desired
.
gains
.
k
[3]-
new_pos_gains
[1])>
FLOAT_CMP_EPS
) {

452 
pose_desired
.
gains
.
k
[3]=
new_pos_gains
[1];

453 
new_pos_gains_flag
=
true
;

455 if (
	`fabs
(
pose_desired
.
gains
.
k
[4]-
new_pos_gains
[1])>
FLOAT_CMP_EPS
) {

456 
pose_desired
.
gains
.
k
[4]=
new_pos_gains
[1];

457 
new_pos_gains_flag
=
true
;

459 if (
	`fabs
(
pose_desired
.
gains
.
k
[5]-
new_pos_gains
[1])>
FLOAT_CMP_EPS
) {

460 
pose_desired
.
gains
.
k
[5]=
new_pos_gains
[1];

461 
new_pos_gains_flag
=
true
;

464 if (
new_pos_gains_flag
){

465 
	`send_floats
(
DST_SNAP
,&
new_pos_gains
,2);

466 
new_pos_gains_flag
=
false
;

470 else if (
rx_buf
.
data
[1] == 
SENSITIVITY
 && rx_buf.data[2]==255 && rx_buf.data[3] == 255)

472 
t_sens
 = (
rx_buf
.
data
[4]<<8)+rx_buf.data[5];

473 
r_sens
 = (
rx_buf
.
data
[6]<<8)+rx_buf.data[7];

474 
p_sens
 = (
rx_buf
.
data
[8]<<8)+rx_buf.data[9];

475 
y_sens
 = (
rx_buf
.
data
[10]<<8)+rx_buf.data[11];

476 
alt_kp
 = (
rx_buf
.
data
[12]<<8)+rx_buf.data[13];

477 
alt_kd
 = (
rx_buf
.
data
[14]<<8)+rx_buf.data[15];

478 
altkp
 = 
alt_kp
/100.0;

479 
altkd
 = 
alt_kd
/100.0;

482 else if (
rx_buf
.
data
[1] == 
TRIM
 && rx_buf.data[2]==255 && rx_buf.data[3] == 255)

484 
trimThrust
 = (
rx_buf
.
data
[4]<<8)+rx_buf.data[5];

485 
trimRoll
 = (
rx_buf
.
data
[6]<<8)+rx_buf.data[7];

486 
trimPitch
 = (
rx_buf
.
data
[8]<<8)+rx_buf.data[9];

487 
trimYaw
 = (
rx_buf
.
data
[10]<<8)+rx_buf.data[11];

488 
trimLeftServo
 = (
rx_buf
.
data
[12]<<8)+rx_buf.data[13];

489 
trimRightServo
 = (
rx_buf
.
data
[14]<<8)+rx_buf.data[15];

494 
gyro_x_filt
 = 0.8*gyro_x_filt+0.2*
gyro
.
x
;

495 
gyro_y_filt
 = 0.8*gyro_y_filt+0.2*
gyro
.
y
;

496 
gyro_z_filt
 = 0.8*gyro_z_filt+0.2*
gyro
.
z
;

498 
snap_msg_specs
.
global_msg_len
 = 0;

500 
pose_desired
.
spektrum_roll
 = pose_desired.
spektrum_roll_trim
;

501 
pose_desired
.
spektrum_pitch
 = pose_desired.
spektrum_pitch_trim
;

502 
pose_desired
.
spektrum_thrust
 = pose_desired.
spektrum_thrust_trim
;

503 
pose_desired
.
spektrum_yaw
 = pose_desired.
spektrum_yaw_trim
;

504 
pose_desired
.
f_roll_d
 = 
r_sens
*(pose_desired.
spektrum_roll
-

505 
RAW_ROLL_BASELINE
)*0.10;

506 
pose_desired
.
f_pitch_d
 = 
p_sens
*(pose_desired.
spektrum_pitch
-

507 
RAW_PITCH_BASELINE
)*0.10;

509 
	`snap_cmd_parse
(

510 &
snap_cmd
,

511 &
snap_msg_specs
,

512 &
snap_buf_rx
);

514 
snap_parse_num
=0;

515 
snap_parse_len
=1;

516 while (
snap_parse_len
 < 
snap_msg_specs
.
global_msg_len
) {

517 
snap_parse_len
 += 
snap_msg_specs
.
len
[
snap_parse_num
]+1;

518 switch(
snap_msg_specs
.
msg_type
[
snap_parse_num
]) {

519 case 
MSG_TYPE_ERROR
:

521 case 
MSG_TYPE_NONE
:

523 case 
MSG_TYPE_KILL
:

524 
pose_desired
.
spektrum_roll_trim
 = 
snap_cmd
.spektrum_roll_trim;

525 
pose_desired
.
spektrum_pitch_trim
 = 
snap_cmd
.spektrum_pitch_trim;

526 
pose_desired
.
spektrum_thrust_trim
 = 
snap_cmd
.spektrum_thrust_trim;

527 
pose_desired
.
spektrum_yaw_trim
 = 
snap_cmd
.spektrum_yaw_trim;

529 
pose_desired
.
spektrum_roll
 = 
snap_cmd
.spektrum_roll;

530 
pose_desired
.
spektrum_pitch
 = 
snap_cmd
.spektrum_pitch;

531 
pose_desired
.
spektrum_thrust
 = 
snap_cmd
.spektrum_thrust;

532 
pose_desired
.
spektrum_yaw
 = 
snap_cmd
.spektrum_yaw;

534 
pose_desired
.
f_roll_d
 = 
r_sens
*(pose_desired.
spektrum_roll
-

535 
RAW_ROLL_BASELINE
)*0.10;

536 
pose_desired
.
f_pitch_d
 = 
p_sens
*(pose_desired.
spektrum_pitch
-

537 
RAW_PITCH_BASELINE
)*0.10;

538 case 
MSG_TYPE_SPEKTRUM
:

541 
pose_desired
.
spektrum_roll
 = 
snap_cmd
.spektrum_roll;

542 
pose_desired
.
spektrum_pitch
 = 
snap_cmd
.spektrum_pitch;

543 
pose_desired
.
spektrum_thrust
 = 
snap_cmd
.spektrum_thrust;

544 
pose_desired
.
spektrum_yaw
 = 
snap_cmd
.spektrum_yaw;

546 
pose_desired
.
f_roll_d
 = 
r_sens
*(pose_desired.
spektrum_roll
-

547 
RAW_ROLL_BASELINE
)*0.10;

548 
pose_desired
.
f_pitch_d
 = 
p_sens
*(pose_desired.
spektrum_pitch
-

549 
RAW_PITCH_BASELINE
)*0.10;

551 case 
MSG_TYPE_SETPOINT
:

552 case 
MSG_TYPE_VISION_POS
:

553 case 
MSG_TYPE_LOCAL_POS
:

554 
pose_desired
.
spektrum_thrust
 = 
snap_cmd
.spektrum_thrust;

557 
pose_desired
.
x_e
 = 
snap_cmd
.
raw_x_e
;

558 
pose_desired
.
y_e
 = 
snap_cmd
.
raw_y_e
;

560 
pose_desired
.
vx_e
 = 
snap_cmd
.
raw_vx_e
;

561 
pose_desired
.
vy_e
 = 
snap_cmd
.
raw_vy_e
;

565 case 
MSG_TYPE_THRUST
:

572 
snap_parse_num
++;

575 
	`form_actuator_ctl_cmd
(

576 &
snap_msg_specs
,

577 &
pose_desired
,

578 &
actuator_ctl
);

590 
euler
.
data
[3] = (
int16_t
)((
pose_desired
.
x_e
 >> 16) & 0xffff);

591 
euler
.
data
[4] = (
int16_t
)(
pose_desired
.
x_e
 & 0xffff);

592 
euler
.
data
[5] = (
int16_t
)((
pose_desired
.
y_e
 >> 16) & 0xffff);

593 
euler
.
data
[6] = (
int16_t
)(
pose_desired
.
y_e
 & 0xffff);

594 
euler
.
data
[7] = (
int16_t
)((
pose_desired
.
vx_e
 >> 16) & 0xffff);

595 
euler
.
data
[8] = (
int16_t
)(
pose_desired
.
vx_e
 & 0xffff);

596 
euler
.
data
[9] = (
int16_t
)((
pose_desired
.
vy_e
 >> 16) & 0xffff);

597 
euler
.
data
[10] = (
int16_t
)(
pose_desired
.
vy_e
 & 0xffff);

599 
euler
.
data
[11] = (
int16_t
)(
_snap_serial_state
);

621 if(
actuator_ctl
.
thrust
 <= 950 ||

622 
actuator_ctl
.
thrust
 > 2000 ||

623 
actuator_ctl
.
roll
 > 2000 ||

624 
actuator_ctl
.
pitch
 > 2000 ||

625 
actuator_ctl
.
yaw
 > 2000) {

626 
actuator_ctl
.
thrust
 = 950;

627 
actuator_ctl
.
roll
 = 0;

628 
actuator_ctl
.
pitch
 = 0;

629 
actuator_ctl
.
yaw
 = 0;

634 
	`distributePower
(
actuator_ctl
.
thrust
,

635 
actuator_ctl
.
roll
,

636 
actuator_ctl
.
pitch
,

637 
actuator_ctl
.
yaw
,

641 
	}
}

643 static void 
	$distributePower
(const 
uint16_t
 
thrust
, const 
int16_t
 
roll
,

644 const 
int16_t
 
pitch
, const int16_t 
yaw
, const int16_t 
lefts
, const int16_t 
rights
)

653 
motorPowerLeftfront
 = 
	`limitThrust
(
thrust
 + 
roll
 - 
pitch
 - 
yaw
 );

654 
motorPowerRightfront
 = 
	`limitThrust
(
thrust
 - 
roll
 - 
pitch
 + 
yaw
 );

655 
motorPowerLeftrear
 = 
	`limitThrust
(
thrust
 + 
roll
 + 
pitch
 + 
yaw
 );

656 
motorPowerRightrear
 = 
	`limitThrust
(
thrust
 - 
roll
 + 
pitch
 - 
yaw
 );

659 
	`motorsSetRatio
(
MOTOR_LEFTFRONT
, 
motorPowerLeftfront
);

660 
	`motorsSetRatio
(
MOTOR_RIGHTFRONT
, 
motorPowerRightfront
);

661 
	`motorsSetRatio
(
MOTOR_LEFTREAR
, 
motorPowerLeftrear
);

662 
	`motorsSetRatio
(
MOTOR_RIGHTREAR
, 
motorPowerRightrear
);

663 
	}
}

665 static 
uint16_t
 
	$limitThrust
(
int32_t
 
value
)

667 if(
value
 > 2000)

669 
value
 = 2000;

671 else if(
value
 < 1000 & value >200)

673 
value
 = 1000;

676 else if(
value
 <200)

678 
value
 = 0;

681 return (
uint16_t
)
value
;

682 
	}
}

684 void 
	$imuinit
(void)

686 static int 
i
;

687 
	`mpu6050Reset
();

689 for (
i
=0; i<10000; i++);

691 
	`mpu6050SetSleepEnabled
(
FALSE
);

693 
	`mpu6050SetTempSensorEnabled
(
TRUE
);

695 
	`mpu6050SetIntEnabled
(
FALSE
);

697 
	`mpu6050SetI2CBypassEnabled
(
TRUE
);

699 
	`mpu6050SetClockSource
(
MPU6050_CLOCK_PLL_XGYRO
);

701 
	`mpu6050SetFullScaleGyroRange
( 
MPU6050_GYRO_FS_2000
);

703 
	`mpu6050SetFullScaleAccelRange
(
MPU6050_ACCEL_FS_8
);

707 
	`mpu6050SetRate
(0);

709 
	`mpu6050SetDLPFMode
(
MPU6050_DLPF_BW_98
);

710 
	}
}

712 void 
	$snap_cmd_parse
(

713 
snap_cmd_s
 *
cmd
,

714 
msg_specs_s
 *
specs
,

715 
rx_xbee
 *
snap_buf_rx
) {

716 
uint16_t
 
global_msg_len
,

717 
curr_idx
 = 0,

718 
msg_num
 = 0;

719 
specs
->
global_msg_len
 = 
snap_buf_rx
->
data
[
SERIAL_HEADER_MSG_LEN
]+1;

720 
curr_idx
 += 
SERIAL_HEADER_LOCAL_MSG_OFFSET
;

722 while (
curr_idx
 < 
specs
->
global_msg_len
) {

723 
	`check_header
(
snap_buf_rx
, 
specs
, 
curr_idx
, 
msg_num
);

724 if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_ERROR
) {

725 
_snap_serial_state
 = 
SERIAL_STATE_NONE
;

727 } else if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_NONE
) {

728 
_snap_serial_state
 = 
SERIAL_STATE_NONE
;

729 } else if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_KILL
) {

730 
_snap_serial_state
 = 
SERIAL_STATE_KILL
;

732 
cmd
->
spektrum_roll
=
RAW_ROLL_BASELINE
;

733 
cmd
->
spektrum_pitch
=
RAW_PITCH_BASELINE
;

734 
cmd
->
spektrum_thrust
=
RAW_THRUST_BASELINE
;

735 
cmd
->
spektrum_yaw
=
RAW_YAW_BASELINE
;

737 
	`combine_bytes
(

738 (void *)(&(
cmd
->
spektrum_roll_trim
)),

739 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
],

741 
true
,

742 
false
);

744 
	`combine_bytes
(

745 (void *)(&(
cmd
->
spektrum_pitch_trim
)),

746 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+2],

748 
true
,

749 
false
);

751 
	`combine_bytes
(

752 (void *)(&(
cmd
->
spektrum_thrust_trim
)),

753 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+4],

755 
true
,

756 
false
);

758 
	`combine_bytes
(

759 (void *)(&(
cmd
->
spektrum_yaw_trim
)),

760 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+6],

762 
true
,

763 
false
);

765 } else if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_SPEKTRUM
) {

766 
_snap_serial_state
 = 
SERIAL_STATE_SPEKTRUM
;

768 
	`combine_bytes
(

769 (void *)(&(
cmd
->
spektrum_roll
)),

770 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
],

772 
true
,

773 
false
);

775 
	`combine_bytes
(

776 (void *)(&(
cmd
->
spektrum_pitch
)),

777 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+2],

779 
true
,

780 
false
);

782 
	`combine_bytes
(

783 (void *)(&(
cmd
->
spektrum_thrust
)),

784 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+4],

786 
true
,

787 
false
);

789 
	`combine_bytes
(

790 (void *)(&(
cmd
->
spektrum_yaw
)),

791 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+6],

793 
true
,

794 
false
);

796 } else if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_VISION_POS
 ||

797 
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_LOCAL_POS
 ||

798 
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_SETPOINT
) {

801 
	`combine_bytes
(

802 (void *)(&(
cmd
->
raw_x_e
)),

803 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
],

805 
true
,

806 
true
);

808 
	`combine_bytes
(

809 (void *)(&(
cmd
->
raw_y_e
)),

810 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+4],

812 
true
,

813 
true
);

824 
	`combine_bytes
(

825 (void *)(&(
cmd
->
raw_vx_e
)),

826 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+8],

828 
true
,

829 
true
);

831 
	`combine_bytes
(

832 (void *)(&(
cmd
->
raw_vy_e
)),

833 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
+12],

835 
true
,

836 
true
);

847 if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_VISION_POS
) {

848 
_snap_serial_state
 = 
SERIAL_STATE_VISION_POS
;

849 } else if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_LOCAL_POS
) {

850 
_snap_serial_state
 = 
SERIAL_STATE_LOCAL_POS
;

851 } else if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_SETPOINT
) {

852 
_snap_serial_state
 = 
SERIAL_STATE_SETPOINT
;

854 
	`convert_position
(
cmd
,

855 
CONVERT_ERR_RAW
,

856 
POSE_MILLIUNITS
);

858 } else if (
specs
->
msg_type
[
msg_num
] == 
MSG_TYPE_THRUST
) {

861 
	`combine_bytes
(

862 (void *)(&(
cmd
->
spektrum_thrust
)),

863 &
snap_buf_rx
->
data
[
curr_idx
+
SERIAL_HEADER_DATA_OFFSET
],

865 
true
,

866 
false
);

869 
_snap_serial_state
 = 
SERIAL_STATE_NONE
;

872 
curr_idx
 += 
specs
->
len
[
msg_num
]+1;

873 
msg_num
++;

875 
	}
}

877 void 
	$convert_position
(

878 
snap_cmd_s
 *
cmd
,

879 
uint8_t
 
conversion_type
,

880 
int16_t
 
units
) {

882 if (
units
 == 
POSE_SERIAL
) {

883 
cmd
->
raw_x_e
 =

884 (
int32_t
)((
int64_t
)
cmd
->
raw_x_e
*
POSITION_MULTIPLIER_MM_RAW
);

885 
cmd
->
raw_y_e
 =

886 (
int32_t
)((
int64_t
)
cmd
->
raw_y_e
*
POSITION_MULTIPLIER_MM_RAW
);

887 
cmd
->
raw_z_e
 =

888 (
int32_t
)((
int64_t
)
cmd
->
raw_z_e
*
POSITION_MULTIPLIER_MM_RAW
);

889 
cmd
->
raw_vx_e
 =

890 (
int32_t
)((
int64_t
)
cmd
->
raw_vx_e
*
VELOCITY_MULTIPLIER_MM_RAW
);

891 
cmd
->
raw_vy_e
 =

892 (
int32_t
)((
int64_t
)
cmd
->
raw_vy_e
*
VELOCITY_MULTIPLIER_MM_RAW
);

893 
cmd
->
raw_vz_e
 =

894 (
int32_t
)((
int64_t
)
cmd
->
raw_vz_e
*
VELOCITY_MULTIPLIER_MM_RAW
);

897 } else if (
units
 == 
POSE_MILLIUNITS
) {

898 
cmd
->
raw_x_e
 =

899 (
int32_t
)(((
int64_t
)
cmd
->
raw_x_e
)/
POSITION_MULTIPLIER_MM_RAW
);

900 
cmd
->
raw_y_e
 =

901 (
int32_t
)(((
int64_t
)
cmd
->
raw_y_e
)/
POSITION_MULTIPLIER_MM_RAW
);

902 
cmd
->
raw_z_e
 =

903 (
int32_t
)(((
int64_t
)
cmd
->
raw_z_e
)/
POSITION_MULTIPLIER_MM_RAW
);

904 
cmd
->
raw_vx_e
 =

905 (
int32_t
)(((
int64_t
)
cmd
->
raw_vx_e
)/
VELOCITY_MULTIPLIER_MM_RAW
);

906 
cmd
->
raw_vy_e
 =

907 (
int32_t
)(((
int64_t
)
cmd
->
raw_vy_e
)/
VELOCITY_MULTIPLIER_MM_RAW
);

908 
cmd
->
raw_vz_e
 =

909 (
int32_t
)(((
int64_t
)
cmd
->
raw_vz_e
)/
VELOCITY_MULTIPLIER_MM_RAW
);

911 
	}
}

913 void 
	$copy_pose_cmds
(
pose_s
 *
src
,

914 
pose_s
 *
dst
) {

915 
dst
->
spektrum_roll
 = 
src
->spektrum_roll;

916 
dst
->
spektrum_pitch
 = 
src
->spektrum_pitch;

917 
dst
->
spektrum_thrust
 = 
src
->spektrum_thrust;

918 
dst
->
spektrum_yaw
 = 
src
->spektrum_yaw;

919 
dst
->
f_roll_d
 = 
src
->f_roll_d;

920 
dst
->
f_pitch_d
 = 
src
->f_pitch_d;

921 
dst
->
f_yaw_d
 = 
src
->f_yaw_d;

922 
	}
}

924 void 
	$form_actuator_ctl_cmd
(

925 
msg_specs_s
 *
msg_specs
,

926 
pose_s
 *
pose_desired
,

927 
actuator_ctl_s
 *
actuator_ctl
) {

928 
uint16_t
 
snap_parse_len
;

929 
uint16_t
 
snap_parse_num
;

930 
int8_t
 
sign_x_d
, 
sign_y_d
, 
sign_x
, 
sign_y
;

933 
actuator_ctl
->
f_roll
 =

934 
rollkp
*(
eulerRollActual
-
pose_desired
->
f_roll_d
) +

935 
rollkd
*
gyro_x_filt
*0.017 + 
trimRoll
;

936 
actuator_ctl
->
f_pitch
 =

937 
pitchkp
*(
eulerPitchActual
-
pose_desired
->
f_pitch_d
) +

938 
pitchkd
*
gyro_y_filt
*0.017 + 
trimPitch
;

939 
actuator_ctl
->
f_thrust
 =

940 (
t_sens
*(
pose_desired
->
spektrum_thrust
-
RAW_THRUST_BASELINE
)*0.1) + 
trimThrust
;

941 
actuator_ctl
->
f_yaw
 =

942 
y_sens
*(
pose_desired
->
spektrum_yaw
-
RAW_YAW_BASELINE
)*0.1 +

943 
trimYaw
 - 
yawkp
*
gyro_z_filt
*0.017;

945 
snap_parse_num
=0;

946 
snap_parse_len
=1;

947 while (
snap_parse_len
 < 
msg_specs
->
global_msg_len
) {

948 
snap_parse_len
 += 
msg_specs
->
len
[
snap_parse_num
]+1;

949 switch(
msg_specs
->
msg_type
[
snap_parse_num
]) {

950 case 
MSG_TYPE_ERROR
:

951 
actuator_ctl
->
f_roll
 = 0;

952 
actuator_ctl
->
f_pitch
 = 0;

953 
actuator_ctl
->
f_yaw
 = 0;

954 
actuator_ctl
->
f_thrust
 = 0;

956 case 
MSG_TYPE_NONE
:

957 
actuator_ctl
->
f_roll
 = 0;

958 
actuator_ctl
->
f_pitch
 = 0;

959 
actuator_ctl
->
f_yaw
 = 0;

960 
actuator_ctl
->
f_thrust
 = 0;

962 case 
MSG_TYPE_KILL
:

963 case 
MSG_TYPE_SPEKTRUM
:

967 case 
MSG_TYPE_THRUST
:

969 case 
MSG_TYPE_VISION_POS
:

970 case 
MSG_TYPE_LOCAL_POS
:

971 case 
MSG_TYPE_SETPOINT
:

973 
_pos_x_fb
 = 
pose_desired
->
gains
.
k
[0]*pose_desired->
x_e
 +

974 
pose_desired
->
gains
.
k
[3]*pose_desired->
vx_e
;

975 
_pos_y_fb
 = 
pose_desired
->
gains
.
k
[1]*pose_desired->
y_e
 +

976 
pose_desired
->
gains
.
k
[4]*pose_desired->
vy_e
;

979 if (
_pos_x_fb
 > 
POS_FB_LIM
) _pos_x_fb = POS_FB_LIM;

980 if (
_pos_x_fb
 < -
POS_FB_LIM
) _pos_x_fb = -POS_FB_LIM;

981 if (
_pos_y_fb
 > 
POS_FB_LIM
) _pos_y_fb = POS_FB_LIM;

982 if (
_pos_y_fb
 < -
POS_FB_LIM
) _pos_y_fb = -POS_FB_LIM;

984 
actuator_ctl
->
f_roll
 += 
_pos_y_fb
;

985 
actuator_ctl
->
f_pitch
 += 
_pos_x_fb
;

986 
actuator_ctl
->
f_thrust
 += 0;

987 
actuator_ctl
->
f_yaw
 += 0;

992 
snap_parse_num
++;

996 
actuator_ctl
->
thrust
 =

997 (int)(
actuator_ctl
->
f_thrust
);

998 
actuator_ctl
->
roll
 =

999 (int)(
actuator_ctl
->
f_roll
);

1000 
actuator_ctl
->
pitch
 =

1001 (int)(
actuator_ctl
->
f_pitch
);

1002 
actuator_ctl
->
yaw
 =

1003 (int)(
actuator_ctl
->
f_yaw
);

1004 
	}
}

1006 void 
	$check_header
(

1007 
rx_xbee
 *
snap_buf_rx
,

1008 
msg_specs_s
 *
specs
,

1009 
uint16_t
 
idx
,

1010 
uint16_t
 
msg_num
) {

1011 if (
snap_buf_rx
->
data
[
idx
+
SERIAL_HEADER_MSG_TYPE
+1] ==

1012 
SERIAL_HEADER_ASSURANCE_BYTE
 &&

1013 
snap_buf_rx
->
data
[
idx
+
SERIAL_HEADER_MSG_TYPE
+2] ==

1014 
SERIAL_HEADER_ASSURANCE_BYTE
) {

1015 
specs
->
len
[
msg_num
] =

1016 
snap_buf_rx
->
data
[
idx
+
SERIAL_HEADER_MSG_LEN
];

1017 
specs
->
msg_type
[
msg_num
] =

1018 
snap_buf_rx
->
data
[
idx
+
SERIAL_HEADER_MSG_TYPE
];

1020 
specs
->
len
[
msg_num
] = 0;

1021 
specs
->
msg_type
[
msg_num
] = 
MSG_TYPE_ERROR
;

1023 
	}
}

1025 void 
	$combine_bytes
(void *
ret
,

1026 char *
bytes
,

1027 
uint8_t
 
len
,

1028 
bool
 
sig_byte_first
,

1029 
bool
 
signed_int
) {

1030 
int64_t
 
ret_tmp_64
 = 0;

1031 
uint64_t
 
uret_tmp_64
 = 0;

1032 
int32_t
 
ret_tmp_32
 = 0;

1033 
uint32_t
 
uret_tmp_32
 = 0;

1034 
int16_t
 
ret_tmp_16
 = 0;

1035 
uint16_t
 
uret_tmp_16
 = 0;

1036 
int8_t
 
ret_tmp_8
 = 0;

1037 
uint8_t
 
uret_tmp_8
 = 0;

1038 int 
i
;

1040 for (
i
=0; i < 
len
; i++) {

1041 if (
sig_byte_first
) {

1042 if (
signed_int
) {

1043 switch (
len
) {

1045 
ret_tmp_64
 += ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1048 
ret_tmp_32
 += ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1051 
ret_tmp_16
 += ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1054 
ret_tmp_8
 += ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1060 switch (
len
) {

1062 
uret_tmp_64
 |= ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1065 
uret_tmp_32
 |= ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1068 
uret_tmp_16
 |= ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1071 
uret_tmp_8
 |= ((
uint8_t
)(*
bytes
) << (8*(
len
-
i
-1)));

1076 if (
signed_int
) {

1077 switch (
len
) {

1079 
ret_tmp_64
 += ((
uint8_t
)(*
bytes
) << (8*
i
));

1082 
ret_tmp_32
 += ((
uint8_t
)(*
bytes
) << (8*
i
));

1085 
ret_tmp_16
 += ((
uint8_t
)(*
bytes
) << (8*
i
));

1088 
ret_tmp_8
 += ((
uint8_t
)(*
bytes
) << (8*
i
));

1094 switch (
len
) {

1096 
uret_tmp_64
 |= ((
uint8_t
)(*
bytes
) << (8*
i
));

1099 
uret_tmp_32
 |= ((
uint8_t
)(*
bytes
) << (8*
i
));

1102 
uret_tmp_16
 |= ((
uint8_t
)(*
bytes
) << (8*
i
));

1105 
uret_tmp_8
 |= ((
uint8_t
)(*
bytes
) << (8*
i
));

1111 
bytes
++;

1114 if (
signed_int
) {

1115 switch (
len
) {

1117 *((
int64_t
 *)
ret
) = (int64_t)
ret_tmp_64
;

1120 *((
int32_t
 *)
ret
) = (int32_t)
ret_tmp_32
;

1123 *((
int16_t
 *)
ret
) = (int16_t)
ret_tmp_16
;

1126 *((
int8_t
 *)
ret
) = (int8_t)
ret_tmp_8
;

1130 switch (
len
) {

1132 *((
uint64_t
 *)
ret
) = (uint64_t)
uret_tmp_64
;

1135 *((
uint32_t
 *)
ret
) = (uint32_t)
uret_tmp_32
;

1138 *((
uint16_t
 *)
ret
) = (uint16_t)
uret_tmp_16
;

1141 *((
uint8_t
 *)
ret
) = (uint8_t)
uret_tmp_8
;

1145 
	}
}

1147 static void 
	$actuator_ftoi
(
actuator_ctl_s
 *
ctl
) {

1148 
ctl
->
thrust
 =

1149 (int)
ctl
->
f_thrust
;

1150 
ctl
->
roll
 =

1151 (int)
ctl
->
f_roll
;

1152 
ctl
->
pitch
 =

1153 (int)
ctl
->
f_pitch
;

1154 
ctl
->
yaw
 =

1155 (int)
ctl
->
f_yaw
;

1156 
	}
}

1158 static void 
	$actuator_itof
(
actuator_ctl_s
 *
ctl
) {

1159 
ctl
->
f_thrust
 =

1160 (float)
ctl
->
thrust
;

1161 
ctl
->
f_roll
 =

1162 (float)
ctl
->
roll
;

1163 
ctl
->
f_pitch
 =

1164 (float)
ctl
->
pitch
;

1165 
ctl
->
f_yaw
 =

1166 (float)
ctl
->
yaw
;

1167 
	}
}

	@src/debug.c

7 #include 
	~<stdarg.h
>

8 #include 
	~<ctype.h
>

9 #include 
	~<stdio.h
>

11 #include 
	~"FreeRTOS.h
"

12 #include 
	~"task.h
"

13 #include 
	~"queue.h
"

14 #include 
	~"semphr.h
"

16 #include 
	~"stm32f4xx.h
"

19 #include 
	~"debug.h
"

24 void 
vNum2String
( char *
s
, 
uint8_t
 *
pPos
, 
uint32_t
 
u32Number
, uint8_t 
u8Base
);

27 #define 
	#DEBUG_QUEUE_SIZE
 128

	)

28 
xQueueHandle
 
	gxDebugQueue
;

30 extern 
xTaskHandle
 
hDebugTask
;

36 void 
	$vDebugInitQueue
( void ) {

37 
xDebugQueue
 = 
	`xQueueCreate
( 
DEBUG_QUEUE_SIZE
, sizeof( char ) );

38 
	}
}

41 
	$portTASK_FUNCTION
( 
vDebugTask
, 
pvParameters
 ) {

42 char 
ch
;

43 
portBASE_TYPE
 
xStatus
;

47 ( void ) 
pvParameters
;

55 if( 
	`USART_GetFlagStatus
( 
USART2
, 
USART_FLAG_TXE
 ) ) {

59 
xStatus
 = 
	`xQueueReceive
( 
xDebugQueue
, &
ch
, 10);

60 if( 
xStatus
 == 
pdPASS
 )

66 
	`USART_SendData
( 
USART2
, 
ch
 );

73 
	`taskYIELD
();

75 
	}
}

83 void 
	$vDebugString
( char *
s
 ) {

84 
portBASE_TYPE
 
xStatus
;

88 
	`taskENTER_CRITICAL
();

89 while ( *
s
 ) {

90 
xStatus
 = 
	`xQueueSendToBack
( 
xDebugQueue
, 
s
++, 0 );

91 if ( 
xStatus
 == 
errQUEUE_FULL
 ) break;

93 
	`taskEXIT_CRITICAL
();

94 
	}
}

98 void 
	$vDebugPrintResetType
( void ) {

100 if ( 
	`PWR_GetFlagStatus
( 
PWR_FLAG_WU
 ) )

101 
	`vDebugPrintf
( "PWR: Wake Up flag\r\n" );

102 if ( 
	`PWR_GetFlagStatus
( 
PWR_FLAG_SB
 ) )

103 
	`vDebugPrintf
( "PWR: StandBy flag.\r\n" );

104 if ( 
	`PWR_GetFlagStatus
( 
PWR_FLAG_PVDO
 ) )

105 
	`vDebugPrintf
( "PWR: PVD Output.\r\n" );

109 if ( 
	`RCC_GetFlagStatus
( 
RCC_FLAG_PINRST
 ) )

110 
	`vDebugPrintf
( "RCC: Pin reset.\r\n" );

111 if ( 
	`RCC_GetFlagStatus
( 
RCC_FLAG_PORRST
 ) )

112 
	`vDebugPrintf
( "RCC: POR/PDR reset.\r\n" );

113 if ( 
	`RCC_GetFlagStatus
( 
RCC_FLAG_SFTRST
 ) )

114 
	`vDebugPrintf
( "RCC: Software reset.\r\n" );

115 if ( 
	`RCC_GetFlagStatus
( 
RCC_FLAG_IWDGRST
 ) )

116 
	`vDebugPrintf
( "RCC: Independent Watchdog reset.\r\n" );

117 if ( 
	`RCC_GetFlagStatus
( 
RCC_FLAG_WWDGRST
 ) )

118 
	`vDebugPrintf
( "RCC: Window Watchdog reset.\r\n" );

119 if ( 
	`RCC_GetFlagStatus
( 
RCC_FLAG_LPWRRST
 ) )

120 
	`vDebugPrintf
( "RCC: Low Power reset.\r\n" );

121 
	}
}

128 void 
	$vDebugPrintf
(const char *
fmt
, ...) {

129 char 
sTmp
[80];

130 
uint8_t
 
pos
=0;

131 char *
bp
 = (char *)
fmt
;

132 
va_list
 
ap
;

133 char 
c
;

134 char *
p
;

135 int 
i
;

137 
	`va_start
(
ap
, 
fmt
);

139 while ((
c
 = *
bp
++)) {

140 if (
c
 != '%') {

141 
sTmp
[
pos
++] = 
c
;

145 switch ((
c
 = *
bp
++)) {

148 
	`vNum2String
( 
sTmp
, &
pos
, 
	`va_arg
(
ap
, 
uint32_t
), 10);

153 
sTmp
[
pos
++] = '0';

154 
sTmp
[
pos
++] = 'x';

155 
	`vNum2String
( 
sTmp
, &
pos
, 
	`va_arg
(
ap
, 
uint32_t
), 16);

160 
sTmp
[
pos
++] = '0';

161 
sTmp
[
pos
++] = 'b';

162 
	`vNum2String
( 
sTmp
, &
pos
, 
	`va_arg
(
ap
, 
uint32_t
), 2);

167 
sTmp
[
pos
++] = 
	`va_arg
(
ap
, int);

172 
i
 = 
	`va_arg
(
ap
, 
int32_t
);

173 if(
i
 < 0){

174 
sTmp
[
pos
++] = '-';

175 
	`vNum2String
( 
sTmp
, &
pos
, (~
i
)+1, 10);

177 
	`vNum2String
( 
sTmp
, &
pos
, 
i
, 10);

183 
p
 = 
	`va_arg
(
ap
, char *);

185 
sTmp
[
pos
++] = *
p
++;

186 } while (*
p
);

191 
sTmp
[
pos
++] = '%';

196 
sTmp
[
pos
++] = '?';

200 
sTmp
[
pos
++] = 0;

201 
	`vDebugString
( 
sTmp
 );

203 
	}
}

208 void 
	$vNum2String
( char *
s
, 
uint8_t
 *
pPos
, 
uint32_t
 
u32Number
, uint8_t 
u8Base
) {

210 char 
buf
[33];

211 char *
p
 = 
buf
 + 33;

212 
uint32_t
 
c
, 
n
;

214 *--
p
 = '\0';

216 
n
 = 
u32Number
 / 
u8Base
;

217 
c
 = 
u32Number
 - (
n
 * 
u8Base
);

218 if (
c
 < 10) {

219 *--
p
 = '0' + 
c
;

221 *--
p
 = 'a' + (
c
 - 10);

223 
u32Number
 /= 
u8Base
;

224 } while (
u32Number
 != 0);

226 while (*
p
){

227 
s
[ *
pPos
 ] = *
p
;

228 *
pPos
 += 1;

229 
p
++;

232 
	}
}

	@src/debug.h

8 #ifndef 
DEBUG_H_


9 #define 
	#DEBUG_H_


	)

11 void 
vDebugInitQueue
( void );

12 void 
vDebugString
( char *
s
 );

13 void 
vDebugPrintf
(const char *
fmt
, ...);

14 void 
vDebugPrintResetType
( void );

	@src/hw_config.c

23 #include 
	~"hw_config.h
"

25 volatile 
uint16_t
 
	gADCConvertedValues
[2];

29 void 
	$prvSetupHardware
( void )

32 
	`NVIC_SetVectorTable
( 
NVIC_VectTab_FLASH
, 0x0 );

33 
	`NVIC_PriorityGroupConfig
( 
NVIC_PriorityGroup_4
 );

37 
	`prvLED_Config
(
GPIO
);

46 
	}
}

48 void 
	$prvLED_Config
(char 
state
)

50 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

52 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOC
 | 
RCC_AHB1Periph_GPIOD
, 
ENABLE
);

54 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_2
| 
GPIO_Pin_3
;

55 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

56 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_100MHz
;

57 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_NOPULL
;

64 if(
state
==
GPIO
)

67 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_OUT
;

68 
	`GPIO_Init
(
GPIOC
, &
GPIO_InitStructure
);

75 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_12
 | 
GPIO_Pin_13
 | 
GPIO_Pin_14
 | 
GPIO_Pin_15
;

76 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

77 
	`GPIO_Init
(
GPIOD
, &
GPIO_InitStructure
);

80 
	`GPIO_PinAFConfig
(
GPIOD
, 
GPIO_PinSource12
, 
GPIO_AF_TIM4
);

81 
	`GPIO_PinAFConfig
(
GPIOD
, 
GPIO_PinSource13
, 
GPIO_AF_TIM4
);

82 
	`GPIO_PinAFConfig
(
GPIOD
, 
GPIO_PinSource14
, 
GPIO_AF_TIM4
);

83 
	`GPIO_PinAFConfig
(
GPIOD
, 
GPIO_PinSource15
, 
GPIO_AF_TIM4
);

85 
	}
}

88 void 
	$prvMEMS_Config
(void)

90 
uint8_t
 
ctrl
 = 0;

91 
uint32_t
 
i
=0;

93 
LIS302DL_InitTypeDef
 
LIS302DL_InitStruct
;

94 
LIS302DL_InterruptConfigTypeDef
 
LIS302DL_InterruptStruct
;

97 
LIS302DL_InitStruct
.
Power_Mode
 = 
LIS302DL_LOWPOWERMODE_ACTIVE
;

98 
LIS302DL_InitStruct
.
Output_DataRate
 = 
LIS302DL_DATARATE_100
;

99 
LIS302DL_InitStruct
.
Axes_Enable
 = 
LIS302DL_X_ENABLE
 | 
LIS302DL_Y_ENABLE
 | 
LIS302DL_Z_ENABLE
;

100 
LIS302DL_InitStruct
.
Full_Scale
 = 
LIS302DL_FULLSCALE_2_3
;

101 
LIS302DL_InitStruct
.
Self_Test
 = 
LIS302DL_SELFTEST_NORMAL
;

102 
	`LIS302DL_Init
(&
LIS302DL_InitStruct
);

105 
LIS302DL_InterruptStruct
.
Latch_Request
 = 
LIS302DL_INTERRUPTREQUEST_LATCHED
;

106 
LIS302DL_InterruptStruct
.
SingleClick_Axes
 = 
LIS302DL_CLICKINTERRUPT_Z_ENABLE
;

107 
LIS302DL_InterruptStruct
.
DoubleClick_Axes
 = 
LIS302DL_DOUBLECLICKINTERRUPT_Z_ENABLE
;

108 
	`LIS302DL_InterruptConfig
(&
LIS302DL_InterruptStruct
);

112 for(
i
=0;i<0x1FFFF;i++);

115 
ctrl
 = 0x07;

116 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CTRL_REG3_ADDR
, 1);

119 
ctrl
 = 0x70;

120 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CLICK_CFG_REG_ADDR
, 1);

123 
ctrl
 = 0xAA;

124 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CLICK_THSY_X_REG_ADDR
, 1);

127 
ctrl
 = 0x0A;

128 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CLICK_THSZ_REG_ADDR
, 1);

131 
ctrl
 = 0x03;

132 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CLICK_TIMELIMIT_REG_ADDR
, 1);

135 
ctrl
 = 0x7F;

136 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CLICK_LATENCY_REG_ADDR
, 1);

139 
ctrl
 = 0x7F;

140 
	`LIS302DL_Write
(&
ctrl
, 
LIS302DL_CLICK_WINDOW_REG_ADDR
, 1);

141 
	}
}

148 
uint32_t
 
	$LIS302DL_TIMEOUT_UserCallback
(void)

154 
	}
}

156 void 
	$prvTIM4_Config
(void)

158 
uint16_t
 
PrescalerValue
 = 0;

159 
TIM_OCInitTypeDef
 
TIM_OCInitStructure
;

160 
TIM_TimeBaseInitTypeDef
 
TIM_TimeBaseStructure
;

164 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_TIM4
, 
ENABLE
);

198 
PrescalerValue
 = (
uint16_t
) ((
SystemCoreClock
 /2) / 28000000) - 1;

201 
TIM_TimeBaseStructure
.
TIM_Period
 = 665;

202 
TIM_TimeBaseStructure
.
TIM_Prescaler
 = 
PrescalerValue
;

203 
TIM_TimeBaseStructure
.
TIM_ClockDivision
 = 0;

204 
TIM_TimeBaseStructure
.
TIM_CounterMode
 = 
TIM_CounterMode_Up
;

205 
	`TIM_TimeBaseInit
(
TIM4
, &
TIM_TimeBaseStructure
);

208 
	`TIM_ARRPreloadConfig
(
TIM4
, 
ENABLE
);

211 
TIM_OCInitStructure
.
TIM_OCMode
 = 
TIM_OCMode_PWM1
;

212 
TIM_OCInitStructure
.
TIM_OutputState
 = 
TIM_OutputState_Enable
;

213 
TIM_OCInitStructure
.
TIM_Pulse
 = 
TIM_CCR
;

214 
TIM_OCInitStructure
.
TIM_OCPolarity
 = 
TIM_OCPolarity_High
;

217 
	`TIM_OC1Init
(
TIM4
, &
TIM_OCInitStructure
);

218 
	`TIM_CCxCmd
(
TIM4
, 
TIM_Channel_1
, 
DISABLE
);

220 
	`TIM_OC1PreloadConfig
(
TIM4
, 
TIM_OCPreload_Enable
);

223 
	`TIM_OC2Init
(
TIM4
, &
TIM_OCInitStructure
);

224 
	`TIM_CCxCmd
(
TIM4
, 
TIM_Channel_2
, 
DISABLE
);

226 
	`TIM_OC2PreloadConfig
(
TIM4
, 
TIM_OCPreload_Enable
);

229 
	`TIM_OC3Init
(
TIM4
, &
TIM_OCInitStructure
);

230 
	`TIM_CCxCmd
(
TIM4
, 
TIM_Channel_3
, 
DISABLE
);

232 
	`TIM_OC3PreloadConfig
(
TIM4
, 
TIM_OCPreload_Enable
);

235 
	`TIM_OC4Init
(
TIM4
, &
TIM_OCInitStructure
);

236 
	`TIM_CCxCmd
(
TIM4
, 
TIM_Channel_4
, 
DISABLE
);

238 
	`TIM_OC4PreloadConfig
(
TIM4
, 
TIM_OCPreload_Enable
);

239 
	}
}

241 void 
	$USART3Init
(
uint32_t
 
baudrate
)

243 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

244 
USART_InitTypeDef
 
USART_InitStructure
;

246 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_USART3
, 
ENABLE
);

249 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOC
, 
ENABLE
);

253 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_10
 | 
GPIO_Pin_11
;

254 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

255 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

256 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

257 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

258 
	`GPIO_Init
(
GPIOC
, &
GPIO_InitStructure
);

265 
	`GPIO_PinAFConfig
(
GPIOC
, 
GPIO_PinSource10
, 
GPIO_AF_USART3
);

266 
	`GPIO_PinAFConfig
(
GPIOC
, 
GPIO_PinSource11
, 
GPIO_AF_USART3
);

270 
USART_InitStructure
.
USART_BaudRate
 = 
baudrate
;

271 
USART_InitStructure
.
USART_WordLength
 = 
USART_WordLength_8b
;

272 
USART_InitStructure
.
USART_StopBits
 = 
USART_StopBits_1
;

273 
USART_InitStructure
.
USART_Parity
 = 
USART_Parity_No
;

274 
USART_InitStructure
.
USART_HardwareFlowControl
 = 
USART_HardwareFlowControl_None
;

275 
USART_InitStructure
.
USART_Mode
 = 
USART_Mode_Tx
 | 
USART_Mode_Rx
;

276 
	`USART_Init
(
USART3
, &
USART_InitStructure
);

279 
	`USART_ITConfig
(
USART3
, 
USART_IT_TXE
, 
DISABLE
);

280 
	`USART_ITConfig
(
USART3
, 
USART_IT_RXNE
, 
ENABLE
);

281 
	`USART_Cmd
(
USART3
, 
ENABLE
);

283 
	}
}

285 void 
	$USART1Init
(
uint32_t
 
baudrate
)

287 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

288 
USART_InitTypeDef
 
USART_InitStructure
;

290 
	`RCC_APB2PeriphClockCmd
(
RCC_APB2Periph_USART1
, 
ENABLE
);

293 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOA
, 
ENABLE
);

297 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_9
 | 
GPIO_Pin_10
;

298 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

299 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

300 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

301 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

302 
	`GPIO_Init
(
GPIOA
, &
GPIO_InitStructure
);

309 
	`GPIO_PinAFConfig
(
GPIOA
, 
GPIO_PinSource9
, 
GPIO_AF_USART1
);

310 
	`GPIO_PinAFConfig
(
GPIOA
, 
GPIO_PinSource10
, 
GPIO_AF_USART1
);

314 
USART_InitStructure
.
USART_BaudRate
 = 
baudrate
;

315 
USART_InitStructure
.
USART_WordLength
 = 
USART_WordLength_8b
;

316 
USART_InitStructure
.
USART_StopBits
 = 
USART_StopBits_1
;

317 
USART_InitStructure
.
USART_Parity
 = 
USART_Parity_No
;

318 
USART_InitStructure
.
USART_HardwareFlowControl
 = 
USART_HardwareFlowControl_None
;

319 
USART_InitStructure
.
USART_Mode
 = 
USART_Mode_Tx
 | 
USART_Mode_Rx
;

320 
	`USART_Init
(
USART1
, &
USART_InitStructure
);

323 
	`USART_ITConfig
(
USART1
, 
USART_IT_TXE
, 
DISABLE
);

324 
	`USART_ITConfig
(
USART1
, 
USART_IT_RXNE
, 
ENABLE
);

325 
	`USART_Cmd
(
USART1
, 
ENABLE
);

327 
	}
}

329 void 
	$init_tim
()

331 
TIM_TimeBaseInitTypeDef
 
TIM_TimeBaseStructure
;

332 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_TIM4
 , 
ENABLE
);

334 
	`TIM_TimeBaseStructInit
(&
TIM_TimeBaseStructure
);

335 
TIM_TimeBaseStructure
.
TIM_Prescaler
 = 
SystemCoreClock
/1000000 - 1;

336 
TIM_TimeBaseStructure
.
TIM_Period
 = 65535;

337 
TIM_TimeBaseStructure
.
TIM_CounterMode
 = 
TIM_CounterMode_Up
;

338 
	`TIM_TimeBaseInit
(
TIM4
, &
TIM_TimeBaseStructure
);

339 
	`TIM_Cmd
(
TIM4
, 
ENABLE
);

341 
	}
}

343 void 
	$USART2Init
(
uint32_t
 
baudrate
)

345 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

346 
USART_InitTypeDef
 
USART_InitStructure
;

348 
	`RCC_APB1PeriphClockCmd
(
RCC_APB1Periph_USART2
, 
ENABLE
);

351 
	`RCC_AHB1PeriphClockCmd
(
RCC_AHB1Periph_GPIOA
, 
ENABLE
);

355 
GPIO_InitStructure
.
GPIO_Pin
 = 
GPIO_Pin_2
 | 
GPIO_Pin_3
;

356 
GPIO_InitStructure
.
GPIO_Mode
 = 
GPIO_Mode_AF
;

357 
GPIO_InitStructure
.
GPIO_Speed
 = 
GPIO_Speed_50MHz
;

358 
GPIO_InitStructure
.
GPIO_OType
 = 
GPIO_OType_PP
;

359 
GPIO_InitStructure
.
GPIO_PuPd
 = 
GPIO_PuPd_UP
;

360 
	`GPIO_Init
(
GPIOA
, &
GPIO_InitStructure
);

367 
	`GPIO_PinAFConfig
(
GPIOA
, 
GPIO_PinSource2
, 
GPIO_AF_USART2
);

368 
	`GPIO_PinAFConfig
(
GPIOA
, 
GPIO_PinSource3
, 
GPIO_AF_USART2
);

372 
USART_InitStructure
.
USART_BaudRate
 = 
baudrate
;

373 
USART_InitStructure
.
USART_WordLength
 = 
USART_WordLength_8b
;

374 
USART_InitStructure
.
USART_StopBits
 = 
USART_StopBits_1
;

375 
USART_InitStructure
.
USART_Parity
 = 
USART_Parity_No
;

376 
USART_InitStructure
.
USART_HardwareFlowControl
 = 
USART_HardwareFlowControl_None
;

377 
USART_InitStructure
.
USART_Mode
 = 
USART_Mode_Tx
 | 
USART_Mode_Rx
;

378 
	`USART_Init
(
USART2
, &
USART_InitStructure
);

382 
	`USART_Cmd
(
USART2
, 
ENABLE
);

384 
	}
}

	@src/hw_config.h

2 #include 
	~"stm32f4xx.h
"

3 #include 
	~"stm32f4_discovery.h
"

4 #include 
	~"stm32f4_discovery_lis302dl.h
"

6 #ifndef 
HW_CONFIG_H


7 #define 
	#HW_CONFIG_H


	)

9 extern 
GPIO_InitTypeDef
 
GPIO_InitStructure
;

10 extern 
NVIC_InitTypeDef
 
NVIC_InitStructure
;

13 #define 
	#TIM_ARR
 ((
uint16_t
)1900)

	)

14 #define 
	#TIM_CCR
 ((
uint16_t
)100)

	)

17 #define 
	#GPIO
 0

	)

18 #define 
	#TIMER
 1

	)

20 void 
prvSetupHardware
( void );

21 void 
prvTIM4_Config
(void);

22 void 
prvMEMS_Config
(void);

23 void 
prvLED_Config
(char 
state
);

24 
uint32_t
 
LIS302DL_TIMEOUT_UserCallback
(void);

25 void 
USART3Init
( 
uint32_t
 
baudrate
 );

26 void 
USART2Init
( 
uint32_t
 
baudrate
 );

27 void 
USART1Init
(
uint32_t
 
baudrate
);

28 void 
init_tim
();

	@src/main.c

23 #include 
	~"stm32f4xx.h
"

24 #include 
	~"stm32f4xx_i2c.h
"

25 #include 
	~"mpu6050.h
"

26 #include 
	~"i2croutines.h
"

27 #include 
	~<stdbool.h
>

28 #include 
	~"imu.h
"

29 #include 
	~"adc.h
"

30 #include 
	~<stdio.h
>

35 #include 
	~"FreeRTOS.h
"

36 #include 
	~"task.h
"

37 #include 
	~"semphr.h
"

38 #include 
	~"FreeRTOSConfig.h
"

40 #include 
	~"hw_config.h
"

41 #include 
	~"motors.h
"

42 #include 
	~"stabilizer.h
"

43 #include 
	~"debug.h
"

44 #include 
	~"nrf24l01.h
"

45 #include 
	~"nRF24L01reg.h
"

46 #include 
	~"px4flow.h
"

47 #include 
	~"serial_tasks.h
"

56 #define 
	#DELAY
 10

	)

57 #define 
	#queueSIZE
 6

	)

58 
uint64_t
 
	gu64Ticks
=0;

59 
uint64_t
 
	gu64IdleTicks
=0;

60 
uint64_t
 
	gu64IdleTicksCnt
=0;

69 static void 
vLEDTask
( void *
pvParameters
 );

70 static void 
imuinit
();

71 static void 
stabilizerTask
(void* 
param
);

72 
portTASK_FUNCTION_PROTO
( 
vDebugTask
, 
pvParameters
 );

73 
portTASK_FUNCTION_PROTO
( 
vElkaRXAck
, 
pvParameters
 );

74 
portTASK_FUNCTION_PROTO
( 
vGetData
, 
pvParameters
 );

75 
portTASK_FUNCTION_PROTO
( 
vSpektrumchannel_DSMX
, 
pvParameters
 );

76 
portTASK_FUNCTION_PROTO
( 
vPx4_read
, 
pvParameters
 );

78 void 
nrfInitRXack
(void);

86 
xQueueHandle
 
	gxDebugQueue
;

87 
xQueueHandle
 
	gtx1Queue
,
	geulerqueue
,
	gspektrumqueue
;

88 
xQueueHandle
 
	gxDebugQueue
, 
	guartData
, 
	gadctransferQueue
;

89 
xSemaphoreHandle
 
	gdataRdy
, 
	gqueuewritten
;

92 
Axis3f
 
	ggyro
;

93 
Axis3f
 
	gacc
;

94 
Axis3i16
 
	ggyroMpu
;

95 
Axis3i16
 
	gaccelMpu
;

96 struct 
	sSpektrumStateStruct


98 
uint8_t
 
	mLostFrame_cnt
;

99 
uint8_t
 
	mSync
;

100 
uint8_t
 
	mChannelCnt
;

101 
uint8_t
 
	mvalues
[14];

103 typedef struct 
SpektrumStateStruct
 
	tSpektrumStateType
;

104 int 
SpektrumParser_DSMX
(
uint8_t
 
c
, 
SpektrumStateType
* 
spektrum_state
);

105 
SpektrumStateType
 
	gPrimarySpektrumState
 = {0,0,0,{0}};

106 int 
	gchanneldata
[7];

107 
uint16_t
 
	gspektrumchannel
[7];

108 
i2c_frame
 
	gpx4_test
;

110 int 
	gchannelnum
;

111 int 
	gspektrum_check
;

113 static const int 
	gLEDS
[4][2] = {{
LED3
,
DELAY
*1},

114 {
LED4
,
DELAY
*2},

115 {
LED5
,
DELAY
*3},

116 {
LED6
,
DELAY
*4}};

119 
xSemaphoreHandle
 
	gxSemaphoreSW
 = 
NULL
;

120 
xQueueHandle
 
	gxQueue
;

122 static void 
	$interruptCallback
()

124 
portBASE_TYPE
 
xHigherPriorityTaskWoken
 = 
pdFALSE
;

126 
	`xSemaphoreGiveFromISR
(
dataRdy
, &
xHigherPriorityTaskWoken
);

127 if(
xHigherPriorityTaskWoken
)

128 
	`vPortYieldFromISR
();

129 
	}
}

134 
imubytes
 
	gimudata
;

136 
int16_t
 
	gaxi16
, 
	gayi16
, 
	gazi16
;

137 
int16_t
 
	ggxi16
 = 0, 
	ggyi16
 = 0, 
	ggzi16
 = 0;

142 int 
	$main
(void)

146 
	`prvSetupHardware
();

148 
	`vDebugInitQueue
();

150 
	`USART1Init
(38400);

151 
	`USART3Init
(38400);

152 
	`rosSerialInit
();

153 int 
j
;

154 for(
j
=0;j<1000000;j++);

157 
	`nrfInit
();

158 
	`nrfInitRxAck
();

159 
	`nrfSetInterruptCallback
(
interruptCallback
);

161 
	`NVIC_Configuration
();

162 
	`vSemaphoreCreateBinary
(
dataRdy
);

163 
	`vSemaphoreCreateBinary
(
queuewritten
);

164 
tx1Queue
 = 
	`xQueueCreate
(3,sizeof(
rxpacket
));

165 
eulerqueue
 = 
	`xQueueCreate
(3,sizeof(
eulerstruct
));

166 
uartData
 = 
	`xQueueCreate
(40, sizeof(
uint8_t
));

171 int 
i
;

172 
uint16_t
 
ratio
;

173 
uint8_t
 
data
;

182 
	`xTaskCreate
( 
vGetData
, 
NULL
, 130, NULL, 1, NULL );

189 
	`stabilizerInit
();

190 
	`vTaskStartScheduler
();

194 
	}
}

197 void 
	$vLEDTask
( void *
pvParameters
 )

199 volatile int *
LED
;

200 
LED
 = (int *) 
pvParameters
;

201 
bool
 
i
;

202 
uint16_t
 
ratio
;

203 
uint8_t
 
data
;

204 
uint8_t
 
buffer
[14];

206 
int16_t
 
ax
,
ay
,
az
,
gx
,
gy
,
gz
;

216 
	`STM_EVAL_LEDToggle
(
LED3
);

224 
	`vTaskDelay
(1000);

226 
	}
}

228 void 
	$vPx4_read
( void *
pvParameters
 )

230 static int 
status
=1;

235 
	`readx1
(
I2C2
, &
px4_test
,
PX4_ADDRESS
,
status
);

237 
	`STM_EVAL_LEDToggle
(
LED3
);

238 
	`vTaskDelay
(10);

240 
	}
}

242 
	$portTASK_FUNCTION
 (
vGetData
, 
pvParameters
)

245 volatile unsigned long 
i
;

246 
uint32_t
 
xlastWakeTime1
;

247 
portTickType
 
xLastWakeTime1
;

248 
xLastWakeTime1
 = 
	`xTaskGetTickCount
();

250 static int 
led1_state
 = 0;

251 
rxpacket
 
test
;

252 
eulerstruct
 
eulerdata
;

253 
uint8_t
 
ubyte
, 
lbyte
;

254 
adcstruct
 
press_sens
;

255 int 
counter
 = 0;

257 
rx_xbee
 
test1
;

266 
	`xQueueReceive
(
eulerqueue
,&
eulerdata
,0);

267 
gxi16
 = (int)(100*
gyro
.
x
);

268 
gyi16
 = (int)(100*
gyro
.
y
);

269 
gzi16
 = (int)(100*
gyro
.
z
);

270 
axi16
 = (int)(100*
acc
.
x
);

271 
ayi16
 = (int)(100*
acc
.
y
);

272 
azi16
 = (int)(100*
acc
.
z
);

275 
imudata
.
gyrobytes
[0] = (
gxi16
>>8)&(0xff);

276 
imudata
.
gyrobytes
[1] = (
gxi16
)&(0xff);

277 
imudata
.
gyrobytes
[2] = (
gyi16
>>8)&(0xff);

278 
imudata
.
gyrobytes
[3] = (
gyi16
)&(0xff);

279 
imudata
.
gyrobytes
[4] = (
gzi16
>>8)&(0xff);

280 
imudata
.
gyrobytes
[5] = (
gzi16
)&(0xff);

289 
imudata
.
eulerangles
[0] = (
euler
.
data
[0]>>8)&(0xff);

290 
imudata
.
eulerangles
[1] = (
euler
.
data
[0])&(0xff);

291 
imudata
.
eulerangles
[2] = (
euler
.
data
[1]>>8)&(0xff);

292 
imudata
.
eulerangles
[3] = (
euler
.
data
[1])&(0xff);

296 
imudata
.
commanded
[0] = (
euler
.
data
[3]>>8)&(0xff);

297 
imudata
.
commanded
[1] = (
euler
.
data
[3])&(0xff);

298 
imudata
.
commanded
[2] = (
euler
.
data
[4]>>8)&(0xff);

299 
imudata
.
commanded
[3] = (
euler
.
data
[4])&(0xff);

300 
imudata
.
commanded
[4] = (
euler
.
data
[5]>>8)&(0xff);

301 
imudata
.
commanded
[5] = (
euler
.
data
[5])&(0xff);

302 
imudata
.
commanded
[6] = (
euler
.
data
[6]>>8)&(0xff);

303 
imudata
.
commanded
[7] = (
euler
.
data
[6])&(0xff);

306 
imudata
.
commanded
[8] = (
euler
.
data
[7]>>8)&(0xff);

307 
imudata
.
commanded
[9] = (
euler
.
data
[7])&(0xff);

308 
imudata
.
commanded
[10] = (
euler
.
data
[8]>>8)&(0xff);

309 
imudata
.
commanded
[11] =(
euler
.
data
[8])&(0xff);

310 
imudata
.
commanded
[12] = (
euler
.
data
[9]>>8)&(0xff);

311 
imudata
.
commanded
[13] = (
euler
.
data
[9])&(0xff);

312 
imudata
.
commanded
[14] = (
euler
.
data
[10]>>8)&(0xff);

313 
imudata
.
commanded
[15] = (
euler
.
data
[10])&(0xff);

324 
imudata
.
commanded
[16] = (
euler
.
data
[11]>>8)&(0xff);

325 
imudata
.
commanded
[17] = (
euler
.
data
[11])&(0xff);

326 
imudata
.
commanded
[18] = (
euler
.
data
[12]>>8)&(0xff);

327 
imudata
.
commanded
[19] = (
euler
.
data
[12])&(0xff);

332 
	`STM_EVAL_LEDToggle
(
LED3
);

333 
	`vTaskDelay
(10);

335 
	}
}

338 
	$portTASK_FUNCTION
 (
vElkaRXAck
, 
pvParameters
)

340 
portTickType
 
xLastWakeTime
;

341 
xLastWakeTime
 = 
	`xTaskGetTickCount
();

342 
uint8_t
 
counter
 = 0;

343 char *
receive
;

344 unsigned char 
bytereceived
[5];

345 
receive
 = &
bytereceived
[0];

346 int 
led1_state
 = 0;

347 int 
i
, 
status
;

348 
uint8_t
 
status1
, 
status2
;

349 char 
id1
,
id2
,
id3
,
id4
, 
id5
;

350 static 
rxpacket
 
pk
, 
pknoreceive
;

351 unsigned char 
dataLen
;

352 for (
i
=0;i<
TX_PAYLOAD_WIDTH
; i++)

354 
pknoreceive
.
data
[
i
] = 0;

357 int *
test
;

361 
	`xSemaphoreTake
(
dataRdy
, 
portMAX_DELAY
);

363 
	`nrfSetEnable
(
false
);

364 if (
	`nrfRead1Reg
(
REG_FIFO_STATUS
)&2)

366 
	`nrfFlushRx
();

368 
status1
=
	`nrfRead1Reg
(
REG_STATUS
);

369 if ((
	`nrfRead1Reg
(
REG_FIFO_STATUS
)>>5)&1)

371 
	`nrfFlushTx
();

378 if ((
	`nrfRead1Reg
(
REG_STATUS
)>>6)&1)

381 
dataLen
 = 
	`nrfRxLength
(0);

382 
	`nrfReadRX
((char *)
pk
.
data
,
dataLen
);

383 
status2
 = 
	`nrfRead1Reg
(
REG_FIFO_STATUS
);

385 
	`nrfWriteAck
(0, &
imudata
,sizeof(imudata));

387 
	`xSemaphoreGive
(
queuewritten
);

389 
	`xQueueSendToBack
(
tx1Queue
,&
pk
,0);

392 else if ((
	`nrfRead1Reg
(
REG_STATUS
)>>6)&0)

394 
	`xQueueSendToBack
(
tx1Queue
,&
pknoreceive
,0);

398 
	`nrfWrite1Reg
(
REG_STATUS
, 0x70);

399 
	`nrfSetEnable
(
true
);

400 
	`vTaskDelay
(7);

401 
	`STM_EVAL_LEDToggle
(
LED3
);

403 
	}
}

405 
	$portTASK_FUNCTION
 (
vSpektrumchannel_DSMX
, 
pvParameters
)

407 volatile unsigned long 
i
;

408 
portTickType
 
xLastWakeTime
;

409 
xLastWakeTime
 = 
	`xTaskGetTickCount
();

410 static int 
led2_state
 = 0;

411 
uint8_t
 
c
;

412 int 
counter
 = 0;

413 
uint8_t
 
check
;

419 if (
	`xQueueReceive
(
uartData
, &
c
, 10000) == 
pdTRUE
)

422 
check
 = 
	`SpektrumParser_DSMX
(
c
, &
PrimarySpektrumState
);

428 if (
check
==3)

430 
counter
++;

432 if (
counter
>10)

434 
	`STM_EVAL_LEDToggle
(
LED3
);

435 
counter
=0;

437 for(
i
=0;i<7;i++)

439 
channeldata
[
i
] = (
PrimarySpektrumState
.
values
[2*i]<<8)|(PrimarySpektrumState.values[2*i+1]);

442 for (
i
=0;i<7;i++)

444 
channelnum
 = (
channeldata
[
i
] >> 11) & 0x0f;

445 
spektrumchannel
[
channelnum
] = 
channeldata
[
i
] & 0x7ff;

447 
spektrumchannel
[6] = 1;

451 else if (
check
 !=3)

458 
	}
}

460 void 
	$vApplicationMallocFailedHook
( void )

468 
	}
}

471 void 
	$vApplicationStackOverflowHook
( 
xTaskHandle
 *
pxTask
, signed char *
pcTaskName
 )

473 ( void ) 
pcTaskName
;

474 ( void ) 
pxTask
;

480 
	}
}

483 #ifdef 
USE_FULL_ASSERT


492 void 
	$assert_failed
(
uint8_t
* 
file
, 
uint32_t
 
line
)

501 
	}
}

504 void 
	$vApplicationTickHook
( void ) {

505 ++
u64Ticks
;

506 
	}
}

511 void 
	$vApplicationIdleHook
( void ) {

512 ++
u64IdleTicksCnt
;

513 
	}
}

516 void 
	$nrfInitRxAck
()

518 char 
radioAddress
[5] = {0x34,0x43,0x10,0x10,0x01};

521 
	`nrfSetAddress
(0, 
radioAddress
);

522 
	`nrfWriteReg
(
REG_TX_ADDR
, 
radioAddress
,5);

523 
	`nrfWrite1Reg
(
REG_SETUP_AW
,3);

525 
	`nrfWrite1Reg
(
REG_RX_PW_P0
,
TX_PAYLOAD_WIDTH
);

526 
	`nrfWrite1Reg
(
REG_EN_AA
,0x01);

527 
	`nrfWrite1Reg
(
REG_RF_CH
,40);

528 
	`nrfWrite1Reg
(
REG_EN_RXADDR
,0x01);

529 
	`nrfWrite1Reg
(
REG_RF_SETUP
,0x26);

530 
	`nrfWrite1Reg
(
REG_SETUP_RETR
,0x7a);

531 
	`nrfSetEnable
(
true
);

533 
	`nrfWrite1Reg
(
REG_FEATURE
, 0x06);

534 
	`nrfWrite1Reg
(
REG_DYNPD
, 0x01);

536 
	`nrfWrite1Reg
(
REG_CONFIG
, 0x3f);

537 
	}
}

539 static 
portBASE_TYPE
 
	gxHigherPriorityTaskWoken
;

571 int 
	$SpektrumParser_DSMX
(
uint8_t
 
c
, 
SpektrumStateType
* 
spektrum_state
)

573 int 
k
;

576 if (
c
==0xA2)

578 
spektrum_state
->
LostFrame_cnt
 = 
c
;

579 
spektrum_state
->
Sync
 = 1;

580 
spektrum_state
->
ChannelCnt
 = 0;

592 if (
spektrum_state
->
Sync
==1)

594 
spektrum_state
->
values
[spektrum_state->
ChannelCnt
] = 
c
;

595 
spektrum_state
->
ChannelCnt
++;

598 if (
spektrum_state
->
ChannelCnt
>=14 )

600 
spektrum_state
->
ChannelCnt
 = 0;

601 
spektrum_state
->
Sync
 = 3;

602 
spektrum_state
->
LostFrame_cnt
 = 0;

604 
k
 = 
spektrum_state
->
Sync
;

605 return 
k
;

607 
	}
}

609 void 
	$NVIC_Configuration
(void)

611 
NVIC_InitTypeDef
 
NVIC_InitStructure
;

617 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
USART1_IRQn
;

618 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 14;

619 
NVIC_InitStructure
.
NVIC_IRQChannelSubPriority
 = 0;

620 
NVIC_InitStructure
.
NVIC_IRQChannelCmd
 = 
ENABLE
;

621 
	`NVIC_Init
(&
NVIC_InitStructure
);

622 
NVIC_InitStructure
.
NVIC_IRQChannel
 = 
USART3_IRQn
;

623 
NVIC_InitStructure
.
NVIC_IRQChannelPreemptionPriority
 = 15;

624 
NVIC_InitStructure
.
NVIC_IRQChannelSubPriority
 = 0;

625 
NVIC_InitStructure
.
NVIC_IRQChannelCmd
 = 
ENABLE
;

626 
	`NVIC_Init
(&
NVIC_InitStructure
);

627 
	}
}

	@src/serial_tasks.c

8 #include 
	~<string.h
>

10 #include 
	~<serial_tasks.h
>

11 #include 
	~"stm32f4xx_conf.h
"

12 #include 
	~"FreeRTOS.h
"

13 #include 
	~"FreeRTOSConfig.h
"

14 #include 
	~"task.h
"

15 #include 
	~"math.h
"

16 #include 
	~"semphr.h
"

17 #include 
	~"stm32f4_discovery.h
"

18 #include 
	~"stabilizer.h
"

20 static void 
vLEDTask
( void *
pvParameters
 );

21 static void 
vSerialWrite
( void *
pvParameters
 );

22 
ROS_Type
 
	gPrimaryROSState
 = {0,{0}};

25 
inline
 
uint8_t
 
	$get_byte_n
(float 
f
,
uint8_t
 
n
,
bool
 
msbf
) {

26 if (
msbf
)

27 return ((int)
f
>>(4-
n
))&0xff;

29 return ((int)
f
>>
n
)&0xff;

30 
	}
}

32 
inline
 void 
	$pack_msg_header
(
uint8_t
 *
msg
,uint8_t 
msg_type
,uint8_t 
len
){

33 *
msg
=
msg_type
;

34 *(
msg
+1)=255;

35 *(
msg
+2)=255;

36 
	}
}

41 void 
	$send_floats
(
uint8_t
 
dst
,float *
f
,uint8_t 
num
) {

42 float 
f_curr
;

43 
uint8_t
 
global_msg_len
=4*
num
+
SERIAL_HEADER_LEN
;

44 static 
uint8_t
 
msg
[
MAX_MSG_LEN
];

45 static 
uint8_t
 
i
,
j
;

47 
msg
[0]=
global_msg_len
;

48 
	`pack_msg_header
(&(
msg
[1]),
MSG_TYPE_PD_GAINS
,4*
num
);

49 for (
i
=0; i<
num
;i++) {

50 
f_curr
=*(
f
+
i
);

51 for (
j
=0; j<4; j++) {

52 
msg
[
SERIAL_HEADER_DATA_OFFSET
+4*
i
+
j
]=
	`get_byte_n
(
f_curr
,j,
true
);

55 if (
dst
 == 
DST_SNAP
){

56 
	`memcpy
(
snap_buf_tx
.
data
,
msg
,
num
*4+
SERIAL_HEADER_LEN
);

58 
	}
}

60 void 
	$rosSerialInit
()

63 
	`xTaskCreate
( 
vLEDTask
, 
NULL
, 
configMINIMAL_STACK_SIZE
, NULL,
tskIDLE_PRIORITY
+1, NULL );

64 
	`xTaskCreate
( 
vSerialWrite
, 
NULL
, 
configMINIMAL_STACK_SIZE
, NULL,
tskIDLE_PRIORITY
+1, NULL );

66 
	}
}

68 void 
	$vLEDTask
( void *
pvParameters
 )

71 
portTickType
 
xLastWakeTime
;

72 
xLastWakeTime
 = 
	`xTaskGetTickCount
();

73 static int 
led2_state
 = 0;

75 
uint8_t
 
check
;

77 
uint8_t
 
i
=0;

78 char 
j
[20];

79 int 
txlen
;

80 
rx_xbee
 
dummy
;

81 
uint8_t
 
snap_index
 = 0;

83 
uint8_t
 
read_index
;

139 
	`vTaskDelay
(40);

142 
	}
}

144 void 
	$vSerialWrite
( void *
pvParameters
 )

147 
portTickType
 
xLastWakeTime
;

148 
xLastWakeTime
 = 
	`xTaskGetTickCount
();

149 static int 
led2_state
 = 0;

150 
uint8_t
 
c
;

151 
uint8_t
 
check
;

152 
uint8_t
 
dummy
[5] = {1,2,3,4,5};

153 
uint8_t
 
i
=0;

154 char 
j
[20], *
pos
 = j;

155 char 
buffer
[128];

156 char 
formattedints
[128];

157 int 
index
 = 0;

163 
	`sprintf
(
j
, "#,%d,%d,%d,",100,100,100);

179 while( !(
USART1
->
SR
 & 0x00000040) );

180 
	`USART_SendData
(
USART1
, '#');

181 
	`USART_puts1
(
USART1
, &
imudata
,30);

182 while( !(
USART1
->
SR
 & 0x00000040) );

183 
	`USART_SendData
(
USART1
, '\r');

184 while( !(
USART1
->
SR
 & 0x00000040) );

185 
	`USART_SendData
(
USART1
, '\n');

186 while( !(
USART3
->
SR
 & 0x00000040) );

187 
	`USART_SendData
(
USART3
, '\n');

188 
	`USART_puts1
(
USART3
,&
snap_buf_tx
,30);

192 
i
++;

193 if (
i
>100)

195 
i
=0;

202 
	`STM_EVAL_LEDToggle
(
LED4
);

203 
	`vTaskDelay
(40);

206 
	}
}

208 void 
	$USART1_IRQHandler
(void)

211 
uint8_t
 
b
;

212 static int 
counter
=0;

213 static int 
rx_buffer
 = 0;

214 static int 
tx_buffer
 = 0;

215 static 
portBASE_TYPE
 
xHigherPriorityTaskWoken
;

218 int 
txlen
;

220 int 
i
 =0;

221 
xHigherPriorityTaskWoken
 = 
pdFALSE
;

222 
uint8_t
 
tx_buf
[5]={1,2,3,4,5};

224 if (
	`USART_GetITStatus
(
USART1
, 
USART_IT_RXNE
))

227 
rx_buf
.
data
[
rx_buffer
++] = 
	`USART_ReceiveData
(
USART1
);

230 
txlen
 = 
rx_buf
.
data
[0];

231 if (
rx_buffer
>
txlen
)

233 
rx_buffer
 = 0;

243 
	`portEND_SWITCHING_ISR
( 
xHigherPriorityTaskWoken
 );

246 
	}
}

248 void 
	$USART3_IRQHandler
(void)

251 
uint8_t
 
b
;

252 static int 
counter
=0;

253 static int 
rx_buffer
 = 0;

254 static int 
tx_buffer
 = 0;

255 static 
portBASE_TYPE
 
xHigherPriorityTaskWoken
;

256 
rx_xbee
 
snap_temp
;

259 int 
txlen
;

261 int 
i
 =0;

262 
xHigherPriorityTaskWoken
 = 
pdFALSE
;

263 
uint8_t
 
tx_buf
[5]={1,2,3,4,5};

265 if (
	`USART_GetITStatus
(
USART3
, 
USART_IT_RXNE
))

268 
snap_buf_rx
.
data
[
rx_buffer
++] = 
	`USART_ReceiveData
(
USART3
);

271 
txlen
 = 
snap_buf_rx
.
data
[0];

272 if (
rx_buffer
>
txlen
)

274 
rx_buffer
 = 0;

287 
	`portEND_SWITCHING_ISR
( 
xHigherPriorityTaskWoken
 );

290 
	}
}

292 void 
	$USART_puts
(
USART_TypeDef
* 
USARTx
, volatile char *
s
){

294 while(*
s
){

296 while( !(
USARTx
->
SR
 & 0x00000040) );

297 
	`USART_SendData
(
USARTx
, *
s
);

298 *
s
++;

300 
	}
}

302 void 
	$USART_puts1
(
USART_TypeDef
* 
USARTx
, 
uint8_t
 *
data
, int 
length
){

304 int 
i
;

305 for (
i
=0;i<
length
;i++){

307 while( !(
USARTx
->
SR
 & 0x00000040) );

308 
	`USART_SendData
(
USARTx
, 
data
[
i
]);

311 
	}
}

313 char* 
	$format_uint_array
(char *
b
, 
uint8_t
* 
data
, int 
length
, char* 
delim
, char* 
fmt
)

315 int 
i
;

316 char 
s
[50];

317 
b
[0] = 0;

318 for( 
i
 = 0; i < 
length
; i++ )

320 
s
[0]=0;

321 
	`sprintf
( 
s
, 
fmt
, 
data
[
i
], (i<
length
-1)?
delim
 : "");

322 
	`strcat
(
b
, 
s
);

324 return 
b
;

325 
	}
}

327 int 
	$ROS_parser
(
uint8_t
* 
c
, 
ROS_Type
* 
ROS_state
)

329 int 
k
;

330 int 
txlen
;

331 int 
i
;

332 
txlen
 = 
c
[0];

333 if (
c
[1]==0)

335 
ROS_state
->
Sync
 = 1;

337 else if((
c
[2]==255) & (
ROS_state
->
Sync
==1))

339 
ROS_state
->
Sync
 = 2;

345 else if(
ROS_state
->
Sync
==2)

347 for (
i
=0;i<
txlen
-3;i++)

350 
ROS_state
->
values
[ROS_state->
ChannelCnt
] = 
c
[
i
+3];

351 
ROS_state
->
ChannelCnt
++;

353 if(
ROS_state
->
ChannelCnt
==8)

355 
ROS_state
->
Sync
 = 3;

356 
ROS_state
->
ChannelCnt
 = 0;

359 
k
 = 
ROS_state
->
Sync
;

360 return 
k
;

361 
	}
}

	@src/serial_tasks.h

8 #ifndef 
SERIAL_TASKS_H_


9 #define 
	#SERIAL_TASKS_H_


	)

11 #include 
	~<stdbool.h
>

12 #include 
	~<stdio.h
>

13 #include 
	~<stdint.h
>

14 #include 
	~"FreeRTOS.h
"

15 #include 
	~"FreeRTOSConfig.h
"

16 #include 
	~"task.h
"

17 #include 
	~"math.h
"

18 #include 
	~"semphr.h
"

20 #define 
	#SERIAL_HEADER_MSG_LEN
 0

	)

21 #define 
	#SERIAL_HEADER_MSG_TYPE
 1

	)

22 #define 
	#SERIAL_HEADER_DATA_OFFSET
 4

	)

25 #define 
	#SERIAL_HEADER_LOCAL_MSG_OFFSET
 1

	)

27 #define 
	#SERIAL_HEADER_LEN
 3

	)

28 #define 
	#SERIAL_HEADER_ASSURANCE_BYTE
 255

	)

30 #define 
	#MSG_TYPE_ERROR
 -1

	)

31 #define 
	#MSG_TYPE_NONE
 0

	)

32 #define 
	#MSG_TYPE_KILL
 1

	)

33 #define 
	#MSG_TYPE_SPEKTRUM
 2

	)

34 #define 
	#MSG_TYPE_VISION_POS
 3

	)

35 #define 
	#MSG_TYPE_LOCAL_POS
 4

	)

36 #define 
	#MSG_TYPE_SETPOINT
 5

	)

37 #define 
	#MSG_TYPE_THRUST
 6

	)

38 #define 
	#MSG_TYPE_PD_GAINS
 7

	)

41 #define 
	#DST_ELKA
 0

	)

42 #define 
	#DST_SNAP
 1

	)

43 #define 
	#DST_XBEE
 2

	)

46 #define 
	#MAX_MSG_LEN
 40

	)

48 void 
rosSerialInit
(void);

51 void 
send_floats
(
uint8_t
 
dst
,float *
f
,uint8_t 
num
);

56 
uint8_t
 
get_byte_n
(float 
f
,uint8_t 
n
,
bool
 
msbf
);

58 void 
pack_msg_header
(
uint8_t
 *
msg
,uint8_t 
msg_type
,uint8_t 
len
);

60 
uint16_t
 
	groschannel
[4];

62 struct 
	sPilot_ROS


64 
uint8_t
 
	mSync
;

65 
uint8_t
 
	mChannelCnt
;

66 
uint8_t
 
	mvalues
[8];

68 typedef struct 
Pilot_ROS
 
	tROS_Type
;

69 int 
ROS_parser
(
uint8_t
* 
c
, 
ROS_Type
* 
ROS_state
);

71 
xQueueHandle
 
	gtxQueue_xbee
;

75 
uint8_t
 
	mgyrobytes
[6];

77 
uint8_t
 
	meulerangles
[4];

78 
uint8_t
 
	mcommanded
[24];

79 }
	timubytes
;

81 
imubytes
 
	gimudata
;

83 #define 
	#RX_XBEE_DATA_LENGTH
 32

	)

88 
uint8_t
 
	mdata
[
RX_XBEE_DATA_LENGTH
];

89 } 
	trx_xbee
;

91 
rx_xbee
 
	grx_buf
,

92 
	gsnap_buf_rx
,

93 
	gsnap_buf_tx
;

	@src/stdbool.h

28 #ifndef 
_STDBOOL_H


29 #define 
	#_STDBOOL_H


	)

31 #ifndef 
__cplusplus


33 #define 
	#bool
 
_Bool


	)

34 #define 
	#true
 1

	)

35 #define 
	#false
 0

	)

36 #define 
	#TRUE
 1

	)

37 #define 
	#FALSE
 0

	)

42 #define 
	#_Bool
 
bool


	)

43 #define 
	#bool
 
bool


	)

44 #define 
	#false
 
false


	)

45 #define 
	#true
 
true


	)

50 #define 
	#__bool_true_false_are_defined
 1

	)

	@src/stm32f4xx_conf.h

27 #ifndef 
__STM32F4xx_CONF_H


28 #define 
	#__STM32F4xx_CONF_H


	)

31 #if 
defined
 (
HSE_VALUE
)

33 #undef 
HSE_VALUE


34 #define 
	#HSE_VALUE
 ((
uint32_t
)12000000)

	)

40 #include 
	~"stm32f4xx_adc.h
"

41 #include 
	~"stm32f4xx_can.h
"

42 #include 
	~"stm32f4xx_crc.h
"

43 #include 
	~"stm32f4xx_cryp.h
"

44 #include 
	~"stm32f4xx_dac.h
"

45 #include 
	~"stm32f4xx_dbgmcu.h
"

46 #include 
	~"stm32f4xx_dcmi.h
"

47 #include 
	~"stm32f4xx_dma.h
"

48 #include 
	~"stm32f4xx_exti.h
"

49 #include 
	~"stm32f4xx_flash.h
"

50 #include 
	~"stm32f4xx_fsmc.h
"

51 #include 
	~"stm32f4xx_hash.h
"

52 #include 
	~"stm32f4xx_gpio.h
"

53 #include 
	~"stm32f4xx_i2c.h
"

54 #include 
	~"stm32f4xx_iwdg.h
"

55 #include 
	~"stm32f4xx_pwr.h
"

56 #include 
	~"stm32f4xx_rcc.h
"

57 #include 
	~"stm32f4xx_rng.h
"

58 #include 
	~"stm32f4xx_rtc.h
"

59 #include 
	~"stm32f4xx_sdio.h
"

60 #include 
	~"stm32f4xx_spi.h
"

61 #include 
	~"stm32f4xx_syscfg.h
"

62 #include 
	~"stm32f4xx_tim.h
"

63 #include 
	~"stm32f4xx_usart.h
"

64 #include 
	~"stm32f4xx_wwdg.h
"

65 #include 
	~"misc.h
"

81 #ifdef 
USE_FULL_ASSERT


91 #define 
	#assert_param
(
expr
) ((expr) ? (void)0 : 
	`assert_failed
((
uint8_t
 *)
__FILE__
, 
__LINE__
))

	)

93 void 
assert_failed
(
uint8_t
* 
file
, 
uint32_t
 
line
);

95 #define 
	#assert_param
(
expr
) ((void)0)

	)

	@src/stm32f4xx_it.c

25 #include 
	~"stm32f4xx.h
"

26 #include 
	~"stm32f4xx_it.h
"

27 #include 
	~"FreeRTOS.h
"

28 #include 
	~"task.h
"

29 #include 
	~"semphr.h
"

35 extern 
xSemaphoreHandle
 
xSemaphoreSW
;

36 
portBASE_TYPE
 
	gxHigherPriorityTaskWoken
;

49 void 
	$NMI_Handler
(void)

51 
	}
}

58 void 
	$HardFault_Handler
(void)

64 
	}
}

71 void 
	$MemManage_Handler
(void)

77 
	}
}

84 void 
	$BusFault_Handler
(void)

90 
	}
}

97 void 
	$UsageFault_Handler
(void)

103 
	}
}

120 void 
	$DebugMon_Handler
(void)

122 
	}
}

161 void 
	$EXTI0_IRQHandler
(void)

163 
xHigherPriorityTaskWoken
 = 
pdFALSE
;

164 if(
	`EXTI_GetITStatus
(
EXTI_Line0
) != 
RESET
)

167 
	`xSemaphoreGiveFromISR
(
xSemaphoreSW
,&
xHigherPriorityTaskWoken
);

170 
	`EXTI_ClearITPendingBit
(
EXTI_Line0
);

171 
	`portEND_SWITCHING_ISR
(
xHigherPriorityTaskWoken
);

173 
	}
}

	@src/stm32f4xx_it.h

23 #ifndef 
__STM32F4xx_IT_H


24 #define 
	#__STM32F4xx_IT_H


	)

26 #ifdef 
__cplusplus


36 void 
NMI_Handler
(void);

37 void 
HardFault_Handler
(void);

38 void 
MemManage_Handler
(void);

39 void 
BusFault_Handler
(void);

40 void 
UsageFault_Handler
(void);

41 void 
SVC_Handler
(void);

42 void 
DebugMon_Handler
(void);

43 void 
PendSV_Handler
(void);

44 void 
SysTick_Handler
(void);

46 #ifdef 
__cplusplus


	@src/system_stm32f4xx.c

117 #include 
	~"stm32f4xx.h
"

142 #define 
	#VECT_TAB_OFFSET
 0x00

	)

159 #define 
	#PLL_M
 12

	)

160 #define 
	#PLL_N
 336

	)

163 #define 
	#PLL_P
 2

	)

166 #define 
	#PLL_Q
 7

	)

184 
uint32_t
 
	gSystemCoreClock
 = 168000000;

186 
__I
 
uint8_t
 
	gAHBPrescTable
[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};

196 static void 
SetSysClock
(void);

197 #ifdef 
DATA_IN_ExtSRAM


198 static void 
SystemInit_ExtMemCtl
(void);

216 void 
	$SystemInit
(void)

220 
RCC
->
CR
 |= (
uint32_t
)0x00000001;

223 
RCC
->
CFGR
 = 0x00000000;

226 
RCC
->
CR
 &= (
uint32_t
)0xFEF6FFFF;

229 
RCC
->
PLLCFGR
 = 0x24003010;

232 
RCC
->
CR
 &= (
uint32_t
)0xFFFBFFFF;

235 
RCC
->
CIR
 = 0x00000000;

237 #ifdef 
DATA_IN_ExtSRAM


238 
	`SystemInit_ExtMemCtl
();

243 
	`SetSysClock
();

246 #ifdef 
VECT_TAB_SRAM


247 
SCB
->
VTOR
 = 
SRAM_BASE
 | 
VECT_TAB_OFFSET
;

249 
SCB
->
VTOR
 = 
FLASH_BASE
 | 
VECT_TAB_OFFSET
;

251 
	}
}

289 void 
	$SystemCoreClockUpdate
(void)

291 
uint32_t
 
tmp
 = 0, 
pllvco
 = 0, 
pllp
 = 2, 
pllsource
 = 0, 
pllm
 = 2;

294 
tmp
 = 
RCC
->
CFGR
 & 
RCC_CFGR_SWS
;

296 switch (
tmp
)

299 
SystemCoreClock
 = 
HSI_VALUE
;

302 
SystemCoreClock
 = 
HSE_VALUE
;

309 
pllsource
 = (
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLSRC
) >> 22;

310 
pllm
 = 
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLM
;

312 if (
pllsource
 != 0)

315 
pllvco
 = (
HSE_VALUE
 / 
pllm
) * ((
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLN
) >> 6);

320 
pllvco
 = (
HSI_VALUE
 / 
pllm
) * ((
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLN
) >> 6);

323 
pllp
 = (((
RCC
->
PLLCFGR
 & 
RCC_PLLCFGR_PLLP
) >>16) + 1 ) *2;

324 
SystemCoreClock
 = 
pllvco
/
pllp
;

327 
SystemCoreClock
 = 
HSI_VALUE
;

332 
tmp
 = 
AHBPrescTable
[((
RCC
->
CFGR
 & 
RCC_CFGR_HPRE
) >> 4)];

334 
SystemCoreClock
 >>= 
tmp
;

335 
	}
}

345 static void 
	$SetSysClock
(void)

350 
__IO
 
uint32_t
 
StartUpCounter
 = 0, 
HSEStatus
 = 0;

353 
RCC
->
CR
 |= ((
uint32_t
)
RCC_CR_HSEON
);

358 
HSEStatus
 = 
RCC
->
CR
 & 
RCC_CR_HSERDY
;

359 
StartUpCounter
++;

360 } while((
HSEStatus
 == 0) && (
StartUpCounter
 != 
HSE_STARTUP_TIMEOUT
));

362 if ((
RCC
->
CR
 & 
RCC_CR_HSERDY
) != 
RESET
)

364 
HSEStatus
 = (
uint32_t
)0x01;

368 
HSEStatus
 = (
uint32_t
)0x00;

371 if (
HSEStatus
 == (
uint32_t
)0x01)

374 
RCC
->
APB1ENR
 |= 
RCC_APB1ENR_PWREN
;

375 
PWR
->
CR
 |= 
PWR_CR_PMODE
;

378 
RCC
->
CFGR
 |= 
RCC_CFGR_HPRE_DIV1
;

381 
RCC
->
CFGR
 |= 
RCC_CFGR_PPRE2_DIV2
;

384 
RCC
->
CFGR
 |= 
RCC_CFGR_PPRE1_DIV4
;

387 
RCC
->
PLLCFGR
 = 
PLL_M
 | (
PLL_N
 << 6) | (((
PLL_P
 >> 1) -1) << 16) |

388 (
RCC_PLLCFGR_PLLSRC_HSE
) | (
PLL_Q
 << 24);

391 
RCC
->
CR
 |= 
RCC_CR_PLLON
;

394 while((
RCC
->
CR
 & 
RCC_CR_PLLRDY
) == 0)

399 
FLASH
->
ACR
 = 
FLASH_ACR_ICEN
 |
FLASH_ACR_DCEN
 |
FLASH_ACR_LATENCY_5WS
;

402 
RCC
->
CFGR
 &= (
uint32_t
)((uint32_t)~(
RCC_CFGR_SW
));

403 
RCC
->
CFGR
 |= 
RCC_CFGR_SW_PLL
;

406 while ((
RCC
->
CFGR
 & (
uint32_t
)
RCC_CFGR_SWS
 ) != 
RCC_CFGR_SWS_PLL
);

415 
	}
}

423 #ifdef 
DATA_IN_ExtSRAM


432 void 
	$SystemInit_ExtMemCtl
(void)

455 
RCC
->
AHB1ENR
 = 0x00000078;

458 
GPIOD
->
AFR
[0] = 0x00cc00cc;

459 
GPIOD
->
AFR
[1] = 0xcc0ccccc;

461 
GPIOD
->
MODER
 = 0xaaaa0a0a;

463 
GPIOD
->
OSPEEDR
 = 0xffff0f0f;

465 
GPIOD
->
OTYPER
 = 0x00000000;

467 
GPIOD
->
PUPDR
 = 0x00000000;

470 
GPIOE
->
AFR
[0] = 0xc00cc0cc;

471 
GPIOE
->
AFR
[1] = 0xcccccccc;

473 
GPIOE
->
MODER
 = 0xaaaa828a;

475 
GPIOE
->
OSPEEDR
 = 0xffffc3cf;

477 
GPIOE
->
OTYPER
 = 0x00000000;

479 
GPIOE
->
PUPDR
 = 0x00000000;

482 
GPIOF
->
AFR
[0] = 0x00cccccc;

483 
GPIOF
->
AFR
[1] = 0xcccc0000;

485 
GPIOF
->
MODER
 = 0xaa000aaa;

487 
GPIOF
->
OSPEEDR
 = 0xff000fff;

489 
GPIOF
->
OTYPER
 = 0x00000000;

491 
GPIOF
->
PUPDR
 = 0x00000000;

494 
GPIOG
->
AFR
[0] = 0x00cccccc;

495 
GPIOG
->
AFR
[1] = 0x000000c0;

497 
GPIOG
->
MODER
 = 0x00080aaa;

499 
GPIOG
->
OSPEEDR
 = 0x000c0fff;

501 
GPIOG
->
OTYPER
 = 0x00000000;

503 
GPIOG
->
PUPDR
 = 0x00000000;

507 
RCC
->
AHB3ENR
 = 0x00000001;

510 
FSMC_Bank1
->
BTCR
[2] = 0x00001015;

511 
FSMC_Bank1
->
BTCR
[3] = 0x00010603;

512 
FSMC_Bank1E
->
BWTR
[2] = 0x0fffffff;

541 
	}
}

	@src/tiny_printf.c

44 #include 
	~<stdarg.h
>

45 #include 
	~<stdio.h
>

48 extern int 
_write
(int 
fd
, char *
str
, int 
len
);

51 void 
ts_itoa
(char **
buf
, unsigned int 
d
, int 
base
);

52 int 
ts_formatstring
(char *
buf
, const char *
fmt
, 
va_list
 
va
);

53 int 
ts_formatlength
(const char *
fmt
, 
va_list
 
va
);

63 void 
	$ts_itoa
(char **
buf
, unsigned int 
d
, int 
base
)

65 int 
div
 = 1;

66 while (
d
/
div
 >= 
base
)

67 
div
 *= 
base
;

69 while (
div
 != 0)

71 int 
num
 = 
d
/
div
;

72 
d
 = d%
div
;

73 
div
 /= 
base
;

74 if (
num
 > 9)

75 *((*
buf
)++) = (
num
-10) + 'A';

77 *((*
buf
)++) = 
num
 + '0';

79 
	}
}

87 int 
	$ts_formatstring
(char *
buf
, const char *
fmt
, 
va_list
 
va
)

89 char *
start_buf
 = 
buf
;

90 while(*
fmt
)

93 if (*
fmt
 == '%')

95 switch (*(++
fmt
))

98 *
buf
++ = 
	`va_arg
(
va
, int);

103 signed int 
val
 = 
	`va_arg
(
va
, signed int);

104 if (
val
 < 0)

106 
val
 *= -1;

107 *
buf
++ = '-';

109 
	`ts_itoa
(&
buf
, 
val
, 10);

114 char * 
arg
 = 
	`va_arg
(
va
, char *);

115 while (*
arg
)

117 *
buf
++ = *
arg
++;

122 
	`ts_itoa
(&
buf
, 
	`va_arg
(
va
, unsigned int), 10);

126 
	`ts_itoa
(&
buf
, 
	`va_arg
(
va
, int), 16);

129 *
buf
++ = '%';

132 
fmt
++;

137 *
buf
++ = *
fmt
++;

140 *
buf
 = 0;

142 return (int)(
buf
 - 
start_buf
);

143 
	}
}

153 int 
	$ts_formatlength
(const char *
fmt
, 
va_list
 
va
)

155 int 
length
 = 0;

156 while (*
fmt
)

158 if (*
fmt
 == '%')

160 ++
fmt
;

161 switch (*
fmt
)

164 
	`va_arg
(
va
, int);

165 ++
length
;

171 
length
 += 11;

172 
	`va_arg
(
va
, int);

176 char * 
str
 = 
	`va_arg
(
va
, char *);

177 while (*
str
++)

178 ++
length
;

184 
length
 += 8;

185 
	`va_arg
(
va
, unsigned int);

188 ++
length
;

194 ++
length
;

196 ++
fmt
;

198 return 
length
;

199 
	}
}

208 int 
	$sprintf
(char *
buf
, const char *
fmt
, ...)

210 int 
length
;

211 
va_list
 
va
;

212 
	`va_start
(
va
, 
fmt
);

213 
length
 = 
	`ts_formatstring
(
buf
, 
fmt
, 
va
);

214 
	`va_end
(
va
);

215 return 
length
;

216 
	}
}

225 int 
	$fprintf
(
FILE
 * 
stream
, const char *
fmt
, ...)

227 int 
length
 = 0;

228 
va_list
 
va
;

229 
	`va_start
(
va
, 
fmt
);

230 
length
 = 
	`ts_formatlength
(
fmt
, 
va
);

231 
	`va_end
(
va
);

233 char 
buf
[
length
];

234 
	`va_start
(
va
, 
fmt
);

235 
length
 = 
	`ts_formatstring
(
buf
, 
fmt
, 
va
);

236 
length
 = 
	`_write
(
stream
->
_file
, 
buf
, length);

237 
	`va_end
(
va
);

239 return 
length
;

240 
	}
}

250 int 
	$printf
(const char *
fmt
, ...)

252 int 
length
 = 0;

253 
va_list
 
va
;

254 
	`va_start
(
va
, 
fmt
);

255 
length
 = 
	`ts_formatlength
(
fmt
, 
va
);

256 
	`va_end
(
va
);

258 char 
buf
[
length
];

259 
	`va_start
(
va
, 
fmt
);

260 
length
 = 
	`ts_formatstring
(
buf
, 
fmt
, 
va
);

261 
length
 = 
	`_write
(1, 
buf
, length);

262 
	`va_end
(
va
);

264 return 
length
;

265 
	}
}

	@utils/interface/cfassert.h

28 #ifndef 
__CFASSERT_H__


29 #define 
	#__CFASSERT_H__


	)

31 #define 
	#ASSERT
(
e
) if (e) ; \

	)

32 else 
assertFail
( #e, 
__FILE__
, 
__LINE__
 )

37 void 
assertFail
(char *
exp
, char *
file
, int 
line
);

	@utils/interface/debug.h

26 #include 
	~"console.h
"

28 #ifdef 
DEBUG_MODULE


29 #define 
	#DEBUG_FMT
(
fmt
) 
DEBUG_MODULE
 ": " 
	)
fmt

32 #ifndef 
DEBUG_FMT


33 #define 
	#DEBUG_FMT
(
fmt
) 
	)
fmt

37 #define 
	#DEBUG_PRINT
(
fmt
, ...) 
	`consolePrintf
(
	`DEBUG_FMT
(fmt), ##
__VA_ARGS__
)

	)

42 #ifdef 
TEST_PRINTS


43 #define 
	#TEST_AND_PRINT
(
e
, 
msgOK
, 
msgFail
)\

44 if(
e
) { 
	`consolePrintf
(
msgOK
); } else { consolePrintf(
msgFail
); }

	)

45 #define 
	#FAIL_PRINT
(
msg
) 
	`consolePrintf
(msg)

	)

47 #define 
	#TEST_AND_PRINT
(
e
, 
msgOK
, 
msgFail
)

	)

48 #define 
	#FAIL_PRINT
(
msg
)

	)

	@utils/interface/filter.h

26 #ifndef 
FILTER_H_


27 #define 
	#FILTER_H_


	)

28 #include 
	~<stdint.h
>

30 #define 
	#IIR_SHIFT
 8

	)

32 
int16_t
 
iirLPFilterSingle
(
int32_t
 
in
, int32_t 
attenuation
, int32_t* 
filt
);

	@utils/interface/version.h

26 #ifndef 
__VERSION_H__


27 #define 
	#__VERSION_H__


	)

29 extern const char * 
V_SLOCAL_REVISION
;

30 extern const char * 
V_SREVISION
;

31 extern const char * 
V_STAG
;

32 extern const 
bool
 
V_MODIFIED
;

	@utils/src/cfassert.c

27 #include 
	~"cfassert.h
"

30 void 
	$assertFail
(char *
exp
, char *
file
, int 
line
)

37 
	}
}

	@utils/src/debug.c

	@utils/src/filter.c

26 #include 
	~"filter.h
"

31 
int16_t
 
	$iirLPFilterSingle
(
int32_t
 
in
, int32_t 
attenuation
, int32_t* 
filt
)

33 
int32_t
 
inScaled
;

34 
int32_t
 
filttmp
 = *
filt
;

35 
int16_t
 
out
;

37 if (
attenuation
 > (1<<
IIR_SHIFT
))

39 
attenuation
 = (1<<
IIR_SHIFT
);

41 else if (
attenuation
 < 1)

43 
attenuation
 = 1;

47 
inScaled
 = 
in
 << 
IIR_SHIFT
;

49 
filttmp
 = filttmp + (((
inScaled
-filttmp) >> 
IIR_SHIFT
) * 
attenuation
);

51 
out
 = (
filttmp
 >> 8) + ((filttmp & (1 << (
IIR_SHIFT
 - 1))) >> (IIR_SHIFT - 1));

52 *
filt
 = 
filttmp
;

54 return 
out
;

55 
	}
}

	@/usr/include/ctype.h

22 #ifndef 
_CTYPE_H


23 #define 
	#_CTYPE_H
 1

	)

25 #include 
	~<features.h
>

26 #include 
	~<bits/types.h
>

28 
	g__BEGIN_DECLS


30 #ifndef 
_ISbit


39 #include 
	~<endian.h
>

40 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


41 #define 
	#_ISbit
(
bit
) (1 << (bit))

	)

43 #define 
	#_ISbit
(
bit
) ((bit) < 8 ? ((1 << (bit)) << 8) : ((1 << (bit)) >> 8))

	)

48 
	m_ISupper
 = 
_ISbit
 (0),

49 
	m_ISlower
 = 
_ISbit
 (1),

50 
	m_ISalpha
 = 
_ISbit
 (2),

51 
	m_ISdigit
 = 
_ISbit
 (3),

52 
	m_ISxdigit
 = 
_ISbit
 (4),

53 
	m_ISspace
 = 
_ISbit
 (5),

54 
	m_ISprint
 = 
_ISbit
 (6),

55 
	m_ISgraph
 = 
_ISbit
 (7),

56 
	m_ISblank
 = 
_ISbit
 (8),

57 
	m_IScntrl
 = 
_ISbit
 (9),

58 
	m_ISpunct
 = 
_ISbit
 (10),

59 
	m_ISalnum
 = 
_ISbit
 (11)

79 extern const unsigned short int **
	$__ctype_b_loc
 (void)

80 
__THROW
 
	`__attribute__
 ((
__const__
));

81 extern const 
__int32_t
 **
	$__ctype_tolower_loc
 (void)

82 
__THROW
 
	`__attribute__
 ((
__const__
));

83 extern const 
__int32_t
 **
	$__ctype_toupper_loc
 (void)

84 
__THROW
 
	`__attribute__
 ((
__const__
));

87 #ifndef 
__cplusplus


88 #define 
	#__isctype
(
c
, 
type
) \

89 ((*
	`__ctype_b_loc
 ())[(int) (
c
)] & (unsigned short int) 
type
)

	)

90 #elif 
defined
 
__USE_EXTERN_INLINES


91 #define 
	#__isctype_f
(
type
) \

92 
__extern_inline
 int \

93 
is
##
	`type
 (int 
__c
) 
__THROW
 \

95 return (*
	`__ctype_b_loc
 ())[(int) (
__c
)] & (unsigned short int) 
_IS
##
type
; \

96 
	}

	)
}

99 #define 
	#__isascii
(
c
) (((c) & ~0x7f) == 0)

	)

100 #define 
	#__toascii
(
c
) ((c) & 0x7f)

	)

102 #define 
	#__exctype
(
name
) extern int 
	`name
 (int) 
__THROW


	)

104 
__BEGIN_NAMESPACE_STD


110 
__exctype
 (
isalnum
);

111 
__exctype
 (
isalpha
);

112 
__exctype
 (
iscntrl
);

113 
__exctype
 (
isdigit
);

114 
__exctype
 (
islower
);

115 
__exctype
 (
isgraph
);

116 
__exctype
 (
isprint
);

117 
__exctype
 (
ispunct
);

118 
__exctype
 (
isspace
);

119 
__exctype
 (
isupper
);

120 
__exctype
 (
isxdigit
);

124 extern int 
	$tolower
 (int 
__c
) 
__THROW
;

127 extern int 
	$toupper
 (int 
__c
) 
__THROW
;

129 
__END_NAMESPACE_STD


133 #ifdef 
__USE_ISOC99


134 
__BEGIN_NAMESPACE_C99


136 
	`__exctype
 (
isblank
);

138 
__END_NAMESPACE_C99


141 #ifdef 
__USE_GNU


143 extern int 
	$isctype
 (int 
__c
, int 
__mask
) 
__THROW
;

146 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


150 extern int 
	$isascii
 (int 
__c
) 
__THROW
;

154 extern int 
	$toascii
 (int 
__c
) 
__THROW
;

158 
	`__exctype
 (
_toupper
);

159 
	`__exctype
 (
_tolower
);

163 #define 
	#__tobody
(
c
, 
f
, 
a
, 
args
) \

164 (
__extension__
 \

165 ({ int 
__res
; \

166 if (sizeof (
c
) > 1) \

168 if (
	`__builtin_constant_p
 (
c
)) \

170 int 
__c
 = (
c
); \

171 
__res
 = 
__c
 < -128 || __c > 255 ? __c : (
a
)[__c]; \

174 
__res
 = 
f
 
args
; \

177 
__res
 = (
a
)[(int) (
c
)]; \

178 
__res
; 
	}
}))

	)

180 #if !
defined
 
__NO_CTYPE


181 #ifdef 
__isctype_f


182 
	$__isctype_f
 (
alnum
)

183 
	$__isctype_f
 (
alpha
)

184 
	$__isctype_f
 (
cntrl
)

185 
	$__isctype_f
 (
digit
)

186 
	$__isctype_f
 (
lower
)

187 
	$__isctype_f
 (
graph
)

188 
	$__isctype_f
 (
print
)

189 
	$__isctype_f
 (
punct
)

190 
	$__isctype_f
 (
space
)

191 
	$__isctype_f
 (
upper
)

192 
	$__isctype_f
 (
xdigit
)

193 #ifdef 
__USE_ISOC99


194 
	$__isctype_f
 (
blank
)

196 #elif 
defined
 
__isctype


197 #define 
	#isalnum
(
c
) 
	`__isctype
((c), 
_ISalnum
)

	)

198 #define 
	#isalpha
(
c
) 
	`__isctype
((c), 
_ISalpha
)

	)

199 #define 
	#iscntrl
(
c
) 
	`__isctype
((c), 
_IScntrl
)

	)

200 #define 
	#isdigit
(
c
) 
	`__isctype
((c), 
_ISdigit
)

	)

201 #define 
	#islower
(
c
) 
	`__isctype
((c), 
_ISlower
)

	)

202 #define 
	#isgraph
(
c
) 
	`__isctype
((c), 
_ISgraph
)

	)

203 #define 
	#isprint
(
c
) 
	`__isctype
((c), 
_ISprint
)

	)

204 #define 
	#ispunct
(
c
) 
	`__isctype
((c), 
_ISpunct
)

	)

205 #define 
	#isspace
(
c
) 
	`__isctype
((c), 
_ISspace
)

	)

206 #define 
	#isupper
(
c
) 
	`__isctype
((c), 
_ISupper
)

	)

207 #define 
	#isxdigit
(
c
) 
	`__isctype
((c), 
_ISxdigit
)

	)

208 #ifdef 
__USE_ISOC99


209 #define 
	#isblank
(
c
) 
	`__isctype
((c), 
_ISblank
)

	)

213 #ifdef 
__USE_EXTERN_INLINES


214 
__extern_inline
 int

215 
	`__NTH
 (
	$tolower
 (int 
__c
))

217 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_tolower_loc
 ())[__c] : __c;

218 
	}
}

220 
__extern_inline
 int

221 
__NTH
 (
	$toupper
 (int 
__c
))

223 return 
__c
 >= -128 && __c < 256 ? (*
	`__ctype_toupper_loc
 ())[__c] : __c;

224 
	}
}

227 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


228 #define 
	#tolower
(
c
) 
	`__tobody
 (c, 
tolower
, *
	`__ctype_tolower_loc
 (), (c))

	)

229 #define 
	#toupper
(
c
) 
	`__tobody
 (c, 
toupper
, *
	`__ctype_toupper_loc
 (), (c))

	)

232 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 || defined 
__USE_XOPEN


233 #define 
	#isascii
(
c
) 
	`__isascii
 (c)

	)

234 #define 
	#toascii
(
c
) 
	`__toascii
 (c)

	)

236 #define 
	#_tolower
(
c
) ((int) (*
	`__ctype_tolower_loc
 ())[(int) (c)])

	)

237 #define 
	#_toupper
(
c
) ((int) (*
	`__ctype_toupper_loc
 ())[(int) (c)])

	)

243 #ifdef 
__USE_XOPEN2K8


257 #include 
	~<xlocale.h
>

261 #define 
	#__isctype_l
(
c
, 
type
, 
locale
) \

262 ((
locale
)->
__ctype_b
[(int) (
c
)] & (unsigned short int) 
type
)

	)

264 #define 
	#__exctype_l
(
name
) \

265 extern int 
	`name
 (int, 
__locale_t
) 
__THROW


	)

271 
__exctype_l
 (
isalnum_l
);

272 
__exctype_l
 (
isalpha_l
);

273 
__exctype_l
 (
iscntrl_l
);

274 
__exctype_l
 (
isdigit_l
);

275 
__exctype_l
 (
islower_l
);

276 
__exctype_l
 (
isgraph_l
);

277 
__exctype_l
 (
isprint_l
);

278 
__exctype_l
 (
ispunct_l
);

279 
__exctype_l
 (
isspace_l
);

280 
__exctype_l
 (
isupper_l
);

281 
__exctype_l
 (
isxdigit_l
);

283 
__exctype_l
 (
isblank_l
);

287 extern int 
	$__tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

288 extern int 
	$tolower_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

291 extern int 
	$__toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

292 extern int 
	$toupper_l
 (int 
__c
, 
__locale_t
 
__l
) 
__THROW
;

294 #if 
__GNUC__
 >= 2 && 
defined
 
__OPTIMIZE__
 && !defined 
__cplusplus


295 #define 
	#__tolower_l
(
c
, 
locale
) \

296 
	`__tobody
 (
c
, 
__tolower_l
, (
locale
)->
__ctype_tolower
, (c, locale))

	)

297 #define 
	#__toupper_l
(
c
, 
locale
) \

298 
	`__tobody
 (
c
, 
__toupper_l
, (
locale
)->
__ctype_toupper
, (c, locale))

	)

299 #define 
	#tolower_l
(
c
, 
locale
) 
	`__tolower_l
 ((c), (locale))

	)

300 #define 
	#toupper_l
(
c
, 
locale
) 
	`__toupper_l
 ((c), (locale))

	)

304 #ifndef 
__NO_CTYPE


305 #define 
	#__isalnum_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalnum
, (l))

	)

306 #define 
	#__isalpha_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISalpha
, (l))

	)

307 #define 
	#__iscntrl_l
(
c
,
l
) 
	`__isctype_l
((c), 
_IScntrl
, (l))

	)

308 #define 
	#__isdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISdigit
, (l))

	)

309 #define 
	#__islower_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISlower
, (l))

	)

310 #define 
	#__isgraph_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISgraph
, (l))

	)

311 #define 
	#__isprint_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISprint
, (l))

	)

312 #define 
	#__ispunct_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISpunct
, (l))

	)

313 #define 
	#__isspace_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISspace
, (l))

	)

314 #define 
	#__isupper_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISupper
, (l))

	)

315 #define 
	#__isxdigit_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISxdigit
, (l))

	)

317 #define 
	#__isblank_l
(
c
,
l
) 
	`__isctype_l
((c), 
_ISblank
, (l))

	)

319 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC


320 #define 
	#__isascii_l
(
c
,
l
) ((l), 
	`__isascii
 (c))

	)

321 #define 
	#__toascii_l
(
c
,
l
) ((l), 
	`__toascii
 (c))

	)

324 #define 
	#isalnum_l
(
c
,
l
) 
	`__isalnum_l
 ((c), (l))

	)

325 #define 
	#isalpha_l
(
c
,
l
) 
	`__isalpha_l
 ((c), (l))

	)

326 #define 
	#iscntrl_l
(
c
,
l
) 
	`__iscntrl_l
 ((c), (l))

	)

327 #define 
	#isdigit_l
(
c
,
l
) 
	`__isdigit_l
 ((c), (l))

	)

328 #define 
	#islower_l
(
c
,
l
) 
	`__islower_l
 ((c), (l))

	)

329 #define 
	#isgraph_l
(
c
,
l
) 
	`__isgraph_l
 ((c), (l))

	)

330 #define 
	#isprint_l
(
c
,
l
) 
	`__isprint_l
 ((c), (l))

	)

331 #define 
	#ispunct_l
(
c
,
l
) 
	`__ispunct_l
 ((c), (l))

	)

332 #define 
	#isspace_l
(
c
,
l
) 
	`__isspace_l
 ((c), (l))

	)

333 #define 
	#isupper_l
(
c
,
l
) 
	`__isupper_l
 ((c), (l))

	)

334 #define 
	#isxdigit_l
(
c
,
l
) 
	`__isxdigit_l
 ((c), (l))

	)

336 #define 
	#isblank_l
(
c
,
l
) 
	`__isblank_l
 ((c), (l))

	)

338 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC


339 #define 
	#isascii_l
(
c
,
l
) 
	`__isascii_l
 ((c), (l))

	)

340 #define 
	#toascii_l
(
c
,
l
) 
	`__toascii_l
 ((c), (l))

	)

347 
__END_DECLS


	@/usr/include/inttypes.h

22 #ifndef 
_INTTYPES_H


23 #define 
	#_INTTYPES_H
 1

	)

25 #include 
	~<features.h
>

27 #include 
	~<stdint.h
>

30 #ifndef 
____gwchar_t_defined


31 #ifdef 
__cplusplus


32 #define 
	#__gwchar_t
 
wchar_t


	)

33 #elif 
defined
 
__WCHAR_TYPE__


34 typedef 
__WCHAR_TYPE__
 
	t__gwchar_t
;

36 #define 
	#__need_wchar_t


	)

37 #include 
	~<stddef.h
>

38 typedef 
wchar_t
 
	t__gwchar_t
;

40 #define 
	#____gwchar_t_defined
 1

	)

43 #if 
__WORDSIZE
 == 64

44 #define 
	#__PRI64_PREFIX
 "l"

	)

45 #define 
	#__PRIPTR_PREFIX
 "l"

	)

47 #define 
	#__PRI64_PREFIX
 "ll"

	)

48 #define 
	#__PRIPTR_PREFIX


	)

54 #define 
	#PRId8
 "d"

	)

55 #define 
	#PRId16
 "d"

	)

56 #define 
	#PRId32
 "d"

	)

57 #define 
	#PRId64
 
__PRI64_PREFIX
 "d"

	)

59 #define 
	#PRIdLEAST8
 "d"

	)

60 #define 
	#PRIdLEAST16
 "d"

	)

61 #define 
	#PRIdLEAST32
 "d"

	)

62 #define 
	#PRIdLEAST64
 
__PRI64_PREFIX
 "d"

	)

64 #define 
	#PRIdFAST8
 "d"

	)

65 #define 
	#PRIdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

66 #define 
	#PRIdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

67 #define 
	#PRIdFAST64
 
__PRI64_PREFIX
 "d"

	)

70 #define 
	#PRIi8
 "i"

	)

71 #define 
	#PRIi16
 "i"

	)

72 #define 
	#PRIi32
 "i"

	)

73 #define 
	#PRIi64
 
__PRI64_PREFIX
 "i"

	)

75 #define 
	#PRIiLEAST8
 "i"

	)

76 #define 
	#PRIiLEAST16
 "i"

	)

77 #define 
	#PRIiLEAST32
 "i"

	)

78 #define 
	#PRIiLEAST64
 
__PRI64_PREFIX
 "i"

	)

80 #define 
	#PRIiFAST8
 "i"

	)

81 #define 
	#PRIiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

82 #define 
	#PRIiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

83 #define 
	#PRIiFAST64
 
__PRI64_PREFIX
 "i"

	)

86 #define 
	#PRIo8
 "o"

	)

87 #define 
	#PRIo16
 "o"

	)

88 #define 
	#PRIo32
 "o"

	)

89 #define 
	#PRIo64
 
__PRI64_PREFIX
 "o"

	)

91 #define 
	#PRIoLEAST8
 "o"

	)

92 #define 
	#PRIoLEAST16
 "o"

	)

93 #define 
	#PRIoLEAST32
 "o"

	)

94 #define 
	#PRIoLEAST64
 
__PRI64_PREFIX
 "o"

	)

96 #define 
	#PRIoFAST8
 "o"

	)

97 #define 
	#PRIoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

98 #define 
	#PRIoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

99 #define 
	#PRIoFAST64
 
__PRI64_PREFIX
 "o"

	)

102 #define 
	#PRIu8
 "u"

	)

103 #define 
	#PRIu16
 "u"

	)

104 #define 
	#PRIu32
 "u"

	)

105 #define 
	#PRIu64
 
__PRI64_PREFIX
 "u"

	)

107 #define 
	#PRIuLEAST8
 "u"

	)

108 #define 
	#PRIuLEAST16
 "u"

	)

109 #define 
	#PRIuLEAST32
 "u"

	)

110 #define 
	#PRIuLEAST64
 
__PRI64_PREFIX
 "u"

	)

112 #define 
	#PRIuFAST8
 "u"

	)

113 #define 
	#PRIuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

114 #define 
	#PRIuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

115 #define 
	#PRIuFAST64
 
__PRI64_PREFIX
 "u"

	)

118 #define 
	#PRIx8
 "x"

	)

119 #define 
	#PRIx16
 "x"

	)

120 #define 
	#PRIx32
 "x"

	)

121 #define 
	#PRIx64
 
__PRI64_PREFIX
 "x"

	)

123 #define 
	#PRIxLEAST8
 "x"

	)

124 #define 
	#PRIxLEAST16
 "x"

	)

125 #define 
	#PRIxLEAST32
 "x"

	)

126 #define 
	#PRIxLEAST64
 
__PRI64_PREFIX
 "x"

	)

128 #define 
	#PRIxFAST8
 "x"

	)

129 #define 
	#PRIxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

130 #define 
	#PRIxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

131 #define 
	#PRIxFAST64
 
__PRI64_PREFIX
 "x"

	)

134 #define 
	#PRIX8
 "X"

	)

135 #define 
	#PRIX16
 "X"

	)

136 #define 
	#PRIX32
 "X"

	)

137 #define 
	#PRIX64
 
__PRI64_PREFIX
 "X"

	)

139 #define 
	#PRIXLEAST8
 "X"

	)

140 #define 
	#PRIXLEAST16
 "X"

	)

141 #define 
	#PRIXLEAST32
 "X"

	)

142 #define 
	#PRIXLEAST64
 
__PRI64_PREFIX
 "X"

	)

144 #define 
	#PRIXFAST8
 "X"

	)

145 #define 
	#PRIXFAST16
 
__PRIPTR_PREFIX
 "X"

	)

146 #define 
	#PRIXFAST32
 
__PRIPTR_PREFIX
 "X"

	)

147 #define 
	#PRIXFAST64
 
__PRI64_PREFIX
 "X"

	)

151 #define 
	#PRIdMAX
 
__PRI64_PREFIX
 "d"

	)

152 #define 
	#PRIiMAX
 
__PRI64_PREFIX
 "i"

	)

153 #define 
	#PRIoMAX
 
__PRI64_PREFIX
 "o"

	)

154 #define 
	#PRIuMAX
 
__PRI64_PREFIX
 "u"

	)

155 #define 
	#PRIxMAX
 
__PRI64_PREFIX
 "x"

	)

156 #define 
	#PRIXMAX
 
__PRI64_PREFIX
 "X"

	)

160 #define 
	#PRIdPTR
 
__PRIPTR_PREFIX
 "d"

	)

161 #define 
	#PRIiPTR
 
__PRIPTR_PREFIX
 "i"

	)

162 #define 
	#PRIoPTR
 
__PRIPTR_PREFIX
 "o"

	)

163 #define 
	#PRIuPTR
 
__PRIPTR_PREFIX
 "u"

	)

164 #define 
	#PRIxPTR
 
__PRIPTR_PREFIX
 "x"

	)

165 #define 
	#PRIXPTR
 
__PRIPTR_PREFIX
 "X"

	)

171 #define 
	#SCNd8
 "hhd"

	)

172 #define 
	#SCNd16
 "hd"

	)

173 #define 
	#SCNd32
 "d"

	)

174 #define 
	#SCNd64
 
__PRI64_PREFIX
 "d"

	)

176 #define 
	#SCNdLEAST8
 "hhd"

	)

177 #define 
	#SCNdLEAST16
 "hd"

	)

178 #define 
	#SCNdLEAST32
 "d"

	)

179 #define 
	#SCNdLEAST64
 
__PRI64_PREFIX
 "d"

	)

181 #define 
	#SCNdFAST8
 "hhd"

	)

182 #define 
	#SCNdFAST16
 
__PRIPTR_PREFIX
 "d"

	)

183 #define 
	#SCNdFAST32
 
__PRIPTR_PREFIX
 "d"

	)

184 #define 
	#SCNdFAST64
 
__PRI64_PREFIX
 "d"

	)

187 #define 
	#SCNi8
 "hhi"

	)

188 #define 
	#SCNi16
 "hi"

	)

189 #define 
	#SCNi32
 "i"

	)

190 #define 
	#SCNi64
 
__PRI64_PREFIX
 "i"

	)

192 #define 
	#SCNiLEAST8
 "hhi"

	)

193 #define 
	#SCNiLEAST16
 "hi"

	)

194 #define 
	#SCNiLEAST32
 "i"

	)

195 #define 
	#SCNiLEAST64
 
__PRI64_PREFIX
 "i"

	)

197 #define 
	#SCNiFAST8
 "hhi"

	)

198 #define 
	#SCNiFAST16
 
__PRIPTR_PREFIX
 "i"

	)

199 #define 
	#SCNiFAST32
 
__PRIPTR_PREFIX
 "i"

	)

200 #define 
	#SCNiFAST64
 
__PRI64_PREFIX
 "i"

	)

203 #define 
	#SCNu8
 "hhu"

	)

204 #define 
	#SCNu16
 "hu"

	)

205 #define 
	#SCNu32
 "u"

	)

206 #define 
	#SCNu64
 
__PRI64_PREFIX
 "u"

	)

208 #define 
	#SCNuLEAST8
 "hhu"

	)

209 #define 
	#SCNuLEAST16
 "hu"

	)

210 #define 
	#SCNuLEAST32
 "u"

	)

211 #define 
	#SCNuLEAST64
 
__PRI64_PREFIX
 "u"

	)

213 #define 
	#SCNuFAST8
 "hhu"

	)

214 #define 
	#SCNuFAST16
 
__PRIPTR_PREFIX
 "u"

	)

215 #define 
	#SCNuFAST32
 
__PRIPTR_PREFIX
 "u"

	)

216 #define 
	#SCNuFAST64
 
__PRI64_PREFIX
 "u"

	)

219 #define 
	#SCNo8
 "hho"

	)

220 #define 
	#SCNo16
 "ho"

	)

221 #define 
	#SCNo32
 "o"

	)

222 #define 
	#SCNo64
 
__PRI64_PREFIX
 "o"

	)

224 #define 
	#SCNoLEAST8
 "hho"

	)

225 #define 
	#SCNoLEAST16
 "ho"

	)

226 #define 
	#SCNoLEAST32
 "o"

	)

227 #define 
	#SCNoLEAST64
 
__PRI64_PREFIX
 "o"

	)

229 #define 
	#SCNoFAST8
 "hho"

	)

230 #define 
	#SCNoFAST16
 
__PRIPTR_PREFIX
 "o"

	)

231 #define 
	#SCNoFAST32
 
__PRIPTR_PREFIX
 "o"

	)

232 #define 
	#SCNoFAST64
 
__PRI64_PREFIX
 "o"

	)

235 #define 
	#SCNx8
 "hhx"

	)

236 #define 
	#SCNx16
 "hx"

	)

237 #define 
	#SCNx32
 "x"

	)

238 #define 
	#SCNx64
 
__PRI64_PREFIX
 "x"

	)

240 #define 
	#SCNxLEAST8
 "hhx"

	)

241 #define 
	#SCNxLEAST16
 "hx"

	)

242 #define 
	#SCNxLEAST32
 "x"

	)

243 #define 
	#SCNxLEAST64
 
__PRI64_PREFIX
 "x"

	)

245 #define 
	#SCNxFAST8
 "hhx"

	)

246 #define 
	#SCNxFAST16
 
__PRIPTR_PREFIX
 "x"

	)

247 #define 
	#SCNxFAST32
 
__PRIPTR_PREFIX
 "x"

	)

248 #define 
	#SCNxFAST64
 
__PRI64_PREFIX
 "x"

	)

252 #define 
	#SCNdMAX
 
__PRI64_PREFIX
 "d"

	)

253 #define 
	#SCNiMAX
 
__PRI64_PREFIX
 "i"

	)

254 #define 
	#SCNoMAX
 
__PRI64_PREFIX
 "o"

	)

255 #define 
	#SCNuMAX
 
__PRI64_PREFIX
 "u"

	)

256 #define 
	#SCNxMAX
 
__PRI64_PREFIX
 "x"

	)

259 #define 
	#SCNdPTR
 
__PRIPTR_PREFIX
 "d"

	)

260 #define 
	#SCNiPTR
 
__PRIPTR_PREFIX
 "i"

	)

261 #define 
	#SCNoPTR
 
__PRIPTR_PREFIX
 "o"

	)

262 #define 
	#SCNuPTR
 
__PRIPTR_PREFIX
 "u"

	)

263 #define 
	#SCNxPTR
 
__PRIPTR_PREFIX
 "x"

	)

266 
	g__BEGIN_DECLS


268 #if 
__WORDSIZE
 == 64

273 long int 
	mquot
;

274 long int 
	mrem
;

275 } 
	timaxdiv_t
;

282 
__extension__
 long long int 
	mquot
;

283 
__extension__
 long long int 
	mrem
;

284 } 
	timaxdiv_t
;

290 extern 
intmax_t
 
	$imaxabs
 (
intmax_t
 
__n
) 
__THROW
 
	`__attribute__
 ((
__const__
));

293 extern 
imaxdiv_t
 
	$imaxdiv
 (
intmax_t
 
__numer
, intmax_t 
__denom
)

294 
__THROW
 
	`__attribute__
 ((
__const__
));

297 extern 
intmax_t
 
	$strtoimax
 (const char *
__restrict
 
__nptr
,

298 char **
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

301 extern 
uintmax_t
 
	$strtoumax
 (const char *
__restrict
 
__nptr
,

302 char ** 
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

305 extern 
intmax_t
 
	$wcstoimax
 (const 
__gwchar_t
 *
__restrict
 
__nptr
,

306 
__gwchar_t
 **
__restrict
 
__endptr
, int 
__base
)

307 
__THROW
;

310 extern 
uintmax_t
 
	$wcstoumax
 (const 
__gwchar_t
 *
__restrict
 
__nptr
,

311 
__gwchar_t
 ** 
__restrict
 
__endptr
, int 
__base
)

312 
__THROW
;

314 #ifdef 
__USE_EXTERN_INLINES


316 #if 
__WORDSIZE
 == 64

318 extern long int 
	$__strtol_internal
 (const char *
__restrict
 
__nptr
,

319 char **
__restrict
 
__endptr
,

320 int 
__base
, int 
__group
)

321 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

323 
__extern_inline
 
intmax_t


324 
	`__NTH
 (
	$strtoimax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

325 int 
base
))

327 return 
	`__strtol_internal
 (
nptr
, 
endptr
, 
base
, 0);

328 
	}
}

330 extern unsigned long int 
	$__strtoul_internal
 (const char *
__restrict
 
__nptr
,

331 char ** 
__restrict
 
__endptr
,

332 int 
__base
, int 
__group
)

333 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

335 
__extern_inline
 
uintmax_t


336 
	`__NTH
 (
	$strtoumax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

337 int 
base
))

339 return 
	`__strtoul_internal
 (
nptr
, 
endptr
, 
base
, 0);

340 
	}
}

342 extern long int 
	$__wcstol_internal
 (const 
__gwchar_t
 * 
__restrict
 
__nptr
,

343 
__gwchar_t
 **
__restrict
 
__endptr
,

344 int 
__base
, int 
__group
)

345 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

347 
__extern_inline
 
intmax_t


348 
	`__NTH
 (
	$wcstoimax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

349 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

351 return 
	`__wcstol_internal
 (
nptr
, 
endptr
, 
base
, 0);

352 
	}
}

354 extern unsigned long int 
	$__wcstoul_internal
 (const 
__gwchar_t
 *

355 
__restrict
 
__nptr
,

356 
__gwchar_t
 **

357 
__restrict
 
__endptr
,

358 int 
__base
, int 
__group
)

359 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

361 
__extern_inline
 
uintmax_t


362 
	`__NTH
 (
	$wcstoumax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

363 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

365 return 
	`__wcstoul_internal
 (
nptr
, 
endptr
, 
base
, 0);

366 
	}
}

370 
__extension__


371 extern long long int 
	$__strtoll_internal
 (const char *
__restrict
 
__nptr
,

372 char **
__restrict
 
__endptr
,

373 int 
__base
, int 
__group
)

374 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

376 
__extern_inline
 
intmax_t


377 
	`__NTH
 (
	$strtoimax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

378 int 
base
))

380 return 
	`__strtoll_internal
 (
nptr
, 
endptr
, 
base
, 0);

381 
	}
}

383 
__extension__


384 extern unsigned long long int 
	$__strtoull_internal
 (const char *

385 
__restrict
 
__nptr
,

387 
__restrict
 
__endptr
,

388 int 
__base
,

389 int 
__group
)

390 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

392 
__extern_inline
 
uintmax_t


393 
	`__NTH
 (
	$strtoumax
 (const char *
__restrict
 
nptr
, char **__restrict 
endptr
,

394 int 
base
))

396 return 
	`__strtoull_internal
 (
nptr
, 
endptr
, 
base
, 0);

397 
	}
}

399 
__extension__


400 extern long long int 
	$__wcstoll_internal
 (const 
__gwchar_t
 *
__restrict
 
__nptr
,

401 
__gwchar_t
 **
__restrict
 
__endptr
,

402 int 
__base
, int 
__group
)

403 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

405 
__extern_inline
 
intmax_t


406 
	`__NTH
 (
	$wcstoimax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

407 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

409 return 
	`__wcstoll_internal
 (
nptr
, 
endptr
, 
base
, 0);

410 
	}
}

413 
__extension__


414 extern unsigned long long int 
	$__wcstoull_internal
 (const 
__gwchar_t
 *

415 
__restrict
 
__nptr
,

416 
__gwchar_t
 **

417 
__restrict
 
__endptr
,

418 int 
__base
,

419 int 
__group
)

420 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

422 
__extern_inline
 
uintmax_t


423 
	`__NTH
 (
	$wcstoumax
 (const 
__gwchar_t
 *
__restrict
 
nptr
,

424 
__gwchar_t
 **
__restrict
 
endptr
, int 
base
))

426 return 
	`__wcstoull_internal
 (
nptr
, 
endptr
, 
base
, 0);

427 
	}
}

432 
	g__END_DECLS


	@/usr/include/math.h

23 #ifndef 
_MATH_H


24 #define 
	#_MATH_H
 1

	)

26 #include 
	~<features.h
>

28 
	g__BEGIN_DECLS


32 #include 
	~<bits/huge_val.h
>

33 #ifdef 
__USE_ISOC99


34 #include 
	~<bits/huge_valf.h
>

35 #include 
	~<bits/huge_vall.h
>

38 #include 
	~<bits/inf.h
>

41 #include 
	~<bits/nan.h
>

45 #include 
	~<bits/mathdef.h
>

52 #define 
	#__MATHCALL
(
function
,
suffix
, 
args
) \

53 
	`__MATHDECL
 (
_Mdouble_
,
function
,
suffix
, 
args
)

	)

54 #define 
	#__MATHDECL
(
type
, 
function
,
suffix
, 
args
) \

55 
	`__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
); \

56 
	`__MATHDECL_1
(
type
, 
	`__CONCAT
(
__
,
function
),
suffix
, 
args
)

	)

57 #define 
	#__MATHCALLX
(
function
,
suffix
, 
args
, 
attrib
) \

58 
	`__MATHDECLX
 (
_Mdouble_
,
function
,
suffix
, 
args
, 
attrib
)

	)

59 #define 
	#__MATHDECLX
(
type
, 
function
,
suffix
, 
args
, 
attrib
) \

60 
	`__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) 
	`__attribute__
 (
attrib
); \

61 
	`__MATHDECL_1
(
type
, 
	`__CONCAT
(
__
,
function
),
suffix
, 
args
) 
	`__attribute__
 (
attrib
)

	)

62 #define 
	#__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) \

63 extern 
type
 
	`__MATH_PRECNAME
(
function
,
suffix
) 
args
 
__THROW


	)

65 #define 
	#_Mdouble_
 double

	)

66 #define 
	#__MATH_PRECNAME
(
name
,
r
) 
	`__CONCAT
(name,r)

	)

67 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_STD


	)

68 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_STD


	)

69 #include 
	~<bits/mathcalls.h
>

70 #undef 
_Mdouble_


71 #undef 
_Mdouble_BEGIN_NAMESPACE


72 #undef 
_Mdouble_END_NAMESPACE


73 #undef 
__MATH_PRECNAME


75 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


81 #ifndef 
_Mfloat_


82 #define 
	#_Mfloat_
 float

	)

84 #define 
	#_Mdouble_
 
_Mfloat_


	)

85 #define 
	#__MATH_PRECNAME
(
name
,
r
) name##
f
##
	)
r

86 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

87 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

88 #include 
	~<bits/mathcalls.h
>

89 #undef 
_Mdouble_


90 #undef 
_Mdouble_BEGIN_NAMESPACE


91 #undef 
_Mdouble_END_NAMESPACE


92 #undef 
__MATH_PRECNAME


94 #if !(
defined
 
__NO_LONG_DOUBLE_MATH
 && defined 
_LIBC
) \

95 || 
defined
 
__LDBL_COMPAT


96 #ifdef 
__LDBL_COMPAT


98 #ifdef 
__USE_ISOC99


99 extern float 
	$__nldbl_nexttowardf
 (float 
__x
, long double 
__y
)

100 
__THROW
 
	`__attribute__
 ((
__const__
));

101 #ifdef 
__REDIRECT_NTH


102 extern float 
	`__REDIRECT_NTH
 (
nexttowardf
, (float 
__x
, long double 
__y
),

103 
__nldbl_nexttowardf
)

104 
	`__attribute__
 ((
__const__
));

105 extern double 
	`__REDIRECT_NTH
 (
nexttoward
, (double 
__x
, long double 
__y
),

106 
nextafter
) 
	`__attribute__
 ((
__const__
));

107 extern long double 
	`__REDIRECT_NTH
 (
nexttowardl
,

108 (long double 
__x
, long double 
__y
),

109 
nextafter
) 
	`__attribute__
 ((
__const__
));

113 #undef 
__MATHDECL_1


114 #define 
	#__MATHDECL_2
(
type
, 
function
,
suffix
, 
args
, 
alias
) \

115 extern 
type
 
	`__REDIRECT_NTH
(
	`__MATH_PRECNAME
(
function
,
suffix
), \

116 
args
, 
alias
)

	)

117 #define 
	#__MATHDECL_1
(
type
, 
function
,
suffix
, 
args
) \

118 
	`__MATHDECL_2
(
type
, 
function
,
suffix
, 
args
, 
	`__CONCAT
(function,suffix))

	)

124 #ifndef 
_Mlong_double_


125 #define 
	#_Mlong_double_
 long double

	)

127 #define 
	#_Mdouble_
 
_Mlong_double_


	)

128 #define 
	#__MATH_PRECNAME
(
name
,
r
) name##
l
##
	)
r

129 #define 
	#_Mdouble_BEGIN_NAMESPACE
 
__BEGIN_NAMESPACE_C99


	)

130 #define 
	#_Mdouble_END_NAMESPACE
 
__END_NAMESPACE_C99


	)

131 #define 
	#__MATH_DECLARE_LDOUBLE
 1

	)

132 #include 
	~<bits/mathcalls.h
>

133 #undef 
_Mdouble_


134 #undef 
_Mdouble_BEGIN_NAMESPACE


135 #undef 
_Mdouble_END_NAMESPACE


136 #undef 
__MATH_PRECNAME


141 #undef 
__MATHDECL_1


142 #undef 
__MATHDECL


143 #undef 
__MATHCALL


146 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


148 extern int 
signgam
;

153 #ifdef 
__USE_ISOC99


191 
FP_NAN
 =

192 #define 
	#FP_NAN
 0

	)

193 
FP_NAN
,

194 
FP_INFINITE
 =

195 #define 
	#FP_INFINITE
 1

	)

196 
FP_INFINITE
,

197 
FP_ZERO
 =

198 #define 
	#FP_ZERO
 2

	)

199 
FP_ZERO
,

200 
FP_SUBNORMAL
 =

201 #define 
	#FP_SUBNORMAL
 3

	)

202 
FP_SUBNORMAL
,

203 
FP_NORMAL
 =

204 #define 
	#FP_NORMAL
 4

	)

205 
FP_NORMAL


209 #ifdef 
__NO_LONG_DOUBLE_MATH


210 #define 
	#fpclassify
(
x
) \

211 (sizeof (
x
) == sizeof (float) ? 
	`__fpclassifyf
 (x) : 
	`__fpclassify
 (x))

	)

213 #define 
	#fpclassify
(
x
) \

214 (sizeof (
x
) == sizeof (float) \

215 ? 
	`__fpclassifyf
 (
x
) \

216 : sizeof (
x
) == sizeof (double) \

217 ? 
	`__fpclassify
 (
x
) : 
	`__fpclassifyl
 (x))

	)

221 #ifdef 
__NO_LONG_DOUBLE_MATH


222 #define 
	#signbit
(
x
) \

223 (sizeof (
x
) == sizeof (float) ? 
	`__signbitf
 (x) : 
	`__signbit
 (x))

	)

225 #define 
	#signbit
(
x
) \

226 (sizeof (
x
) == sizeof (float) \

227 ? 
	`__signbitf
 (
x
) \

228 : sizeof (
x
) == sizeof (double) \

229 ? 
	`__signbit
 (
x
) : 
	`__signbitl
 (x))

	)

233 #ifdef 
__NO_LONG_DOUBLE_MATH


234 #define 
	#isfinite
(
x
) \

235 (sizeof (
x
) == sizeof (float) ? 
	`__finitef
 (x) : 
	`__finite
 (x))

	)

237 #define 
	#isfinite
(
x
) \

238 (sizeof (
x
) == sizeof (float) \

239 ? 
	`__finitef
 (
x
) \

240 : sizeof (
x
) == sizeof (double) \

241 ? 
	`__finite
 (
x
) : 
	`__finitel
 (x))

	)

245 #define 
	#isnormal
(
x
) (
	`fpclassify
 (x) == 
FP_NORMAL
)

	)

249 #ifdef 
__NO_LONG_DOUBLE_MATH


250 #define 
	#isnan
(
x
) \

251 (sizeof (
x
) == sizeof (float) ? 
	`__isnanf
 (x) : 
	`__isnan
 (x))

	)

253 #define 
	#isnan
(
x
) \

254 (sizeof (
x
) == sizeof (float) \

255 ? 
	`__isnanf
 (
x
) \

256 : sizeof (
x
) == sizeof (double) \

257 ? 
	`__isnan
 (
x
) : 
	`__isnanl
 (x))

	)

261 #ifdef 
__NO_LONG_DOUBLE_MATH


262 #define 
	#isinf
(
x
) \

263 (sizeof (
x
) == sizeof (float) ? 
	`__isinff
 (x) : 
	`__isinf
 (x))

	)

265 #define 
	#isinf
(
x
) \

266 (sizeof (
x
) == sizeof (float) \

267 ? 
	`__isinff
 (
x
) \

268 : sizeof (
x
) == sizeof (double) \

269 ? 
	`__isinf
 (
x
) : 
	`__isinfl
 (x))

	)

273 #define 
	#MATH_ERRNO
 1

	)

274 #define 
	#MATH_ERREXCEPT
 2

	)

279 #ifndef 
__FAST_MATH__


280 #define 
	#math_errhandling
 (
MATH_ERRNO
 | 
MATH_ERREXCEPT
)

	)

285 #ifdef 
__USE_GNU


287 #ifdef 
__NO_LONG_DOUBLE_MATH


288 #define 
	#issignaling
(
x
) \

289 (sizeof (
x
) == sizeof (float) ? 
	`__issignalingf
 (x) : 
	`__issignaling
 (x))

	)

291 #define 
	#issignaling
(
x
) \

292 (sizeof (
x
) == sizeof (float) \

293 ? 
	`__issignalingf
 (
x
) \

294 : sizeof (
x
) == sizeof (double) \

295 ? 
	`__issignaling
 (
x
) : 
	`__issignalingl
 (x))

	)

299 #ifdef 
__USE_MISC


303 
_IEEE_
 = -1,

304 
_SVID_
,

305 
_XOPEN_
,

306 
_POSIX_
,

307 
_ISOC_


308 } 
	t_LIB_VERSION_TYPE
;

313 extern 
_LIB_VERSION_TYPE
 
_LIB_VERSION
;

317 #ifdef 
__USE_SVID


323 #ifdef 
__cplusplus


324 struct 
__exception


326 struct 
exception


329 int 
type
;

330 char *
name
;

331 double 
arg1
;

332 double 
arg2
;

333 double 
retval
;

334 
	}
};

336 #ifdef 
__cplusplus


337 extern int 
	$matherr
 (struct 
__exception
 *
__exc
) 
	`throw
 ();

339 extern int 
	`matherr
 (struct 
exception
 *
__exc
);

342 #define 
	#X_TLOSS
 1.41484755040568800000e+16

	)

345 #define 
	#DOMAIN
 1

	)

346 #define 
	#SING
 2

	)

347 #define 
	#OVERFLOW
 3

	)

348 #define 
	#UNDERFLOW
 4

	)

349 #define 
	#TLOSS
 5

	)

350 #define 
	#PLOSS
 6

	)

353 #define 
	#HUGE
 3.40282347e+38F

	)

357 #ifdef 
__USE_XOPEN


359 #define 
	#MAXFLOAT
 3.40282347e+38F

	)

366 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN


367 #define 
	#M_E
 2.7182818284590452354

	)

368 #define 
	#M_LOG2E
 1.4426950408889634074

	)

369 #define 
	#M_LOG10E
 0.43429448190325182765

	)

370 #define 
	#M_LN2
 0.69314718055994530942

	)

371 #define 
	#M_LN10
 2.30258509299404568402

	)

372 #define 
	#M_PI
 3.14159265358979323846

	)

373 #define 
	#M_PI_2
 1.57079632679489661923

	)

374 #define 
	#M_PI_4
 0.78539816339744830962

	)

375 #define 
	#M_1_PI
 0.31830988618379067154

	)

376 #define 
	#M_2_PI
 0.63661977236758134308

	)

377 #define 
	#M_2_SQRTPI
 1.12837916709551257390

	)

378 #define 
	#M_SQRT2
 1.41421356237309504880

	)

379 #define 
	#M_SQRT1_2
 0.70710678118654752440

	)

385 #ifdef 
__USE_GNU


386 #define 
	#M_El
 2.718281828459045235360287471352662498L

	)

387 #define 
	#M_LOG2El
 1.442695040888963407359924681001892137L

	)

388 #define 
	#M_LOG10El
 0.434294481903251827651128918916605082L

	)

389 #define 
	#M_LN2l
 0.693147180559945309417232121458176568L

	)

390 #define 
	#M_LN10l
 2.302585092994045684017991454684364208L

	)

391 #define 
	#M_PIl
 3.141592653589793238462643383279502884L

	)

392 #define 
	#M_PI_2l
 1.570796326794896619231321691639751442L

	)

393 #define 
	#M_PI_4l
 0.785398163397448309615660845819875721L

	)

394 #define 
	#M_1_PIl
 0.318309886183790671537767526745028724L

	)

395 #define 
	#M_2_PIl
 0.636619772367581343075535053490057448L

	)

396 #define 
	#M_2_SQRTPIl
 1.128379167095512573896158903121545172L

	)

397 #define 
	#M_SQRT2l
 1.414213562373095048801688724209698079L

	)

398 #define 
	#M_SQRT1_2l
 0.707106781186547524400844362104849039L

	)

405 #if 
defined
 
__STRICT_ANSI__
 && !defined 
__NO_MATH_INLINES


406 #define 
	#__NO_MATH_INLINES
 1

	)

409 #if 
defined
 
__USE_ISOC99
 && 
	`__GNUC_PREREQ
(2,97)

416 #define 
	#isgreater
(
x
, 
y
) 
	`__builtin_isgreater
(x, y)

	)

417 #define 
	#isgreaterequal
(
x
, 
y
) 
	`__builtin_isgreaterequal
(x, y)

	)

418 #define 
	#isless
(
x
, 
y
) 
	`__builtin_isless
(x, y)

	)

419 #define 
	#islessequal
(
x
, 
y
) 
	`__builtin_islessequal
(x, y)

	)

420 #define 
	#islessgreater
(
x
, 
y
) 
	`__builtin_islessgreater
(x, y)

	)

421 #define 
	#isunordered
(
u
, 
v
) 
	`__builtin_isunordered
(u, v)

	)

425 #ifdef 
__USE_EXTERN_INLINES


426 #include 
	~<bits/mathinline.h
>

431 #if 
defined
 
__FINITE_MATH_ONLY__
 && __FINITE_MATH_ONLY__ > 0

432 #include 
	~<bits/math-finite.h
>

435 #ifdef 
__USE_ISOC99


439 #ifndef 
isgreater


440 #define 
	#isgreater
(
x
, 
y
) \

441 (
__extension__
 \

442 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

443 !
	`isunordered
 (
__x
, 
__y
) && __x > __y; 
	}
}))

	)

447 #ifndef 
isgreaterequal


448 #define 
	#isgreaterequal
(
x
, 
y
) \

449 (
__extension__
 \

450 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

451 !
	`isunordered
 (
__x
, 
__y
) && __x >= __y; }))

	)

455 #ifndef 
isless


456 #define 
	#isless
(
x
, 
y
) \

457 (
__extension__
 \

458 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

459 !
	`isunordered
 (
__x
, 
__y
) && __x < __y; }))

	)

463 #ifndef 
islessequal


464 #define 
	#islessequal
(
x
, 
y
) \

465 (
__extension__
 \

466 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

467 !
	`isunordered
 (
__x
, 
__y
) && __x <= __y; }))

	)

471 #ifndef 
islessgreater


472 #define 
	#islessgreater
(
x
, 
y
) \

473 (
__extension__
 \

474 ({ 
	`__typeof__
(
x
) 
__x
 = (x); __typeof__(
y
) 
__y
 = (y); \

475 !
	`isunordered
 (
__x
, 
__y
) && (__x < __y || __y < __x); }))

	)

479 #ifndef 
isunordered


480 #define 
	#isunordered
(
u
, 
v
) \

481 (
__extension__
 \

482 ({ 
	`__typeof__
(
u
) 
__u
 = (u); __typeof__(
v
) 
__v
 = (v); \

483 
	`fpclassify
 (
__u
) == 
FP_NAN
 || fpclassify (
__v
) == FP_NAN; }))

	)

488 
	g__END_DECLS


	@/usr/include/stdint.h

22 #ifndef 
_STDINT_H


23 #define 
	#_STDINT_H
 1

	)

25 #include 
	~<features.h
>

26 #include 
	~<bits/wchar.h
>

27 #include 
	~<bits/wordsize.h
>

34 #ifndef 
__int8_t_defined


35 #define 
	#__int8_t_defined


	)

36 typedef signed char 
	tint8_t
;

37 typedef short int 
	tint16_t
;

38 typedef int 
	tint32_t
;

39 #if 
__WORDSIZE
 == 64

40 typedef long int 
	tint64_t
;

42 
__extension__


43 typedef long long int 
	tint64_t
;

48 typedef unsigned char 
	tuint8_t
;

49 typedef unsigned short int 
	tuint16_t
;

50 #ifndef 
__uint32_t_defined


51 typedef unsigned int 
	tuint32_t
;

52 #define 
	#__uint32_t_defined


	)

54 #if 
__WORDSIZE
 == 64

55 typedef unsigned long int 
	tuint64_t
;

57 
__extension__


58 typedef unsigned long long int 
	tuint64_t
;

65 typedef signed char 
	tint_least8_t
;

66 typedef short int 
	tint_least16_t
;

67 typedef int 
	tint_least32_t
;

68 #if 
__WORDSIZE
 == 64

69 typedef long int 
	tint_least64_t
;

71 
__extension__


72 typedef long long int 
	tint_least64_t
;

76 typedef unsigned char 
	tuint_least8_t
;

77 typedef unsigned short int 
	tuint_least16_t
;

78 typedef unsigned int 
	tuint_least32_t
;

79 #if 
__WORDSIZE
 == 64

80 typedef unsigned long int 
	tuint_least64_t
;

82 
__extension__


83 typedef unsigned long long int 
	tuint_least64_t
;

90 typedef signed char 
	tint_fast8_t
;

91 #if 
__WORDSIZE
 == 64

92 typedef long int 
	tint_fast16_t
;

93 typedef long int 
	tint_fast32_t
;

94 typedef long int 
	tint_fast64_t
;

96 typedef int 
	tint_fast16_t
;

97 typedef int 
	tint_fast32_t
;

98 
__extension__


99 typedef long long int 
	tint_fast64_t
;

103 typedef unsigned char 
	tuint_fast8_t
;

104 #if 
__WORDSIZE
 == 64

105 typedef unsigned long int 
	tuint_fast16_t
;

106 typedef unsigned long int 
	tuint_fast32_t
;

107 typedef unsigned long int 
	tuint_fast64_t
;

109 typedef unsigned int 
	tuint_fast16_t
;

110 typedef unsigned int 
	tuint_fast32_t
;

111 
__extension__


112 typedef unsigned long long int 
	tuint_fast64_t
;

117 #if 
__WORDSIZE
 == 64

118 #ifndef 
__intptr_t_defined


119 typedef long int 
	tintptr_t
;

120 #define 
	#__intptr_t_defined


	)

122 typedef unsigned long int 
	tuintptr_t
;

124 #ifndef 
__intptr_t_defined


125 typedef int 
	tintptr_t
;

126 #define 
	#__intptr_t_defined


	)

128 typedef unsigned int 
	tuintptr_t
;

133 #if 
__WORDSIZE
 == 64

134 typedef long int 
	tintmax_t
;

135 typedef unsigned long int 
	tuintmax_t
;

137 
__extension__


138 typedef long long int 
	tintmax_t
;

139 
__extension__


140 typedef unsigned long long int 
	tuintmax_t
;

144 #if 
__WORDSIZE
 == 64

145 #define 
	#__INT64_C
(
c
) c ## 
L


	)

146 #define 
	#__UINT64_C
(
c
) c ## 
UL


	)

148 #define 
	#__INT64_C
(
c
) c ## 
LL


	)

149 #define 
	#__UINT64_C
(
c
) c ## 
ULL


	)

155 #define 
	#INT8_MIN
 (-128)

	)

156 #define 
	#INT16_MIN
 (-32767-1)

	)

157 #define 
	#INT32_MIN
 (-2147483647-1)

	)

158 #define 
	#INT64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

160 #define 
	#INT8_MAX
 (127)

	)

161 #define 
	#INT16_MAX
 (32767)

	)

162 #define 
	#INT32_MAX
 (2147483647)

	)

163 #define 
	#INT64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

166 #define 
	#UINT8_MAX
 (255)

	)

167 #define 
	#UINT16_MAX
 (65535)

	)

168 #define 
	#UINT32_MAX
 (4294967295U)

	)

169 #define 
	#UINT64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

173 #define 
	#INT_LEAST8_MIN
 (-128)

	)

174 #define 
	#INT_LEAST16_MIN
 (-32767-1)

	)

175 #define 
	#INT_LEAST32_MIN
 (-2147483647-1)

	)

176 #define 
	#INT_LEAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

178 #define 
	#INT_LEAST8_MAX
 (127)

	)

179 #define 
	#INT_LEAST16_MAX
 (32767)

	)

180 #define 
	#INT_LEAST32_MAX
 (2147483647)

	)

181 #define 
	#INT_LEAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

184 #define 
	#UINT_LEAST8_MAX
 (255)

	)

185 #define 
	#UINT_LEAST16_MAX
 (65535)

	)

186 #define 
	#UINT_LEAST32_MAX
 (4294967295U)

	)

187 #define 
	#UINT_LEAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

191 #define 
	#INT_FAST8_MIN
 (-128)

	)

192 #if 
__WORDSIZE
 == 64

193 #define 
	#INT_FAST16_MIN
 (-9223372036854775807L-1)

	)

194 #define 
	#INT_FAST32_MIN
 (-9223372036854775807L-1)

	)

196 #define 
	#INT_FAST16_MIN
 (-2147483647-1)

	)

197 #define 
	#INT_FAST32_MIN
 (-2147483647-1)

	)

199 #define 
	#INT_FAST64_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

201 #define 
	#INT_FAST8_MAX
 (127)

	)

202 #if 
__WORDSIZE
 == 64

203 #define 
	#INT_FAST16_MAX
 (9223372036854775807L)

	)

204 #define 
	#INT_FAST32_MAX
 (9223372036854775807L)

	)

206 #define 
	#INT_FAST16_MAX
 (2147483647)

	)

207 #define 
	#INT_FAST32_MAX
 (2147483647)

	)

209 #define 
	#INT_FAST64_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

212 #define 
	#UINT_FAST8_MAX
 (255)

	)

213 #if 
__WORDSIZE
 == 64

214 #define 
	#UINT_FAST16_MAX
 (18446744073709551615UL)

	)

215 #define 
	#UINT_FAST32_MAX
 (18446744073709551615UL)

	)

217 #define 
	#UINT_FAST16_MAX
 (4294967295U)

	)

218 #define 
	#UINT_FAST32_MAX
 (4294967295U)

	)

220 #define 
	#UINT_FAST64_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

224 #if 
__WORDSIZE
 == 64

225 #define 
	#INTPTR_MIN
 (-9223372036854775807L-1)

	)

226 #define 
	#INTPTR_MAX
 (9223372036854775807L)

	)

227 #define 
	#UINTPTR_MAX
 (18446744073709551615UL)

	)

229 #define 
	#INTPTR_MIN
 (-2147483647-1)

	)

230 #define 
	#INTPTR_MAX
 (2147483647)

	)

231 #define 
	#UINTPTR_MAX
 (4294967295U)

	)

236 #define 
	#INTMAX_MIN
 (-
	`__INT64_C
(9223372036854775807)-1)

	)

238 #define 
	#INTMAX_MAX
 (
	`__INT64_C
(9223372036854775807))

	)

241 #define 
	#UINTMAX_MAX
 (
	`__UINT64_C
(18446744073709551615))

	)

247 #if 
__WORDSIZE
 == 64

248 #define 
	#PTRDIFF_MIN
 (-9223372036854775807L-1)

	)

249 #define 
	#PTRDIFF_MAX
 (9223372036854775807L)

	)

251 #define 
	#PTRDIFF_MIN
 (-2147483647-1)

	)

252 #define 
	#PTRDIFF_MAX
 (2147483647)

	)

256 #define 
	#SIG_ATOMIC_MIN
 (-2147483647-1)

	)

257 #define 
	#SIG_ATOMIC_MAX
 (2147483647)

	)

260 #if 
__WORDSIZE
 == 64

261 #define 
	#SIZE_MAX
 (18446744073709551615UL)

	)

263 #define 
	#SIZE_MAX
 (4294967295U)

	)

267 #ifndef 
WCHAR_MIN


269 #define 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

270 #define 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

274 #define 
	#WINT_MIN
 (0u)

	)

275 #define 
	#WINT_MAX
 (4294967295u)

	)

278 #define 
	#INT8_C
(
c
) 
	)
c

279 #define 
	#INT16_C
(
c
) 
	)
c

280 #define 
	#INT32_C
(
c
) 
	)
c

281 #if 
__WORDSIZE
 == 64

282 #define 
	#INT64_C
(
c
) c ## 
L


	)

284 #define 
	#INT64_C
(
c
) c ## 
LL


	)

288 #define 
	#UINT8_C
(
c
) 
	)
c

289 #define 
	#UINT16_C
(
c
) 
	)
c

290 #define 
	#UINT32_C
(
c
) c ## 
U


	)

291 #if 
__WORDSIZE
 == 64

292 #define 
	#UINT64_C
(
c
) c ## 
UL


	)

294 #define 
	#UINT64_C
(
c
) c ## 
ULL


	)

298 #if 
__WORDSIZE
 == 64

299 #define 
	#INTMAX_C
(
c
) c ## 
L


	)

300 #define 
	#UINTMAX_C
(
c
) c ## 
UL


	)

302 #define 
	#INTMAX_C
(
c
) c ## 
LL


	)

303 #define 
	#UINTMAX_C
(
c
) c ## 
ULL


	)

	@/usr/include/stdio.h

23 #ifndef 
_STDIO_H


25 #if !
defined
 
__need_FILE
 && !defined 
__need___FILE


26 #define 
	#_STDIO_H
 1

	)

27 #include 
	~<features.h
>

29 
	g__BEGIN_DECLS


31 #define 
	#__need_size_t


	)

32 #define 
	#__need_NULL


	)

33 #include 
	~<stddef.h
>

35 #include 
	~<bits/types.h
>

36 #define 
	#__need_FILE


	)

37 #define 
	#__need___FILE


	)

41 #if !
defined
 
__FILE_defined
 && defined 
__need_FILE


44 struct 
	g_IO_FILE
;

46 
__BEGIN_NAMESPACE_STD


48 typedef struct 
_IO_FILE
 
	tFILE
;

49 
	g__END_NAMESPACE_STD


50 #if 
defined
 
__USE_LARGEFILE64
 || defined 
__USE_SVID
 || defined 
__USE_POSIX
 \

51 || 
defined
 
	g__USE_BSD
 || defined 
	g__USE_ISOC99
 || defined 
	g__USE_XOPEN
 \

52 || 
defined
 
__USE_POSIX2


53 
	$__USING_NAMESPACE_STD
(
FILE
)

56 #define 
	#__FILE_defined
 1

	)

58 #undef 
__need_FILE


61 #if !
defined
 
____FILE_defined
 && defined 
__need___FILE


64 typedef struct 
_IO_FILE
 
	t__FILE
;

66 #define 
	#____FILE_defined
 1

	)

68 #undef 
__need___FILE


71 #ifdef 
_STDIO_H


72 #define 
	#_STDIO_USES_IOSTREAM


	)

74 #include 
	~<libio.h
>

76 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


77 #ifdef 
__GNUC__


78 #ifndef 
_VA_LIST_DEFINED


79 typedef 
_G_va_list
 
	tva_list
;

80 #define 
	#_VA_LIST_DEFINED


	)

83 #include 
	~<stdarg.h
>

87 #ifdef 
__USE_XOPEN2K8


88 #ifndef 
__off_t_defined


89 #ifndef 
__USE_FILE_OFFSET64


90 typedef 
__off_t
 
	toff_t
;

92 typedef 
__off64_t
 
	toff_t
;

94 #define 
	#__off_t_defined


	)

96 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


97 typedef 
__off64_t
 
	toff64_t
;

98 #define 
	#__off64_t_defined


	)

101 #ifndef 
__ssize_t_defined


102 typedef 
__ssize_t
 
	tssize_t
;

103 #define 
	#__ssize_t_defined


	)

108 
__BEGIN_NAMESPACE_STD


109 #ifndef 
__USE_FILE_OFFSET64


110 typedef 
_G_fpos_t
 
	tfpos_t
;

112 typedef 
_G_fpos64_t
 
	tfpos_t
;

114 
__END_NAMESPACE_STD


115 #ifdef 
__USE_LARGEFILE64


116 typedef 
_G_fpos64_t
 
	tfpos64_t
;

120 #define 
	#_IOFBF
 0

	)

121 #define 
	#_IOLBF
 1

	)

122 #define 
	#_IONBF
 2

	)

126 #ifndef 
BUFSIZ


127 #define 
	#BUFSIZ
 
_IO_BUFSIZ


	)

133 #ifndef 
EOF


134 #define 
	#EOF
 (-1)

	)

140 #define 
	#SEEK_SET
 0

	)

141 #define 
	#SEEK_CUR
 1

	)

142 #define 
	#SEEK_END
 2

	)

143 #ifdef 
__USE_GNU


144 #define 
	#SEEK_DATA
 3

	)

145 #define 
	#SEEK_HOLE
 4

	)

149 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


151 #define 
	#P_tmpdir
 "/tmp"

	)

164 #include 
	~<bits/stdio_lim.h
>

168 extern struct 
_IO_FILE
 *
stdin
;

169 extern struct 
_IO_FILE
 *
stdout
;

170 extern struct 
_IO_FILE
 *
stderr
;

172 #define 
	#stdin
 
stdin


	)

173 #define 
	#stdout
 
stdout


	)

174 #define 
	#stderr
 
stderr


	)

176 
__BEGIN_NAMESPACE_STD


178 extern int 
	$remove
 (const char *
__filename
) 
__THROW
;

180 extern int 
	$rename
 (const char *
__old
, const char *
__new
) 
__THROW
;

181 
__END_NAMESPACE_STD


183 #ifdef 
__USE_ATFILE


185 extern int 
	$renameat
 (int 
__oldfd
, const char *
__old
, int 
__newfd
,

186 const char *
__new
) 
__THROW
;

189 
__BEGIN_NAMESPACE_STD


194 #ifndef 
__USE_FILE_OFFSET64


195 extern 
FILE
 *
	$tmpfile
 (void) 
__wur
;

197 #ifdef 
__REDIRECT


198 extern 
FILE
 *
	`__REDIRECT
 (
tmpfile
, (void), 
tmpfile64
) 
__wur
;

200 #define 
	#tmpfile
 
tmpfile64


	)

204 #ifdef 
__USE_LARGEFILE64


205 extern 
FILE
 *
	$tmpfile64
 (void) 
__wur
;

209 extern char *
	$tmpnam
 (char *
__s
) 
__THROW
 
__wur
;

210 
__END_NAMESPACE_STD


212 #ifdef 
__USE_MISC


215 extern char *
	$tmpnam_r
 (char *
__s
) 
__THROW
 
__wur
;

219 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


227 extern char *
	$tempnam
 (const char *
__dir
, const char *
__pfx
)

228 
__THROW
 
__attribute_malloc__
 
__wur
;

232 
__BEGIN_NAMESPACE_STD


237 extern int 
	`fclose
 (
FILE
 *
__stream
);

242 extern int 
	`fflush
 (
FILE
 *
__stream
);

243 
__END_NAMESPACE_STD


245 #ifdef 
__USE_MISC


252 extern int 
	`fflush_unlocked
 (
FILE
 *
__stream
);

255 #ifdef 
__USE_GNU


262 extern int 
	`fcloseall
 (void);

266 
__BEGIN_NAMESPACE_STD


267 #ifndef 
__USE_FILE_OFFSET64


272 extern 
FILE
 *
	$fopen
 (const char *
__restrict
 
__filename
,

273 const char *
__restrict
 
__modes
) 
__wur
;

278 extern 
FILE
 *
	$freopen
 (const char *
__restrict
 
__filename
,

279 const char *
__restrict
 
__modes
,

280 
FILE
 *
__restrict
 
__stream
) 
__wur
;

282 #ifdef 
__REDIRECT


283 extern 
FILE
 *
	`__REDIRECT
 (
fopen
, (const char *
__restrict
 
__filename
,

284 const char *
__restrict
 
__modes
), 
fopen64
)

285 
__wur
;

286 extern 
FILE
 *
	`__REDIRECT
 (
freopen
, (const char *
__restrict
 
__filename
,

287 const char *
__restrict
 
__modes
,

288 
FILE
 *
__restrict
 
__stream
), 
freopen64
)

289 
__wur
;

291 #define 
	#fopen
 
fopen64


	)

292 #define 
	#freopen
 
freopen64


	)

295 
__END_NAMESPACE_STD


296 #ifdef 
__USE_LARGEFILE64


297 extern 
FILE
 *
	$fopen64
 (const char *
__restrict
 
__filename
,

298 const char *
__restrict
 
__modes
) 
__wur
;

299 extern 
FILE
 *
	$freopen64
 (const char *
__restrict
 
__filename
,

300 const char *
__restrict
 
__modes
,

301 
FILE
 *
__restrict
 
__stream
) 
__wur
;

304 #ifdef 
__USE_POSIX


306 extern 
FILE
 *
	$fdopen
 (int 
__fd
, const char *
__modes
) 
__THROW
 
__wur
;

309 #ifdef 
__USE_GNU


312 extern 
FILE
 *
	$fopencookie
 (void *
__restrict
 
__magic_cookie
,

313 const char *
__restrict
 
__modes
,

314 
_IO_cookie_io_functions_t
 
__io_funcs
) 
__THROW
 
__wur
;

317 #ifdef 
__USE_XOPEN2K8


319 extern 
FILE
 *
	$fmemopen
 (void *
__s
, 
size_t
 
__len
, const char *
__modes
)

320 
__THROW
 
__wur
;

325 extern 
FILE
 *
	$open_memstream
 (char **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
 
__wur
;

329 
__BEGIN_NAMESPACE_STD


332 extern void 
	$setbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
) 
__THROW
;

336 extern int 
	$setvbuf
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

337 int 
__modes
, 
size_t
 
__n
) 
__THROW
;

338 
__END_NAMESPACE_STD


340 #ifdef 
__USE_BSD


343 extern void 
	$setbuffer
 (
FILE
 *
__restrict
 
__stream
, char *__restrict 
__buf
,

344 
size_t
 
__size
) 
__THROW
;

347 extern void 
	$setlinebuf
 (
FILE
 *
__stream
) 
__THROW
;

351 
__BEGIN_NAMESPACE_STD


356 extern int 
	`fprintf
 (
FILE
 *
__restrict
 
__stream
,

357 const char *
__restrict
 
__format
, ...);

362 extern int 
	`printf
 (const char *
__restrict
 
__format
, ...);

364 extern int 
	$sprintf
 (char *
__restrict
 
__s
,

365 const char *
__restrict
 
__format
, ...) 
__THROWNL
;

371 extern int 
	`vfprintf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

372 
_G_va_list
 
__arg
);

377 extern int 
	`vprintf
 (const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
);

379 extern int 
	$vsprintf
 (char *
__restrict
 
__s
, const char *__restrict 
__format
,

380 
_G_va_list
 
__arg
) 
__THROWNL
;

381 
__END_NAMESPACE_STD


383 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


384 
__BEGIN_NAMESPACE_C99


386 extern int 
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

387 const char *
__restrict
 
__format
, ...)

388 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

390 extern int 
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__maxlen
,

391 const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

392 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

393 
__END_NAMESPACE_C99


396 #ifdef 
__USE_GNU


399 extern int 
	$vasprintf
 (char **
__restrict
 
__ptr
, const char *__restrict 
__f
,

400 
_G_va_list
 
__arg
)

401 
__THROWNL
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 0))) 
__wur
;

402 extern int 
	$__asprintf
 (char **
__restrict
 
__ptr
,

403 const char *
__restrict
 
__fmt
, ...)

404 
__THROWNL
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

405 extern int 
	$asprintf
 (char **
__restrict
 
__ptr
,

406 const char *
__restrict
 
__fmt
, ...)

407 
__THROWNL
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 2, 3))) 
__wur
;

410 #ifdef 
__USE_XOPEN2K8


412 extern int 
	$vdprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
,

413 
_G_va_list
 
__arg
)

414 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

415 extern int 
	$dprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
, ...)

416 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

420 
__BEGIN_NAMESPACE_STD


425 extern int 
	$fscanf
 (
FILE
 *
__restrict
 
__stream
,

426 const char *
__restrict
 
__format
, ...) 
__wur
;

431 extern int 
	$scanf
 (const char *
__restrict
 
__format
, ...) 
__wur
;

433 extern int 
	$sscanf
 (const char *
__restrict
 
__s
,

434 const char *
__restrict
 
__format
, ...) 
__THROW
;

436 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

437 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

438 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

439 #ifdef 
__REDIRECT


443 extern int 
	`__REDIRECT
 (
fscanf
, (
FILE
 *
__restrict
 
__stream
,

444 const char *
__restrict
 
__format
, ...),

445 
__isoc99_fscanf
) 
__wur
;

446 extern int 
	`__REDIRECT
 (
scanf
, (const char *
__restrict
 
__format
, ...),

447 
__isoc99_scanf
) 
__wur
;

448 extern int 
	`__REDIRECT_NTH
 (
sscanf
, (const char *
__restrict
 
__s
,

449 const char *
__restrict
 
__format
, ...),

450 
__isoc99_sscanf
);

452 extern int 
	$__isoc99_fscanf
 (
FILE
 *
__restrict
 
__stream
,

453 const char *
__restrict
 
__format
, ...) 
__wur
;

454 extern int 
	$__isoc99_scanf
 (const char *
__restrict
 
__format
, ...) 
__wur
;

455 extern int 
	$__isoc99_sscanf
 (const char *
__restrict
 
__s
,

456 const char *
__restrict
 
__format
, ...) 
__THROW
;

457 #define 
	#fscanf
 
__isoc99_fscanf


	)

458 #define 
	#scanf
 
__isoc99_scanf


	)

459 #define 
	#sscanf
 
__isoc99_sscanf


	)

463 
__END_NAMESPACE_STD


465 #ifdef 
__USE_ISOC99


466 
__BEGIN_NAMESPACE_C99


471 extern int 
	$vfscanf
 (
FILE
 *
__restrict
 
__s
, const char *__restrict 
__format
,

472 
_G_va_list
 
__arg
)

473 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

479 extern int 
	$vscanf
 (const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

480 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

483 extern int 
	$vsscanf
 (const char *
__restrict
 
__s
,

484 const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
)

485 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

487 #if !
defined
 
__USE_GNU
 \

488 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

489 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

490 #ifdef 
__REDIRECT


494 extern int 
	`__REDIRECT
 (
vfscanf
,

495 (
FILE
 *
__restrict
 
__s
,

496 const char *
__restrict
 
__format
, 
_G_va_list
 
__arg
),

497 
__isoc99_vfscanf
)

498 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 2, 0))) 
__wur
;

499 extern int 
	`__REDIRECT
 (
vscanf
, (const char *
__restrict
 
__format
,

500 
_G_va_list
 
__arg
), 
__isoc99_vscanf
)

501 
	`__attribute__
 ((
	$__format__
 (
__scanf__
, 1, 0))) 
__wur
;

502 extern int 
	`__REDIRECT_NTH
 (
vsscanf
,

503 (const char *
__restrict
 
__s
,

504 const char *
__restrict
 
__format
,

505 
_G_va_list
 
__arg
), 
__isoc99_vsscanf
)

506 
	`__attribute__
 ((
	`__format__
 (
__scanf__
, 2, 0)));

508 extern int 
	$__isoc99_vfscanf
 (
FILE
 *
__restrict
 
__s
,

509 const char *
__restrict
 
__format
,

510 
_G_va_list
 
__arg
) 
__wur
;

511 extern int 
	$__isoc99_vscanf
 (const char *
__restrict
 
__format
,

512 
_G_va_list
 
__arg
) 
__wur
;

513 extern int 
	$__isoc99_vsscanf
 (const char *
__restrict
 
__s
,

514 const char *
__restrict
 
__format
,

515 
_G_va_list
 
__arg
) 
__THROW
;

516 #define 
	#vfscanf
 
__isoc99_vfscanf


	)

517 #define 
	#vscanf
 
__isoc99_vscanf


	)

518 #define 
	#vsscanf
 
__isoc99_vsscanf


	)

522 
__END_NAMESPACE_C99


526 
__BEGIN_NAMESPACE_STD


531 extern int 
	`fgetc
 (
FILE
 *
__stream
);

532 extern int 
	`getc
 (
FILE
 *
__stream
);

538 extern int 
	`getchar
 (void);

539 
__END_NAMESPACE_STD


543 #define 
	#getc
(
_fp
) 
	`_IO_getc
 (_fp)

	)

545 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


550 extern int 
	`getc_unlocked
 (
FILE
 *
__stream
);

551 extern int 
	`getchar_unlocked
 (void);

554 #ifdef 
__USE_MISC


561 extern int 
	`fgetc_unlocked
 (
FILE
 *
__stream
);

565 
__BEGIN_NAMESPACE_STD


573 extern int 
	`fputc
 (int 
__c
, 
FILE
 *
__stream
);

574 extern int 
	`putc
 (int 
__c
, 
FILE
 *
__stream
);

580 extern int 
	`putchar
 (int 
__c
);

581 
__END_NAMESPACE_STD


585 #define 
	#putc
(
_ch
, 
_fp
) 
	`_IO_putc
 (_ch, _fp)

	)

587 #ifdef 
__USE_MISC


594 extern int 
	`fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

597 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


602 extern int 
	`putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
);

603 extern int 
	`putchar_unlocked
 (int 
__c
);

607 #if 
defined
 
__USE_SVID
 || defined 
__USE_MISC
 \

608 || (
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
)

610 extern int 
	`getw
 (
FILE
 *
__stream
);

613 extern int 
	`putw
 (int 
__w
, 
FILE
 *
__stream
);

617 
__BEGIN_NAMESPACE_STD


622 extern char *
	$fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

623 
__wur
;

625 #if !
defined
 
__USE_ISOC11
 \

626 || (
defined
 
__cplusplus
 && __cplusplus <= 201103L)

638 extern char *
	$gets
 (char *
__s
) 
__wur
 
__attribute_deprecated__
;

640 
__END_NAMESPACE_STD


642 #ifdef 
__USE_GNU


649 extern char *
	$fgets_unlocked
 (char *
__restrict
 
__s
, int 
__n
,

650 
FILE
 *
__restrict
 
__stream
) 
__wur
;

654 #ifdef 
__USE_XOPEN2K8


665 extern 
_IO_ssize_t
 
	$__getdelim
 (char **
__restrict
 
__lineptr
,

666 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

667 
FILE
 *
__restrict
 
__stream
) 
__wur
;

668 extern 
_IO_ssize_t
 
	$getdelim
 (char **
__restrict
 
__lineptr
,

669 
size_t
 *
__restrict
 
__n
, int 
__delimiter
,

670 
FILE
 *
__restrict
 
__stream
) 
__wur
;

678 extern 
_IO_ssize_t
 
	$getline
 (char **
__restrict
 
__lineptr
,

679 
size_t
 *
__restrict
 
__n
,

680 
FILE
 *
__restrict
 
__stream
) 
__wur
;

684 
__BEGIN_NAMESPACE_STD


689 extern int 
	`fputs
 (const char *
__restrict
 
__s
, 
FILE
 *__restrict 
__stream
);

695 extern int 
	`puts
 (const char *
__s
);

702 extern int 
	`ungetc
 (int 
__c
, 
FILE
 *
__stream
);

709 extern 
size_t
 
	$fread
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

710 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

715 extern 
size_t
 
	`fwrite
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

716 
size_t
 
__n
, 
FILE
 *
__restrict
 
__s
);

717 
__END_NAMESPACE_STD


719 #ifdef 
__USE_GNU


726 extern int 
	`fputs_unlocked
 (const char *
__restrict
 
__s
,

727 
FILE
 *
__restrict
 
__stream
);

730 #ifdef 
__USE_MISC


737 extern 
size_t
 
	$fread_unlocked
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

738 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

739 extern 
size_t
 
	`fwrite_unlocked
 (const void *
__restrict
 
__ptr
, size_t 
__size
,

740 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
);

744 
__BEGIN_NAMESPACE_STD


749 extern int 
	`fseek
 (
FILE
 *
__stream
, long int 
__off
, int 
__whence
);

754 extern long int 
	$ftell
 (
FILE
 *
__stream
) 
__wur
;

759 extern void 
	`rewind
 (
FILE
 *
__stream
);

760 
__END_NAMESPACE_STD


767 #if 
defined
 
__USE_LARGEFILE
 || defined 
__USE_XOPEN2K


768 #ifndef 
__USE_FILE_OFFSET64


773 extern int 
	`fseeko
 (
FILE
 *
__stream
, 
__off_t
 
__off
, int 
__whence
);

778 extern 
__off_t
 
	$ftello
 (
FILE
 *
__stream
) 
__wur
;

780 #ifdef 
__REDIRECT


781 extern int 
	`__REDIRECT
 (
fseeko
,

782 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
),

783 
fseeko64
);

784 extern 
__off64_t
 
	`__REDIRECT
 (
ftello
, (
FILE
 *
__stream
), 
ftello64
);

786 #define 
	#fseeko
 
fseeko64


	)

787 #define 
	#ftello
 
ftello64


	)

792 
__BEGIN_NAMESPACE_STD


793 #ifndef 
__USE_FILE_OFFSET64


798 extern int 
	`fgetpos
 (
FILE
 *
__restrict
 
__stream
, 
fpos_t
 *__restrict 
__pos
);

803 extern int 
	`fsetpos
 (
FILE
 *
__stream
, const 
fpos_t
 *
__pos
);

805 #ifdef 
__REDIRECT


806 extern int 
	`__REDIRECT
 (
fgetpos
, (
FILE
 *
__restrict
 
__stream
,

807 
fpos_t
 *
__restrict
 
__pos
), 
fgetpos64
);

808 extern int 
	`__REDIRECT
 (
fsetpos
,

809 (
FILE
 *
__stream
, const 
fpos_t
 *
__pos
), 
fsetpos64
);

811 #define 
	#fgetpos
 
fgetpos64


	)

812 #define 
	#fsetpos
 
fsetpos64


	)

815 
__END_NAMESPACE_STD


817 #ifdef 
__USE_LARGEFILE64


818 extern int 
	`fseeko64
 (
FILE
 *
__stream
, 
__off64_t
 
__off
, int 
__whence
);

819 extern 
__off64_t
 
	$ftello64
 (
FILE
 *
__stream
) 
__wur
;

820 extern int 
	`fgetpos64
 (
FILE
 *
__restrict
 
__stream
, 
fpos64_t
 *__restrict 
__pos
);

821 extern int 
	`fsetpos64
 (
FILE
 *
__stream
, const 
fpos64_t
 *
__pos
);

824 
__BEGIN_NAMESPACE_STD


826 extern void 
	$clearerr
 (
FILE
 *
__stream
) 
__THROW
;

828 extern int 
	$feof
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

830 extern int 
	$ferror
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

831 
__END_NAMESPACE_STD


833 #ifdef 
__USE_MISC


835 extern void 
	$clearerr_unlocked
 (
FILE
 *
__stream
) 
__THROW
;

836 extern int 
	$feof_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

837 extern int 
	$ferror_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

841 
__BEGIN_NAMESPACE_STD


846 extern void 
	`perror
 (const char *
__s
);

847 
__END_NAMESPACE_STD


853 #include 
	~<bits/sys_errlist.h
>

856 #ifdef 
__USE_POSIX


858 extern int 
	$fileno
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

861 #ifdef 
__USE_MISC


863 extern int 
	$fileno_unlocked
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

867 #if (
defined
 
__USE_POSIX2
 || defined 
__USE_SVID
 || defined 
__USE_BSD
 || \

868 
defined
 
__USE_MISC
)

873 extern 
FILE
 *
	$popen
 (const char *
__command
, const char *
__modes
) 
__wur
;

879 extern int 
	`pclose
 (
FILE
 *
__stream
);

883 #ifdef 
__USE_POSIX


885 extern char *
	$ctermid
 (char *
__s
) 
__THROW
;

889 #ifdef 
__USE_XOPEN


891 extern char *
	`cuserid
 (char *
__s
);

895 #ifdef 
__USE_GNU


896 struct 
obstack
;

899 extern int 
	$obstack_printf
 (struct 
obstack
 *
__restrict
 
__obstack
,

900 const char *
__restrict
 
__format
, ...)

901 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 3)));

902 extern int 
	$obstack_vprintf
 (struct 
obstack
 *
__restrict
 
__obstack
,

903 const char *
__restrict
 
__format
,

904 
_G_va_list
 
__args
)

905 
__THROWNL
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 2, 0)));

909 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


913 extern void 
	$flockfile
 (
FILE
 *
__stream
) 
__THROW
;

917 extern int 
	$ftrylockfile
 (
FILE
 *
__stream
) 
__THROW
 
__wur
;

920 extern void 
	$funlockfile
 (
FILE
 *
__stream
) 
__THROW
;

923 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_XOPEN2K
 && !defined 
__USE_GNU


927 #define 
	#__need_getopt


	)

928 #include 
	~<getopt.h
>

933 #ifdef 
__USE_EXTERN_INLINES


934 #include 
	~<bits/stdio.h
>

936 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__extern_always_inline


937 #include 
	~<bits/stdio2.h
>

939 #ifdef 
__LDBL_COMPAT


940 #include 
	~<bits/stdio-ldbl.h
>

943 
__END_DECLS


	@/usr/include/stdlib.h

22 #ifndef 
_STDLIB_H


24 #include 
	~<features.h
>

27 #define 
	#__need_size_t


	)

28 #ifndef 
__need_malloc_and_calloc


29 #define 
	#__need_wchar_t


	)

30 #define 
	#__need_NULL


	)

32 #include 
	~<stddef.h
>

34 
	g__BEGIN_DECLS


36 #ifndef 
__need_malloc_and_calloc


37 #define 
	#_STDLIB_H
 1

	)

39 #if (
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8
) && !defined 
_SYS_WAIT_H


41 #include 
	~<bits/waitflags.h
>

42 #include 
	~<bits/waitstatus.h
>

44 #ifdef 
__USE_BSD


49 #if 
defined
 
__GNUC__
 && !defined 
__cplusplus


50 #define 
	#__WAIT_INT
(
status
) \

51 (
	`__extension__
 (((union { 
	`__typeof
(
status
) 
__in
; int 
__i
; }) \

52 { .
__in
 = (
status
) }).
__i
))

	)

54 #define 
	#__WAIT_INT
(
status
) (*(int *) &(status))

	)

62 #if !
defined
 
__GNUC__
 || __GNUC__ < 2 || defined 
__cplusplus


63 #define 
	#__WAIT_STATUS
 void *

	)

64 #define 
	#__WAIT_STATUS_DEFN
 void *

	)

69 union 
wait
 *
	m__uptr
;

70 int *
	m__iptr
;

71 } 
	t__WAIT_STATUS
 
	t__attribute__
 ((
	t__transparent_union__
));

72 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

77 #define 
	#__WAIT_INT
(
status
) (status)

	)

78 #define 
	#__WAIT_STATUS
 int *

	)

79 #define 
	#__WAIT_STATUS_DEFN
 int *

	)

84 #define 
	#WEXITSTATUS
(
status
) 
	`__WEXITSTATUS
 (
	`__WAIT_INT
 (status))

	)

85 #define 
	#WTERMSIG
(
status
) 
	`__WTERMSIG
 (
	`__WAIT_INT
 (status))

	)

86 #define 
	#WSTOPSIG
(
status
) 
	`__WSTOPSIG
 (
	`__WAIT_INT
 (status))

	)

87 #define 
	#WIFEXITED
(
status
) 
	`__WIFEXITED
 (
	`__WAIT_INT
 (status))

	)

88 #define 
	#WIFSIGNALED
(
status
) 
	`__WIFSIGNALED
 (
	`__WAIT_INT
 (status))

	)

89 #define 
	#WIFSTOPPED
(
status
) 
	`__WIFSTOPPED
 (
	`__WAIT_INT
 (status))

	)

90 #ifdef 
__WIFCONTINUED


91 #define 
	#WIFCONTINUED
(
status
) 
	`__WIFCONTINUED
 (
	`__WAIT_INT
 (status))

	)

95 
__BEGIN_NAMESPACE_STD


99 int 
	mquot
;

100 int 
	mrem
;

101 } 
	tdiv_t
;

104 #ifndef 
__ldiv_t_defined


107 long int 
	mquot
;

108 long int 
	mrem
;

109 } 
	tldiv_t
;

110 #define 
	#__ldiv_t_defined
 1

	)

112 
	g__END_NAMESPACE_STD


114 #if 
defined
 
__USE_ISOC99
 && !defined 
__lldiv_t_defined


115 
__BEGIN_NAMESPACE_C99


117 
__extension__
 typedef struct

119 long long int 
	mquot
;

120 long long int 
	mrem
;

121 } 
	tlldiv_t
;

122 #define 
	#__lldiv_t_defined
 1

	)

123 
	g__END_NAMESPACE_C99


128 #define 
	#RAND_MAX
 2147483647

	)

133 #define 
	#EXIT_FAILURE
 1

	)

134 #define 
	#EXIT_SUCCESS
 0

	)

138 #define 
	#MB_CUR_MAX
 (
	`__ctype_get_mb_cur_max
 ())

	)

139 extern 
size_t
 
	$__ctype_get_mb_cur_max
 (void) 
__THROW
 
__wur
;

142 
__BEGIN_NAMESPACE_STD


144 extern double 
	$atof
 (const char *
__nptr
)

145 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

147 extern int 
	$atoi
 (const char *
__nptr
)

148 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

150 extern long int 
	$atol
 (const char *
__nptr
)

151 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

152 
__END_NAMESPACE_STD


154 #if 
defined
 
__USE_ISOC99
 || defined 
__USE_MISC


155 
__BEGIN_NAMESPACE_C99


157 
__extension__
 extern long long int 
	$atoll
 (const char *
__nptr
)

158 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

159 
__END_NAMESPACE_C99


162 
__BEGIN_NAMESPACE_STD


164 extern double 
	$strtod
 (const char *
__restrict
 
__nptr
,

165 char **
__restrict
 
__endptr
)

166 
__THROW
 
	`__nonnull
 ((1));

167 
__END_NAMESPACE_STD


169 #ifdef 
__USE_ISOC99


170 
__BEGIN_NAMESPACE_C99


172 extern float 
	$strtof
 (const char *
__restrict
 
__nptr
,

173 char **
__restrict
 
__endptr
) 
__THROW
 
	`__nonnull
 ((1));

175 extern long double 
	$strtold
 (const char *
__restrict
 
__nptr
,

176 char **
__restrict
 
__endptr
)

177 
__THROW
 
	`__nonnull
 ((1));

178 
__END_NAMESPACE_C99


181 
__BEGIN_NAMESPACE_STD


183 extern long int 
	$strtol
 (const char *
__restrict
 
__nptr
,

184 char **
__restrict
 
__endptr
, int 
__base
)

185 
__THROW
 
	`__nonnull
 ((1));

187 extern unsigned long int 
	$strtoul
 (const char *
__restrict
 
__nptr
,

188 char **
__restrict
 
__endptr
, int 
__base
)

189 
__THROW
 
	`__nonnull
 ((1));

190 
__END_NAMESPACE_STD


192 #ifdef 
__USE_BSD


194 
__extension__


195 extern long long int 
	$strtoq
 (const char *
__restrict
 
__nptr
,

196 char **
__restrict
 
__endptr
, int 
__base
)

197 
__THROW
 
	`__nonnull
 ((1));

199 
__extension__


200 extern unsigned long long int 
	$strtouq
 (const char *
__restrict
 
__nptr
,

201 char **
__restrict
 
__endptr
, int 
__base
)

202 
__THROW
 
	`__nonnull
 ((1));

205 #if 
defined
 
__USE_ISOC99
 || defined 
__USE_MISC


206 
__BEGIN_NAMESPACE_C99


208 
__extension__


209 extern long long int 
	$strtoll
 (const char *
__restrict
 
__nptr
,

210 char **
__restrict
 
__endptr
, int 
__base
)

211 
__THROW
 
	`__nonnull
 ((1));

213 
__extension__


214 extern unsigned long long int 
	$strtoull
 (const char *
__restrict
 
__nptr
,

215 char **
__restrict
 
__endptr
, int 
__base
)

216 
__THROW
 
	`__nonnull
 ((1));

217 
__END_NAMESPACE_C99


221 #ifdef 
__USE_GNU


235 #include 
	~<xlocale.h
>

239 extern long int 
	$strtol_l
 (const char *
__restrict
 
__nptr
,

240 char **
__restrict
 
__endptr
, int 
__base
,

241 
__locale_t
 
__loc
) 
__THROW
 
	`__nonnull
 ((1, 4));

243 extern unsigned long int 
	$strtoul_l
 (const char *
__restrict
 
__nptr
,

244 char **
__restrict
 
__endptr
,

245 int 
__base
, 
__locale_t
 
__loc
)

246 
__THROW
 
	`__nonnull
 ((1, 4));

248 
__extension__


249 extern long long int 
	$strtoll_l
 (const char *
__restrict
 
__nptr
,

250 char **
__restrict
 
__endptr
, int 
__base
,

251 
__locale_t
 
__loc
)

252 
__THROW
 
	`__nonnull
 ((1, 4));

254 
__extension__


255 extern unsigned long long int 
	$strtoull_l
 (const char *
__restrict
 
__nptr
,

256 char **
__restrict
 
__endptr
,

257 int 
__base
, 
__locale_t
 
__loc
)

258 
__THROW
 
	`__nonnull
 ((1, 4));

260 extern double 
	$strtod_l
 (const char *
__restrict
 
__nptr
,

261 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

262 
__THROW
 
	`__nonnull
 ((1, 3));

264 extern float 
	$strtof_l
 (const char *
__restrict
 
__nptr
,

265 char **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

266 
__THROW
 
	`__nonnull
 ((1, 3));

268 extern long double 
	$strtold_l
 (const char *
__restrict
 
__nptr
,

269 char **
__restrict
 
__endptr
,

270 
__locale_t
 
__loc
)

271 
__THROW
 
	`__nonnull
 ((1, 3));

275 #ifdef 
__USE_EXTERN_INLINES


276 
__BEGIN_NAMESPACE_STD


277 
__extern_inline
 int

278 
	`__NTH
 (
	$atoi
 (const char *
__nptr
))

280 return (int) 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

281 
	}
}

282 
__extern_inline
 long int

283 
__NTH
 (
	$atol
 (const char *
__nptr
))

285 return 
	`strtol
 (
__nptr
, (char **) 
NULL
, 10);

286 
	}
}

287 
	g__END_NAMESPACE_STD


289 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


290 
__BEGIN_NAMESPACE_C99


291 
__extension__
 
__extern_inline
 long long int

292 
__NTH
 (
	$atoll
 (const char *
__nptr
))

294 return 
	`strtoll
 (
__nptr
, (char **) 
NULL
, 10);

295 
	}
}

296 
	g__END_NAMESPACE_C99


301 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED


305 extern char *
	$l64a
 (long int 
__n
) 
__THROW
 
__wur
;

308 extern long int 
	$a64l
 (const char *
__s
)

309 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1)) 
__wur
;

313 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_BSD


314 #include 
	~<sys/types.h
>

321 extern long int 
	$random
 (void) 
__THROW
;

324 extern void 
	$srandom
 (unsigned int 
__seed
) 
__THROW
;

330 extern char *
	$initstate
 (unsigned int 
__seed
, char *
__statebuf
,

331 
size_t
 
__statelen
) 
__THROW
 
	`__nonnull
 ((2));

335 extern char *
	$setstate
 (char *
__statebuf
) 
__THROW
 
	`__nonnull
 ((1));

338 #ifdef 
__USE_MISC


343 struct 
	srandom_data


345 
int32_t
 *
fptr
;

346 
int32_t
 *
rptr
;

347 
int32_t
 *
state
;

348 int 
rand_type
;

349 int 
rand_deg
;

350 int 
rand_sep
;

351 
int32_t
 *
end_ptr
;

354 extern int 
	$random_r
 (struct 
random_data
 *
__restrict
 
__buf
,

355 
int32_t
 *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

357 extern int 
	$srandom_r
 (unsigned int 
__seed
, struct 
random_data
 *
__buf
)

358 
__THROW
 
	`__nonnull
 ((2));

360 extern int 
	$initstate_r
 (unsigned int 
__seed
, char *
__restrict
 
__statebuf
,

361 
size_t
 
__statelen
,

362 struct 
random_data
 *
__restrict
 
__buf
)

363 
__THROW
 
	`__nonnull
 ((2, 4));

365 extern int 
	$setstate_r
 (char *
__restrict
 
__statebuf
,

366 struct 
random_data
 *
__restrict
 
__buf
)

367 
__THROW
 
	`__nonnull
 ((1, 2));

372 
__BEGIN_NAMESPACE_STD


374 extern int 
	$rand
 (void) 
__THROW
;

376 extern void 
	$srand
 (unsigned int 
__seed
) 
__THROW
;

377 
__END_NAMESPACE_STD


379 #ifdef 
__USE_POSIX


381 extern int 
	$rand_r
 (unsigned int *
__seed
) 
__THROW
;

385 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


389 extern double 
	$drand48
 (void) 
__THROW
;

390 extern double 
	$erand48
 (unsigned short int 
__xsubi
[3]) 
__THROW
 
	`__nonnull
 ((1));

393 extern long int 
	$lrand48
 (void) 
__THROW
;

394 extern long int 
	$nrand48
 (unsigned short int 
__xsubi
[3])

395 
__THROW
 
	`__nonnull
 ((1));

398 extern long int 
	$mrand48
 (void) 
__THROW
;

399 extern long int 
	$jrand48
 (unsigned short int 
__xsubi
[3])

400 
__THROW
 
	`__nonnull
 ((1));

403 extern void 
	$srand48
 (long int 
__seedval
) 
__THROW
;

404 extern unsigned short int *
	$seed48
 (unsigned short int 
__seed16v
[3])

405 
__THROW
 
	`__nonnull
 ((1));

406 extern void 
	$lcong48
 (unsigned short int 
__param
[7]) 
__THROW
 
	`__nonnull
 ((1));

408 #ifdef 
__USE_MISC


412 struct 
	sdrand48_data


414 unsigned short int 
__x
[3];

415 unsigned short int 
__old_x
[3];

416 unsigned short int 
__c
;

417 unsigned short int 
__init
;

418 
__extension__
 unsigned long long int 
__a
;

423 extern int 
	$drand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

424 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

425 extern int 
	$erand48_r
 (unsigned short int 
__xsubi
[3],

426 struct 
drand48_data
 *
__restrict
 
__buffer
,

427 double *
__restrict
 
__result
) 
__THROW
 
	`__nonnull
 ((1, 2));

430 extern int 
	$lrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

431 long int *
__restrict
 
__result
)

432 
__THROW
 
	`__nonnull
 ((1, 2));

433 extern int 
	$nrand48_r
 (unsigned short int 
__xsubi
[3],

434 struct 
drand48_data
 *
__restrict
 
__buffer
,

435 long int *
__restrict
 
__result
)

436 
__THROW
 
	`__nonnull
 ((1, 2));

439 extern int 
	$mrand48_r
 (struct 
drand48_data
 *
__restrict
 
__buffer
,

440 long int *
__restrict
 
__result
)

441 
__THROW
 
	`__nonnull
 ((1, 2));

442 extern int 
	$jrand48_r
 (unsigned short int 
__xsubi
[3],

443 struct 
drand48_data
 *
__restrict
 
__buffer
,

444 long int *
__restrict
 
__result
)

445 
__THROW
 
	`__nonnull
 ((1, 2));

448 extern int 
	$srand48_r
 (long int 
__seedval
, struct 
drand48_data
 *
__buffer
)

449 
__THROW
 
	`__nonnull
 ((2));

451 extern int 
	$seed48_r
 (unsigned short int 
__seed16v
[3],

452 struct 
drand48_data
 *
__buffer
) 
__THROW
 
	`__nonnull
 ((1, 2));

454 extern int 
	$lcong48_r
 (unsigned short int 
__param
[7],

455 struct 
drand48_data
 *
__buffer
)

456 
__THROW
 
	`__nonnull
 ((1, 2));

462 #ifndef 
__malloc_and_calloc_defined


463 #define 
	#__malloc_and_calloc_defined


	)

464 
__BEGIN_NAMESPACE_STD


466 extern void *
	$malloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

468 extern void *
	$calloc
 (
size_t
 
__nmemb
, size_t 
__size
)

469 
__THROW
 
__attribute_malloc__
 
__wur
;

470 
__END_NAMESPACE_STD


473 #ifndef 
__need_malloc_and_calloc


474 
__BEGIN_NAMESPACE_STD


480 extern void *
	$realloc
 (void *
__ptr
, 
size_t
 
__size
)

481 
__THROW
 
__attribute_warn_unused_result__
;

483 extern void 
	$free
 (void *
__ptr
) 
__THROW
;

484 
__END_NAMESPACE_STD


486 #ifdef 
__USE_MISC


488 extern void 
	$cfree
 (void *
__ptr
) 
__THROW
;

491 #if 
defined
 
__USE_GNU
 || defined 
__USE_BSD
 || defined 
__USE_MISC


492 #include 
	~<alloca.h
>

495 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K
) \

496 || 
defined
 
__USE_BSD


498 extern void *
	$valloc
 (
size_t
 
__size
) 
__THROW
 
__attribute_malloc__
 
__wur
;

501 #ifdef 
__USE_XOPEN2K


503 extern int 
	$posix_memalign
 (void **
__memptr
, 
size_t
 
__alignment
, size_t 
__size
)

504 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

507 #ifdef 
__USE_ISOC11


509 extern void *
	$aligned_alloc
 (
size_t
 
__alignment
, size_t 
__size
)

510 
__THROW
 
__attribute_malloc__
 
	`__attribute_alloc_size__
 ((2)) 
__wur
;

513 
__BEGIN_NAMESPACE_STD


515 extern void 
	$abort
 (void) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

519 extern int 
	`atexit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

521 #if 
defined
 
__USE_ISOC11
 || defined 
__USE_ISOCXX11


523 #ifdef 
__cplusplus


524 extern "C++" int 
	`at_quick_exit
 (void (*
__func
) (void))

525 
__THROW
 
	`__asm
 ("at_quick_exit") 
	`__nonnull
 ((1));

527 extern int 
	`at_quick_exit
 (void (*
__func
) (void)) 
__THROW
 
	`__nonnull
 ((1));

530 
__END_NAMESPACE_STD


532 #ifdef 
__USE_MISC


535 extern int 
	`on_exit
 (void (*
__func
) (int 
__status
, void *
__arg
), void *__arg)

536 
__THROW
 
	`__nonnull
 ((1));

539 
__BEGIN_NAMESPACE_STD


543 extern void 
	$exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

545 #if 
defined
 
__USE_ISOC11
 || defined 
__USE_ISOCXX11


549 extern void 
	$quick_exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

551 
__END_NAMESPACE_STD


553 #ifdef 
__USE_ISOC99


554 
__BEGIN_NAMESPACE_C99


557 extern void 
	$_Exit
 (int 
__status
) 
__THROW
 
	`__attribute__
 ((
__noreturn__
));

558 
__END_NAMESPACE_C99


562 
__BEGIN_NAMESPACE_STD


564 extern char *
	$getenv
 (const char *
__name
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

565 
__END_NAMESPACE_STD


567 #ifdef 
__USE_GNU


570 extern char *
	$secure_getenv
 (const char *
__name
)

571 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

574 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


578 extern int 
	$putenv
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

581 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K


584 extern int 
	$setenv
 (const char *
__name
, const char *
__value
, int 
__replace
)

585 
__THROW
 
	`__nonnull
 ((2));

588 extern int 
	$unsetenv
 (const char *
__name
) 
__THROW
 
	`__nonnull
 ((1));

591 #ifdef 
__USE_MISC


595 extern int 
	$clearenv
 (void) 
__THROW
;

599 #if 
defined
 
__USE_MISC
 \

600 || (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
)

606 extern char *
	$mktemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1));

609 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 \

610 || 
defined
 
__USE_XOPEN2K8


619 #ifndef 
__USE_FILE_OFFSET64


620 extern int 
	$mkstemp
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

622 #ifdef 
__REDIRECT


623 extern int 
	`__REDIRECT
 (
mkstemp
, (char *
__template
), 
mkstemp64
)

624 
	`__nonnull
 ((1)) 
__wur
;

626 #define 
	#mkstemp
 
mkstemp64


	)

629 #ifdef 
__USE_LARGEFILE64


630 extern int 
	$mkstemp64
 (char *
__template
) 
	`__nonnull
 ((1)) 
__wur
;

634 #ifdef 
__USE_MISC


641 #ifndef 
__USE_FILE_OFFSET64


642 extern int 
	$mkstemps
 (char *
__template
, int 
__suffixlen
) 
	`__nonnull
 ((1)) 
__wur
;

644 #ifdef 
__REDIRECT


645 extern int 
	`__REDIRECT
 (
mkstemps
, (char *
__template
, int 
__suffixlen
),

646 
mkstemps64
) 
	`__nonnull
 ((1)) 
__wur
;

648 #define 
	#mkstemps
 
mkstemps64


	)

651 #ifdef 
__USE_LARGEFILE64


652 extern int 
	$mkstemps64
 (char *
__template
, int 
__suffixlen
)

653 
	`__nonnull
 ((1)) 
__wur
;

657 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN2K8


663 extern char *
	$mkdtemp
 (char *
__template
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

666 #ifdef 
__USE_GNU


673 #ifndef 
__USE_FILE_OFFSET64


674 extern int 
	$mkostemp
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

676 #ifdef 
__REDIRECT


677 extern int 
	`__REDIRECT
 (
mkostemp
, (char *
__template
, int 
__flags
), 
mkostemp64
)

678 
	`__nonnull
 ((1)) 
__wur
;

680 #define 
	#mkostemp
 
mkostemp64


	)

683 #ifdef 
__USE_LARGEFILE64


684 extern int 
	$mkostemp64
 (char *
__template
, int 
__flags
) 
	`__nonnull
 ((1)) 
__wur
;

693 #ifndef 
__USE_FILE_OFFSET64


694 extern int 
	$mkostemps
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

695 
	`__nonnull
 ((1)) 
__wur
;

697 #ifdef 
__REDIRECT


698 extern int 
	`__REDIRECT
 (
mkostemps
, (char *
__template
, int 
__suffixlen
,

699 int 
__flags
), 
mkostemps64
)

700 
	`__nonnull
 ((1)) 
__wur
;

702 #define 
	#mkostemps
 
mkostemps64


	)

705 #ifdef 
__USE_LARGEFILE64


706 extern int 
	$mkostemps64
 (char *
__template
, int 
__suffixlen
, int 
__flags
)

707 
	`__nonnull
 ((1)) 
__wur
;

712 
__BEGIN_NAMESPACE_STD


717 extern int 
	$system
 (const char *
__command
) 
__wur
;

718 
__END_NAMESPACE_STD


721 #ifdef 
__USE_GNU


724 extern char *
	$canonicalize_file_name
 (const char *
__name
)

725 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

728 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


734 extern char *
	$realpath
 (const char *
__restrict
 
__name
,

735 char *
__restrict
 
__resolved
) 
__THROW
 
__wur
;

740 #ifndef 
__COMPAR_FN_T


741 #define 
	#__COMPAR_FN_T


	)

742 typedef int (*
	t__compar_fn_t
) (const void *, const void *);

744 #ifdef 
__USE_GNU


745 typedef 
__compar_fn_t
 
	tcomparison_fn_t
;

748 #ifdef 
__USE_GNU


749 typedef int (*
	t__compar_d_fn_t
) (const void *, const void *, void *);

752 
__BEGIN_NAMESPACE_STD


755 extern void *
	$bsearch
 (const void *
__key
, const void *
__base
,

756 
size_t
 
__nmemb
, size_t 
__size
, 
__compar_fn_t
 
__compar
)

757 
	`__nonnull
 ((1, 2, 5)) 
__wur
;

759 #ifdef 
__USE_EXTERN_INLINES


760 #include 
	~<bits/stdlib-bsearch.h
>

765 extern void 
	$qsort
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

766 
__compar_fn_t
 
__compar
) 
	`__nonnull
 ((1, 4));

767 #ifdef 
__USE_GNU


768 extern void 
	$qsort_r
 (void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

769 
__compar_d_fn_t
 
__compar
, void *
__arg
)

770 
	`__nonnull
 ((1, 4));

775 extern int 
	$abs
 (int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

776 extern long int 
	$labs
 (long int 
__x
) 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

777 
__END_NAMESPACE_STD


779 #ifdef 
__USE_ISOC99


780 
__extension__
 extern long long int 
	$llabs
 (long long int 
__x
)

781 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

785 
__BEGIN_NAMESPACE_STD


789 extern 
div_t
 
	$div
 (int 
__numer
, int 
__denom
)

790 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

791 extern 
ldiv_t
 
	$ldiv
 (long int 
__numer
, long int 
__denom
)

792 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

793 
__END_NAMESPACE_STD


795 #ifdef 
__USE_ISOC99


796 
__BEGIN_NAMESPACE_C99


797 
__extension__
 extern 
lldiv_t
 
	$lldiv
 (long long int 
__numer
,

798 long long int 
__denom
)

799 
__THROW
 
	`__attribute__
 ((
__const__
)) 
__wur
;

800 
__END_NAMESPACE_C99


804 #if (
defined
 
__USE_XOPEN_EXTENDED
 && !defined 
__USE_XOPEN2K8
) \

805 || 
defined
 
__USE_SVID


812 extern char *
	$ecvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

813 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

818 extern char *
	$fcvt
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

819 int *
__restrict
 
__sign
) 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

824 extern char *
	$gcvt
 (double 
__value
, int 
__ndigit
, char *
__buf
)

825 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

828 #ifdef 
__USE_MISC


830 extern char *
	$qecvt
 (long double 
__value
, int 
__ndigit
,

831 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

832 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

833 extern char *
	$qfcvt
 (long double 
__value
, int 
__ndigit
,

834 int *
__restrict
 
__decpt
, int *__restrict 
__sign
)

835 
__THROW
 
	`__nonnull
 ((3, 4)) 
__wur
;

836 extern char *
	$qgcvt
 (long double 
__value
, int 
__ndigit
, char *
__buf
)

837 
__THROW
 
	`__nonnull
 ((3)) 
__wur
;

842 extern int 
	$ecvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

843 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

844 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

845 extern int 
	$fcvt_r
 (double 
__value
, int 
__ndigit
, int *
__restrict
 
__decpt
,

846 int *
__restrict
 
__sign
, char *__restrict 
__buf
,

847 
size_t
 
__len
) 
__THROW
 
	`__nonnull
 ((3, 4, 5));

849 extern int 
	$qecvt_r
 (long double 
__value
, int 
__ndigit
,

850 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

851 char *
__restrict
 
__buf
, 
size_t
 
__len
)

852 
__THROW
 
	`__nonnull
 ((3, 4, 5));

853 extern int 
	$qfcvt_r
 (long double 
__value
, int 
__ndigit
,

854 int *
__restrict
 
__decpt
, int *__restrict 
__sign
,

855 char *
__restrict
 
__buf
, 
size_t
 
__len
)

856 
__THROW
 
	`__nonnull
 ((3, 4, 5));

860 
__BEGIN_NAMESPACE_STD


863 extern int 
	$mblen
 (const char *
__s
, 
size_t
 
__n
) 
__THROW
;

866 extern int 
	$mbtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

867 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
;

870 extern int 
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
) 
__THROW
;

874 extern 
size_t
 
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__pwcs
,

875 const char *
__restrict
 
__s
, 
size_t
 
__n
) 
__THROW
;

877 extern 
size_t
 
	$wcstombs
 (char *
__restrict
 
__s
,

878 const 
wchar_t
 *
__restrict
 
__pwcs
, 
size_t
 
__n
)

879 
__THROW
;

880 
__END_NAMESPACE_STD


883 #ifdef 
__USE_SVID


888 extern int 
	$rpmatch
 (const char *
__response
) 
__THROW
 
	`__nonnull
 ((1)) 
__wur
;

892 #if 
defined
 
__USE_XOPEN_EXTENDED
 || defined 
__USE_XOPEN2K8


899 extern int 
	$getsubopt
 (char **
__restrict
 
__optionp
,

900 char *const *
__restrict
 
__tokens
,

901 char **
__restrict
 
__valuep
)

902 
__THROW
 
	`__nonnull
 ((1, 2, 3)) 
__wur
;

906 #ifdef 
__USE_XOPEN


908 extern void 
	$setkey
 (const char *
__key
) 
__THROW
 
	`__nonnull
 ((1));

914 #ifdef 
__USE_XOPEN2KXSI


916 extern int 
	$posix_openpt
 (int 
__oflag
) 
__wur
;

919 #ifdef 
__USE_XOPEN


924 extern int 
	$grantpt
 (int 
__fd
) 
__THROW
;

928 extern int 
	$unlockpt
 (int 
__fd
) 
__THROW
;

933 extern char *
	$ptsname
 (int 
__fd
) 
__THROW
 
__wur
;

936 #ifdef 
__USE_GNU


940 extern int 
	$ptsname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
)

941 
__THROW
 
	`__nonnull
 ((2));

944 extern int 
	`getpt
 (void);

947 #ifdef 
__USE_BSD


951 extern int 
	$getloadavg
 (double 
__loadavg
[], int 
__nelem
)

952 
__THROW
 
	`__nonnull
 ((1));

955 #include 
	~<bits/stdlib-float.h
>

958 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


959 #include 
	~<bits/stdlib.h
>

961 #ifdef 
__LDBL_COMPAT


962 #include 
	~<bits/stdlib-ldbl.h
>

966 #undef 
__need_malloc_and_calloc


968 
__END_DECLS


	@/usr/include/string.h

22 #ifndef 
_STRING_H


23 #define 
	#_STRING_H
 1

	)

25 #include 
	~<features.h
>

27 
	g__BEGIN_DECLS


30 #define 
	#__need_size_t


	)

31 #define 
	#__need_NULL


	)

32 #include 
	~<stddef.h
>

39 #if 
defined
 
__cplusplus
 && (__cplusplus >= 199711L || 
__GNUC_PREREQ
 (4, 4))

40 #define 
	#__CORRECT_ISO_CPP_STRING_H_PROTO


	)

44 
__BEGIN_NAMESPACE_STD


46 extern void *
	$memcpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

47 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

50 extern void *
	$memmove
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

51 
__THROW
 
	`__nonnull
 ((1, 2));

52 
__END_NAMESPACE_STD


57 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN


58 extern void *
	$memccpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

59 int 
__c
, 
size_t
 
__n
)

60 
__THROW
 
	`__nonnull
 ((1, 2));

64 
__BEGIN_NAMESPACE_STD


66 extern void *
	$memset
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

69 extern int 
	$memcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

70 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

73 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


76 extern void *
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

77 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

78 extern const void *
	`memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

79 
__THROW
 
	`__asm
 ("memchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

81 #ifdef 
__OPTIMIZE__


82 
__extern_always_inline
 void *

83 
	`memchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


85 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

88 
__extern_always_inline
 const void *

89 
	`memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
) 
__THROW


91 return 
	`__builtin_memchr
 (
__s
, 
__c
, 
__n
);

94 
	}
}

96 extern void *
	$memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

97 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

99 
__END_NAMESPACE_STD


101 #ifdef 
__USE_GNU


104 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


105 extern "C++" void *
	$rawmemchr
 (void *
__s
, int 
__c
)

106 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

107 extern "C++" const void *
	$rawmemchr
 (const void *
__s
, int 
__c
)

108 
__THROW
 
	`__asm
 ("rawmemchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

110 extern void *
	$rawmemchr
 (const void *
__s
, int 
__c
)

111 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

115 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


116 extern "C++" void *
	$memrchr
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

117 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

118 extern "C++" const void *
	$memrchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

119 
__THROW
 
	`__asm
 ("memrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

121 extern void *
	$memrchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

122 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

127 
__BEGIN_NAMESPACE_STD


129 extern char *
	$strcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

130 
__THROW
 
	`__nonnull
 ((1, 2));

132 extern char *
	$strncpy
 (char *
__restrict
 
__dest
,

133 const char *
__restrict
 
__src
, 
size_t
 
__n
)

134 
__THROW
 
	`__nonnull
 ((1, 2));

137 extern char *
	$strcat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

138 
__THROW
 
	`__nonnull
 ((1, 2));

140 extern char *
	$strncat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
,

141 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1, 2));

144 extern int 
	$strcmp
 (const char *
__s1
, const char *
__s2
)

145 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

147 extern int 
	$strncmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

148 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

151 extern int 
	$strcoll
 (const char *
__s1
, const char *
__s2
)

152 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

154 extern 
size_t
 
	$strxfrm
 (char *
__restrict
 
__dest
,

155 const char *
__restrict
 
__src
, 
size_t
 
__n
)

156 
__THROW
 
	`__nonnull
 ((2));

157 
__END_NAMESPACE_STD


159 #ifdef 
__USE_XOPEN2K8


163 #include 
	~<xlocale.h
>

166 extern int 
	$strcoll_l
 (const char *
__s1
, const char *
__s2
, 
__locale_t
 
__l
)

167 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

169 extern 
size_t
 
	$strxfrm_l
 (char *
__dest
, const char *
__src
, 
size_t
 
__n
,

170 
__locale_t
 
__l
) 
__THROW
 
	`__nonnull
 ((2, 4));

173 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED
 \

174 || 
defined
 
__USE_XOPEN2K8


176 extern char *
	$strdup
 (const char *
__s
)

177 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

183 #if 
defined
 
__USE_XOPEN2K8


184 extern char *
	$strndup
 (const char *
__string
, 
size_t
 
__n
)

185 
__THROW
 
__attribute_malloc__
 
	`__nonnull
 ((1));

188 #if 
defined
 
__USE_GNU
 && defined 
__GNUC__


190 #define 
	#strdupa
(
s
) \

191 (
__extension__
 \

193 const char *
__old
 = (
s
); \

194 
size_t
 
__len
 = 
	`strlen
 (
__old
) + 1; \

195 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
); \

196 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

197 
	}
}))

	)

200 #define 
	#strndupa
(
s
, 
n
) \

201 (
__extension__
 \

203 const char *
__old
 = (
s
); \

204 
size_t
 
__len
 = 
	`strnlen
 (
__old
, (
n
)); \

205 char *
__new
 = (char *) 
	`__builtin_alloca
 (
__len
 + 1); \

206 
__new
[
__len
] = '\0'; \

207 (char *) 
	`memcpy
 (
__new
, 
__old
, 
__len
); \

208 }))

	)

211 
	g__BEGIN_NAMESPACE_STD


213 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


216 extern char *
strchr
 (char *
__s
, int 
__c
)

217 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

218 extern const char *
strchr
 (const char *
__s
, int 
__c
)

219 
__THROW
 
__asm
 ("strchr") 
__attribute_pure__
 
__nonnull
 ((1));

221 #ifdef 
__OPTIMIZE__


222 
__extern_always_inline
 char *

223 
strchr
 (char *
__s
, int 
__c
) 
	g__THROW


225 return 
__builtin_strchr
 (
__s
, 
__c
);

228 
__extern_always_inline
 const char *

229 
strchr
 (const char *
__s
, int 
__c
) 
	g__THROW


231 return 
__builtin_strchr
 (
__s
, 
__c
);

236 extern char *
	$strchr
 (const char *
__s
, int 
__c
)

237 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

240 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


243 extern char *
	`strrchr
 (char *
__s
, int 
__c
)

244 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

245 extern const char *
	`strrchr
 (const char *
__s
, int 
__c
)

246 
__THROW
 
	`__asm
 ("strrchr") 
__attribute_pure__
 
	`__nonnull
 ((1));

248 #ifdef 
__OPTIMIZE__


249 
__extern_always_inline
 char *

250 
	`strrchr
 (char *
__s
, int 
__c
) 
__THROW


252 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

255 
__extern_always_inline
 const char *

256 
	`strrchr
 (const char *
__s
, int 
__c
) 
__THROW


258 return 
	`__builtin_strrchr
 (
__s
, 
__c
);

261 
	}
}

263 extern char *
	$strrchr
 (const char *
__s
, int 
__c
)

264 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

266 
__END_NAMESPACE_STD


268 #ifdef 
__USE_GNU


271 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


272 extern "C++" char *
	$strchrnul
 (char *
__s
, int 
__c
)

273 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

274 extern "C++" const char *
	$strchrnul
 (const char *
__s
, int 
__c
)

275 
__THROW
 
	`__asm
 ("strchrnul") 
__attribute_pure__
 
	`__nonnull
 ((1));

277 extern char *
	$strchrnul
 (const char *
__s
, int 
__c
)

278 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

282 
__BEGIN_NAMESPACE_STD


285 extern 
size_t
 
	$strcspn
 (const char *
__s
, const char *
__reject
)

286 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

289 extern 
size_t
 
	$strspn
 (const char *
__s
, const char *
__accept
)

290 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

292 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


295 extern char *
	`strpbrk
 (char *
__s
, const char *
__accept
)

296 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

297 extern const char *
	`strpbrk
 (const char *
__s
, const char *
__accept
)

298 
__THROW
 
	`__asm
 ("strpbrk") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

300 #ifdef 
__OPTIMIZE__


301 
__extern_always_inline
 char *

302 
	`strpbrk
 (char *
__s
, const char *
__accept
) 
__THROW


304 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

307 
__extern_always_inline
 const char *

308 
	`strpbrk
 (const char *
__s
, const char *
__accept
) 
__THROW


310 return 
	`__builtin_strpbrk
 (
__s
, 
__accept
);

313 
	}
}

315 extern char *
	$strpbrk
 (const char *
__s
, const char *
__accept
)

316 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

319 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


322 extern char *
	`strstr
 (char *
__haystack
, const char *
__needle
)

323 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

324 extern const char *
	`strstr
 (const char *
__haystack
, const char *
__needle
)

325 
__THROW
 
	`__asm
 ("strstr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

327 #ifdef 
__OPTIMIZE__


328 
__extern_always_inline
 char *

329 
	`strstr
 (char *
__haystack
, const char *
__needle
) 
__THROW


331 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

334 
__extern_always_inline
 const char *

335 
	`strstr
 (const char *
__haystack
, const char *
__needle
) 
__THROW


337 return 
	`__builtin_strstr
 (
__haystack
, 
__needle
);

340 
	}
}

342 extern char *
	$strstr
 (const char *
__haystack
, const char *
__needle
)

343 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

348 extern char *
	$strtok
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
)

349 
__THROW
 
	`__nonnull
 ((2));

350 
__END_NAMESPACE_STD


354 extern char *
	$__strtok_r
 (char *
__restrict
 
__s
,

355 const char *
__restrict
 
__delim
,

356 char **
__restrict
 
__save_ptr
)

357 
__THROW
 
	`__nonnull
 ((2, 3));

358 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


359 extern char *
	$strtok_r
 (char *
__restrict
 
__s
, const char *__restrict 
__delim
,

360 char **
__restrict
 
__save_ptr
)

361 
__THROW
 
	`__nonnull
 ((2, 3));

364 #ifdef 
__USE_GNU


366 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


367 extern "C++" char *
	$strcasestr
 (char *
__haystack
, const char *
__needle
)

368 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

369 extern "C++" const char *
	$strcasestr
 (const char *
__haystack
,

370 const char *
__needle
)

371 
__THROW
 
	`__asm
 ("strcasestr") 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

373 extern char *
	$strcasestr
 (const char *
__haystack
, const char *
__needle
)

374 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

378 #ifdef 
__USE_GNU


382 extern void *
	$memmem
 (const void *
__haystack
, 
size_t
 
__haystacklen
,

383 const void *
__needle
, 
size_t
 
__needlelen
)

384 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 3));

388 extern void *
	$__mempcpy
 (void *
__restrict
 
__dest
,

389 const void *
__restrict
 
__src
, 
size_t
 
__n
)

390 
__THROW
 
	`__nonnull
 ((1, 2));

391 extern void *
	$mempcpy
 (void *
__restrict
 
__dest
,

392 const void *
__restrict
 
__src
, 
size_t
 
__n
)

393 
__THROW
 
	`__nonnull
 ((1, 2));

397 
__BEGIN_NAMESPACE_STD


399 extern 
size_t
 
	$strlen
 (const char *
__s
)

400 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

401 
__END_NAMESPACE_STD


403 #ifdef 
__USE_XOPEN2K8


406 extern 
size_t
 
	$strnlen
 (const char *
__string
, 
size_t
 
__maxlen
)

407 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

411 
__BEGIN_NAMESPACE_STD


413 extern char *
	$strerror
 (int 
__errnum
) 
__THROW
;

414 
__END_NAMESPACE_STD


415 #if 
defined
 
__USE_XOPEN2K
 || defined 
__USE_MISC


423 #if 
defined
 
__USE_XOPEN2K
 && !defined 
__USE_GNU


426 #ifdef 
__REDIRECT_NTH


427 extern int 
	`__REDIRECT_NTH
 (
strerror_r
,

428 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
),

429 
__xpg_strerror_r
) 
	`__nonnull
 ((2));

431 extern int 
	$__xpg_strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

432 
__THROW
 
	`__nonnull
 ((2));

433 #define 
	#strerror_r
 
__xpg_strerror_r


	)

438 extern char *
	$strerror_r
 (int 
__errnum
, char *
__buf
, 
size_t
 
__buflen
)

439 
__THROW
 
	`__nonnull
 ((2)) 
__wur
;

443 #ifdef 
__USE_XOPEN2K8


445 extern char *
	$strerror_l
 (int 
__errnum
, 
__locale_t
 
__l
) 
__THROW
;

451 extern void 
	$__bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

453 #ifdef 
__USE_BSD


455 extern void 
	$bcopy
 (const void *
__src
, void *
__dest
, 
size_t
 
__n
)

456 
__THROW
 
	`__nonnull
 ((1, 2));

459 extern void 
	$bzero
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

462 extern int 
	$bcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

463 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

466 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


469 extern char *
	`index
 (char *
__s
, int 
__c
)

470 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

471 extern const char *
	`index
 (const char *
__s
, int 
__c
)

472 
__THROW
 
	`__asm
 ("index") 
__attribute_pure__
 
	`__nonnull
 ((1));

474 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


475 
__extern_always_inline
 char *

476 
	`index
 (char *
__s
, int 
__c
) 
__THROW


478 return 
	`__builtin_index
 (
__s
, 
__c
);

481 
__extern_always_inline
 const char *

482 
	`index
 (const char *
__s
, int 
__c
) 
__THROW


484 return 
	`__builtin_index
 (
__s
, 
__c
);

487 
	}
}

489 extern char *
	$index
 (const char *
__s
, int 
__c
)

490 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

494 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


497 extern char *
	`rindex
 (char *
__s
, int 
__c
)

498 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

499 extern const char *
	`rindex
 (const char *
__s
, int 
__c
)

500 
__THROW
 
	`__asm
 ("rindex") 
__attribute_pure__
 
	`__nonnull
 ((1));

502 #if 
defined
 
__OPTIMIZE__
 && !defined 
__CORRECT_ISO_CPP_STRINGS_H_PROTO


503 
__extern_always_inline
 char *

504 
	`rindex
 (char *
__s
, int 
__c
) 
__THROW


506 return 
	`__builtin_rindex
 (
__s
, 
__c
);

509 
__extern_always_inline
 const char *

510 
	`rindex
 (const char *
__s
, int 
__c
) 
__THROW


512 return 
	`__builtin_rindex
 (
__s
, 
__c
);

515 
	}
}

517 extern char *
	$rindex
 (const char *
__s
, int 
__c
)

518 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1));

523 extern int 
	$ffs
 (int 
__i
) 
__THROW
 
	`__attribute__
 ((
__const__
));

527 #ifdef 
__USE_GNU


528 extern int 
	$ffsl
 (long int 
__l
) 
__THROW
 
	`__attribute__
 ((
__const__
));

529 
__extension__
 extern int 
	$ffsll
 (long long int 
__ll
)

530 
__THROW
 
	`__attribute__
 ((
__const__
));

534 extern int 
	$strcasecmp
 (const char *
__s1
, const char *
__s2
)

535 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

538 extern int 
	$strncasecmp
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

539 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

542 #ifdef 
__USE_GNU


545 extern int 
	$strcasecmp_l
 (const char *
__s1
, const char *
__s2
,

546 
__locale_t
 
__loc
)

547 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 3));

549 extern int 
	$strncasecmp_l
 (const char *
__s1
, const char *
__s2
,

550 
size_t
 
__n
, 
__locale_t
 
__loc
)

551 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2, 4));

554 #ifdef 
__USE_BSD


557 extern char *
	$strsep
 (char **
__restrict
 
__stringp
,

558 const char *
__restrict
 
__delim
)

559 
__THROW
 
	`__nonnull
 ((1, 2));

562 #ifdef 
__USE_XOPEN2K8


564 extern char *
	$strsignal
 (int 
__sig
) 
__THROW
;

567 extern char *
	$__stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

568 
__THROW
 
	`__nonnull
 ((1, 2));

569 extern char *
	$stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
)

570 
__THROW
 
	`__nonnull
 ((1, 2));

574 extern char *
	$__stpncpy
 (char *
__restrict
 
__dest
,

575 const char *
__restrict
 
__src
, 
size_t
 
__n
)

576 
__THROW
 
	`__nonnull
 ((1, 2));

577 extern char *
	$stpncpy
 (char *
__restrict
 
__dest
,

578 const char *
__restrict
 
__src
, 
size_t
 
__n
)

579 
__THROW
 
	`__nonnull
 ((1, 2));

582 #ifdef 
__USE_GNU


584 extern int 
	$strverscmp
 (const char *
__s1
, const char *
__s2
)

585 
__THROW
 
__attribute_pure__
 
	`__nonnull
 ((1, 2));

588 extern char *
	$strfry
 (char *
__string
) 
__THROW
 
	`__nonnull
 ((1));

591 extern void *
	$memfrob
 (void *
__s
, 
size_t
 
__n
) 
__THROW
 
	`__nonnull
 ((1));

593 #ifndef 
basename


598 #ifdef 
__CORRECT_ISO_CPP_STRING_H_PROTO


599 extern "C++" char *
	$basename
 (char *
__filename
)

600 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

601 extern "C++" const char *
	$basename
 (const char *
__filename
)

602 
__THROW
 
	`__asm
 ("basename") 
	`__nonnull
 ((1));

604 extern char *
	$basename
 (const char *
__filename
) 
__THROW
 
	`__nonnull
 ((1));

610 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

611 #if 
defined
 
__OPTIMIZE__
 && !defined 
__OPTIMIZE_SIZE__
 \

612 && !
defined
 
__NO_INLINE__
 && !defined 
__cplusplus


632 #include 
	~<bits/string.h
>

635 #include 
	~<bits/string2.h
>

638 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


640 #include 
	~<bits/string3.h
>

644 
__END_DECLS


	@/usr/include/alloca.h

18 #ifndef 
_ALLOCA_H


19 #define 
	#_ALLOCA_H
 1

	)

21 #include 
	~<features.h
>

23 #define 
	#__need_size_t


	)

24 #include 
	~<stddef.h
>

26 
	g__BEGIN_DECLS


29 #undef 
alloca


32 extern void *
	$alloca
 (
size_t
 
__size
) 
__THROW
;

34 #ifdef 
__GNUC__


35 #define 
	#alloca
(
size
) 
	`__builtin_alloca
 (size)

	)

38 
__END_DECLS


	@/usr/include/bits/huge_val.h

20 #ifndef 
_MATH_H


26 #if 
__GNUC_PREREQ
(3,3)

27 #define 
	#HUGE_VAL
 (
	`__builtin_huge_val
())

	)

28 #elif 
__GNUC_PREREQ
(2,96)

29 #define 
	#HUGE_VAL
 (
__extension__
 0x1.0
p2047
)

	)

30 #elif 
defined
 
__GNUC__


32 #define 
	#HUGE_VAL
 \

33 (
__extension__
 \

34 ((union { unsigned 
__l
 
	`__attribute__
((
	`__mode__
(
__DI__
))); double 
__d
; }) \

35 { 
__l
: 0x7ff0000000000000ULL }).
__d
)

	)

39 #include 
	~<endian.h
>

41 typedef union { unsigned char 
	m__c
[8]; double 
	m__d
; } 
	t__huge_val_t
;

43 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


44 #define 
	#__HUGE_VAL_bytes
 { 0x7f, 0xf0, 0, 0, 0, 0, 0, 0 }

	)

46 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


47 #define 
	#__HUGE_VAL_bytes
 { 0, 0, 0, 0, 0, 0, 0xf0, 0x7f }

	)

50 static 
__huge_val_t
 
	g__huge_val
 = { 
__HUGE_VAL_bytes
 };

51 #define 
	#HUGE_VAL
 (
__huge_val
.
__d
)

	)

	@/usr/include/bits/huge_valf.h

20 #ifndef 
_MATH_H


26 #if 
__GNUC_PREREQ
(3,3)

27 #define 
	#HUGE_VALF
 (
	`__builtin_huge_valf
())

	)

28 #elif 
__GNUC_PREREQ
(2,96)

29 #define 
	#HUGE_VALF
 (
__extension__
 0x1.0
p255f
)

	)

30 #elif 
defined
 
__GNUC__


32 #define 
	#HUGE_VALF
 \

33 (
__extension__
 \

34 ((union { unsigned 
__l
 
	`__attribute__
((
	`__mode__
(
__SI__
))); float 
__d
; }) \

35 { 
__l
: 0x7f800000UL }).
__d
)

	)

39 typedef union { unsigned char 
	m__c
[4]; float 
	m__f
; } 
	t__huge_valf_t
;

41 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


42 #define 
	#__HUGE_VALF_bytes
 { 0x7f, 0x80, 0, 0 }

	)

44 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


45 #define 
	#__HUGE_VALF_bytes
 { 0, 0, 0x80, 0x7f }

	)

48 static 
__huge_valf_t
 
	g__huge_valf
 = { 
__HUGE_VALF_bytes
 };

49 #define 
	#HUGE_VALF
 (
__huge_valf
.
__f
)

	)

	@/usr/include/bits/huge_vall.h

20 #ifndef 
_MATH_H


24 #if 
__GNUC_PREREQ
(3,3)

25 #define 
	#HUGE_VALL
 (
	`__builtin_huge_vall
())

	)

26 #elif 
__GNUC_PREREQ
(2,96)

27 #define 
	#HUGE_VALL
 (
__extension__
 0x1.0
p32767L
)

	)

30 #define 
	#__HUGE_VALL_bytes
 { 0, 0, 0, 0, 0, 0, 0, 0x80, 0xff, 0x7f, 0, 0 }

	)

32 #define 
	#__huge_vall_t
 union { unsigned char 
__c
[12]; long double 
__ld
; }

	)

33 #ifdef 
__GNUC__


34 #define 
	#HUGE_VALL
 (
__extension__
 \

35 ((
__huge_vall_t
) { 
__c
: 
__HUGE_VALL_bytes
 }).
__ld
)

	)

37 static 
__huge_vall_t
 
	g__huge_vall
 = { 
__HUGE_VALL_bytes
 };

38 #define 
	#HUGE_VALL
 (
__huge_vall
.
__ld
)

	)

	@/usr/include/bits/inf.h

19 #ifndef 
_MATH_H


25 #if 
__GNUC_PREREQ
(3,3)

26 #define 
	#INFINITY
 (
	`__builtin_inff
())

	)

28 #define 
	#INFINITY
 
HUGE_VALF


	)

	@/usr/include/bits/math-finite.h

19 #ifndef 
_MATH_H


24 extern double 
__REDIRECT_NTH
 (
acos
, (double), 
__acos_finite
);

25 extern float 
__REDIRECT_NTH
 (
acosf
, (float), 
__acosf_finite
);

26 #ifdef 
__MATH_DECLARE_LDOUBLE


27 #ifdef 
__NO_LONG_DOUBLE_MATH


28 extern long double 
__REDIRECT_NTH
 (
acosl
, (long double), 
__acos_finite
);

30 extern long double 
__REDIRECT_NTH
 (
acosl
, (long double), 
__acosl_finite
);

34 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


36 extern double 
__REDIRECT_NTH
 (
acosh
, (double), 
__acosh_finite
);

37 extern float 
__REDIRECT_NTH
 (
acoshf
, (float), 
__acoshf_finite
);

38 #ifdef 
__MATH_DECLARE_LDOUBLE


39 #ifdef 
__NO_LONG_DOUBLE_MATH


40 extern long double 
__REDIRECT_NTH
 (
acoshl
, (long double), 
__acosh_finite
);

42 extern long double 
__REDIRECT_NTH
 (
acoshl
, (long double), 
__acoshl_finite
);

48 extern double 
__REDIRECT_NTH
 (
asin
, (double), 
__asin_finite
);

49 extern float 
__REDIRECT_NTH
 (
asinf
, (float), 
__asinf_finite
);

50 #ifdef 
__MATH_DECLARE_LDOUBLE


51 #ifdef 
__NO_LONG_DOUBLE_MATH


52 extern long double 
__REDIRECT_NTH
 (
asinl
, (long double), 
__asin_finite
);

54 extern long double 
__REDIRECT_NTH
 (
asinl
, (long double), 
__asinl_finite
);

59 extern double 
__REDIRECT_NTH
 (
atan2
, (double, double), 
__atan2_finite
);

60 extern float 
__REDIRECT_NTH
 (
atan2f
, (float, float), 
__atan2f_finite
);

61 #ifdef 
__MATH_DECLARE_LDOUBLE


62 #ifdef 
__NO_LONG_DOUBLE_MATH


63 extern long double 
__REDIRECT_NTH
 (
atan2l
, (long double, long double),

64 
__atan2_finite
);

66 extern long double 
__REDIRECT_NTH
 (
atan2l
, (long double, long double),

67 
__atan2l_finite
);

71 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


73 extern double 
__REDIRECT_NTH
 (
atanh
, (double), 
__atanh_finite
);

74 extern float 
__REDIRECT_NTH
 (
atanhf
, (float), 
__atanhf_finite
);

75 #ifdef 
__MATH_DECLARE_LDOUBLE


76 #ifdef 
__NO_LONG_DOUBLE_MATH


77 extern long double 
__REDIRECT_NTH
 (
atanhl
, (long double), 
__atanh_finite
);

79 extern long double 
__REDIRECT_NTH
 (
atanhl
, (long double), 
__atanhl_finite
);

85 extern double 
__REDIRECT_NTH
 (
cosh
, (double), 
__cosh_finite
);

86 extern float 
__REDIRECT_NTH
 (
coshf
, (float), 
__coshf_finite
);

87 #ifdef 
__MATH_DECLARE_LDOUBLE


88 #ifdef 
__NO_LONG_DOUBLE_MATH


89 extern long double 
__REDIRECT_NTH
 (
coshl
, (long double), 
__cosh_finite
);

91 extern long double 
__REDIRECT_NTH
 (
coshl
, (long double), 
__coshl_finite
);

96 extern double 
__REDIRECT_NTH
 (
exp
, (double), 
__exp_finite
);

97 extern float 
__REDIRECT_NTH
 (
expf
, (float), 
__expf_finite
);

98 #ifdef 
__MATH_DECLARE_LDOUBLE


99 #ifdef 
__NO_LONG_DOUBLE_MATH


100 extern long double 
__REDIRECT_NTH
 (
expl
, (long double), 
__exp_finite
);

102 extern long double 
__REDIRECT_NTH
 (
expl
, (long double), 
__expl_finite
);

106 #ifdef 
__USE_GNU


108 extern double 
__REDIRECT_NTH
 (
exp10
, (double), 
__exp10_finite
);

109 extern float 
__REDIRECT_NTH
 (
exp10f
, (float), 
__exp10f_finite
);

110 #ifdef 
__MATH_DECLARE_LDOUBLE


111 #ifdef 
__NO_LONG_DOUBLE_MATH


112 extern long double 
__REDIRECT_NTH
 (
exp10l
, (long double), 
__exp10_finite
);

114 extern long double 
__REDIRECT_NTH
 (
exp10l
, (long double), 
__exp10l_finite
);

119 extern double 
__REDIRECT_NTH
 (
pow10
, (double), 
__exp10_finite
);

120 extern float 
__REDIRECT_NTH
 (
pow10f
, (float), 
__exp10f_finite
);

121 #ifdef 
__MATH_DECLARE_LDOUBLE


122 #ifdef 
__NO_LONG_DOUBLE_MATH


123 extern long double 
__REDIRECT_NTH
 (
pow10l
, (long double), 
__exp10_finite
);

125 extern long double 
__REDIRECT_NTH
 (
pow10l
, (long double), 
__exp10l_finite
);

130 #ifdef 
__USE_ISOC99


132 extern double 
__REDIRECT_NTH
 (
exp2
, (double), 
__exp2_finite
);

133 extern float 
__REDIRECT_NTH
 (
exp2f
, (float), 
__exp2f_finite
);

134 #ifdef 
__MATH_DECLARE_LDOUBLE


135 #ifdef 
__NO_LONG_DOUBLE_MATH


136 extern long double 
__REDIRECT_NTH
 (
exp2l
, (long double), 
__exp2_finite
);

138 extern long double 
__REDIRECT_NTH
 (
exp2l
, (long double), 
__exp2l_finite
);

144 extern double 
__REDIRECT_NTH
 (
fmod
, (double, double), 
__fmod_finite
);

145 extern float 
__REDIRECT_NTH
 (
fmodf
, (float, float), 
__fmodf_finite
);

146 #ifdef 
__MATH_DECLARE_LDOUBLE


147 #ifdef 
__NO_LONG_DOUBLE_MATH


148 extern long double 
__REDIRECT_NTH
 (
fmodl
, (long double, long double),

149 
__fmod_finite
);

151 extern long double 
__REDIRECT_NTH
 (
fmodl
, (long double, long double),

152 
__fmodl_finite
);

156 #ifdef 
__USE_ISOC99


158 extern double 
__REDIRECT_NTH
 (
hypot
, (double, double), 
__hypot_finite
);

159 extern float 
__REDIRECT_NTH
 (
hypotf
, (float, float), 
__hypotf_finite
);

160 #ifdef 
__MATH_DECLARE_LDOUBLE


161 #ifdef 
__NO_LONG_DOUBLE_MATH


162 extern long double 
__REDIRECT_NTH
 (
hypotl
, (long double, long double),

163 
__hypot_finite
);

165 extern long double 
__REDIRECT_NTH
 (
hypotl
, (long double, long double),

166 
__hypotl_finite
);

171 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


173 extern double 
__REDIRECT_NTH
 (
j0
, (double), 
__j0_finite
);

174 extern float 
__REDIRECT_NTH
 (
j0f
, (float), 
__j0f_finite
);

175 #ifdef 
__MATH_DECLARE_LDOUBLE


176 #ifdef 
__NO_LONG_DOUBLE_MATH


177 extern long double 
__REDIRECT_NTH
 (
j0l
, (long double), 
__j0_finite
);

179 extern long double 
__REDIRECT_NTH
 (
j0l
, (long double), 
__j0l_finite
);

184 extern double 
__REDIRECT_NTH
 (
y0
, (double), 
__y0_finite
);

185 extern float 
__REDIRECT_NTH
 (
y0f
, (float), 
__y0f_finite
);

186 #ifdef 
__MATH_DECLARE_LDOUBLE


187 #ifdef 
__NO_LONG_DOUBLE_MATH


188 extern long double 
__REDIRECT_NTH
 (
y0l
, (long double), 
__y0_finite
);

190 extern long double 
__REDIRECT_NTH
 (
y0l
, (long double), 
__y0l_finite
);

195 extern double 
__REDIRECT_NTH
 (
j1
, (double), 
__j1_finite
);

196 extern float 
__REDIRECT_NTH
 (
j1f
, (float), 
__j1f_finite
);

197 #ifdef 
__MATH_DECLARE_LDOUBLE


198 #ifdef 
__NO_LONG_DOUBLE_MATH


199 extern long double 
__REDIRECT_NTH
 (
j1l
, (long double), 
__j1_finite
);

201 extern long double 
__REDIRECT_NTH
 (
j1l
, (long double), 
__j1l_finite
);

206 extern double 
__REDIRECT_NTH
 (
y1
, (double), 
__y1_finite
);

207 extern float 
__REDIRECT_NTH
 (
y1f
, (float), 
__y1f_finite
);

208 #ifdef 
__MATH_DECLARE_LDOUBLE


209 #ifdef 
__NO_LONG_DOUBLE_MATH


210 extern long double 
__REDIRECT_NTH
 (
y1l
, (long double), 
__y1_finite
);

212 extern long double 
__REDIRECT_NTH
 (
y1l
, (long double), 
__y1l_finite
);

217 extern double 
__REDIRECT_NTH
 (
jn
, (int, double), 
__jn_finite
);

218 extern float 
__REDIRECT_NTH
 (
jnf
, (int, float), 
__jnf_finite
);

219 #ifdef 
__MATH_DECLARE_LDOUBLE


220 #ifdef 
__NO_LONG_DOUBLE_MATH


221 extern long double 
__REDIRECT_NTH
 (
jnl
, (int, long double), 
__jn_finite
);

223 extern long double 
__REDIRECT_NTH
 (
jnl
, (int, long double), 
__jnl_finite
);

228 extern double 
__REDIRECT_NTH
 (
yn
, (int, double), 
__yn_finite
);

229 extern float 
__REDIRECT_NTH
 (
ynf
, (int, float), 
__ynf_finite
);

230 #ifdef 
__MATH_DECLARE_LDOUBLE


231 #ifdef 
__NO_LONG_DOUBLE_MATH


232 extern long double 
__REDIRECT_NTH
 (
ynl
, (int, long double), 
__yn_finite
);

234 extern long double 
__REDIRECT_NTH
 (
ynl
, (int, long double), 
__ynl_finite
);

239 #ifdef 
__USE_MISC


241 extern double 
__REDIRECT_NTH
 (
lgamma_r
, (double, int *), 
__lgamma_r_finite
);

242 extern float 
__REDIRECT_NTH
 (
lgammaf_r
, (float, int *), 
__lgammaf_r_finite
);

243 #ifdef 
__MATH_DECLARE_LDOUBLE


244 #ifdef 
__NO_LONG_DOUBLE_MATH


245 extern long double 
__REDIRECT_NTH
 (
lgammal_r
, (long double, int *),

246 
__lgamma_r_finite
);

248 extern long double 
__REDIRECT_NTH
 (
lgammal_r
, (long double, int *),

249 
__lgammal_r_finite
);

254 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN
 || defined 
__USE_ISOC99


256 
__extern_always_inline
 double 
__NTH
 (
	$lgamma
 (double 
__d
))

258 #ifdef 
__USE_ISOC99


259 int 
__local_signgam
 = 0;

260 return 
	`lgamma_r
 (
__d
, &
__local_signgam
);

262 return 
	`lgamma_r
 (
__d
, &
signgam
);

264 
	}
}

265 
__extern_always_inline
 float 
__NTH
 (
	$lgammaf
 (float 
__d
))

267 #ifdef 
__USE_ISOC99


268 int 
__local_signgam
 = 0;

269 return 
	`lgammaf_r
 (
__d
, &
__local_signgam
);

271 return 
	`lgammaf_r
 (
__d
, &
signgam
);

273 
	}
}

274 #ifdef 
__MATH_DECLARE_LDOUBLE


275 
__extern_always_inline
 long double 
__NTH
 (
	$lgammal
 (long double 
__d
))

277 #ifdef 
__USE_ISOC99


278 int 
__local_signgam
 = 0;

279 return 
	`lgammal_r
 (
__d
, &
__local_signgam
);

281 return 
	`lgammal_r
 (
__d
, &
signgam
);

283 
	}
}

287 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


289 
__extern_always_inline
 double 
__NTH
 (
	$gamma
 (double 
__d
))

291 #ifdef 
__USE_ISOC99


292 int 
__local_signgam
 = 0;

293 return 
	`lgamma_r
 (
__d
, &
__local_signgam
);

295 return 
	`lgamma_r
 (
__d
, &
signgam
);

297 
	}
}

298 
__extern_always_inline
 float 
__NTH
 (
	$gammaf
 (float 
__d
))

300 #ifdef 
__USE_ISOC99


301 int 
__local_signgam
 = 0;

302 return 
	`lgammaf_r
 (
__d
, &
__local_signgam
);

304 return 
	`lgammaf_r
 (
__d
, &
signgam
);

306 
	}
}

307 #ifdef 
__MATH_DECLARE_LDOUBLE


308 
__extern_always_inline
 long double 
__NTH
 (
	$gammal
 (long double 
__d
))

310 #ifdef 
__USE_ISOC99


311 int 
__local_signgam
 = 0;

312 return 
	`lgammal_r
 (
__d
, &
__local_signgam
);

314 return 
	`lgammal_r
 (
__d
, &
signgam
);

316 
	}
}

321 extern double 
__REDIRECT_NTH
 (
log
, (double), 
__log_finite
);

322 extern float 
__REDIRECT_NTH
 (
logf
, (float), 
__logf_finite
);

323 #ifdef 
__MATH_DECLARE_LDOUBLE


324 #ifdef 
__NO_LONG_DOUBLE_MATH


325 extern long double 
__REDIRECT_NTH
 (
logl
, (long double), 
__log_finite
);

327 extern long double 
__REDIRECT_NTH
 (
logl
, (long double), 
__logl_finite
);

332 extern double 
__REDIRECT_NTH
 (
log10
, (double), 
__log10_finite
);

333 extern float 
__REDIRECT_NTH
 (
log10f
, (float), 
__log10f_finite
);

334 #ifdef 
__MATH_DECLARE_LDOUBLE


335 #ifdef 
__NO_LONG_DOUBLE_MATH


336 extern long double 
__REDIRECT_NTH
 (
log10l
, (long double), 
__log10_finite
);

338 extern long double 
__REDIRECT_NTH
 (
log10l
, (long double), 
__log10l_finite
);

342 #ifdef 
__USE_ISOC99


344 extern double 
__REDIRECT_NTH
 (
log2
, (double), 
__log2_finite
);

345 extern float 
__REDIRECT_NTH
 (
log2f
, (float), 
__log2f_finite
);

346 #ifdef 
__MATH_DECLARE_LDOUBLE


347 #ifdef 
__NO_LONG_DOUBLE_MATH


348 extern long double 
__REDIRECT_NTH
 (
log2l
, (long double), 
__log2_finite
);

350 extern long double 
__REDIRECT_NTH
 (
log2l
, (long double), 
__log2l_finite
);

356 extern double 
__REDIRECT_NTH
 (
ldexp
, (double, int), 
scalbn
);

357 extern float 
__REDIRECT_NTH
 (
ldexpf
, (float, int), 
scalbnf
);

358 #ifdef 
__MATH_DECLARE_LDOUBLE


359 extern long double 
__REDIRECT_NTH
 (
ldexpl
, (long double, int), 
scalbnl
);

363 extern double 
__REDIRECT_NTH
 (
pow
, (double, double), 
__pow_finite
);

364 extern float 
__REDIRECT_NTH
 (
powf
, (float, float), 
__powf_finite
);

365 #ifdef 
__MATH_DECLARE_LDOUBLE


366 #ifdef 
__NO_LONG_DOUBLE_MATH


367 extern long double 
__REDIRECT_NTH
 (
powl
, (long double, long double),

368 
__pow_finite
);

370 extern long double 
__REDIRECT_NTH
 (
powl
, (long double, long double),

371 
__powl_finite
);

376 extern double 
__REDIRECT_NTH
 (
remainder
, (double, double), 
__remainder_finite
);

377 extern float 
__REDIRECT_NTH
 (
remainderf
, (float, float), 
__remainderf_finite
);

378 #ifdef 
__MATH_DECLARE_LDOUBLE


379 #ifdef 
__NO_LONG_DOUBLE_MATH


380 extern long double 
__REDIRECT_NTH
 (
remainderl
, (long double, long double),

381 
__remainder_finite
);

383 extern long double 
__REDIRECT_NTH
 (
remainderl
, (long double, long double),

384 
__remainderl_finite
);

388 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


390 extern double 
__REDIRECT_NTH
 (
scalb
, (double, double), 
__scalb_finite
);

391 extern float 
__REDIRECT_NTH
 (
scalbf
, (float, float), 
__scalbf_finite
);

392 #ifdef 
__MATH_DECLARE_LDOUBLE


393 #ifdef 
__NO_LONG_DOUBLE_MATH


394 extern long double 
__REDIRECT_NTH
 (
scalbl
, (long double, long double),

395 
__scalb_finite
);

397 extern long double 
__REDIRECT_NTH
 (
scalbl
, (long double, long double),

398 
__scalbl_finite
);

404 extern double 
__REDIRECT_NTH
 (
sinh
, (double), 
__sinh_finite
);

405 extern float 
__REDIRECT_NTH
 (
sinhf
, (float), 
__sinhf_finite
);

406 #ifdef 
__MATH_DECLARE_LDOUBLE


407 #ifdef 
__NO_LONG_DOUBLE_MATH


408 extern long double 
__REDIRECT_NTH
 (
sinhl
, (long double), 
__sinh_finite
);

410 extern long double 
__REDIRECT_NTH
 (
sinhl
, (long double), 
__sinhl_finite
);

415 extern double 
__REDIRECT_NTH
 (
sqrt
, (double), 
__sqrt_finite
);

416 extern float 
__REDIRECT_NTH
 (
sqrtf
, (float), 
__sqrtf_finite
);

417 #ifdef 
__MATH_DECLARE_LDOUBLE


418 #ifdef 
__NO_LONG_DOUBLE_MATH


419 extern long double 
__REDIRECT_NTH
 (
sqrtl
, (long double), 
__sqrt_finite
);

421 extern long double 
__REDIRECT_NTH
 (
sqrtl
, (long double), 
__sqrtl_finite
);

425 #ifdef 
__USE_ISOC99


427 extern double 
__gamma_r_finite
 (double, int *);

428 
__extern_always_inline
 double 
__NTH
 (
	$tgamma
 (double 
__d
))

430 int 
__local_signgam
 = 0;

431 double 
__res
 = 
	`__gamma_r_finite
 (
__d
, &
__local_signgam
);

432 return 
__local_signgam
 < 0 ? -
__res
 : __res;

433 
	}
}

434 extern float 
__gammaf_r_finite
 (float, int *);

435 
__extern_always_inline
 float 
__NTH
 (
	$tgammaf
 (float 
__d
))

437 int 
__local_signgam
 = 0;

438 float 
__res
 = 
	`__gammaf_r_finite
 (
__d
, &
__local_signgam
);

439 return 
__local_signgam
 < 0 ? -
__res
 : __res;

440 
	}
}

441 #ifdef 
__MATH_DECLARE_LDOUBLE


442 extern long double 
__gammal_r_finite
 (long double, int *);

443 
__extern_always_inline
 long double 
__NTH
 (
	$tgammal
 (long double 
__d
))

445 int 
__local_signgam
 = 0;

446 #ifdef 
__NO_LONG_DOUBLE_MATH


447 long double 
__res
 = 
	`__gamma_r_finite
 (
__d
, &
__local_signgam
);

449 long double 
__res
 = 
	`__gammal_r_finite
 (
__d
, &
__local_signgam
);

451 return 
__local_signgam
 < 0 ? -
__res
 : __res;

452 
	}
}

	@/usr/include/bits/mathcalls.h

45 #ifndef 
_MATH_H


52 
_Mdouble_BEGIN_NAMESPACE


54 
__MATHCALL
 (
acos
,, (
_Mdouble_
 
__x
));

56 
__MATHCALL
 (
asin
,, (
_Mdouble_
 
__x
));

58 
__MATHCALL
 (
atan
,, (
_Mdouble_
 
__x
));

60 
__MATHCALL
 (
atan2
,, (
_Mdouble_
 
__y
, _Mdouble_ 
__x
));

63 
__MATHCALL
 (
cos
,, (
_Mdouble_
 
__x
));

65 
__MATHCALL
 (
sin
,, (
_Mdouble_
 
__x
));

67 
__MATHCALL
 (
tan
,, (
_Mdouble_
 
__x
));

72 
__MATHCALL
 (
cosh
,, (
_Mdouble_
 
__x
));

74 
__MATHCALL
 (
sinh
,, (
_Mdouble_
 
__x
));

76 
__MATHCALL
 (
tanh
,, (
_Mdouble_
 
__x
));

77 
	g_Mdouble_END_NAMESPACE


79 #ifdef 
__USE_GNU


81 
__MATHDECL
 (void,
sincos
,,

82 (
_Mdouble_
 
__x
, _Mdouble_ *
__sinx
, _Mdouble_ *
__cosx
));

85 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


86 
__BEGIN_NAMESPACE_C99


88 
__MATHCALL
 (
acosh
,, (
_Mdouble_
 
__x
));

90 
__MATHCALL
 (
asinh
,, (
_Mdouble_
 
__x
));

92 
__MATHCALL
 (
atanh
,, (
_Mdouble_
 
__x
));

93 
	g__END_NAMESPACE_C99


98 
_Mdouble_BEGIN_NAMESPACE


100 
__MATHCALL
 (
exp
,, (
_Mdouble_
 
__x
));

103 
__MATHCALL
 (
frexp
,, (
_Mdouble_
 
__x
, int *
__exponent
));

106 
__MATHCALL
 (
ldexp
,, (
_Mdouble_
 
__x
, int 
__exponent
));

109 
__MATHCALL
 (
log
,, (
_Mdouble_
 
__x
));

112 
__MATHCALL
 (
log10
,, (
_Mdouble_
 
__x
));

115 
__MATHCALL
 (
modf
,, (
_Mdouble_
 
__x
, _Mdouble_ *
__iptr
)) 
__nonnull
 ((2));

116 
	g_Mdouble_END_NAMESPACE


118 #ifdef 
__USE_GNU


120 
__MATHCALL
 (
exp10
,, (
_Mdouble_
 
__x
));

122 
__MATHCALL
 (
pow10
,, (
_Mdouble_
 
__x
));

125 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


126 
__BEGIN_NAMESPACE_C99


128 
__MATHCALL
 (
expm1
,, (
_Mdouble_
 
__x
));

131 
__MATHCALL
 (
log1p
,, (
_Mdouble_
 
__x
));

134 
__MATHCALL
 (
logb
,, (
_Mdouble_
 
__x
));

135 
	g__END_NAMESPACE_C99


138 #ifdef 
__USE_ISOC99


139 
__BEGIN_NAMESPACE_C99


141 
__MATHCALL
 (
exp2
,, (
_Mdouble_
 
__x
));

144 
__MATHCALL
 (
log2
,, (
_Mdouble_
 
__x
));

145 
	g__END_NAMESPACE_C99


151 
_Mdouble_BEGIN_NAMESPACE


153 
__MATHCALL
 (
pow
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

156 
__MATHCALL
 (
sqrt
,, (
_Mdouble_
 
__x
));

157 
	g_Mdouble_END_NAMESPACE


159 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN
 || defined 
__USE_ISOC99


160 
__BEGIN_NAMESPACE_C99


162 
__MATHCALL
 (
hypot
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

163 
	g__END_NAMESPACE_C99


166 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


167 
__BEGIN_NAMESPACE_C99


169 
__MATHCALL
 (
cbrt
,, (
_Mdouble_
 
__x
));

170 
	g__END_NAMESPACE_C99


176 
_Mdouble_BEGIN_NAMESPACE


178 
__MATHCALLX
 (
ceil
,, (
_Mdouble_
 
__x
), (
__const__
));

181 
__MATHCALLX
 (
fabs
,, (
_Mdouble_
 
__x
), (
__const__
));

184 
__MATHCALLX
 (
floor
,, (
_Mdouble_
 
__x
), (
__const__
));

187 
__MATHCALL
 (
fmod
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

192 
__MATHDECL_1
 (int,
__isinf
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

195 
__MATHDECL_1
 (int,
__finite
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

196 
	g_Mdouble_END_NAMESPACE


198 #ifdef 
__USE_MISC


201 
__MATHDECL_1
 (int,
isinf
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

204 
__MATHDECL_1
 (int,
finite
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

207 
__MATHCALL
 (
drem
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

211 
__MATHCALL
 (
significand
,, (
_Mdouble_
 
__x
));

214 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


215 
__BEGIN_NAMESPACE_C99


217 
__MATHCALLX
 (
copysign
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
), (
__const__
));

218 
	g__END_NAMESPACE_C99


221 #ifdef 
__USE_ISOC99


222 
__BEGIN_NAMESPACE_C99


224 
__MATHCALLX
 (
nan
,, (const char *
__tagb
), (
__const__
));

225 
	g__END_NAMESPACE_C99


230 
__MATHDECL_1
 (int,
__isnan
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

232 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


234 
__MATHDECL_1
 (int,
isnan
,, (
_Mdouble_
 
__value
)) 
__attribute__
 ((
__const__
));

237 
__MATHCALL
 (
j0
,, (
_Mdouble_
));

238 
__MATHCALL
 (
j1
,, (
_Mdouble_
));

239 
__MATHCALL
 (
jn
,, (int, 
_Mdouble_
));

240 
__MATHCALL
 (
y0
,, (
_Mdouble_
));

241 
__MATHCALL
 (
y1
,, (
_Mdouble_
));

242 
__MATHCALL
 (
yn
,, (int, 
_Mdouble_
));

246 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN
 || defined 
__USE_ISOC99


247 
__BEGIN_NAMESPACE_C99


249 
__MATHCALL
 (
erf
,, (
_Mdouble_
));

250 
__MATHCALL
 (
erfc
,, (
_Mdouble_
));

251 
__MATHCALL
 (
lgamma
,, (
_Mdouble_
));

252 
	g__END_NAMESPACE_C99


255 #ifdef 
__USE_ISOC99


256 
__BEGIN_NAMESPACE_C99


258 
__MATHCALL
 (
tgamma
,, (
_Mdouble_
));

259 
	g__END_NAMESPACE_C99


262 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN


264 
__MATHCALL
 (
gamma
,, (
_Mdouble_
));

267 #ifdef 
__USE_MISC


271 
__MATHCALL
 (
lgamma
,
_r
, (
_Mdouble_
, int *
__signgamp
));

275 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


276 
__BEGIN_NAMESPACE_C99


279 
__MATHCALL
 (
rint
,, (
_Mdouble_
 
__x
));

282 
__MATHCALLX
 (
nextafter
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
), (
__const__
));

283 #if 
defined
 
__USE_ISOC99
 && !defined 
__LDBL_COMPAT


284 
__MATHCALLX
 (
nexttoward
,, (
_Mdouble_
 
__x
, long double 
__y
), (
__const__
));

288 
__MATHCALL
 (
remainder
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

290 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


292 
__MATHCALL
 (
scalbn
,, (
_Mdouble_
 
__x
, int 
__n
));

296 
__MATHDECL
 (int,
ilogb
,, (
_Mdouble_
 
__x
));

299 #ifdef 
__USE_ISOC99


301 
__MATHCALL
 (
scalbln
,, (
_Mdouble_
 
__x
, long int 
__n
));

305 
__MATHCALL
 (
nearbyint
,, (
_Mdouble_
 
__x
));

309 
__MATHCALLX
 (
round
,, (
_Mdouble_
 
__x
), (
__const__
));

313 
__MATHCALLX
 (
trunc
,, (
_Mdouble_
 
__x
), (
__const__
));

318 
__MATHCALL
 (
remquo
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
, int *
__quo
));

325 
__MATHDECL
 (long int,
lrint
,, (
_Mdouble_
 
__x
));

326 
__extension__


327 
__MATHDECL
 (long long int,
llrint
,, (
_Mdouble_
 
__x
));

331 
__MATHDECL
 (long int,
lround
,, (
_Mdouble_
 
__x
));

332 
__extension__


333 
__MATHDECL
 (long long int,
llround
,, (
_Mdouble_
 
__x
));

337 
__MATHCALL
 (
fdim
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
));

340 
__MATHCALLX
 (
fmax
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
), (
__const__
));

343 
__MATHCALLX
 (
fmin
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
), (
__const__
));

347 
__MATHDECL_1
 (int, 
__fpclassify
,, (
_Mdouble_
 
__value
))

348 
__attribute__
 ((
__const__
));

351 
__MATHDECL_1
 (int, 
__signbit
,, (
_Mdouble_
 
__value
))

352 
__attribute__
 ((
__const__
));

356 
__MATHCALL
 (
fma
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__y
, _Mdouble_ 
__z
));

359 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


360 
	g__END_NAMESPACE_C99


363 #ifdef 
__USE_GNU


365 
__MATHDECL_1
 (int, 
__issignaling
,, (
_Mdouble_
 
__value
))

366 
__attribute__
 ((
__const__
));

369 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED


371 
__MATHCALL
 (
scalb
,, (
_Mdouble_
 
__x
, _Mdouble_ 
__n
));

	@/usr/include/bits/mathdef.h

18 #if !
defined
 
_MATH_H
 && !defined 
_COMPLEX_H


22 #if 
defined
 
__USE_ISOC99
 && defined 
_MATH_H
 && !defined 
_MATH_H_MATHDEF


23 #define 
	#_MATH_H_MATHDEF
 1

	)

25 #if 
defined
 
__x86_64__
 || (defined 
__FLT_EVAL_METHOD__
 && __FLT_EVAL_METHOD__ == 0)

28 typedef float 
	tfloat_t
;

29 typedef double 
	tdouble_t
;

35 typedef long double 
	tfloat_t
;

37 typedef long double 
	tdouble_t
;

42 #define 
	#FP_ILOGB0
 (-2147483647 - 1)

	)

43 #define 
	#FP_ILOGBNAN
 (-2147483647 - 1)

	)

47 #if 
__FP_FAST_FMA


48 #define 
	#FP_FAST_FMA
 1

	)

51 #if 
__FP_FAST_FMAF


52 #define 
	#FP_FAST_FMAF
 1

	)

55 #if 
__FP_FAST_FMAL


56 #define 
	#FP_FAST_FMAL
 1

	)

	@/usr/include/bits/mathinline.h

19 #ifndef 
_MATH_H


23 #ifndef 
__extern_always_inline


24 #define 
	#__MATH_INLINE
 
__inline


	)

26 #define 
	#__MATH_INLINE
 
__extern_always_inline


	)

30 #if 
defined
 
__USE_ISOC99
 && defined 
__GNUC__
 && __GNUC__ >= 2

32 #if !
__GNUC_PREREQ
 (2,97)

37 #undef 
isgreater


38 #undef 
isgreaterequal


39 #undef 
isless


40 #undef 
islessequal


41 #undef 
islessgreater


42 #undef 
isunordered


43 #ifdef 
__i686__


46 #define 
	#isgreater
(
x
, 
y
) \

47 ({ register char 
__result
; \

48 
	`__asm__
 ("fucomip %%st(1), %%st; seta %%al" \

49 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st"); \

50 
__result
; })

	)

51 #define 
	#isgreaterequal
(
x
, 
y
) \

52 ({ register char 
__result
; \

53 
	`__asm__
 ("fucomip %%st(1), %%st; setae %%al" \

54 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st"); \

55 
__result
; })

	)

57 #define 
	#isless
(
x
, 
y
) \

58 ({ register char 
__result
; \

59 
	`__asm__
 ("fucomip %%st(1), %%st; seta %%al" \

60 : "=a" (
__result
) : "u" (
x
), "t" (
y
) : "cc", "st"); \

61 
__result
; })

	)

63 #define 
	#islessequal
(
x
, 
y
) \

64 ({ register char 
__result
; \

65 
	`__asm__
 ("fucomip %%st(1), %%st; setae %%al" \

66 : "=a" (
__result
) : "u" (
x
), "t" (
y
) : "cc", "st"); \

67 
__result
; })

	)

69 #define 
	#islessgreater
(
x
, 
y
) \

70 ({ register char 
__result
; \

71 
	`__asm__
 ("fucomip %%st(1), %%st; setne %%al" \

72 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st"); \

73 
__result
; })

	)

75 #define 
	#isunordered
(
x
, 
y
) \

76 ({ register char 
__result
; \

77 
	`__asm__
 ("fucomip %%st(1), %%st; setp %%al" \

78 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st"); \

79 
__result
; })

	)

82 #define 
	#isgreater
(
x
, 
y
) \

83 ({ register char 
__result
; \

84 
	`__asm__
 ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al" \

85 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

86 
__result
; })

	)

88 #define 
	#isgreaterequal
(
x
, 
y
) \

89 ({ register char 
__result
; \

90 
	`__asm__
 ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al" \

91 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

92 
__result
; })

	)

94 #define 
	#isless
(
x
, 
y
) \

95 ({ register char 
__result
; \

96 
	`__asm__
 ("fucompp; fnstsw; testb $0x45, %%ah; setz %%al" \

97 : "=a" (
__result
) : "u" (
x
), "t" (
y
) : "cc", "st", "st(1)"); \

98 
__result
; })

	)

100 #define 
	#islessequal
(
x
, 
y
) \

101 ({ register char 
__result
; \

102 
	`__asm__
 ("fucompp; fnstsw; testb $0x05, %%ah; setz %%al" \

103 : "=a" (
__result
) : "u" (
x
), "t" (
y
) : "cc", "st", "st(1)"); \

104 
__result
; })

	)

106 #define 
	#islessgreater
(
x
, 
y
) \

107 ({ register char 
__result
; \

108 
	`__asm__
 ("fucompp; fnstsw; testb $0x44, %%ah; setz %%al" \

109 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

110 
__result
; })

	)

112 #define 
	#isunordered
(
x
, 
y
) \

113 ({ register char 
__result
; \

114 
	`__asm__
 ("fucompp; fnstsw; sahf; setp %%al" \

115 : "=a" (
__result
) : "u" (
y
), "t" (
x
) : "cc", "st", "st(1)"); \

116 
__result
; })

	)

122 #if 
__GNUC_PREREQ
 (2, 8)

123 
__BEGIN_NAMESPACE_C99


126 
__MATH_INLINE
 int

127 
__NTH
 (
	$__signbitf
 (float 
__x
))

129 #ifdef 
__SSE2_MATH__


130 int 
__m
;

131 
	`__asm
 ("pmovmskb %1, %0" : "=r" (
__m
) : "x" (
__x
));

132 return (
__m
 & 0x8) != 0;

134 
__extension__
 union { float 
__f
; int 
__i
; } 
__u
 = { __f: 
__x
 };

135 return 
__u
.
__i
 < 0;

137 
	}
}

138 
__MATH_INLINE
 int

139 
__NTH
 (
	$__signbit
 (double 
__x
))

141 #ifdef 
__SSE2_MATH__


142 int 
__m
;

143 
	`__asm
 ("pmovmskb %1, %0" : "=r" (
__m
) : "x" (
__x
));

144 return (
__m
 & 0x80) != 0;

146 
__extension__
 union { double 
__d
; int 
__i
[2]; } 
__u
 = { __d: 
__x
 };

147 return 
__u
.
__i
[1] < 0;

149 
	}
}

150 
__MATH_INLINE
 int

151 
__NTH
 (
	$__signbitl
 (long double 
__x
))

153 
__extension__
 union { long double 
__l
; int 
__i
[3]; } 
__u
 = { __l: 
__x
 };

154 return (
__u
.
__i
[2] & 0x8000) != 0;

155 
	}
}

157 
	g__END_NAMESPACE_C99


164 #if 
__GNUC_PREREQ
 (2, 8)

165 #if !
__GNUC_PREREQ
 (3, 4) && !
defined
 
__NO_MATH_INLINES
 \

166 && 
defined
 
	g__OPTIMIZE__


170 #ifdef 
__USE_ISOC99


171 
	g__BEGIN_NAMESPACE_C99


174 #ifdef 
__SSE_MATH__


175 
__MATH_INLINE
 long int

176 
__NTH
 (
	$lrintf
 (float 
__x
))

178 long int 
__res
;

183 
__asm
 
	`__volatile__
 ("cvtss2si %1, %0" : "=r" (
__res
) : "xm" (
__x
));

184 return 
__res
;

185 
	}
}

187 #ifdef 
__SSE2_MATH__


188 
__MATH_INLINE
 long int

189 
__NTH
 (
	$lrint
 (double 
__x
))

191 long int 
__res
;

196 
__asm
 
	`__volatile__
 ("cvtsd2si %1, %0" : "=r" (
__res
) : "xm" (
__x
));

197 return 
__res
;

198 
	}
}

200 #ifdef 
__x86_64__


201 
__extension__


202 
__MATH_INLINE
 long long int

203 
__NTH
 (
	$llrintf
 (float 
__x
))

205 long long int 
__res
;

210 
__asm
 
	`__volatile__
 ("cvtss2si %1, %0" : "=r" (
__res
) : "xm" (
__x
));

211 return 
__res
;

212 
	}
}

213 
__extension__


214 
__MATH_INLINE
 long long int

215 
__NTH
 (
	$llrint
 (double 
__x
))

217 long long int 
__res
;

222 
__asm
 
	`__volatile__
 ("cvtsd2si %1, %0" : "=r" (
__res
) : "xm" (
__x
));

223 return 
__res
;

224 
	}
}

227 #if 
defined
 
__FINITE_MATH_ONLY__
 && __FINITE_MATH_ONLY__ > 0 \

228 && 
defined
 
__SSE2_MATH__


230 
__MATH_INLINE
 float

231 
__NTH
 (
	$fmaxf
 (float 
__x
, float 
__y
))

233 #ifdef 
__AVX__


234 float 
__res
;

235 
	`__asm
 ("vmaxss %2, %1, %0" : "=x" (
__res
) : "x" (
x
), "xm" (
__y
));

236 return 
__res
;

238 
	`__asm
 ("maxss %1, %0" : "+x" (
__x
) : "xm" (
__y
));

239 return 
__x
;

241 
	}
}

242 
__MATH_INLINE
 double

243 
__NTH
 (
	$fmax
 (double 
__x
, double 
__y
))

245 #ifdef 
__AVX__


246 float 
__res
;

247 
	`__asm
 ("vmaxsd %2, %1, %0" : "=x" (
__res
) : "x" (
x
), "xm" (
__y
));

248 return 
__res
;

250 
	`__asm
 ("maxsd %1, %0" : "+x" (
__x
) : "xm" (
__y
));

251 return 
__x
;

253 
	}
}

256 
__MATH_INLINE
 float

257 
__NTH
 (
	$fminf
 (float 
__x
, float 
__y
))

259 #ifdef 
__AVX__


260 float 
__res
;

261 
	`__asm
 ("vminss %2, %1, %0" : "=x" (
__res
) : "x" (
x
), "xm" (
__y
));

262 return 
__res
;

264 
	`__asm
 ("minss %1, %0" : "+x" (
__x
) : "xm" (
__y
));

265 return 
__x
;

267 
	}
}

268 
__MATH_INLINE
 double

269 
__NTH
 (
	$fmin
 (double 
__x
, double 
__y
))

271 #ifdef 
__AVX__


272 float 
__res
;

273 
	`__asm
 ("vminsd %2, %1, %0" : "=x" (
__res
) : "x" (
x
), "xm" (
__y
));

274 return 
__res
;

276 
	`__asm
 ("minsd %1, %0" : "+x" (
__x
) : "xm" (
__y
));

277 return 
__x
;

279 
	}
}

282 
	g__END_NAMESPACE_C99


285 #if 
defined
 
__SSE4_1__
 && defined 
__SSE2_MATH__


286 #if 
defined
 
__USE_MISC
 || defined 
__USE_XOPEN_EXTENDED
 || defined 
__USE_ISOC99


287 
__BEGIN_NAMESPACE_C99


290 
__MATH_INLINE
 double

291 
__NTH
 (
	$rint
 (double 
__x
))

293 double 
__res
;

298 
__asm
 
	`__volatile__
 ("roundsd $4, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

299 return 
__res
;

300 
	}
}

301 
__MATH_INLINE
 float

302 
__NTH
 (
	$rintf
 (float 
__x
))

304 float 
__res
;

309 
__asm
 
	`__volatile__
 ("roundss $4, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

310 return 
__res
;

311 
	}
}

313 #ifdef 
__USE_ISOC99


315 
__MATH_INLINE
 double

316 
__NTH
 (
	$nearbyint
 (double 
__x
))

318 double 
__res
;

323 
__asm
 
	`__volatile__
 ("roundsd $0xc, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

324 return 
__res
;

325 
	}
}

326 
__MATH_INLINE
 float

327 
__NTH
 (
	$nearbyintf
 (float 
__x
))

329 float 
__res
;

334 
__asm
 
	`__volatile__
 ("roundss $0xc, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

335 return 
__res
;

336 
	}
}

339 
	g__END_NAMESPACE_C99


342 
__BEGIN_NAMESPACE_STD


344 
__MATH_INLINE
 double

345 
__NTH
 (
	$ceil
 (double 
__x
))

347 double 
__res
;

348 
	`__asm
 ("roundsd $2, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

349 return 
__res
;

350 
	}
}

351 
__END_NAMESPACE_STD


353 
__BEGIN_NAMESPACE_C99


354 
__MATH_INLINE
 float

355 
__NTH
 (
	$ceilf
 (float 
__x
))

357 float 
__res
;

358 
	`__asm
 ("roundss $2, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

359 return 
__res
;

360 
	}
}

361 
__END_NAMESPACE_C99


363 
__BEGIN_NAMESPACE_STD


365 
__MATH_INLINE
 double

366 
__NTH
 (
	$floor
 (double 
__x
))

368 double 
__res
;

369 
	`__asm
 ("roundsd $1, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

370 return 
__res
;

371 
	}
}

372 
__END_NAMESPACE_STD


374 
__BEGIN_NAMESPACE_C99


375 
__MATH_INLINE
 float

376 
__NTH
 (
	$floorf
 (float 
__x
))

378 float 
__res
;

379 
	`__asm
 ("roundss $1, %1, %0" : "=x" (
__res
) : "xm" (
__x
));

380 return 
__res
;

381 
	}
}

382 
	g__END_NAMESPACE_C99


387 #ifndef 
__SSE2_MATH__


388 #if ((!
defined
 
__NO_MATH_INLINES
 || defined 
__LIBC_INTERNAL_MATH_INLINES
) \

389 && 
defined
 
	g__OPTIMIZE__
)

393 #undef 
math_errhandling


402 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


403 #define 
	#__inline_mathop
(
func
, 
op
) \

404 
	`__inline_mathop_
 (double, 
func
, 
op
) \

405 
	`__inline_mathop_
 (float, 
	`__CONCAT
(
func
,
f
), 
op
) \

406 
	`__inline_mathop_
 (long double, 
	`__CONCAT
(
func
,
l
), 
op
)

	)

407 #define 
	#__inline_mathopNP
(
func
, 
op
) \

408 
	`__inline_mathopNP_
 (double, 
func
, 
op
) \

409 
	`__inline_mathopNP_
 (float, 
	`__CONCAT
(
func
,
f
), 
op
) \

410 
	`__inline_mathopNP_
 (long double, 
	`__CONCAT
(
func
,
l
), 
op
)

	)

412 #define 
	#__inline_mathop
(
func
, 
op
) \

413 
	`__inline_mathop_
 (double, 
func
, 
op
)

	)

414 #define 
	#__inline_mathopNP
(
func
, 
op
) \

415 
	`__inline_mathopNP_
 (double, 
func
, 
op
)

	)

418 #define 
	#__inline_mathop_
(
float_type
, 
func
, 
op
) \

419 
	`__inline_mathop_decl_
 (
float_type
, 
func
, 
op
, "0" (
__x
))

	)

420 #define 
	#__inline_mathopNP_
(
float_type
, 
func
, 
op
) \

421 
	`__inline_mathop_declNP_
 (
float_type
, 
func
, 
op
, "0" (
__x
))

	)

424 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


425 #define 
	#__inline_mathop_decl
(
func
, 
op
, 
params
...) \

426 
	`__inline_mathop_decl_
 (double, 
func
, 
op
, 
params
) \

427 
	`__inline_mathop_decl_
 (float, 
	`__CONCAT
(
func
,
f
), 
op
, 
params
) \

428 
	`__inline_mathop_decl_
 (long double, 
	`__CONCAT
(
func
,
l
), 
op
, 
params
)

	)

429 #define 
	#__inline_mathop_declNP
(
func
, 
op
, 
params
...) \

430 
	`__inline_mathop_declNP_
 (double, 
func
, 
op
, 
params
) \

431 
	`__inline_mathop_declNP_
 (float, 
	`__CONCAT
(
func
,
f
), 
op
, 
params
) \

432 
	`__inline_mathop_declNP_
 (long double, 
	`__CONCAT
(
func
,
l
), 
op
, 
params
)

	)

434 #define 
	#__inline_mathop_decl
(
func
, 
op
, 
params
...) \

435 
	`__inline_mathop_decl_
 (double, 
func
, 
op
, 
params
)

	)

436 #define 
	#__inline_mathop_declNP
(
func
, 
op
, 
params
...) \

437 
	`__inline_mathop_declNP_
 (double, 
func
, 
op
, 
params
)

	)

440 #define 
	#__inline_mathop_decl_
(
float_type
, 
func
, 
op
, 
params
...) \

441 
__MATH_INLINE
 
float_type
 
	`func
 (float_type) 
__THROW
; \

442 
	`__inline_mathop_declNP_
 (
float_type
, 
func
, 
op
, 
params
)

	)

444 #define 
	#__inline_mathop_declNP_
(
float_type
, 
func
, 
op
, 
params
...) \

445 
__MATH_INLINE
 
float_type
 
	`__NTH
 (
	`func
 (float_type 
__x
)) \

447 register 
float_type
 
__result
; \

448 
__asm
 
	`__volatile__
 (
op
 : "=t" (
__result
) : 
params
); \

449 return 
__result
; \

450 }

	)

453 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


454 #define 
	#__inline_mathcode
(
func
, 
arg
, 
code
) \

455 
	`__inline_mathcode_
 (double, 
func
, 
arg
, 
code
) \

456 
	`__inline_mathcode_
 (float, 
	`__CONCAT
(
func
,
f
), 
arg
, 
code
) \

457 
	`__inline_mathcode_
 (long double, 
	`__CONCAT
(
func
,
l
), 
arg
, 
code
)

	)

458 #define 
	#__inline_mathcodeNP
(
func
, 
arg
, 
code
) \

459 
	`__inline_mathcodeNP_
 (double, 
func
, 
arg
, 
code
) \

460 
	`__inline_mathcodeNP_
 (float, 
	`__CONCAT
(
func
,
f
), 
arg
, 
code
) \

461 
	`__inline_mathcodeNP_
 (long double, 
	`__CONCAT
(
func
,
l
), 
arg
, 
code
)

	)

462 #define 
	#__inline_mathcode2
(
func
, 
arg1
, 
arg2
, 
code
) \

463 
	`__inline_mathcode2_
 (double, 
func
, 
arg1
, 
arg2
, 
code
) \

464 
	`__inline_mathcode2_
 (float, 
	`__CONCAT
(
func
,
f
), 
arg1
, 
arg2
, 
code
) \

465 
	`__inline_mathcode2_
 (long double, 
	`__CONCAT
(
func
,
l
), 
arg1
, 
arg2
, 
code
)

	)

466 #define 
	#__inline_mathcodeNP2
(
func
, 
arg1
, 
arg2
, 
code
) \

467 
	`__inline_mathcodeNP2_
 (double, 
func
, 
arg1
, 
arg2
, 
code
) \

468 
	`__inline_mathcodeNP2_
 (float, 
	`__CONCAT
(
func
,
f
), 
arg1
, 
arg2
, 
code
) \

469 
	`__inline_mathcodeNP2_
 (long double, 
	`__CONCAT
(
func
,
l
), 
arg1
, 
arg2
, 
code
)

	)

470 #define 
	#__inline_mathcode3
(
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

471 
	`__inline_mathcode3_
 (double, 
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

472 
	`__inline_mathcode3_
 (float, 
	`__CONCAT
(
func
,
f
), 
arg1
, 
arg2
, 
arg3
, 
code
) \

473 
	`__inline_mathcode3_
 (long double, 
	`__CONCAT
(
func
,
l
), 
arg1
, 
arg2
, 
arg3
, 
code
)

	)

474 #define 
	#__inline_mathcodeNP3
(
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

475 
	`__inline_mathcodeNP3_
 (double, 
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

476 
	`__inline_mathcodeNP3_
 (float, 
	`__CONCAT
(
func
,
f
), 
arg1
, 
arg2
, 
arg3
, 
code
) \

477 
	`__inline_mathcodeNP3_
 (long double, 
	`__CONCAT
(
func
,
l
), 
arg1
, 
arg2
, 
arg3
, 
code
)

	)

479 #define 
	#__inline_mathcode
(
func
, 
arg
, 
code
) \

480 
	`__inline_mathcode_
 (double, 
func
, (
arg
), 
code
)

	)

481 #define 
	#__inline_mathcodeNP
(
func
, 
arg
, 
code
) \

482 
	`__inline_mathcodeNP_
 (double, 
func
, (
arg
), 
code
)

	)

483 #define 
	#__inline_mathcode2
(
func
, 
arg1
, 
arg2
, 
code
) \

484 
	`__inline_mathcode2_
 (double, 
func
, 
arg1
, 
arg2
, 
code
)

	)

485 #define 
	#__inline_mathcodeNP2
(
func
, 
arg1
, 
arg2
, 
code
) \

486 
	`__inline_mathcodeNP2_
 (double, 
func
, 
arg1
, 
arg2
, 
code
)

	)

487 #define 
	#__inline_mathcode3
(
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

488 
	`__inline_mathcode3_
 (double, 
func
, 
arg1
, 
arg2
, 
arg3
, 
code
)

	)

489 #define 
	#__inline_mathcodeNP3
(
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

490 
	`__inline_mathcodeNP3_
 (double, 
func
, 
arg1
, 
arg2
, 
arg3
, 
code
)

	)

493 #define 
	#__inline_mathcode_
(
float_type
, 
func
, 
arg
, 
code
) \

494 
__MATH_INLINE
 
float_type
 
	`func
 (float_type) 
__THROW
; \

495 
	`__inline_mathcodeNP_
(
float_type
, 
func
, 
arg
, 
code
)

	)

497 #define 
	#__inline_mathcodeNP_
(
float_type
, 
func
, 
arg
, 
code
) \

498 
__MATH_INLINE
 
float_type
 
	`__NTH
 (
	`func
 (float_type 
arg
)) \

500 
code
; \

501 }

	)

504 #define 
	#__inline_mathcode2_
(
float_type
, 
func
, 
arg1
, 
arg2
, 
code
) \

505 
__MATH_INLINE
 
float_type
 
	`func
 (float_type, float_type) 
__THROW
; \

506 
	`__inline_mathcodeNP2_
 (
float_type
, 
func
, 
arg1
, 
arg2
, 
code
)

	)

508 #define 
	#__inline_mathcodeNP2_
(
float_type
, 
func
, 
arg1
, 
arg2
, 
code
) \

509 
__MATH_INLINE
 
float_type
 
	`__NTH
 (
	`func
 (float_type 
arg1
, float_type 
arg2
)) \

511 
code
; \

512 }

	)

514 #define 
	#__inline_mathcode3_
(
float_type
, 
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

515 
__MATH_INLINE
 
float_type
 
	`func
 (float_type, float_type, float_type) 
__THROW
; \

516 
	`__inline_mathcodeNP3_
(
float_type
, 
func
, 
arg1
, 
arg2
, 
arg3
, 
code
)

	)

518 #define 
	#__inline_mathcodeNP3_
(
float_type
, 
func
, 
arg1
, 
arg2
, 
arg3
, 
code
) \

519 
__MATH_INLINE
 
float_type
 
	`__NTH
 (
	`func
 (float_type 
arg1
, float_type 
arg2
, \

520 
float_type
 
arg3
)) \

522 
code
; \

523 }

	)

527 #if !
defined
 
__NO_MATH_INLINES
 && defined 
__OPTIMIZE__


531 #ifdef 
__FAST_MATH__


532 #ifdef 
__USE_GNU


533 #define 
	#__sincos_code
 \

534 register long double 
__cosr
; \

535 register long double 
__sinr
; \

536 register unsigned int 
__swtmp
; \

537 
__asm
 
__volatile__
 \

552 : "=t" (
__cosr
), "=u" (
__sinr
), "=a" (
__swtmp
) : "0" (
__x
)); \

553 *
__sinx
 = 
__sinr
; \

554 *
__cosx
 = 
__cosr


	)

556 
__MATH_INLINE
 void

557 
__NTH
 (
	$__sincos
 (double 
__x
, double *
__sinx
, double *
__cosx
))

559 
__sincos_code
;

560 
	}
}

562 
__MATH_INLINE
 void

563 
__NTH
 (
	$__sincosf
 (float 
__x
, float *
__sinx
, float *
__cosx
))

565 
__sincos_code
;

566 
	}
}

568 
__MATH_INLINE
 void

569 
__NTH
 (
	$__sincosl
 (long double 
__x
, long double *
__sinx
, long double *
__cosx
))

571 
__sincos_code
;

572 
	}
}

579 #if 
__GNUC_PREREQ
 (3, 5)

580 #define 
	#__expm1_code
 \

581 register long double 
__temp
; \

582 
__temp
 = 
	`__builtin_expm1l
 (
__x
); \

583 return 
__temp
 ? __temp : 
__x


	)

585 #define 
	#__expm1_code
 \

586 register long double 
__value
; \

587 register long double 
__exponent
; \

588 register long double 
__temp
; \

589 
__asm
 
__volatile__
 \

598 : "=t" (
__value
), "=u" (
__exponent
) : "0" (
__x
)); \

599 
__asm
 
__volatile__
 \

601 : "=t" (
__temp
) : "0" (1.0), "u" (
__exponent
)); \

602 
__temp
 -= 1.0; \

603 
__temp
 += 
__value
; \

604 return 
__temp
 ? __temp : 
__x


	)

606 
	$__inline_mathcodeNP_
 (long double, 
__expm1l
, 
__x
, 
__expm1_code
)

608 #if 
	`__GNUC_PREREQ
 (3, 4)

609 
	`__inline_mathcodeNP_
 (long double, 
__expl
, 
__x
, return 
	$__builtin_expl
 (
__x
))

611 #define 
	#__exp_code
 \

612 register long double 
__value
; \

613 register long double 
__exponent
; \

614 
__asm
 
__volatile__
 \

622 : "=t" (
__value
), "=u" (
__exponent
) : "0" (
__x
)); \

623 
__value
 += 1.0; \

624 
__asm
 
__volatile__
 \

626 : "=t" (
__value
) : "0" (__value), "u" (
__exponent
)); \

627 return 
__value


	)

628 
	$__inline_mathcodeNP
 (
exp
, 
__x
, 
__exp_code
)

629 
	$__inline_mathcodeNP_
 (long double, 
__expl
, 
__x
, 
__exp_code
)

633 #if !
	`__GNUC_PREREQ
 (3, 5)

634 
	`__inline_mathcodeNP
 (
tan
, 
__x
, \

635 register long double 
__value
; \

636 register long double 
__value2
 
	`__attribute__
 ((
__unused__
)); \

637 
__asm
 
__volatile__
 \

639 : "=t" (
__value2
), "=u" (
__value
) : "0" (
__x
)); \

640 return 
__value
)

645 #if 
	`__GNUC_PREREQ
 (3, 4)

646 
	`__inline_mathcodeNP2_
 (long double, 
__atan2l
, 
__y
, 
__x
,

647 return 
	$__builtin_atan2l
 (
__y
, 
__x
))

649 #define 
	#__atan2_code
 \

650 register long double 
__value
; \

651 
__asm
 
__volatile__
 \

653 : "=t" (
__value
) : "0" (
__x
), "u" (
__y
) : "st(1)"); \

654 return 
__value


	)

655 #ifdef 
__FAST_MATH__


656 
	$__inline_mathcodeNP2
 (
atan2
, 
__y
, 
__x
, 
__atan2_code
)

658 
	$__inline_mathcodeNP2_
 (long double, 
__atan2l
, 
__y
, 
__x
, 
__atan2_code
)

662 #if 
defined
 
__FAST_MATH__
 && !
	`__GNUC_PREREQ
 (3, 5)

663 
	`__inline_mathcodeNP2
 (
fmod
, 
__x
, 
__y
, \

664 register long double 
__value
; \

665 
__asm
 
__volatile__
 \

670 : "=t" (
__value
) : "0" (
__x
), "u" (
__y
) : "ax", "cc"); \

671 return 
__value
)

675 #ifdef 
__FAST_MATH__


676 #if !
	`__GNUC_PREREQ
 (3,3)

677 
	`__inline_mathopNP
 (
sqrt
, "fsqrt")

678 
	`__inline_mathopNP_
 (long double, 
__sqrtl
, "fsqrt")

679 #define 
	#__libc_sqrtl
(
n
) 
	`__sqrtl
 (n)

	)

681 #define 
	#__libc_sqrtl
(
n
) 
	`__builtin_sqrtl
 (n)

	)

685 #if 
	`__GNUC_PREREQ
 (2, 8)

686 
	`__inline_mathcodeNP_
 (double, 
fabs
, 
__x
, return 
	$__builtin_fabs
 (
__x
))

687 #if 
defined
 
__USE_MISC
 || defined 
__USE_ISOC99


688 
	`__inline_mathcodeNP_
 (float, 
fabsf
, 
__x
, return 
	$__builtin_fabsf
 (
__x
))

689 
	`__inline_mathcodeNP_
 (long double, 
fabsl
, 
__x
, return 
	$__builtin_fabsl
 (
__x
))

691 
	`__inline_mathcodeNP_
 (long double, 
__fabsl
, 
__x
, return 
	$__builtin_fabsl
 (
__x
))

693 
	`__inline_mathop
 (
fabs
, "fabs")

694 
	`__inline_mathop_
 (long double, 
__fabsl
, "fabs")

697 #ifdef 
__FAST_MATH__


698 #if !
	`__GNUC_PREREQ
 (3, 4)

700 
	`__inline_mathopNP
 (
sin
, "fsin")

702 
	`__inline_mathopNP
 (
cos
, "fcos")

704 
	`__inline_mathop_declNP
 (
log
, "fldln2; fxch; fyl2x", "0" (
__x
) : "st(1)")

707 #if !
	`__GNUC_PREREQ
 (3, 5)

708 
	`__inline_mathop_declNP
 (
log10
, "fldlg2; fxch; fyl2x", "0" (
__x
) : "st(1)")

710 
	`__inline_mathcodeNP
 (
asin
, 
__x
, return 
	`__atan2l
 (__x, 
	`__libc_sqrtl
 (1.0 - __x * __x)))

711 
	`__inline_mathcodeNP
 (
acos
, 
__x
, return 
	`__atan2l
 (
	`__libc_sqrtl
 (1.0 - __x * __x), __x))

714 #if !
	`__GNUC_PREREQ
 (3, 4)

715 
	`__inline_mathop_declNP
 (
atan
, "fld1; fpatan", "0" (
__x
) : "st(1)")

719 
	`__inline_mathcode_
 (long double, 
__sgn1l
, 
__x
, \

720 
__extension__
 union { long double 
__xld
; unsigned int 
__xi
[3]; } 
__n
 = \

721 { 
__xld
: 
__x
 
	}
}; \

722 
	g__n
.
	g__xi
[2] = (
__n
.
__xi
[2] & 0x8000) | 0x3fff; \

723 
	g__n
.
	g__xi
[1] = 0x80000000; \

724 
	g__n
.
	g__xi
[0] = 0; \

725 return 
	g__n
.
	g__xld
)

728 #ifdef 
__FAST_MATH__


730 
__inline_mathcodeNP
 (
sinh
, 
__x
, \

731 register long double 
__exm1
 = 
__expm1l
 (
__fabsl
 (
__x
)); \

732 return 0.5 * (
__exm1
 / (__exm1 + 1.0) + __exm1) * 
	$__sgn1l
 (
__x
))

734 
	`__inline_mathcodeNP
 (
cosh
, 
__x
, \

735 register long double 
__ex
 = 
	`__expl
 (
__x
); \

736 return 0.5 * (
__ex
 + 1.0 / __ex))

738 
	`__inline_mathcodeNP
 (
tanh
, 
__x
, \

739 register long double 
__exm1
 = 
	`__expm1l
 (-
	`__fabsl
 (
__x
 + __x)); \

740 return 
__exm1
 / (__exm1 + 2.0) * 
	`__sgn1l
 (-
__x
))

743 
	`__inline_mathcodeNP
 (
floor
, 
__x
, \

744 register long double 
__value
; \

745 register int 
__ignore
; \

746 unsigned short int 
__cw
; \

747 unsigned short int 
__cwtmp
; \

748 
__asm
 
	`__volatile
 ("fnstcw %3\n\t" \

756 : "=t" (
__value
), "=&q" (
__ignore
), "=m" (
__cwtmp
), \

757 "=m" (
__cw
) \

758 : "0" (
__x
)); \

759 return 
__value
)

761 
	`__inline_mathcodeNP
 (
ceil
, 
__x
, \

762 register long double 
__value
; \

763 register int 
__ignore
; \

764 unsigned short int 
__cw
; \

765 unsigned short int 
__cwtmp
; \

766 
__asm
 
	`__volatile
 ("fnstcw %3\n\t" \

774 : "=t" (
__value
), "=&q" (
__ignore
), "=m" (
__cwtmp
), \

775 "=m" (
__cw
) \

776 : "0" (
__x
)); \

777 return 
__value
)

779 #ifdef 
__FAST_MATH__


780 #define 
	#__ldexp_code
 \

781 register long double 
__value
; \

782 
__asm
 
__volatile__
 \

784 : "=t" (
__value
) : "0" (
__x
), "u" ((long double) 
__y
)); \

785 return 
__value


	)

787 
__MATH_INLINE
 double

788 
	`__NTH
 (
	$ldexp
 (double 
__x
, int 
__y
))

790 
__ldexp_code
;

791 
	}
}

796 #if 
defined
 
__USE_ISOC99
 || defined 
__USE_MISC


798 #ifdef 
__FAST_MATH__


799 
	$__inline_mathcodeNP
 (
expm1
, 
__x
, 
__expm1_code
)

803 #define 
	#__M_SQRT2
 1.41421356237309504880L

	)

805 #if !
	`__GNUC_PREREQ
 (3, 5)

806 
	`__inline_mathcodeNP
 (
log1p
, 
__x
, \

807 register long double 
__value
; \

808 if (
	`__fabsl
 (
__x
) >= 1.0 - 0.5 * 
__M_SQRT2
) \

809 
__value
 = 
	`logl
 (1.0 + 
__x
); \

811 
__asm
 
__volatile__
 \

815 : "=t" (
__value
) : "0" (
__x
) : "st(1)"); \

816 return 
__value
)

821 
	`__inline_mathcodeNP
 (
asinh
, 
__x
, \

822 register long double 
__y
 = 
	`__fabsl
 (
__x
); \

823 return (
	`log1pl
 (
__y
 * __y / (
	`__libc_sqrtl
 (__y * __y + 1.0) + 1.0) + __y) \

824 * 
	$__sgn1l
 (
__x
)))

826 
	`__inline_mathcodeNP
 (
acosh
, 
__x
, \

827 return 
	`logl
 (
__x
 + 
	`__libc_sqrtl
 (__x - 1.0) * __libc_sqrtl (__x + 1.0)))

829 
	`__inline_mathcodeNP
 (
atanh
, 
__x
, \

830 register long double 
__y
 = 
	`__fabsl
 (
__x
); \

831 return -0.5 * 
	`log1pl
 (-(
__y
 + __y) / (1.0 + __y)) * 
	$__sgn1l
 (
__x
))

834 
	`__inline_mathcodeNP2
 (
hypot
, 
__x
, 
__y
,

835 return 
	`__libc_sqrtl
 (
__x
 * __x + 
__y
 * __y))

837 #if !
	`__GNUC_PREREQ
 (3, 5)

838 
	`__inline_mathcodeNP
(
logb
, 
__x
, \

839 register long double 
__value
; \

840 register long double 
__junk
; \

841 
__asm
 
__volatile__
 \

843 : "=t" (
__junk
), "=u" (
__value
) : "0" (
__x
)); \

844 return 
__value
)

850 #ifdef 
__USE_ISOC99


851 #ifdef 
__FAST_MATH__


853 #if !
	`__GNUC_PREREQ
 (3, 5)

854 
	`__inline_mathop_declNP
 (
log2
, "fld1; fxch; fyl2x", "0" (
__x
) : "st(1)")

857 
__MATH_INLINE
 float

858 
	`__NTH
 (
	$ldexpf
 (float 
__x
, int 
__y
))

860 
__ldexp_code
;

861 
	}
}

863 
__MATH_INLINE
 long double

864 
__NTH
 (
	$ldexpl
 (long double 
__x
, int 
__y
))

866 
__ldexp_code
;

867 
	}
}

869 
__inline_mathopNP
 (
rint
, "frndint")

872 #define 
	#__lrint_code
 \

873 long int 
__lrintres
; \

874 
__asm__
 
__volatile__
 \

876 : "=m" (
__lrintres
) : "t" (
__x
) : "st"); \

877 return 
__lrintres


	)

878 
__MATH_INLINE
 long int

879 
__NTH
 (
	$lrintf
 (float 
__x
))

881 
__lrint_code
;

882 
	}
}

883 
__MATH_INLINE
 long int

884 
__NTH
 (
	$lrint
 (double 
__x
))

886 
__lrint_code
;

887 
	}
}

888 
__MATH_INLINE
 long int

889 
__NTH
 (
	$lrintl
 (long double 
__x
))

891 
__lrint_code
;

892 
	}
}

893 #undef 
__lrint_code


895 #define 
	#__llrint_code
 \

896 long long int 
__llrintres
; \

897 
__asm__
 
__volatile__
 \

899 : "=m" (
__llrintres
) : "t" (
__x
) : "st"); \

900 return 
__llrintres


	)

901 
__extension__


902 
__MATH_INLINE
 long long int

903 
__NTH
 (
	$llrintf
 (float 
__x
))

905 
__llrint_code
;

906 
	}
}

907 
__extension__


908 
__MATH_INLINE
 long long int

909 
__NTH
 (
	$llrint
 (double 
__x
))

911 
__llrint_code
;

912 
	}
}

913 
__extension__


914 
__MATH_INLINE
 long long int

915 
__NTH
 (
	$llrintl
 (long double 
__x
))

917 
__llrint_code
;

918 
	}
}

919 #undef 
__llrint_code


924 #ifdef 
__USE_MISC


926 #if 
defined
 
__FAST_MATH__
 && !
__GNUC_PREREQ
 (3, 5)

927 
__inline_mathcodeNP2
 (
drem
, 
__x
, 
__y
, \

928 register double 
__value
; \

929 register int 
__clobbered
; \

930 
__asm
 
__volatile__
 \

935 : "=t" (
__value
), "=&a" (
__clobbered
) : "0" (
__x
), "u" (
__y
) : "cc"); \

936 return 
__value
)

941 
__MATH_INLINE
 int

942 
__NTH
 (
	$__finite
 (double 
__x
))

944 return (
__extension__


945 (((((union { double 
__d
; int 
__i
[2]; }) {__d: 
__x
}).__i[1]

947 
	}
}

952 #undef 
__atan2_code


953 #ifdef 
__FAST_MATH__


954 #undef 
__expm1_code


955 #undef 
__exp_code


956 #undef 
__sincos_code


963 #ifdef 
__LIBC_INTERNAL_MATH_INLINES


964 
__inline_mathop
 (
__ieee754_sqrt
, "fsqrt")

965 
__inline_mathcode2
 (
__ieee754_atan2
, 
__y
, 
__x
,

966 register long double 
__value
;

967 
__asm
 
__volatile__
 ("fpatan\n\t"

968 : "=t" (
__value
)

969 : "0" (
__x
), "u" (
__y
) : "st(1)");

970 return 
__value
;)

	@/usr/include/bits/nan.h

19 #ifndef 
_MATH_H


26 #if 
__GNUC_PREREQ
(3,3)

28 #define 
	#NAN
 (
	`__builtin_nanf
 (""))

	)

30 #elif 
defined
 
__GNUC__


32 #define 
	#NAN
 \

33 (
__extension__
 \

34 ((union { unsigned 
__l
 
	`__attribute__
 ((
	`__mode__
 (
__SI__
))); float 
__d
; }) \

35 { 
__l
: 0x7fc00000UL }).
__d
)

	)

39 #include 
	~<endian.h
>

41 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


42 #define 
	#__qnan_bytes
 { 0x7f, 0xc0, 0, 0 }

	)

44 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


45 #define 
	#__qnan_bytes
 { 0, 0, 0xc0, 0x7f }

	)

48 static union { unsigned char 
	m__c
[4]; float 
	m__d
; } 
__qnan_union


49 
__attribute__
 ((
__unused__
)) = { 
__qnan_bytes
 };

50 #define 
	#NAN
 (
__qnan_union
.
__d
)

	)

	@/usr/include/bits/stdio-ldbl.h

19 #ifndef 
_STDIO_H


23 
__BEGIN_NAMESPACE_STD


24 
	$__LDBL_REDIR_DECL
 (
fprintf
)

25 
	$__LDBL_REDIR_DECL
 (
printf
)

26 
	$__LDBL_REDIR_DECL
 (
sprintf
)

27 
	$__LDBL_REDIR_DECL
 (
vfprintf
)

28 
	$__LDBL_REDIR_DECL
 (
vprintf
)

29 
	$__LDBL_REDIR_DECL
 (
vsprintf
)

30 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

31 && !
defined
 
__REDIRECT
 \

32 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

33 
	$__LDBL_REDIR1_DECL
 (
fscanf
, 
__nldbl___isoc99_fscanf
)

34 
	$__LDBL_REDIR1_DECL
 (
scanf
, 
__nldbl___isoc99_scanf
)

35 
	$__LDBL_REDIR1_DECL
 (
sscanf
, 
__nldbl___isoc99_sscanf
)

37 
	$__LDBL_REDIR_DECL
 (
fscanf
)

38 
	$__LDBL_REDIR_DECL
 (
scanf
)

39 
	$__LDBL_REDIR_DECL
 (
sscanf
)

41 
__END_NAMESPACE_STD


43 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


44 
__BEGIN_NAMESPACE_C99


45 
	$__LDBL_REDIR_DECL
 (
snprintf
)

46 
	$__LDBL_REDIR_DECL
 (
vsnprintf
)

47 
__END_NAMESPACE_C99


50 #ifdef 
__USE_ISOC99


51 
__BEGIN_NAMESPACE_C99


52 #if !
defined
 
__USE_GNU
 && !defined 
__REDIRECT
 \

53 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

54 
	$__LDBL_REDIR1_DECL
 (
vfscanf
, 
__nldbl___isoc99_vfscanf
)

55 
	$__LDBL_REDIR1_DECL
 (
vscanf
, 
__nldbl___isoc99_vscanf
)

56 
	$__LDBL_REDIR1_DECL
 (
vsscanf
, 
__nldbl___isoc99_vsscanf
)

58 
	$__LDBL_REDIR_DECL
 (
vfscanf
)

59 
	$__LDBL_REDIR_DECL
 (
vsscanf
)

60 
	$__LDBL_REDIR_DECL
 (
vscanf
)

62 
__END_NAMESPACE_C99


65 #ifdef 
__USE_XOPEN2K8


66 
	$__LDBL_REDIR_DECL
 (
vdprintf
)

67 
	$__LDBL_REDIR_DECL
 (
dprintf
)

70 #ifdef 
__USE_GNU


71 
	$__LDBL_REDIR_DECL
 (
vasprintf
)

72 
	$__LDBL_REDIR_DECL
 (
__asprintf
)

73 
	$__LDBL_REDIR_DECL
 (
asprintf
)

74 
	$__LDBL_REDIR_DECL
 (
obstack_printf
)

75 
	$__LDBL_REDIR_DECL
 (
obstack_vprintf
)

78 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


79 
	$__LDBL_REDIR_DECL
 (
__sprintf_chk
)

80 
	$__LDBL_REDIR_DECL
 (
__vsprintf_chk
)

81 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


82 
	$__LDBL_REDIR_DECL
 (
__snprintf_chk
)

83 
	$__LDBL_REDIR_DECL
 (
__vsnprintf_chk
)

85 #if 
__USE_FORTIFY_LEVEL
 > 1

86 
	$__LDBL_REDIR_DECL
 (
__fprintf_chk
)

87 
	$__LDBL_REDIR_DECL
 (
__printf_chk
)

88 
	$__LDBL_REDIR_DECL
 (
__vfprintf_chk
)

89 
	$__LDBL_REDIR_DECL
 (
__vprintf_chk
)

90 #ifdef 
__USE_XOPEN2K8


91 
	$__LDBL_REDIR_DECL
 (
__dprintf_chk
)

92 
	$__LDBL_REDIR_DECL
 (
__vdprintf_chk
)

94 #ifdef 
__USE_GNU


95 
	$__LDBL_REDIR_DECL
 (
__asprintf_chk
)

96 
	$__LDBL_REDIR_DECL
 (
__vasprintf_chk
)

97 
	$__LDBL_REDIR_DECL
 (
__obstack_printf_chk
)

98 
	$__LDBL_REDIR_DECL
 (
__obstack_vprintf_chk
)

	@/usr/include/bits/stdio.h

19 #ifndef 
_STDIO_H


23 #ifndef 
__extern_inline


24 #define 
	#__STDIO_INLINE
 
inline


	)

26 #define 
	#__STDIO_INLINE
 
__extern_inline


	)

30 #ifdef 
__USE_EXTERN_INLINES


33 #if !(
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function
)

35 
__STDIO_INLINE
 int

36 
	$vprintf
 (const char *
__restrict
 
__fmt
, 
_G_va_list
 
__arg
)

38 return 
	`vfprintf
 (
stdout
, 
__fmt
, 
__arg
);

39 
	}
}

43 
__STDIO_INLINE
 int

44 
	$getchar
 (void)

46 return 
	`_IO_getc
 (
stdin
);

47 
	}
}

50 #ifdef 
__USE_MISC


52 
__STDIO_INLINE
 int

53 
	$fgetc_unlocked
 (
FILE
 *
__fp
)

55 return 
	`_IO_getc_unlocked
 (
__fp
);

56 
	}
}

60 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


62 
__STDIO_INLINE
 int

63 
	$getc_unlocked
 (
FILE
 *
__fp
)

65 return 
	`_IO_getc_unlocked
 (
__fp
);

66 
	}
}

69 
__STDIO_INLINE
 int

70 
	$getchar_unlocked
 (void)

72 return 
	`_IO_getc_unlocked
 (
stdin
);

73 
	}
}

78 
__STDIO_INLINE
 int

79 
	$putchar
 (int 
__c
)

81 return 
	`_IO_putc
 (
__c
, 
stdout
);

82 
	}
}

85 #ifdef 
__USE_MISC


87 
__STDIO_INLINE
 int

88 
	$fputc_unlocked
 (int 
__c
, 
FILE
 *
__stream
)

90 return 
	`_IO_putc_unlocked
 (
__c
, 
__stream
);

91 
	}
}

95 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


97 
__STDIO_INLINE
 int

98 
	$putc_unlocked
 (int 
__c
, 
FILE
 *
__stream
)

100 return 
	`_IO_putc_unlocked
 (
__c
, 
__stream
);

101 
	}
}

104 
__STDIO_INLINE
 int

105 
	$putchar_unlocked
 (int 
__c
)

107 return 
	`_IO_putc_unlocked
 (
__c
, 
stdout
);

108 
	}
}

112 #ifdef 
__USE_GNU


114 
__STDIO_INLINE
 
_IO_ssize_t


115 
	$getline
 (char **
__lineptr
, 
size_t
 *
__n
, 
FILE
 *
__stream
)

117 return 
	`__getdelim
 (
__lineptr
, 
__n
, '\n', 
__stream
);

118 
	}
}

122 #ifdef 
__USE_MISC


124 
__STDIO_INLINE
 int

125 
__NTH
 (
	$feof_unlocked
 (
FILE
 *
__stream
))

127 return 
	`_IO_feof_unlocked
 (
__stream
);

128 
	}
}

131 
__STDIO_INLINE
 int

132 
__NTH
 (
	$ferror_unlocked
 (
FILE
 *
__stream
))

134 return 
	`_IO_ferror_unlocked
 (
__stream
);

135 
	}
}

141 #if 
defined
 
__USE_MISC
 && defined 
__GNUC__
 && defined 
__OPTIMIZE__
 \

142 && !
defined
 
	g__cplusplus


144 #define 
	#fread_unlocked
(
ptr
, 
size
, 
n
, 
stream
) \

145 (
	`__extension__
 ((
	`__builtin_constant_p
 (
size
) && __builtin_constant_p (
n
) \

146 && (
size_t
) (
size
) * (size_t) (
n
) <= 8 \

147 && (
size_t
) (
size
) != 0) \

148 ? ({ char *
__ptr
 = (char *) (
ptr
); \

149 
FILE
 *
__stream
 = (
stream
); \

150 
size_t
 
__cnt
; \

151 for (
__cnt
 = (
size_t
) (
size
) * (size_t) (
n
); \

152 
__cnt
 > 0; --__cnt) \

154 int 
__c
 = 
	`_IO_getc_unlocked
 (
__stream
); \

155 if (
__c
 == 
EOF
) \

157 *
__ptr
++ = 
__c
; \

159 ((
size_t
) (
size
) * (size_t) (
n
) - 
__cnt
) \

160 / (
size_t
) (
size
); }) \

161 : (((
	`__builtin_constant_p
 (
size
) && (
size_t
) (size) == 0) \

162 || (
	`__builtin_constant_p
 (
n
) && (
size_t
) (n) == 0)) \

164 ? ((void) (
ptr
), (void) (
stream
), (void) (
size
), \

165 (void) (
n
), (
size_t
) 0) \

166 : 
	`fread_unlocked
 (
ptr
, 
size
, 
n
, 
stream
))))

	)

168 #define 
	#fwrite_unlocked
(
ptr
, 
size
, 
n
, 
stream
) \

169 (
	`__extension__
 ((
	`__builtin_constant_p
 (
size
) && __builtin_constant_p (
n
) \

170 && (
size_t
) (
size
) * (size_t) (
n
) <= 8 \

171 && (
size_t
) (
size
) != 0) \

172 ? ({ const char *
__ptr
 = (const char *) (
ptr
); \

173 
FILE
 *
__stream
 = (
stream
); \

174 
size_t
 
__cnt
; \

175 for (
__cnt
 = (
size_t
) (
size
) * (size_t) (
n
); \

176 
__cnt
 > 0; --__cnt) \

177 if (
	`_IO_putc_unlocked
 (*
__ptr
++, 
__stream
) == 
EOF
) \

179 ((
size_t
) (
size
) * (size_t) (
n
) - 
__cnt
) \

180 / (
size_t
) (
size
); }) \

181 : (((
	`__builtin_constant_p
 (
size
) && (
size_t
) (size) == 0) \

182 || (
	`__builtin_constant_p
 (
n
) && (
size_t
) (n) == 0)) \

184 ? ((void) (
ptr
), (void) (
stream
), (void) (
size
), \

185 (void) (
n
), (
size_t
) 0) \

186 : 
	`fwrite_unlocked
 (
ptr
, 
size
, 
n
, 
stream
))))

	)

190 #undef 
__STDIO_INLINE


	@/usr/include/bits/stdio2.h

19 #ifndef 
_STDIO_H


23 extern int 
	$__sprintf_chk
 (char *
__restrict
 
__s
, int 
__flag
, 
size_t
 
__slen
,

24 const char *
__restrict
 
__format
, ...) 
__THROW
;

25 extern int 
	$__vsprintf_chk
 (char *
__restrict
 
__s
, int 
__flag
, 
size_t
 
__slen
,

26 const char *
__restrict
 
__format
,

27 
_G_va_list
 
__ap
) 
__THROW
;

29 #ifdef 
__va_arg_pack


30 
__fortify_function
 int

31 
	`__NTH
 (
	$sprintf
 (char *
__restrict
 
__s
, const char *__restrict 
__fmt
, ...))

33 return 
	`__builtin___sprintf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

34 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_arg_pack
 ());

35 
	}
}

36 #elif !
defined
 
__cplusplus


37 #define 
	#sprintf
(
str
, ...) \

38 
	`__builtin___sprintf_chk
 (
str
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

39 
__VA_ARGS__
)

	)

42 
__fortify_function
 int

43 
__NTH
 (
	$vsprintf
 (char *
__restrict
 
__s
, const char *__restrict 
__fmt
,

44 
_G_va_list
 
__ap
))

46 return 
	`__builtin___vsprintf_chk
 (
__s
, 
__USE_FORTIFY_LEVEL
 - 1,

47 
	`__bos
 (
__s
), 
__fmt
, 
__ap
);

48 
	}
}

50 #if 
defined
 
__USE_BSD
 || defined 
__USE_ISOC99
 || defined 
__USE_UNIX98


52 extern int 
	$__snprintf_chk
 (char *
__restrict
 
__s
, 
size_t
 
__n
, int 
__flag
,

53 
size_t
 
__slen
, const char *
__restrict
 
__format
,

54 ...) 
__THROW
;

55 extern int 
	$__vsnprintf_chk
 (char *
__restrict
 
__s
, 
size_t
 
__n
, int 
__flag
,

56 
size_t
 
__slen
, const char *
__restrict
 
__format
,

57 
_G_va_list
 
__ap
) 
__THROW
;

59 #ifdef 
__va_arg_pack


60 
__fortify_function
 int

61 
	`__NTH
 (
	$snprintf
 (char *
__restrict
 
__s
, 
size_t
 
__n
,

62 const char *
__restrict
 
__fmt
, ...))

64 return 
	`__builtin___snprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

65 
	`__bos
 (
__s
), 
__fmt
, 
	`__va_arg_pack
 ());

66 
	}
}

67 #elif !
defined
 
__cplusplus


68 #define 
	#snprintf
(
str
, 
len
, ...) \

69 
	`__builtin___snprintf_chk
 (
str
, 
len
, 
__USE_FORTIFY_LEVEL
 - 1, 
	`__bos
 (str), \

70 
__VA_ARGS__
)

	)

73 
__fortify_function
 int

74 
__NTH
 (
	$vsnprintf
 (char *
__restrict
 
__s
, 
size_t
 
__n
,

75 const char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
))

77 return 
	`__builtin___vsnprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

78 
	`__bos
 (
__s
), 
__fmt
, 
__ap
);

79 
	}
}

83 #if 
__USE_FORTIFY_LEVEL
 > 1

85 extern int 
__fprintf_chk
 (
FILE
 *
__restrict
 
__stream
, int 
__flag
,

86 const char *
__restrict
 
__format
, ...);

87 extern int 
__printf_chk
 (int 
__flag
, const char *
__restrict
 
__format
, ...);

88 extern int 
__vfprintf_chk
 (
FILE
 *
__restrict
 
__stream
, int 
__flag
,

89 const char *
__restrict
 
__format
, 
_G_va_list
 
__ap
);

90 extern int 
__vprintf_chk
 (int 
__flag
, const char *
__restrict
 
__format
,

91 
_G_va_list
 
__ap
);

93 #ifdef 
__va_arg_pack


94 
__fortify_function
 int

95 
	$fprintf
 (
FILE
 *
__restrict
 
__stream
, const char *__restrict 
__fmt
, ...)

97 return 
	`__fprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

98 
	`__va_arg_pack
 ());

99 
	}
}

101 
__fortify_function
 int

102 
	$printf
 (const char *
__restrict
 
__fmt
, ...)

104 return 
	`__printf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_arg_pack
 ());

105 
	}
}

106 #elif !
defined
 
__cplusplus


107 #define 
	#printf
(...) \

108 
	`__printf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

109 #define 
	#fprintf
(
stream
, ...) \

110 
	`__fprintf_chk
 (
stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

113 
__fortify_function
 int

114 
	$vprintf
 (const char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
)

116 #ifdef 
__USE_EXTERN_INLINES


117 return 
	`__vfprintf_chk
 (
stdout
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

119 return 
	`__vprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

121 
	}
}

123 
__fortify_function
 int

124 
	$vfprintf
 (
FILE
 *
__restrict
 
__stream
,

125 const char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
)

127 return 
	`__vfprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

128 
	}
}

130 #ifdef 
__USE_XOPEN2K8


131 extern int 
	$__dprintf_chk
 (int 
__fd
, int 
__flag
, const char *
__restrict
 
__fmt
,

132 ...) 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

133 extern int 
	$__vdprintf_chk
 (int 
__fd
, int 
__flag
,

134 const char *
__restrict
 
__fmt
, 
_G_va_list
 
__arg
)

135 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

137 #ifdef 
__va_arg_pack


138 
__fortify_function
 int

139 
	$dprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
, ...)

141 return 
	`__dprintf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

142 
	`__va_arg_pack
 ());

143 
	}
}

144 #elif !
defined
 
__cplusplus


145 #define 
	#dprintf
(
fd
, ...) \

146 
	`__dprintf_chk
 (
fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

149 
__fortify_function
 int

150 
	$vdprintf
 (int 
__fd
, const char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
)

152 return 
	`__vdprintf_chk
 (
__fd
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

153 
	}
}

156 #ifdef 
__USE_GNU


158 extern int 
	$__asprintf_chk
 (char **
__restrict
 
__ptr
, int 
__flag
,

159 const char *
__restrict
 
__fmt
, ...)

160 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 3, 4))) 
__wur
;

161 extern int 
	$__vasprintf_chk
 (char **
__restrict
 
__ptr
, int 
__flag
,

162 const char *
__restrict
 
__fmt
, 
_G_va_list
 
__arg
)

163 
__THROW
 
	`__attribute__
 ((
	$__format__
 (
__printf__
, 3, 0))) 
__wur
;

164 extern int 
	$__obstack_printf_chk
 (struct 
obstack
 *
__restrict
 
__obstack
,

165 int 
__flag
, const char *
__restrict
 
__format
,

167 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 4)));

168 extern int 
	$__obstack_vprintf_chk
 (struct 
obstack
 *
__restrict
 
__obstack
,

169 int 
__flag
,

170 const char *
__restrict
 
__format
,

171 
_G_va_list
 
__args
)

172 
__THROW
 
	`__attribute__
 ((
	`__format__
 (
__printf__
, 3, 0)));

174 #ifdef 
__va_arg_pack


175 
__fortify_function
 int

176 
	`__NTH
 (
	$asprintf
 (char **
__restrict
 
__ptr
, const char *__restrict 
__fmt
, ...))

178 return 
	`__asprintf_chk
 (
__ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

179 
	`__va_arg_pack
 ());

180 
	}
}

182 
__fortify_function
 int

183 
__NTH
 (
	$__asprintf
 (char **
__restrict
 
__ptr
, const char *__restrict 
__fmt
,

186 return 
	`__asprintf_chk
 (
__ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

187 
	`__va_arg_pack
 ());

188 
	}
}

190 
__fortify_function
 int

191 
__NTH
 (
	$obstack_printf
 (struct 
obstack
 *
__restrict
 
__obstack
,

192 const char *
__restrict
 
__fmt
, ...))

194 return 
	`__obstack_printf_chk
 (
__obstack
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

195 
	`__va_arg_pack
 ());

196 
	}
}

197 #elif !
defined
 
__cplusplus


198 #define 
	#asprintf
(
ptr
, ...) \

199 
	`__asprintf_chk
 (
ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

200 #define 
	#__asprintf
(
ptr
, ...) \

201 
	`__asprintf_chk
 (
ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

202 #define 
	#obstack_printf
(
obstack
, ...) \

203 
	`__obstack_printf_chk
 (
obstack
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

206 
__fortify_function
 int

207 
__NTH
 (
	$vasprintf
 (char **
__restrict
 
__ptr
, const char *__restrict 
__fmt
,

208 
_G_va_list
 
__ap
))

210 return 
	`__vasprintf_chk
 (
__ptr
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

211 
	}
}

213 
__fortify_function
 int

214 
__NTH
 (
	$obstack_vprintf
 (struct 
obstack
 *
__restrict
 
__obstack
,

215 const char *
__restrict
 
__fmt
, 
_G_va_list
 
__ap
))

217 return 
	`__obstack_vprintf_chk
 (
__obstack
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

218 
__ap
);

219 
	}
}

225 #if !
defined
 
__USE_ISOC11
 \

226 || (
defined
 
	g__cplusplus
 && __cplusplus <= 201103L && !defined 
__USE_GNU
)

227 extern char *
	$__gets_chk
 (char *
__str
, 
size_t
) 
__wur
;

228 extern char *
	`__REDIRECT
 (
__gets_warn
, (char *
__str
), 
gets
)

229 
__wur
 
	`__warnattr
 ("please use fgets or getline instead, gets can't "

232 
__fortify_function
 
__wur
 char *

233 
	$gets
 (char *
__str
)

235 if (
	`__bos
 (
__str
) != (
size_t
) -1)

236 return 
	`__gets_chk
 (
__str
, 
	`__bos
 (__str));

237 return 
	`__gets_warn
 (
__str
);

238 
	}
}

241 extern char *
	$__fgets_chk
 (char *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

242 
FILE
 *
__restrict
 
__stream
) 
__wur
;

243 extern char *
	`__REDIRECT
 (
__fgets_alias
,

244 (char *
__restrict
 
__s
, int 
__n
,

245 
FILE
 *
__restrict
 
__stream
), 
fgets
) 
__wur
;

246 extern char *
	`__REDIRECT
 (
__fgets_chk_warn
,

247 (char *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

248 
FILE
 *
__restrict
 
__stream
), 
__fgets_chk
)

249 
__wur
 
	`__warnattr
 ("fgets called with bigger size than length "

252 
__fortify_function
 
__wur
 char *

253 
	$fgets
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

255 if (
	`__bos
 (
__s
) != (
size_t
) -1)

257 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

258 return 
	`__fgets_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

260 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
))

261 return 
	`__fgets_chk_warn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

263 return 
	`__fgets_alias
 (
__s
, 
__n
, 
__stream
);

264 
	}
}

266 extern 
size_t
 
	$__fread_chk
 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

267 
size_t
 
__size
, size_t 
__n
,

268 
FILE
 *
__restrict
 
__stream
) 
__wur
;

269 extern 
size_t
 
	`__REDIRECT
 (
__fread_alias
,

270 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

271 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
),

272 
fread
) 
__wur
;

273 extern 
size_t
 
	`__REDIRECT
 (
__fread_chk_warn
,

274 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

275 
size_t
 
__size
, size_t 
__n
,

276 
FILE
 *
__restrict
 
__stream
),

277 
__fread_chk
)

278 
__wur
 
	`__warnattr
 ("fread called with bigger size * nmemb than length "

281 
__fortify_function
 
__wur
 
size_t


282 
	$fread
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
, size_t 
__n
,

283 
FILE
 *
__restrict
 
__stream
)

285 if (
	`__bos0
 (
__ptr
) != (
size_t
) -1)

287 if (!
	`__builtin_constant_p
 (
__size
)

288 || !
	`__builtin_constant_p
 (
__n
)

289 || (
__size
 | 
__n
) >= (((
size_t
) 1) << (8 * sizeof (size_t) / 2)))

290 return 
	`__fread_chk
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
, 
__stream
);

292 if (
__size
 * 
__n
 > 
	`__bos0
 (
__ptr
))

293 return 
	`__fread_chk_warn
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
, 
__stream
);

295 return 
	`__fread_alias
 (
__ptr
, 
__size
, 
__n
, 
__stream
);

296 
	}
}

298 #ifdef 
__USE_GNU


299 extern char *
	$__fgets_unlocked_chk
 (char *
__restrict
 
__s
, 
size_t
 
__size
,

300 int 
__n
, 
FILE
 *
__restrict
 
__stream
) 
__wur
;

301 extern char *
	`__REDIRECT
 (
__fgets_unlocked_alias
,

302 (char *
__restrict
 
__s
, int 
__n
,

303 
FILE
 *
__restrict
 
__stream
), 
fgets_unlocked
) 
__wur
;

304 extern char *
	`__REDIRECT
 (
__fgets_unlocked_chk_warn
,

305 (char *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

306 
FILE
 *
__restrict
 
__stream
), 
__fgets_unlocked_chk
)

307 
__wur
 
	`__warnattr
 ("fgets_unlocked called with bigger size than length "

310 
__fortify_function
 
__wur
 char *

311 
	$fgets_unlocked
 (char *
__restrict
 
__s
, int 
__n
, 
FILE
 *__restrict 
__stream
)

313 if (
	`__bos
 (
__s
) != (
size_t
) -1)

315 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

316 return 
	`__fgets_unlocked_chk
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

318 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
))

319 return 
	`__fgets_unlocked_chk_warn
 (
__s
, 
	`__bos
 (__s), 
__n
, 
__stream
);

321 return 
	`__fgets_unlocked_alias
 (
__s
, 
__n
, 
__stream
);

322 
	}
}

325 #ifdef 
__USE_MISC


326 #undef 
fread_unlocked


327 extern 
size_t
 
	$__fread_unlocked_chk
 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

328 
size_t
 
__size
, size_t 
__n
,

329 
FILE
 *
__restrict
 
__stream
) 
__wur
;

330 extern 
size_t
 
	`__REDIRECT
 (
__fread_unlocked_alias
,

331 (void *
__restrict
 
__ptr
, 
size_t
 
__size
,

332 
size_t
 
__n
, 
FILE
 *
__restrict
 
__stream
),

333 
fread_unlocked
) 
__wur
;

334 extern 
size_t
 
	`__REDIRECT
 (
__fread_unlocked_chk_warn
,

335 (void *
__restrict
 
__ptr
, 
size_t
 
__ptrlen
,

336 
size_t
 
__size
, size_t 
__n
,

337 
FILE
 *
__restrict
 
__stream
),

338 
__fread_unlocked_chk
)

339 
__wur
 
	`__warnattr
 ("fread_unlocked called with bigger size * nmemb than "

342 
__fortify_function
 
__wur
 
size_t


343 
	$fread_unlocked
 (void *
__restrict
 
__ptr
, 
size_t
 
__size
, size_t 
__n
,

344 
FILE
 *
__restrict
 
__stream
)

346 if (
	`__bos0
 (
__ptr
) != (
size_t
) -1)

348 if (!
	`__builtin_constant_p
 (
__size
)

349 || !
	`__builtin_constant_p
 (
__n
)

350 || (
__size
 | 
__n
) >= (((
size_t
) 1) << (8 * sizeof (size_t) / 2)))

351 return 
	`__fread_unlocked_chk
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
,

352 
__stream
);

354 if (
__size
 * 
__n
 > 
	`__bos0
 (
__ptr
))

355 return 
	`__fread_unlocked_chk_warn
 (
__ptr
, 
	`__bos0
 (__ptr), 
__size
, 
__n
,

356 
__stream
);

359 #ifdef 
__USE_EXTERN_INLINES


360 if (
	`__builtin_constant_p
 (
__size
)

361 && 
	`__builtin_constant_p
 (
__n
)

362 && (
__size
 | 
__n
) < (((
size_t
) 1) << (8 * sizeof (size_t) / 2))

363 && 
__size
 * 
__n
 <= 8)

365 
size_t
 
__cnt
 = 
__size
 * 
__n
;

366 char *
__cptr
 = (char *) 
__ptr
;

367 if (
__cnt
 == 0)

370 for (; 
__cnt
 > 0; --__cnt)

372 int 
__c
 = 
	`_IO_getc_unlocked
 (
__stream
);

373 if (
__c
 == 
EOF
)

375 *
__cptr
++ = 
__c
;

377 return (
__cptr
 - (char *) 
__ptr
) / 
__size
;

380 return 
	`__fread_unlocked_alias
 (
__ptr
, 
__size
, 
__n
, 
__stream
);

381 
	}
}

	@/usr/include/bits/stdio_lim.h

18 #if !
defined
 
_STDIO_H
 && !defined 
__need_FOPEN_MAX
 && !defined 
__need_IOV_MAX


22 #ifdef 
_STDIO_H


23 #define 
	#L_tmpnam
 20

	)

24 #define 
	#TMP_MAX
 238328

	)

25 #define 
	#FILENAME_MAX
 4096

	)

27 #ifdef 
__USE_POSIX


28 #define 
	#L_ctermid
 9

	)

29 #if !
defined
 
__USE_XOPEN2K
 || defined 
__USE_GNU


30 #define 
	#L_cuserid
 9

	)

35 #if 
defined
 
__need_FOPEN_MAX
 || defined 
_STDIO_H


36 #undef 
FOPEN_MAX


37 #define 
	#FOPEN_MAX
 16

	)

40 #if 
defined
 
__need_IOV_MAX
 && !defined 
IOV_MAX


41 #define 
	#IOV_MAX
 1024

	)

	@/usr/include/bits/stdlib-bsearch.h

19 
__extern_inline
 void *

20 
	$bsearch
 (const void *
__key
, const void *
__base
, 
size_t
 
__nmemb
, size_t 
__size
,

21 
__compar_fn_t
 
__compar
)

23 
size_t
 
__l
, 
__u
, 
__idx
;

24 const void *
__p
;

25 int 
__comparison
;

27 
__l
 = 0;

28 
__u
 = 
__nmemb
;

29 while (
__l
 < 
__u
)

31 
__idx
 = (
__l
 + 
__u
) / 2;

32 
__p
 = (void *) (((const char *) 
__base
) + (
__idx
 * 
__size
));

33 
__comparison
 = (*
__compar
) (
__key
, 
__p
);

34 if (
__comparison
 < 0)

35 
__u
 = 
__idx
;

36 else if (
__comparison
 > 0)

37 
__l
 = 
__idx
 + 1;

39 return (void *) 
__p
;

42 return 
NULL
;

43 
	}
}

	@/usr/include/bits/stdlib-float.h

19 #ifndef 
_STDLIB_H


23 #ifdef 
__USE_EXTERN_INLINES


24 
__BEGIN_NAMESPACE_STD


25 
__extern_inline
 double

26 
__NTH
 (
	$atof
 (const char *
__nptr
))

28 return 
	`strtod
 (
__nptr
, (char **) 
NULL
);

29 
	}
}

30 
	g__END_NAMESPACE_STD


	@/usr/include/bits/stdlib-ldbl.h

19 #ifndef 
_STDLIB_H


23 #ifdef 
__USE_ISOC99


24 
__BEGIN_NAMESPACE_C99


25 
	$__LDBL_REDIR1_DECL
 (
strtold
, 
strtod
)

26 
__END_NAMESPACE_C99


29 #ifdef 
__USE_GNU


30 
	$__LDBL_REDIR1_DECL
 (
strtold_l
, 
strtod_l
)

33 #ifdef 
__USE_MISC


34 
	$__LDBL_REDIR1_DECL
 (
qecvt
, 
ecvt
)

35 
	$__LDBL_REDIR1_DECL
 (
qfcvt
, 
fcvt
)

36 
	$__LDBL_REDIR1_DECL
 (
qgcvt
, 
gcvt
)

37 
	$__LDBL_REDIR1_DECL
 (
qecvt_r
, 
ecvt_r
)

38 
	$__LDBL_REDIR1_DECL
 (
qfcvt_r
, 
fcvt_r
)

	@/usr/include/bits/stdlib.h

19 #ifndef 
_STDLIB_H


23 extern char *
	$__realpath_chk
 (const char *
__restrict
 
__name
,

24 char *
__restrict
 
__resolved
,

25 
size_t
 
__resolvedlen
) 
__THROW
 
__wur
;

26 extern char *
	`__REDIRECT_NTH
 (
__realpath_alias
,

27 (const char *
__restrict
 
__name
,

28 char *
__restrict
 
__resolved
), 
realpath
) 
__wur
;

29 extern char *
	`__REDIRECT_NTH
 (
__realpath_chk_warn
,

30 (const char *
__restrict
 
__name
,

31 char *
__restrict
 
__resolved
,

32 
size_t
 
__resolvedlen
), 
__realpath_chk
) 
__wur


33 
	`__warnattr
 ("second argument of realpath must be either NULL or at "

36 
__fortify_function
 
__wur
 char *

37 
	`__NTH
 (
	$realpath
 (const char *
__restrict
 
__name
, char *__restrict 
__resolved
))

39 if (
	`__bos
 (
__resolved
) != (
size_t
) -1)

41 #if 
defined
 
_LIBC_LIMITS_H_
 && defined 
PATH_MAX


42 if (
	`__bos
 (
__resolved
) < 
PATH_MAX
)

43 return 
	`__realpath_chk_warn
 (
__name
, 
__resolved
, 
	`__bos
 (__resolved));

45 return 
	`__realpath_chk
 (
__name
, 
__resolved
, 
	`__bos
 (__resolved));

48 return 
	`__realpath_alias
 (
__name
, 
__resolved
);

49 
	}
}

52 extern int 
	$__ptsname_r_chk
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
,

53 
size_t
 
__nreal
) 
__THROW
 
	`__nonnull
 ((2));

54 extern int 
	`__REDIRECT_NTH
 (
__ptsname_r_alias
, (int 
__fd
, char *
__buf
,

55 
size_t
 
__buflen
), 
ptsname_r
)

56 
	`__nonnull
 ((2));

57 extern int 
	`__REDIRECT_NTH
 (
__ptsname_r_chk_warn
,

58 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
,

59 
size_t
 
__nreal
), 
__ptsname_r_chk
)

60 
	`__nonnull
 ((2)) 
	`__warnattr
 ("ptsname_r called with buflen bigger than "

63 
__fortify_function
 int

64 
	`__NTH
 (
	$ptsname_r
 (int 
__fd
, char *
__buf
, 
size_t
 
__buflen
))

66 if (
	`__bos
 (
__buf
) != (
size_t
) -1)

68 if (!
	`__builtin_constant_p
 (
__buflen
))

69 return 
	`__ptsname_r_chk
 (
__fd
, 
__buf
, 
__buflen
, 
	`__bos
 (__buf));

70 if (
__buflen
 > 
	`__bos
 (
__buf
))

71 return 
	`__ptsname_r_chk_warn
 (
__fd
, 
__buf
, 
__buflen
, 
	`__bos
 (__buf));

73 return 
	`__ptsname_r_alias
 (
__fd
, 
__buf
, 
__buflen
);

74 
	}
}

77 extern int 
	$__wctomb_chk
 (char *
__s
, 
wchar_t
 
__wchar
, 
size_t
 
__buflen
)

78 
__THROW
 
__wur
;

79 extern int 
	`__REDIRECT_NTH
 (
__wctomb_alias
, (char *
__s
, 
wchar_t
 
__wchar
),

80 
wctomb
) 
__wur
;

82 
__fortify_function
 
__wur
 int

83 
	`__NTH
 (
	$wctomb
 (char *
__s
, 
wchar_t
 
__wchar
))

88 #define 
	#__STDLIB_MB_LEN_MAX
 16

	)

89 #if 
defined
 
MB_LEN_MAX
 && MB_LEN_MAX != 
__STDLIB_MB_LEN_MAX


92 if (
	`__bos
 (
__s
) != (
size_t
) -1 && 
__STDLIB_MB_LEN_MAX
 > __bos (__s))

93 return 
	`__wctomb_chk
 (
__s
, 
__wchar
, 
	`__bos
 (__s));

94 return 
	`__wctomb_alias
 (
__s
, 
__wchar
);

95 
	}
}

98 extern 
size_t
 
	$__mbstowcs_chk
 (
wchar_t
 *
__restrict
 
__dst
,

99 const char *
__restrict
 
__src
,

100 
size_t
 
__len
, size_t 
__dstlen
) 
__THROW
;

101 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbstowcs_alias
,

102 (
wchar_t
 *
__restrict
 
__dst
,

103 const char *
__restrict
 
__src
,

104 
size_t
 
__len
), 
mbstowcs
);

105 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbstowcs_chk_warn
,

106 (
wchar_t
 *
__restrict
 
__dst
,

107 const char *
__restrict
 
__src
,

108 
size_t
 
__len
, size_t 
__dstlen
), 
__mbstowcs_chk
)

109 
	`__warnattr
 ("mbstowcs called with dst buffer smaller than len "

112 
__fortify_function
 
size_t


113 
	`__NTH
 (
	$mbstowcs
 (
wchar_t
 *
__restrict
 
__dst
, const char *__restrict 
__src
,

114 
size_t
 
__len
))

116 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

118 if (!
	`__builtin_constant_p
 (
__len
))

119 return 
	`__mbstowcs_chk
 (
__dst
, 
__src
, 
__len
,

120 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

122 if (
__len
 > 
	`__bos
 (
__dst
) / sizeof (
wchar_t
))

123 return 
	`__mbstowcs_chk_warn
 (
__dst
, 
__src
, 
__len
,

124 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

126 return 
	`__mbstowcs_alias
 (
__dst
, 
__src
, 
__len
);

127 
	}
}

130 extern 
size_t
 
	$__wcstombs_chk
 (char *
__restrict
 
__dst
,

131 const 
wchar_t
 *
__restrict
 
__src
,

132 
size_t
 
__len
, size_t 
__dstlen
) 
__THROW
;

133 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcstombs_alias
,

134 (char *
__restrict
 
__dst
,

135 const 
wchar_t
 *
__restrict
 
__src
,

136 
size_t
 
__len
), 
wcstombs
);

137 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcstombs_chk_warn
,

138 (char *
__restrict
 
__dst
,

139 const 
wchar_t
 *
__restrict
 
__src
,

140 
size_t
 
__len
, size_t 
__dstlen
), 
__wcstombs_chk
)

141 
	`__warnattr
 ("wcstombs called with dst buffer smaller than len");

143 
__fortify_function
 
size_t


144 
	`__NTH
 (
	$wcstombs
 (char *
__restrict
 
__dst
, const 
wchar_t
 *__restrict 
__src
,

145 
size_t
 
__len
))

147 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

149 if (!
	`__builtin_constant_p
 (
__len
))

150 return 
	`__wcstombs_chk
 (
__dst
, 
__src
, 
__len
, 
	`__bos
 (__dst));

151 if (
__len
 > 
	`__bos
 (
__dst
))

152 return 
	`__wcstombs_chk_warn
 (
__dst
, 
__src
, 
__len
, 
	`__bos
 (__dst));

154 return 
	`__wcstombs_alias
 (
__dst
, 
__src
, 
__len
);

155 
	}
}

	@/usr/include/bits/string.h

19 #ifndef 
_STRING_H


24 #define 
	#_STRING_ARCH_unaligned
 1

	)

28 #if !
defined
 
__x86_64__
 && (defined 
__i486__
 || defined 
__pentium__
 \

29 || 
defined
 
	g__pentiumpro__
 || defined 
	g__pentium4__
 \

30 || 
defined
 
	g__nocona__
 || defined 
	g__atom__
 \

31 || 
defined
 
	g__core2__
 || defined 
	g__corei7__
 \

32 || 
defined
 
	g__k6__
 || defined 
	g__geode__
 \

33 || 
defined
 
	g__k8__
 || defined 
	g__athlon__
 \

34 || 
defined
 
	g__amdfam10__
)

38 #if !
defined
 
__NO_STRING_INLINES
 && defined 
__USE_STRING_INLINES
 \

39 && 
defined
 
	g__GNUC__
 && __GNUC__ >= 2

41 #ifndef 
__STRING_INLINE


42 #ifndef 
__extern_inline


43 #define 
	#__STRING_INLINE
 
inline


	)

45 #define 
	#__STRING_INLINE
 
__extern_inline


	)

50 #define 
	#__STRING_SMALL_GET16
(
src
, 
idx
) \

51 ((((const unsigned char *) (
src
))[
idx
 + 1] << 8) \

52 | ((const unsigned char *) (
src
))[
idx
])

	)

53 #define 
	#__STRING_SMALL_GET32
(
src
, 
idx
) \

54 (((((const unsigned char *) (
src
))[
idx
 + 3] << 8 \

55 | ((const unsigned char *) (
src
))[
idx
 + 2]) << 8 \

56 | ((const unsigned char *) (
src
))[
idx
 + 1]) << 8 \

57 | ((const unsigned char *) (
src
))[
idx
])

	)

61 #define 
	#_HAVE_STRING_ARCH_memcpy
 1

	)

62 #define 
	#memcpy
(
dest
, 
src
, 
n
) \

63 (
	`__extension__
 (
	`__builtin_constant_p
 (
n
) \

64 ? 
	`__memcpy_c
 ((
dest
), (
src
), (
n
)) \

65 : 
	`__memcpy_g
 ((
dest
), (
src
), (
n
))))

	)

66 #define 
	#__memcpy_c
(
dest
, 
src
, 
n
) \

67 ((
n
) == 0 \

68 ? (
dest
) \

69 : (((
n
) % 4 == 0) \

70 ? 
	`__memcpy_by4
 (
dest
, 
src
, 
n
) \

71 : (((
n
) % 2 == 0) \

72 ? 
	`__memcpy_by2
 (
dest
, 
src
, 
n
) \

73 : 
	`__memcpy_g
 (
dest
, 
src
, 
n
))))

	)

75 
__STRING_INLINE
 void *
__memcpy_by4
 (void *
__dest
, const void *
__src
,

76 
size_t
 
__n
);

78 
__STRING_INLINE
 void *

79 
	$__memcpy_by4
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

81 register unsigned long int 
__d0
, 
__d1
;

82 register void *
__tmp
 = 
__dest
;

83 
__asm__
 
__volatile__


91 : "=&r" (
__d0
), "=&r" (
__tmp
), "=&r" (
__src
), "=&r" (
__d1
)

92 : "1" (
__tmp
), "2" (
__src
), "3" (
__n
 / 4)

94 return 
__dest
;

95 
	}
}

97 
__STRING_INLINE
 void *
__memcpy_by2
 (void *
__dest
, const void *
__src
,

98 
size_t
 
__n
);

100 
__STRING_INLINE
 void *

101 
	$__memcpy_by2
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

103 register unsigned long int 
__d0
, 
__d1
;

104 register void *
__tmp
 = 
__dest
;

105 
__asm__
 
__volatile__


118 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__src
), "=&r" (
__d1
)

119 : "1" (
__tmp
), "2" (
__src
), "3" (
__n
 / 2)

121 return 
__dest
;

122 
	}
}

124 
__STRING_INLINE
 void *
__memcpy_g
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
);

126 
__STRING_INLINE
 void *

127 
	$__memcpy_g
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

129 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

130 register void *
__tmp
 = 
__dest
;

131 
__asm__
 
__volatile__


142 : "=&c" (
__d0
), "=&D" (
__d1
), "=&S" (
__d2
),

143 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__dest
)

144 : "0" (
__n
), "1" (
__tmp
), "2" (
__src
),

145 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__src
)

147 return 
__dest
;

148 
	}
}

150 #define 
	#_HAVE_STRING_ARCH_memmove
 1

	)

151 #ifndef 
_FORCE_INLINES


154 #define 
	#memmove
(
dest
, 
src
, 
n
) 
	`__memmove_g
 (dest, src, n)

	)

156 
__STRING_INLINE
 void *
	$__memmove_g
 (void *, const void *, 
size_t
)

157 
	`__asm__
 ("memmove");

159 
__STRING_INLINE
 void *

160 
	$__memmove_g
 (void *
__dest
, const void *
__src
, 
size_t
 
__n
)

162 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

163 register void *
__tmp
 = 
__dest
;

164 if (
__dest
 < 
__src
)

165 
__asm__
 
__volatile__


168 : "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
),

169 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__dest
)

170 : "0" (
__n
), "1" (
__src
), "2" (
__tmp
),

171 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__src
));

173 
__asm__
 
__volatile__


177 : "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
),

178 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__dest
)

179 : "0" (
__n
), "1" (__n - 1 + (const char *) 
__src
),

180 "2" (
__n
 - 1 + (char *) 
__tmp
),

181 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__src
));

182 return 
__dest
;

183 
	}
}

187 #define 
	#_HAVE_STRING_ARCH_memcmp
 1

	)

188 #ifndef 
_FORCE_INLINES


189 #ifndef 
__PIC__


191 
__STRING_INLINE
 int

192 
	$memcmp
 (const void *
__s1
, const void *
__s2
, 
size_t
 
__n
)

194 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

195 register int 
__res
;

196 
__asm__
 
__volatile__


204 : "=&a" (
__res
), "=&S" (
__d0
), "=&D" (
__d1
), "=&c" (
__d2
)

205 : "0" (0), "1" (
__s1
), "2" (
__s2
), "3" (
__n
),

206 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s1
),

207 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s2
)

209 return 
__res
;

210 
	}
}

215 #define 
	#_HAVE_STRING_ARCH_memset
 1

	)

216 #define 
	#_USE_STRING_ARCH_memset
 1

	)

217 #define 
	#memset
(
s
, 
c
, 
n
) \

218 (
	`__extension__
 (
	`__builtin_constant_p
 (
n
) && (n) <= 16 \

219 ? ((
n
) == 1 \

220 ? 
	`__memset_c1
 ((
s
), (
c
)) \

221 : 
	`__memset_gc
 ((
s
), (
c
), (
n
))) \

222 : (
	`__builtin_constant_p
 (
c
) \

223 ? (
	`__builtin_constant_p
 (
n
) \

224 ? 
	`__memset_ccn
 ((
s
), (
c
), (
n
)) \

225 : 
	`memset
 ((
s
), (
c
), (
n
))) \

226 : (
	`__builtin_constant_p
 (
n
) \

227 ? 
	`__memset_gcn
 ((
s
), (
c
), (
n
)) \

228 : 
	`memset
 ((
s
), (
c
), (
n
))))))

	)

230 #define 
	#__memset_c1
(
s
, 
c
) ({ void *
__s
 = (s); \

231 *((unsigned char *) 
__s
) = (unsigned char) (
c
); \

232 
__s
; })

	)

234 #define 
	#__memset_gc
(
s
, 
c
, 
n
) \

235 ({ void *
__s
 = (
s
); \

237 unsigned int 
__ui
; \

238 unsigned short int 
__usi
; \

239 unsigned char 
__uc
; \

240 } *
__u
 = 
__s
; \

241 unsigned int 
__c
 = ((unsigned int) ((unsigned char) (
c
))) * 0x01010101; \

247 if ((
n
) == 3 || (n) >= 5) \

248 
__asm__
 
	`__volatile__
 ("" : "=r" (
__c
) : "0" (__c)); \

251 switch (
n
) \

254 
__u
->
__ui
 = 
__c
; \

255 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

257 
__u
->
__ui
 = 
__c
; \

258 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

260 
__u
->
__ui
 = 
__c
; \

261 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

263 
__u
->
__usi
 = (unsigned short int) 
__c
; \

264 
__u
 = 
	`__extension__
 ((void *) __u + 2); \

265 
__u
->
__uc
 = (unsigned char) 
__c
; \

269 
__u
->
__ui
 = 
__c
; \

270 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

272 
__u
->
__ui
 = 
__c
; \

273 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

275 
__u
->
__ui
 = 
__c
; \

276 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

278 
__u
->
__usi
 = (unsigned short int) 
__c
; \

282 
__u
->
__ui
 = 
__c
; \

283 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

285 
__u
->
__ui
 = 
__c
; \

286 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

288 
__u
->
__ui
 = 
__c
; \

289 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

291 
__u
->
__uc
 = (unsigned char) 
__c
; \

295 
__u
->
__ui
 = 
__c
; \

296 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

298 
__u
->
__ui
 = 
__c
; \

299 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

301 
__u
->
__ui
 = 
__c
; \

302 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

304 
__u
->
__ui
 = 
__c
; \

309 
__s
; })

	)

311 #define 
	#__memset_ccn
(
s
, 
c
, 
n
) \

312 (((
n
) % 4 == 0) \

313 ? 
	`__memset_ccn_by4
 (
s
, ((unsigned int) ((unsigned char) (
c
))) * 0x01010101,\

314 
n
) \

315 : (((
n
) % 2 == 0) \

316 ? 
	`__memset_ccn_by2
 (
s
, \

317 ((unsigned int) ((unsigned char) (
c
))) * 0x01010101,\

318 
n
) \

319 : 
	`memset
 (
s
, 
c
, 
n
)))

	)

321 
__STRING_INLINE
 void *
__memset_ccn_by4
 (void *
__s
, unsigned int 
__c
,

322 
size_t
 
__n
);

324 
__STRING_INLINE
 void *

325 
	$__memset_ccn_by4
 (void *
__s
, unsigned int 
__c
, 
size_t
 
__n
)

327 register void *
__tmp
 = 
__s
;

328 register unsigned long int 
__d0
;

329 #ifdef 
__i686__


330 
__asm__
 
__volatile__


333 : "=&a" (
__c
), "=&D" (
__tmp
), "=&c" (
__d0
),

334 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

335 : "0" ((unsigned int) 
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

338 
__asm__
 
__volatile__


344 : "=&r" (
__c
), "=&r" (
__tmp
), "=&r" (
__d0
),

345 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

346 : "0" ((unsigned int) 
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

349 return 
__s
;

350 
	}
}

352 
__STRING_INLINE
 void *
__memset_ccn_by2
 (void *
__s
, unsigned int 
__c
,

353 
size_t
 
__n
);

355 
__STRING_INLINE
 void *

356 
	$__memset_ccn_by2
 (void *
__s
, unsigned int 
__c
, 
size_t
 
__n
)

358 register unsigned long int 
__d0
, 
__d1
;

359 register void *
__tmp
 = 
__s
;

360 #ifdef 
__i686__


361 
__asm__
 
__volatile__


365 : "=&a" (
__d0
), "=&D" (
__tmp
), "=&c" (
__d1
),

366 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

367 : "0" ((unsigned int) 
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

370 
__asm__
 
__volatile__


376 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__d1
),

377 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

378 : "0" ((unsigned int) 
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

381 return 
__s
;

382 
	}
}

384 #define 
	#__memset_gcn
(
s
, 
c
, 
n
) \

385 (((
n
) % 4 == 0) \

386 ? 
	`__memset_gcn_by4
 (
s
, 
c
, 
n
) \

387 : (((
n
) % 2 == 0) \

388 ? 
	`__memset_gcn_by2
 (
s
, 
c
, 
n
) \

389 : 
	`memset
 (
s
, 
c
, 
n
)))

	)

391 
__STRING_INLINE
 void *
__memset_gcn_by4
 (void *
__s
, int 
__c
, 
size_t
 
__n
);

393 
__STRING_INLINE
 void *

394 
	$__memset_gcn_by4
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

396 register void *
__tmp
 = 
__s
;

397 register unsigned long int 
__d0
;

398 
__asm__
 
__volatile__


408 : "=&q" (
__c
), "=&r" (
__tmp
), "=&r" (
__d0
),

409 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

410 : "0" ((unsigned int) 
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

412 return 
__s
;

413 
	}
}

415 
__STRING_INLINE
 void *
__memset_gcn_by2
 (void *
__s
, int 
__c
, 
size_t
 
__n
);

417 
__STRING_INLINE
 void *

418 
	$__memset_gcn_by2
 (void *
__s
, int 
__c
, 
size_t
 
__n
)

420 register unsigned long int 
__d0
, 
__d1
;

421 register void *
__tmp
 = 
__s
;

422 
__asm__
 
__volatile__


433 : "=&q" (
__d0
), "=&r" (
__tmp
), "=&r" (
__d1
),

434 "=m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

435 : "0" ((unsigned int) 
__c
), "1" (
__tmp
), "2" (
__n
 / 4)

437 return 
__s
;

438 
	}
}

442 #define 
	#_HAVE_STRING_ARCH_memchr
 1

	)

443 #ifndef 
_FORCE_INLINES


444 
__STRING_INLINE
 void *

445 
	$memchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

447 register unsigned long int 
__d0
;

448 #ifdef 
__i686__


449 register unsigned long int 
__d1
;

451 register unsigned char *
__res
;

452 if (
__n
 == 0)

453 return 
NULL
;

454 #ifdef 
__i686__


455 
__asm__
 
__volatile__


459 : "=D" (
__res
), "=&c" (
__d0
), "=&r" (
__d1
)

460 : "a" (
__c
), "0" (
__s
), "1" (
__n
), "2" (1),

461 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

464 
__asm__
 
__volatile__


470 : "=D" (
__res
), "=&c" (
__d0
)

471 : "a" (
__c
), "0" (
__s
), "1" (
__n
),

472 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

475 return 
__res
 - 1;

476 
	}
}

479 #define 
	#_HAVE_STRING_ARCH_memrchr
 1

	)

480 #ifndef 
_FORCE_INLINES


481 
__STRING_INLINE
 void *
__memrchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
);

483 
__STRING_INLINE
 void *

484 
	$__memrchr
 (const void *
__s
, int 
__c
, 
size_t
 
__n
)

486 register unsigned long int 
__d0
;

487 #ifdef 
__i686__


488 register unsigned long int 
__d1
;

490 register void *
__res
;

491 if (
__n
 == 0)

492 return 
NULL
;

493 #ifdef 
__i686__


494 
__asm__
 
__volatile__


500 : "=D" (
__res
), "=&c" (
__d0
), "=&r" (
__d1
)

501 : "a" (
__c
), "0" (
__s
 + 
__n
 - 1), "1" (__n), "2" (-1),

502 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

505 
__asm__
 
__volatile__


512 : "=D" (
__res
), "=&c" (
__d0
)

513 : "a" (
__c
), "0" (
__s
 + 
__n
 - 1), "1" (__n),

514 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s
)

517 return 
__res
;

518 
	}
}

519 #ifdef 
__USE_GNU


520 #define 
	#memrchr
(
s
, 
c
, 
n
) 
	`__memrchr
 ((s), (c), (n))

	)

525 #define 
	#_HAVE_STRING_ARCH_rawmemchr
 1

	)

526 
__STRING_INLINE
 void *
__rawmemchr
 (const void *
__s
, int 
__c
);

528 #ifndef 
_FORCE_INLINES


529 
__STRING_INLINE
 void *

530 
	$__rawmemchr
 (const void *
__s
, int 
__c
)

532 register unsigned long int 
__d0
;

533 register unsigned char *
__res
;

534 
__asm__
 
__volatile__


537 : "=D" (
__res
), "=&c" (
__d0
)

538 : "a" (
__c
), "0" (
__s
), "1" (0xffffffff),

539 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

541 return 
__res
 - 1;

542 
	}
}

543 #ifdef 
__USE_GNU


544 
__STRING_INLINE
 void *

545 
	$rawmemchr
 (const void *
__s
, int 
__c
)

547 return 
	`__rawmemchr
 (
__s
, 
__c
);

548 
	}
}

554 #define 
	#_HAVE_STRING_ARCH_strlen
 1

	)

555 #define 
	#strlen
(
str
) \

556 (
	`__extension__
 (
	`__builtin_constant_p
 (
str
) \

557 ? 
	`__builtin_strlen
 (
str
) \

558 : 
	`__strlen_g
 (
str
)))

	)

559 
__STRING_INLINE
 
size_t
 
__strlen_g
 (const char *
__str
);

561 
__STRING_INLINE
 
size_t


562 
	$__strlen_g
 (const char *
__str
)

564 register char 
__dummy
;

565 register const char *
__tmp
 = 
__str
;

566 
__asm__
 
__volatile__


572 : "=r" (
__tmp
), "=&q" (
__dummy
)

573 : "0" (
__str
),

574 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__str
)

576 return 
__tmp
 - 
__str
 - 1;

577 
	}
}

581 #define 
	#_HAVE_STRING_ARCH_strcpy
 1

	)

582 #define 
	#strcpy
(
dest
, 
src
) \

583 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

584 ? (sizeof ((
src
)[0]) == 1 && 
	`strlen
 (src) + 1 <= 8 \

585 ? 
	`__strcpy_a_small
 ((
dest
), (
src
), 
	`strlen
 (src) + 1) \

586 : (char *) 
	`memcpy
 ((char *) (
dest
), \

587 (const char *) (
src
), \

588 
	`strlen
 (
src
) + 1)) \

589 : 
	`__strcpy_g
 ((
dest
), (
src
))))

	)

591 #define 
	#__strcpy_a_small
(
dest
, 
src
, 
srclen
) \

592 (
	`__extension__
 ({ char *
__dest
 = (
dest
); \

594 unsigned int 
__ui
; \

595 unsigned short int 
__usi
; \

596 unsigned char 
__uc
; \

597 char 
__c
; \

598 } *
__u
 = (void *) 
__dest
; \

599 switch (
srclen
) \

602 
__u
->
__uc
 = '\0'; \

605 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 0); \

608 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 0); \

609 
__u
 = 
	`__extension__
 ((void *) __u + 2); \

610 
__u
->
__uc
 = '\0'; \

613 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

616 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

617 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

618 
__u
->
__uc
 = '\0'; \

621 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

622 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

623 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 4); \

626 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

627 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

628 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 4); \

629 
__u
 = 
	`__extension__
 ((void *) __u + 2); \

630 
__u
->
__uc
 = '\0'; \

633 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

634 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

635 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 4); \

638 (char *) 
__dest
; }))

	)

640 
__STRING_INLINE
 char *
__strcpy_g
 (char *
__dest
, const char *
__src
);

642 
__STRING_INLINE
 char *

643 
	$__strcpy_g
 (char *
__dest
, const char *
__src
)

645 register char *
__tmp
 = 
__dest
;

646 register char 
__dummy
;

647 
__asm__
 
__volatile__


656 : "=&r" (
__src
), "=&r" (
__tmp
), "=&q" (
__dummy
),

657 "=m" ( *(struct { char 
__x
[0xfffffff]; } *)
__dest
)

658 : "0" (
__src
), "1" (
__tmp
),

659 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__src
)

661 return 
__dest
;

662 
	}
}

665 #ifdef 
__USE_GNU


666 #define 
	#_HAVE_STRING_ARCH_stpcpy
 1

	)

668 #define 
	#__stpcpy
(
dest
, 
src
) \

669 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

670 ? (
	`strlen
 (
src
) + 1 <= 8 \

671 ? 
	`__stpcpy_a_small
 ((
dest
), (
src
), 
	`strlen
 (src) + 1) \

672 : 
	`__stpcpy_c
 ((
dest
), (
src
), 
	`strlen
 (src) + 1)) \

673 : 
	`__stpcpy_g
 ((
dest
), (
src
))))

	)

674 #define 
	#__stpcpy_c
(
dest
, 
src
, 
srclen
) \

675 ((
srclen
) % 4 == 0 \

676 ? 
	`__mempcpy_by4
 (
dest
, 
src
, 
srclen
) - 1 \

677 : ((
srclen
) % 2 == 0 \

678 ? 
	`__mempcpy_by2
 (
dest
, 
src
, 
srclen
) - 1 \

679 : 
	`__mempcpy_byn
 (
dest
, 
src
, 
srclen
) - 1))

	)

682 #define 
	#stpcpy
(
dest
, 
src
) 
	`__stpcpy
 ((dest), (src))

	)

684 #define 
	#__stpcpy_a_small
(
dest
, 
src
, 
srclen
) \

685 (
	`__extension__
 ({ union { \

686 unsigned int 
__ui
; \

687 unsigned short int 
__usi
; \

688 unsigned char 
__uc
; \

689 char 
__c
; \

690 } *
__u
 = (void *) (
dest
); \

691 switch (
srclen
) \

694 
__u
->
__uc
 = '\0'; \

697 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 0); \

698 
__u
 = 
	`__extension__
 ((void *) __u + 1); \

701 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 0); \

702 
__u
 = 
	`__extension__
 ((void *) __u + 2); \

703 
__u
->
__uc
 = '\0'; \

706 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

707 
__u
 = 
	`__extension__
 ((void *) __u + 3); \

710 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

711 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

712 
__u
->
__uc
 = '\0'; \

715 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

716 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

717 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 4); \

718 
__u
 = 
	`__extension__
 ((void *) __u + 1); \

721 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

722 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

723 
__u
->
__usi
 = 
	`__STRING_SMALL_GET16
 (
src
, 4); \

724 
__u
 = 
	`__extension__
 ((void *) __u + 2); \

725 
__u
->
__uc
 = '\0'; \

728 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 0); \

729 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

730 
__u
->
__ui
 = 
	`__STRING_SMALL_GET32
 (
src
, 4); \

731 
__u
 = 
	`__extension__
 ((void *) __u + 3); \

734 (char *) 
__u
; }))

	)

736 
__STRING_INLINE
 char *
__mempcpy_by4
 (char *
__dest
, const char *
__src
,

737 
size_t
 
__srclen
);

739 
__STRING_INLINE
 char *

740 
	$__mempcpy_by4
 (char *
__dest
, const char *
__src
, 
size_t
 
__srclen
)

742 register char *
__tmp
 = 
__dest
;

743 register unsigned long int 
__d0
, 
__d1
;

744 
__asm__
 
__volatile__


752 : "=&r" (
__d0
), "=r" (
__tmp
), "=&r" (
__src
), "=&r" (
__d1
)

753 : "1" (
__tmp
), "2" (
__src
), "3" (
__srclen
 / 4)

755 return 
__tmp
;

756 
	}
}

758 
__STRING_INLINE
 char *
__mempcpy_by2
 (char *
__dest
, const char *
__src
,

759 
size_t
 
__srclen
);

761 
__STRING_INLINE
 char *

762 
	$__mempcpy_by2
 (char *
__dest
, const char *
__src
, 
size_t
 
__srclen
)

764 register char *
__tmp
 = 
__dest
;

765 register unsigned long int 
__d0
, 
__d1
;

766 
__asm__
 
__volatile__


779 : "=&q" (
__d0
), "=r" (
__tmp
), "=&r" (
__src
), "=&r" (
__d1
),

780 "=m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__dest
)

781 : "1" (
__tmp
), "2" (
__src
), "3" (
__srclen
 / 2),

782 "m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__src
)

784 return 
__tmp
 + 2;

785 
	}
}

787 
__STRING_INLINE
 char *
__mempcpy_byn
 (char *
__dest
, const char *
__src
,

788 
size_t
 
__srclen
);

790 
__STRING_INLINE
 char *

791 
	$__mempcpy_byn
 (char *
__dest
, const char *
__src
, 
size_t
 
__srclen
)

793 register unsigned long 
__d0
, 
__d1
;

794 register char *
__tmp
 = 
__dest
;

795 
__asm__
 
__volatile__


806 : "=D" (
__tmp
), "=&c" (
__d0
), "=&S" (
__d1
),

807 "=m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__dest
)

808 : "0" (
__tmp
), "1" (
__srclen
), "2" (
__src
),

809 "m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__src
)

811 return 
__tmp
;

812 
	}
}

814 
__STRING_INLINE
 char *
__stpcpy_g
 (char *
__dest
, const char *
__src
);

816 
__STRING_INLINE
 char *

817 
	$__stpcpy_g
 (char *
__dest
, const char *
__src
)

819 register char *
__tmp
 = 
__dest
;

820 register char 
__dummy
;

821 
__asm__
 
__volatile__


830 : "=&r" (
__src
), "=r" (
__tmp
), "=&q" (
__dummy
),

831 "=m" ( *(struct { char 
__x
[0xfffffff]; } *)
__dest
)

832 : "0" (
__src
), "1" (
__tmp
),

833 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__src
)

835 return 
__tmp
 - 1;

836 
	}
}

841 #define 
	#_HAVE_STRING_ARCH_strncpy
 1

	)

842 #define 
	#strncpy
(
dest
, 
src
, 
n
) \

843 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

844 ? ((
	`strlen
 (
src
) + 1 >= ((
size_t
) (
n
)) \

845 ? (char *) 
	`memcpy
 ((char *) (
dest
), \

846 (const char *) (
src
), 
n
) \

847 : 
	`__strncpy_cg
 ((
dest
), (
src
), 
	`strlen
 (src) + 1, 
n
))) \

848 : 
	`__strncpy_gg
 ((
dest
), (
src
), 
n
)))

	)

849 #define 
	#__strncpy_cg
(
dest
, 
src
, 
srclen
, 
n
) \

850 (((
srclen
) % 4 == 0) \

851 ? 
	`__strncpy_by4
 (
dest
, 
src
, 
srclen
, 
n
) \

852 : (((
srclen
) % 2 == 0) \

853 ? 
	`__strncpy_by2
 (
dest
, 
src
, 
srclen
, 
n
) \

854 : 
	`__strncpy_byn
 (
dest
, 
src
, 
srclen
, 
n
)))

	)

856 
__STRING_INLINE
 char *
__strncpy_by4
 (char *
__dest
, const char 
__src
[],

857 
size_t
 
__srclen
, size_t 
__n
);

859 
__STRING_INLINE
 char *

860 
	$__strncpy_by4
 (char *
__dest
, const char 
__src
[], 
size_t
 
__srclen
, size_t 
__n
)

862 register char *
__tmp
 = 
__dest
;

863 register int 
__dummy1
, 
__dummy2
;

864 
__asm__
 
__volatile__


872 : "=&r" (
__dummy1
), "=r" (
__tmp
), "=&r" (
__src
), "=&r" (
__dummy2
),

873 "=m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__dest
)

874 : "1" (
__tmp
), "2" (
__src
), "3" (
__srclen
 / 4),

875 "m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__src
)

877 (void) 
	`memset
 (
__tmp
, '\0', 
__n
 - 
__srclen
);

878 return 
__dest
;

879 
	}
}

881 
__STRING_INLINE
 char *
__strncpy_by2
 (char *
__dest
, const char 
__src
[],

882 
size_t
 
__srclen
, size_t 
__n
);

884 
__STRING_INLINE
 char *

885 
	$__strncpy_by2
 (char *
__dest
, const char 
__src
[], 
size_t
 
__srclen
, size_t 
__n
)

887 register char *
__tmp
 = 
__dest
;

888 register int 
__dummy1
, 
__dummy2
;

889 
__asm__
 
__volatile__


902 : "=&q" (
__dummy1
), "=r" (
__tmp
), "=&r" (
__src
), "=&r" (
__dummy2
),

903 "=m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__dest
)

904 : "1" (
__tmp
), "2" (
__src
), "3" (
__srclen
 / 2),

905 "m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__src
)

907 (void) 
	`memset
 (
__tmp
 + 2, '\0', 
__n
 - 
__srclen
);

908 return 
__dest
;

909 
	}
}

911 
__STRING_INLINE
 char *
__strncpy_byn
 (char *
__dest
, const char 
__src
[],

912 
size_t
 
__srclen
, size_t 
__n
);

914 
__STRING_INLINE
 char *

915 
	$__strncpy_byn
 (char *
__dest
, const char 
__src
[], 
size_t
 
__srclen
, size_t 
__n
)

917 register unsigned long int 
__d0
, 
__d1
;

918 register char *
__tmp
 = 
__dest
;

919 
__asm__
 
__volatile__


930 : "=D" (
__tmp
), "=&c" (
__d0
), "=&S" (
__d1
),

931 "=m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__dest
)

932 : "1" (
__srclen
), "0" (
__tmp
),"2" (
__src
),

933 "m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__src
)

935 (void) 
	`memset
 (
__tmp
, '\0', 
__n
 - 
__srclen
);

936 return 
__dest
;

937 
	}
}

939 
__STRING_INLINE
 char *
__strncpy_gg
 (char *
__dest
, const char *
__src
,

940 
size_t
 
__n
);

942 
__STRING_INLINE
 char *

943 
	$__strncpy_gg
 (char *
__dest
, const char *
__src
, 
size_t
 
__n
)

945 register char *
__tmp
 = 
__dest
;

946 register char 
__dummy
;

947 if (
__n
 > 0)

948 
__asm__
 
__volatile__


964 : "=&r" (
__src
), "=&r" (
__tmp
), "=&q" (
__dummy
), "=&r" (
__n
)

965 : "0" (
__src
), "1" (
__tmp
), "3" (
__n
)

968 return 
__dest
;

969 
	}
}

973 #define 
	#_HAVE_STRING_ARCH_strcat
 1

	)

974 #define 
	#strcat
(
dest
, 
src
) \

975 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

976 ? 
	`__strcat_c
 ((
dest
), (
src
), 
	`strlen
 (src) + 1) \

977 : 
	`__strcat_g
 ((
dest
), (
src
))))

	)

979 
__STRING_INLINE
 char *
__strcat_c
 (char *
__dest
, const char 
__src
[],

980 
size_t
 
__srclen
);

982 
__STRING_INLINE
 char *

983 
	$__strcat_c
 (char *
__dest
, const char 
__src
[], 
size_t
 
__srclen
)

985 #ifdef 
__i686__


986 register unsigned long int 
__d0
;

987 register char *
__tmp
;

988 
__asm__
 
__volatile__


990 : "=D" (
__tmp
), "=&c" (
__d0
),

991 "=m" ( *(struct { char 
__x
[0xfffffff]; } *)
__dest
)

992 : "0" (
__dest
), "1" (0xffffffff), "a" (0),

993 "m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__src
)

995 --
__tmp
;

997 register char *
__tmp
 = 
__dest
 - 1;

998 
__asm__
 
__volatile__


1003 : "=r" (
__tmp
),

1004 "=m" ( *(struct { char 
__x
[0xfffffff]; } *)
__dest
)

1005 : "0" (
__tmp
),

1006 "m" ( *(struct { 
__extension__
 char 
__x
[
__srclen
]; } *)
__src
)

1009 (void) 
	`memcpy
 (
__tmp
, 
__src
, 
__srclen
);

1010 return 
__dest
;

1011 
	}
}

1013 
__STRING_INLINE
 char *
__strcat_g
 (char *
__dest
, const char *
__src
);

1015 
__STRING_INLINE
 char *

1016 
	$__strcat_g
 (char *
__dest
, const char *
__src
)

1018 register char *
__tmp
 = 
__dest
 - 1;

1019 register char 
__dummy
;

1020 
__asm__
 
__volatile__


1032 : "=&q" (
__dummy
), "=&r" (
__tmp
), "=&r" (
__src
),

1033 "=m" ( *(struct { char 
__x
[0xfffffff]; } *)
__dest
)

1034 : "1" (
__tmp
), "2" (
__src
),

1035 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__src
)

1037 return 
__dest
;

1038 
	}
}

1042 #define 
	#_HAVE_STRING_ARCH_strncat
 1

	)

1043 #define 
	#strncat
(
dest
, 
src
, 
n
) \

1044 (
	`__extension__
 ({ char *
__dest
 = (
dest
); \

1045 
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

1046 ? (
	`strlen
 (
src
) < ((
size_t
) (
n
)) \

1047 ? 
	`strcat
 (
__dest
, (
src
)) \

1048 : (*(char *)
	`__mempcpy
 (
	`strchr
 (
__dest
, '\0'), \

1049 (const char *) (
src
), \

1050 (
n
)) = 0, 
__dest
)) \

1051 : 
	`__strncat_g
 (
__dest
, (
src
), (
n
)); }))

	)

1053 
__STRING_INLINE
 char *
__strncat_g
 (char *
__dest
, const char 
__src
[],

1054 
size_t
 
__n
);

1056 
__STRING_INLINE
 char *

1057 
	$__strncat_g
 (char *
__dest
, const char 
__src
[], 
size_t
 
__n
)

1059 register char *
__tmp
 = 
__dest
;

1060 register char 
__dummy
;

1061 #ifdef 
__i686__


1062 
__asm__
 
__volatile__


1076 : "=&a" (
__dummy
), "=&D" (
__tmp
), "=&S" (
__src
), "=&c" (
__n
)

1077 : "g" (
__n
), "0" (0), "1" (
__tmp
), "2" (
__src
), "3" (0xffffffff)

1080 --
__tmp
;

1081 
__asm__
 
__volatile__


1098 : "=&q" (
__dummy
), "=&r" (
__tmp
), "=&r" (
__src
), "=&r" (
__n
)

1099 : "1" (
__tmp
), "2" (
__src
), "3" (
__n
)

1102 return 
__dest
;

1103 
	}
}

1107 #define 
	#_HAVE_STRING_ARCH_strcmp
 1

	)

1108 #define 
	#strcmp
(
s1
, 
s2
) \

1109 (
	`__extension__
 (
	`__builtin_constant_p
 (
s1
) && __builtin_constant_p (
s2
) \

1110 && (sizeof ((
s1
)[0]) != 1 || 
	`strlen
 (s1) >= 4) \

1111 && (sizeof ((
s2
)[0]) != 1 || 
	`strlen
 (s2) >= 4) \

1112 ? 
	`memcmp
 ((const char *) (
s1
), (const char *) (
s2
), \

1113 (
	`strlen
 (
s1
) < strlen (
s2
) \

1114 ? 
	`strlen
 (
s1
) : strlen (
s2
)) + 1) \

1115 : (
	`__builtin_constant_p
 (
s1
) && sizeof ((s1)[0]) == 1 \

1116 && sizeof ((
s2
)[0]) == 1 && 
	`strlen
 (
s1
) < 4 \

1117 ? (
	`__builtin_constant_p
 (
s2
) && sizeof ((s2)[0]) == 1 \

1118 ? 
	`__strcmp_cc
 ((const unsigned char *) (
s1
), \

1119 (const unsigned char *) (
s2
), \

1120 
	`strlen
 (
s1
)) \

1121 : 
	`__strcmp_cg
 ((const unsigned char *) (
s1
), \

1122 (const unsigned char *) (
s2
), \

1123 
	`strlen
 (
s1
))) \

1124 : (
	`__builtin_constant_p
 (
s2
) && sizeof ((
s1
)[0]) == 1 \

1125 && sizeof ((
s2
)[0]) == 1 && 
	`strlen
 (s2) < 4 \

1126 ? (
	`__builtin_constant_p
 (
s1
) \

1127 ? 
	`__strcmp_cc
 ((const unsigned char *) (
s1
), \

1128 (const unsigned char *) (
s2
), \

1129 
	`strlen
 (
s2
)) \

1130 : 
	`__strcmp_gc
 ((const unsigned char *) (
s1
), \

1131 (const unsigned char *) (
s2
), \

1132 
	`strlen
 (
s2
))) \

1133 : 
	`__strcmp_gg
 ((
s1
), (
s2
))))))

	)

1135 #define 
	#__strcmp_cc
(
s1
, 
s2
, 
l
) \

1136 (
	`__extension__
 ({ register int 
__result
 = (
s1
)[0] - (
s2
)[0]; \

1137 if (
l
 > 0 && 
__result
 == 0) \

1139 
__result
 = (
s1
)[1] - (
s2
)[1]; \

1140 if (
l
 > 1 && 
__result
 == 0) \

1142 
__result
 = (
s1
)[2] - (
s2
)[2]; \

1143 if (
l
 > 2 && 
__result
 == 0) \

1144 
__result
 = (
s1
)[3] - (
s2
)[3]; \

1147 
__result
; }))

	)

1149 #define 
	#__strcmp_cg
(
s1
, 
s2
, 
l1
) \

1150 (
	`__extension__
 ({ const unsigned char *
__s2
 = (
s2
); \

1151 register int 
__result
 = (
s1
)[0] - 
__s2
[0]; \

1152 if (
l1
 > 0 && 
__result
 == 0) \

1154 
__result
 = (
s1
)[1] - 
__s2
[1]; \

1155 if (
l1
 > 1 && 
__result
 == 0) \

1157 
__result
 = (
s1
)[2] - 
__s2
[2]; \

1158 if (
l1
 > 2 && 
__result
 == 0) \

1159 
__result
 = (
s1
)[3] - 
__s2
[3]; \

1162 
__result
; }))

	)

1164 #define 
	#__strcmp_gc
(
s1
, 
s2
, 
l2
) \

1165 (
	`__extension__
 ({ const unsigned char *
__s1
 = (
s1
); \

1166 register int 
__result
 = 
__s1
[0] - (
s2
)[0]; \

1167 if (
l2
 > 0 && 
__result
 == 0) \

1169 
__result
 = 
__s1
[1] - (
s2
)[1]; \

1170 if (
l2
 > 1 && 
__result
 == 0) \

1172 
__result
 = 
__s1
[2] - (
s2
)[2]; \

1173 if (
l2
 > 2 && 
__result
 == 0) \

1174 
__result
 = 
__s1
[3] - (
s2
)[3]; \

1177 
__result
; }))

	)

1179 
__STRING_INLINE
 int 
__strcmp_gg
 (const char *
__s1
, const char *
__s2
);

1181 
__STRING_INLINE
 int

1182 
	$__strcmp_gg
 (const char *
__s1
, const char *
__s2
)

1184 register int 
__res
;

1185 
__asm__
 
__volatile__


1201 : "=q" (
__res
), "=&r" (
__s1
), "=&r" (
__s2
)

1202 : "1" (
__s1
), "2" (
__s2
),

1203 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s1
),

1204 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s2
)

1206 return 
__res
;

1207 
	}
}

1211 #define 
	#_HAVE_STRING_ARCH_strncmp
 1

	)

1212 #define 
	#strncmp
(
s1
, 
s2
, 
n
) \

1213 (
	`__extension__
 (
	`__builtin_constant_p
 (
s1
) && 
	`strlen
 (s1) < ((
size_t
) (
n
)) \

1214 ? 
	`strcmp
 ((
s1
), (
s2
)) \

1215 : (
	`__builtin_constant_p
 (
s2
) && 
	`strlen
 (s2) < ((
size_t
) (
n
))\

1216 ? 
	`strcmp
 ((
s1
), (
s2
)) \

1217 : 
	`__strncmp_g
 ((
s1
), (
s2
), (
n
)))))

	)

1219 
__STRING_INLINE
 int 
__strncmp_g
 (const char *
__s1
, const char *
__s2
,

1220 
size_t
 
__n
);

1222 
__STRING_INLINE
 int

1223 
	$__strncmp_g
 (const char *
__s1
, const char *
__s2
, 
size_t
 
__n
)

1225 register int 
__res
;

1226 
__asm__
 
__volatile__


1245 : "=q" (
__res
), "=&r" (
__s1
), "=&r" (
__s2
), "=&r" (
__n
)

1246 : "1" (
__s1
), "2" (
__s2
), "3" (
__n
),

1247 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s1
),

1248 "m" ( *(struct { 
__extension__
 char 
__x
[
__n
]; } *)
__s2
)

1250 return 
__res
;

1251 
	}
}

1255 #define 
	#_HAVE_STRING_ARCH_strchr
 1

	)

1256 #define 
	#_USE_STRING_ARCH_strchr
 1

	)

1257 #define 
	#strchr
(
s
, 
c
) \

1258 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) \

1259 ? ((
c
) == '\0' \

1260 ? (char *) 
	`__rawmemchr
 ((
s
), (
c
)) \

1261 : 
	`__strchr_c
 ((
s
), ((
c
) & 0xff) << 8)) \

1262 : 
	`__strchr_g
 ((
s
), (
c
))))

	)

1264 
__STRING_INLINE
 char *
__strchr_c
 (const char *
__s
, int 
__c
);

1266 
__STRING_INLINE
 char *

1267 
	$__strchr_c
 (const char *
__s
, int 
__c
)

1269 register unsigned long int 
__d0
;

1270 register char *
__res
;

1271 
__asm__
 
__volatile__


1281 : "=r" (
__res
), "=&a" (
__d0
)

1282 : "0" (
__s
), "1" (
__c
),

1283 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1285 return 
__res
;

1286 
	}
}

1288 
__STRING_INLINE
 char *
__strchr_g
 (const char *
__s
, int 
__c
);

1290 
__STRING_INLINE
 char *

1291 
	$__strchr_g
 (const char *
__s
, int 
__c
)

1293 register unsigned long int 
__d0
;

1294 register char *
__res
;

1295 
__asm__
 
__volatile__


1306 : "=r" (
__res
), "=&a" (
__d0
)

1307 : "0" (
__s
), "1" (
__c
),

1308 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1310 return 
__res
;

1311 
	}
}

1315 #define 
	#_HAVE_STRING_ARCH_strchrnul
 1

	)

1316 #define 
	#__strchrnul
(
s
, 
c
) \

1317 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) \

1318 ? ((
c
) == '\0' \

1319 ? (char *) 
	`__rawmemchr
 ((
s
), 
c
) \

1320 : 
	`__strchrnul_c
 ((
s
), ((
c
) & 0xff) << 8)) \

1321 : 
	`__strchrnul_g
 ((
s
), 
c
)))

	)

1323 
__STRING_INLINE
 char *
__strchrnul_c
 (const char *
__s
, int 
__c
);

1325 
__STRING_INLINE
 char *

1326 
	$__strchrnul_c
 (const char *
__s
, int 
__c
)

1328 register unsigned long int 
__d0
;

1329 register char *
__res
;

1330 
__asm__
 
__volatile__


1340 : "=r" (
__res
), "=&a" (
__d0
)

1341 : "0" (
__s
), "1" (
__c
),

1342 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1344 return 
__res
;

1345 
	}
}

1347 
__STRING_INLINE
 char *
__strchrnul_g
 (const char *
__s
, int 
__c
);

1349 
__STRING_INLINE
 char *

1350 
	$__strchrnul_g
 (const char *
__s
, int 
__c
)

1352 register unsigned long int 
__d0
;

1353 register char *
__res
;

1354 
__asm__
 
__volatile__


1365 : "=r" (
__res
), "=&a" (
__d0
)

1366 : "0" (
__s
), "1" (
__c
),

1367 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1369 return 
__res
;

1370 
	}
}

1371 #ifdef 
__USE_GNU


1372 #define 
	#strchrnul
(
s
, 
c
) 
	`__strchrnul
 ((s), (c))

	)

1376 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


1378 #define 
	#_HAVE_STRING_ARCH_index
 1

	)

1379 #define 
	#index
(
s
, 
c
) \

1380 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) \

1381 ? 
	`__strchr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1382 : 
	`__strchr_g
 ((
s
), (
c
))))

	)

1387 #define 
	#_HAVE_STRING_ARCH_strrchr
 1

	)

1388 #define 
	#strrchr
(
s
, 
c
) \

1389 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) \

1390 ? 
	`__strrchr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1391 : 
	`__strrchr_g
 ((
s
), (
c
))))

	)

1393 #ifdef 
__i686__


1394 
__STRING_INLINE
 char *
__strrchr_c
 (const char *
__s
, int 
__c
);

1396 
__STRING_INLINE
 char *

1397 
	$__strrchr_c
 (const char *
__s
, int 
__c
)

1399 register unsigned long int 
__d0
, 
__d1
;

1400 register char *
__res
;

1401 
__asm__
 
__volatile__


1409 : "=d" (
__res
), "=&S" (
__d0
), "=&a" (
__d1
)

1410 : "0" (1), "1" (
__s
), "2" (
__c
),

1411 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1413 return 
__res
 - 1;

1414 
	}
}

1416 
__STRING_INLINE
 char *
__strrchr_g
 (const char *
__s
, int 
__c
);

1418 
__STRING_INLINE
 char *

1419 
	$__strrchr_g
 (const char *
__s
, int 
__c
)

1421 register unsigned long int 
__d0
, 
__d1
;

1422 register char *
__res
;

1423 
__asm__
 
__volatile__


1432 : "=d" (
__res
), "=&S" (
__d0
), "=&a" (
__d1
)

1433 : "0" (1), "1" (
__s
), "2" (
__c
),

1434 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1436 return 
__res
 - 1;

1437 
	}
}

1439 
__STRING_INLINE
 char *
__strrchr_c
 (const char *
__s
, int 
__c
);

1441 
__STRING_INLINE
 char *

1442 
	$__strrchr_c
 (const char *
__s
, int 
__c
)

1444 register unsigned long int 
__d0
, 
__d1
;

1445 register char *
__res
;

1446 
__asm__
 
__volatile__


1456 : "=d" (
__res
), "=&S" (
__d0
), "=&a" (
__d1
)

1457 : "0" (0), "1" (
__s
), "2" (
__c
),

1458 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1460 return 
__res
;

1461 
	}
}

1463 
__STRING_INLINE
 char *
__strrchr_g
 (const char *
__s
, int 
__c
);

1465 
__STRING_INLINE
 char *

1466 
	$__strrchr_g
 (const char *
__s
, int 
__c
)

1468 register unsigned long int 
__d0
, 
__d1
;

1469 register char *
__res
;

1470 
__asm__
 
__volatile__


1481 : "=r" (
__res
), "=&S" (
__d0
), "=&a" (
__d1
)

1482 : "0" (0), "1" (
__s
), "2" (
__c
),

1483 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1485 return 
__res
;

1486 
	}
}

1490 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


1492 #define 
	#_HAVE_STRING_ARCH_rindex
 1

	)

1493 #define 
	#rindex
(
s
, 
c
) \

1494 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) \

1495 ? 
	`__strrchr_c
 ((
s
), ((
c
) & 0xff) << 8) \

1496 : 
	`__strrchr_g
 ((
s
), (
c
))))

	)

1502 #define 
	#_HAVE_STRING_ARCH_strcspn
 1

	)

1503 #define 
	#strcspn
(
s
, 
reject
) \

1504 (
	`__extension__
 (
	`__builtin_constant_p
 (
reject
) && sizeof ((reject)[0]) == 1 \

1505 ? ((
reject
)[0] == '\0' \

1506 ? 
	`strlen
 (
s
) \

1507 : ((
reject
)[1] == '\0' \

1508 ? 
	`__strcspn_c1
 ((
s
), (((
reject
)[0] << 8) & 0xff00)) \

1509 : 
	`__strcspn_cg
 ((
s
), (
reject
), 
	`strlen
 (reject)))) \

1510 : 
	`__strcspn_g
 ((
s
), (
reject
))))

	)

1512 
__STRING_INLINE
 
size_t
 
__strcspn_c1
 (const char *
__s
, int 
__reject
);

1514 #ifndef 
_FORCE_INLINES


1515 
__STRING_INLINE
 
size_t


1516 
	$__strcspn_c1
 (const char *
__s
, int 
__reject
)

1518 register unsigned long int 
__d0
;

1519 register char *
__res
;

1520 
__asm__
 
__volatile__


1529 : "=r" (
__res
), "=&a" (
__d0
)

1530 : "0" (
__s
), "1" (
__reject
),

1531 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1533 return (
__res
 - 1) - 
__s
;

1534 
	}
}

1537 
__STRING_INLINE
 
size_t
 
__strcspn_cg
 (const char *
__s
, const char 
__reject
[],

1538 
size_t
 
__reject_len
);

1540 
__STRING_INLINE
 
size_t


1541 
	$__strcspn_cg
 (const char *
__s
, const char 
__reject
[], 
size_t
 
__reject_len
)

1543 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1544 register const char *
__res
;

1545 
__asm__
 
__volatile__


1556 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1557 : "0" (
__s
), "d" (
__reject
), "g" (
__reject_len
)

1559 return (
__res
 - 1) - 
__s
;

1560 
	}
}

1562 
__STRING_INLINE
 
size_t
 
__strcspn_g
 (const char *
__s
, const char *
__reject
);

1563 #ifdef 
__PIC__


1565 
__STRING_INLINE
 
size_t


1566 
	$__strcspn_g
 (const char *
__s
, const char *
__reject
)

1568 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1569 register const char *
__res
;

1570 
__asm__
 
__volatile__


1587 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1588 : "r" (
__reject
), "0" (
__s
), "1" (0), "2" (0xffffffff)

1590 return (
__res
 - 1) - 
__s
;

1591 
	}
}

1593 
__STRING_INLINE
 
size_t


1594 
	$__strcspn_g
 (const char *
__s
, const char *
__reject
)

1596 register unsigned long int 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1597 register const char *
__res
;

1598 
__asm__
 
__volatile__


1612 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1613 : "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (
__reject
), "b" (__reject)

1616 return (
__res
 - 1) - 
__s
;

1617 
	}
}

1623 #define 
	#_HAVE_STRING_ARCH_strspn
 1

	)

1624 #define 
	#strspn
(
s
, 
accept
) \

1625 (
	`__extension__
 (
	`__builtin_constant_p
 (
accept
) && sizeof ((accept)[0]) == 1 \

1626 ? ((
accept
)[0] == '\0' \

1627 ? ((void) (
s
), 0) \

1628 : ((
accept
)[1] == '\0' \

1629 ? 
	`__strspn_c1
 ((
s
), (((
accept
)[0] << 8 ) & 0xff00)) \

1630 : 
	`__strspn_cg
 ((
s
), (
accept
), 
	`strlen
 (accept)))) \

1631 : 
	`__strspn_g
 ((
s
), (
accept
))))

	)

1633 #ifndef 
_FORCE_INLINES


1634 
__STRING_INLINE
 
size_t
 
__strspn_c1
 (const char *
__s
, int 
__accept
);

1636 
__STRING_INLINE
 
size_t


1637 
	$__strspn_c1
 (const char *
__s
, int 
__accept
)

1639 register unsigned long int 
__d0
;

1640 register char *
__res
;

1642 
__asm__
 
__volatile__


1648 : "=r" (
__res
), "=&q" (
__d0
)

1649 : "0" (
__s
), "1" (
__accept
),

1650 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
)

1652 return (
__res
 - 1) - 
__s
;

1653 
	}
}

1656 
__STRING_INLINE
 
size_t
 
__strspn_cg
 (const char *
__s
, const char 
__accept
[],

1657 
size_t
 
__accept_len
);

1659 
__STRING_INLINE
 
size_t


1660 
	$__strspn_cg
 (const char *
__s
, const char 
__accept
[], 
size_t
 
__accept_len
)

1662 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1663 register const char *
__res
;

1664 
__asm__
 
__volatile__


1675 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1676 : "0" (
__s
), "g" (
__accept
), "g" (
__accept_len
),

1679 "m" ( *(struct { char 
__x
[0xfffffff]; } *)
__s
),

1680 "m" ( *(struct { 
__extension__
 char 
__x
[
__accept_len
]; } *)
__accept
)

1682 return (
__res
 - 1) - 
__s
;

1683 
	}
}

1685 
__STRING_INLINE
 
size_t
 
__strspn_g
 (const char *
__s
, const char *
__accept
);

1686 #ifdef 
__PIC__


1688 
__STRING_INLINE
 
size_t


1689 
	$__strspn_g
 (const char *
__s
, const char *
__accept
)

1691 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1692 register const char *
__res
;

1693 
__asm__
 
__volatile__


1709 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1710 : "d" (
__accept
), "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (__accept)

1712 return (
__res
 - 1) - 
__s
;

1713 
	}
}

1715 
__STRING_INLINE
 
size_t


1716 
	$__strspn_g
 (const char *
__s
, const char *
__accept
)

1718 register unsigned long int 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1719 register const char *
__res
;

1720 
__asm__
 
__volatile__


1734 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1735 : "0" (
__s
), "1" (0), "2" (0xffffffff), "3" (
__accept
), "b" (__accept)

1737 return (
__res
 - 1) - 
__s
;

1738 
	}
}

1743 #define 
	#_HAVE_STRING_ARCH_strpbrk
 1

	)

1744 #define 
	#strpbrk
(
s
, 
accept
) \

1745 (
	`__extension__
 (
	`__builtin_constant_p
 (
accept
) && sizeof ((accept)[0]) == 1 \

1746 ? ((
accept
)[0] == '\0' \

1747 ? ((void) (
s
), (char *) 0) \

1748 : ((
accept
)[1] == '\0' \

1749 ? 
	`strchr
 ((
s
), (
accept
)[0]) \

1750 : 
	`__strpbrk_cg
 ((
s
), (
accept
), 
	`strlen
 (accept)))) \

1751 : 
	`__strpbrk_g
 ((
s
), (
accept
))))

	)

1753 
__STRING_INLINE
 char *
__strpbrk_cg
 (const char *
__s
, const char 
__accept
[],

1754 
size_t
 
__accept_len
);

1756 
__STRING_INLINE
 char *

1757 
	$__strpbrk_cg
 (const char *
__s
, const char 
__accept
[], 
size_t
 
__accept_len
)

1759 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1760 register char *
__res
;

1761 
__asm__
 
__volatile__


1776 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1777 : "0" (
__s
), "d" (
__accept
), "g" (
__accept_len
)

1779 return 
__res
;

1780 
	}
}

1782 
__STRING_INLINE
 char *
__strpbrk_g
 (const char *
__s
, const char *
__accept
);

1783 #ifdef 
__PIC__


1785 
__STRING_INLINE
 char *

1786 
	$__strpbrk_g
 (const char *
__s
, const char *
__accept
)

1788 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1789 register char *
__res
;

1790 
__asm__
 
__volatile__


1811 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&D" (
__d2
)

1812 : "d" (
__accept
), "0" (
__s
), "1" (0), "2" (0xffffffff)

1814 return 
__res
;

1815 
	}
}

1817 
__STRING_INLINE
 char *

1818 
	$__strpbrk_g
 (const char *
__s
, const char *
__accept
)

1820 register unsigned long int 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1821 register char *
__res
;

1822 
__asm__
 
__volatile__


1841 : "=S" (
__res
), "=&a" (
__d0
), "=&c" (
__d1
), "=&d" (
__d2
), "=&D" (
__d3
)

1842 : "0" (
__s
), "1" (0), "2" (0xffffffff), "b" (
__accept
)

1844 return 
__res
;

1845 
	}
}

1850 #define 
	#_HAVE_STRING_ARCH_strstr
 1

	)

1851 #define 
	#strstr
(
haystack
, 
needle
) \

1852 (
	`__extension__
 (
	`__builtin_constant_p
 (
needle
) && sizeof ((needle)[0]) == 1 \

1853 ? ((
needle
)[0] == '\0' \

1854 ? (
haystack
) \

1855 : ((
needle
)[1] == '\0' \

1856 ? 
	`strchr
 ((
haystack
), (
needle
)[0]) \

1857 : 
	`__strstr_cg
 ((
haystack
), (
needle
), \

1858 
	`strlen
 (
needle
)))) \

1859 : 
	`__strstr_g
 ((
haystack
), (
needle
))))

	)

1863 
__STRING_INLINE
 char *
__strstr_cg
 (const char *
__haystack
,

1864 const char 
__needle
[],

1865 
size_t
 
__needle_len
);

1867 
__STRING_INLINE
 char *

1868 
	$__strstr_cg
 (const char *
__haystack
, const char 
__needle
[],

1869 
size_t
 
__needle_len
)

1871 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1872 register char *
__res
;

1873 
__asm__
 
__volatile__


1886 : "=&a" (
__res
), "=&S" (
__d0
), "=&D" (
__d1
), "=&c" (
__d2
)

1887 : "g" (
__needle_len
), "1" (
__haystack
), "d" (
__needle
)

1889 return 
__res
;

1890 
	}
}

1892 
__STRING_INLINE
 char *
__strstr_g
 (const char *
__haystack
,

1893 const char *
__needle
);

1894 #ifdef 
__PIC__


1896 
__STRING_INLINE
 char *

1897 
	$__strstr_g
 (const char *
__haystack
, const char *
__needle
)

1899 register unsigned long int 
__d0
, 
__d1
, 
__d2
;

1900 register char *
__res
;

1901 
__asm__
 
__volatile__


1920 : "=&a" (
__res
), "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
)

1921 : "0" (0), "1" (0xffffffff), "2" (
__haystack
), "3" (
__needle
),

1922 "d" (
__needle
)

1924 return 
__res
;

1925 
	}
}

1927 
__STRING_INLINE
 char *

1928 
	$__strstr_g
 (const char *
__haystack
, const char *
__needle
)

1930 register unsigned long int 
__d0
, 
__d1
, 
__d2
, 
__d3
;

1931 register char *
__res
;

1932 
__asm__
 
__volatile__


1949 : "=&a" (
__res
), "=&c" (
__d0
), "=&S" (
__d1
), "=&D" (
__d2
), "=&d" (
__d3
)

1950 : "0" (0), "1" (0xffffffff), "2" (
__haystack
), "3" (
__needle
),

1951 "b" (
__needle
)

1953 return 
__res
;

1954 
	}
}

1960 #if 
defined
 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


1961 #ifdef 
__i686__


1962 #define 
	#_HAVE_STRING_ARCH_ffs
 1

	)

1963 #define 
	#ffs
(
word
) (
	`__builtin_constant_p
 (word) \

1964 ? 
	`__builtin_ffs
 (
word
) \

1965 : ({ int 
__cnt
, 
__tmp
; \

1966 
__asm__
 
__volatile__
 \

1969 : "=&r" (
__cnt
), "=r" (
__tmp
) \

1970 : "rm" (
word
), "1" (-1)); \

1971 
__cnt
 + 1; }))

	)

1973 #ifndef 
ffsl


1974 #define 
	#ffsl
(
word
) 
	`ffs
(word)

	)

1979 #ifndef 
_FORCE_INLINES


1980 #undef 
__STRING_INLINE


	@/usr/include/bits/string2.h

20 #ifndef 
_STRING_H


24 #ifndef 
__NO_STRING_INLINES


41 #ifndef 
__STRING_INLINE


42 #ifdef 
__cplusplus


43 #define 
	#__STRING_INLINE
 
inline


	)

45 #define 
	#__STRING_INLINE
 
__extern_inline


	)

49 #if 
_STRING_ARCH_unaligned


51 #include 
	~<endian.h
>

52 #include 
	~<bits/types.h
>

54 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


55 #define 
	#__STRING2_SMALL_GET16
(
src
, 
idx
) \

56 (((const unsigned char *) (const char *) (
src
))[
idx
 + 1] << 8 \

57 | ((const unsigned char *) (const char *) (
src
))[
idx
])

	)

58 #define 
	#__STRING2_SMALL_GET32
(
src
, 
idx
) \

59 (((((const unsigned char *) (const char *) (
src
))[
idx
 + 3] << 8 \

60 | ((const unsigned char *) (const char *) (
src
))[
idx
 + 2]) << 8 \

61 | ((const unsigned char *) (const char *) (
src
))[
idx
 + 1]) << 8 \

62 | ((const unsigned char *) (const char *) (
src
))[
idx
])

	)

64 #define 
	#__STRING2_SMALL_GET16
(
src
, 
idx
) \

65 (((const unsigned char *) (const char *) (
src
))[
idx
] << 8 \

66 | ((const unsigned char *) (const char *) (
src
))[
idx
 + 1])

	)

67 #define 
	#__STRING2_SMALL_GET32
(
src
, 
idx
) \

68 (((((const unsigned char *) (const char *) (
src
))[
idx
] << 8 \

69 | ((const unsigned char *) (const char *) (
src
))[
idx
 + 1]) << 8 \

70 | ((const unsigned char *) (const char *) (
src
))[
idx
 + 2]) << 8 \

71 | ((const unsigned char *) (const char *) (
src
))[
idx
 + 3])

	)

76 #define 
	#__STRING2_COPY_TYPE
(
N
) \

77 typedef struct { unsigned char 
__arr
[
N
]; } \

78 
	t__attribute__
 ((
	t__packed__
)) 
	t__STRING2_COPY_ARR
##
	tN


	)

79 
	t__STRING2_COPY_TYPE
 (2);

80 
__STRING2_COPY_TYPE
 (3);

81 
__STRING2_COPY_TYPE
 (4);

82 
__STRING2_COPY_TYPE
 (5);

83 
__STRING2_COPY_TYPE
 (6);

84 
__STRING2_COPY_TYPE
 (7);

85 
__STRING2_COPY_TYPE
 (8);

86 #undef 
__STRING2_COPY_TYPE


92 #define 
	#__string2_1bptr_p
(
__x
) \

93 ((
size_t
)(const void *)((
__x
) + 1) - (size_t)(const void *)(__x) == 1)

	)

96 #if !
defined
 
_HAVE_STRING_ARCH_memset


97 #if !
__GNUC_PREREQ
 (3, 0)

98 #if 
_STRING_ARCH_unaligned


99 #define 
	#memset
(
s
, 
c
, 
n
) \

100 (
	`__extension__
 (
	`__builtin_constant_p
 (
n
) && (n) <= 16 \

101 ? ((
n
) == 1 \

102 ? 
	`__memset_1
 (
s
, 
c
) \

103 : 
	`__memset_gc
 (
s
, 
c
, 
n
)) \

104 : (
	`__builtin_constant_p
 (
c
) && (c) == '\0' \

105 ? ({ void *
__s
 = (
s
); 
	`__bzero
 (__s, 
n
); __s; }) \

106 : 
	`memset
 (
s
, 
c
, 
n
))))

	)

108 #define 
	#__memset_1
(
s
, 
c
) ({ void *
__s
 = (s); \

109 *((
__uint8_t
 *) 
__s
) = (__uint8_t) 
c
; __s; })

	)

111 #define 
	#__memset_gc
(
s
, 
c
, 
n
) \

112 ({ void *
__s
 = (
s
); \

114 unsigned int 
__ui
; \

115 unsigned short int 
__usi
; \

116 unsigned char 
__uc
; \

117 } *
__u
 = 
__s
; \

118 
__uint8_t
 
__c
 = (__uint8_t) (
c
); \

121 switch ((unsigned int) (
n
)) \

124 
__u
->
__ui
 = 
__c
 * 0x01010101; \

125 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

127 
__u
->
__ui
 = 
__c
 * 0x01010101; \

128 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

130 
__u
->
__ui
 = 
__c
 * 0x01010101; \

131 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

133 
__u
->
__usi
 = (unsigned short int) 
__c
 * 0x0101; \

134 
__u
 = 
	`__extension__
 ((void *) __u + 2); \

135 
__u
->
__uc
 = (unsigned char) 
__c
; \

139 
__u
->
__ui
 = 
__c
 * 0x01010101; \

140 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

142 
__u
->
__ui
 = 
__c
 * 0x01010101; \

143 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

145 
__u
->
__ui
 = 
__c
 * 0x01010101; \

146 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

148 
__u
->
__usi
 = (unsigned short int) 
__c
 * 0x0101; \

152 
__u
->
__ui
 = 
__c
 * 0x01010101; \

153 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

155 
__u
->
__ui
 = 
__c
 * 0x01010101; \

156 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

158 
__u
->
__ui
 = 
__c
 * 0x01010101; \

159 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

161 
__u
->
__uc
 = (unsigned char) 
__c
; \

165 
__u
->
__ui
 = 
__c
 * 0x01010101; \

166 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

168 
__u
->
__ui
 = 
__c
 * 0x01010101; \

169 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

171 
__u
->
__ui
 = 
__c
 * 0x01010101; \

172 
__u
 = 
	`__extension__
 ((void *) __u + 4); \

174 
__u
->
__ui
 = 
__c
 * 0x01010101; \

179 
__s
; })

	)

181 #define 
	#memset
(
s
, 
c
, 
n
) \

182 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) && (c) == '\0' \

183 ? ({ void *
__s
 = (
s
); 
	`__bzero
 (__s, 
n
); __s; }) \

184 : 
	`memset
 (
s
, 
c
, 
n
)))

	)

193 #if 
__GNUC_PREREQ
 (2, 91)

194 #define 
	#__bzero
(
s
, 
n
) 
	`__builtin_memset
 (s, '\0', n)

	)

202 #ifdef 
__USE_GNU


203 #if !
defined
 
_HAVE_STRING_ARCH_mempcpy
 || defined 
_FORCE_INLINES


204 #ifndef 
_HAVE_STRING_ARCH_mempcpy


205 #if 
__GNUC_PREREQ
 (3, 4)

206 #define 
	#__mempcpy
(
dest
, 
src
, 
n
) 
	`__builtin_mempcpy
 (dest, src, n)

	)

207 #elif 
__GNUC_PREREQ
 (3, 0)

208 #define 
	#__mempcpy
(
dest
, 
src
, 
n
) \

209 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

210 && 
	`__string2_1bptr_p
 (
src
) && 
n
 <= 8 \

211 ? 
	`__builtin_memcpy
 (
dest
, 
src
, 
n
) + (n) \

212 : 
	`__mempcpy
 (
dest
, 
src
, 
n
)))

	)

214 #define 
	#__mempcpy
(
dest
, 
src
, 
n
) \

215 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

216 && 
	`__string2_1bptr_p
 (
src
) && 
n
 <= 8 \

217 ? 
	`__mempcpy_small
 (
dest
, 
	`__mempcpy_args
 (
src
), 
n
) \

218 : 
	`__mempcpy
 (
dest
, 
src
, 
n
)))

	)

222 #define 
	#mempcpy
(
dest
, 
src
, 
n
) 
	`__mempcpy
 (dest, src, n)

	)

225 #if !
__GNUC_PREREQ
 (3, 0) || 
defined
 
_FORCE_INLINES


226 #if 
_STRING_ARCH_unaligned


227 #ifndef 
_FORCE_INLINES


228 #define 
	#__mempcpy_args
(
src
) \

229 ((const char *) (
src
))[0], ((const char *) (src))[2], \

230 ((const char *) (
src
))[4], ((const char *) (src))[6], \

231 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 0), \

232 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 4), \

233 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 0), \

234 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 4)

	)

236 
__STRING_INLINE
 void *
__mempcpy_small
 (void *, char, char, char, char,

237 
__uint16_t
, __uint16_t, 
__uint32_t
,

238 
__uint32_t
, 
size_t
);

239 
__STRING_INLINE
 void *

240 
	$__mempcpy_small
 (void *
__dest1
,

241 char 
__src0_1
, char 
__src2_1
, char 
__src4_1
, char 
__src6_1
,

242 
__uint16_t
 
__src0_2
, __uint16_t 
__src4_2
,

243 
__uint32_t
 
__src0_4
, __uint32_t 
__src4_4
,

244 
size_t
 
__srclen
)

247 
__uint32_t
 
__ui
;

248 
__uint16_t
 
__usi
;

249 unsigned char 
__uc
;

250 unsigned char 
__c
;

251 } *
__u
 = 
__dest1
;

252 switch ((unsigned int) 
__srclen
)

255 
__u
->
__c
 = 
__src0_1
;

256 
__u
 = 
	`__extension__
 ((void *) __u + 1);

259 
__u
->
__usi
 = 
__src0_2
;

260 
__u
 = 
	`__extension__
 ((void *) __u + 2);

263 
__u
->
__usi
 = 
__src0_2
;

264 
__u
 = 
	`__extension__
 ((void *) __u + 2);

265 
__u
->
__c
 = 
__src2_1
;

266 
__u
 = 
	`__extension__
 ((void *) __u + 1);

269 
__u
->
__ui
 = 
__src0_4
;

270 
__u
 = 
	`__extension__
 ((void *) __u + 4);

273 
__u
->
__ui
 = 
__src0_4
;

274 
__u
 = 
	`__extension__
 ((void *) __u + 4);

275 
__u
->
__c
 = 
__src4_1
;

276 
__u
 = 
	`__extension__
 ((void *) __u + 1);

279 
__u
->
__ui
 = 
__src0_4
;

280 
__u
 = 
	`__extension__
 ((void *) __u + 4);

281 
__u
->
__usi
 = 
__src4_2
;

282 
__u
 = 
	`__extension__
 ((void *) __u + 2);

285 
__u
->
__ui
 = 
__src0_4
;

286 
__u
 = 
	`__extension__
 ((void *) __u + 4);

287 
__u
->
__usi
 = 
__src4_2
;

288 
__u
 = 
	`__extension__
 ((void *) __u + 2);

289 
__u
->
__c
 = 
__src6_1
;

290 
__u
 = 
	`__extension__
 ((void *) __u + 1);

293 
__u
->
__ui
 = 
__src0_4
;

294 
__u
 = 
	`__extension__
 ((void *) __u + 4);

295 
__u
->
__ui
 = 
__src4_4
;

296 
__u
 = 
	`__extension__
 ((void *) __u + 4);

299 return (void *) 
__u
;

300 
	}
}

302 #ifndef 
_FORCE_INLINES


303 #define 
	#__mempcpy_args
(
src
) \

304 ((const char *) (
src
))[0], \

305 
	`__extension__
 ((
__STRING2_COPY_ARR2
) \

306 { { ((const char *) (
src
))[0], ((const char *) (src))[1] } }), \

307 
	`__extension__
 ((
__STRING2_COPY_ARR3
) \

308 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

309 ((const char *) (
src
))[2] } }), \

310 
	`__extension__
 ((
__STRING2_COPY_ARR4
) \

311 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

312 ((const char *) (
src
))[2], ((const char *) (src))[3] } }), \

313 
	`__extension__
 ((
__STRING2_COPY_ARR5
) \

314 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

315 ((const char *) (
src
))[2], ((const char *) (src))[3], \

316 ((const char *) (
src
))[4] } }), \

317 
	`__extension__
 ((
__STRING2_COPY_ARR6
) \

318 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

319 ((const char *) (
src
))[2], ((const char *) (src))[3], \

320 ((const char *) (
src
))[4], ((const char *) (src))[5] } }), \

321 
	`__extension__
 ((
__STRING2_COPY_ARR7
) \

322 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

323 ((const char *) (
src
))[2], ((const char *) (src))[3], \

324 ((const char *) (
src
))[4], ((const char *) (src))[5], \

325 ((const char *) (
src
))[6] } }), \

326 
	`__extension__
 ((
__STRING2_COPY_ARR8
) \

327 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

328 ((const char *) (
src
))[2], ((const char *) (src))[3], \

329 ((const char *) (
src
))[4], ((const char *) (src))[5], \

330 ((const char *) (
src
))[6], ((const char *) (src))[7] } })

	)

332 
__STRING_INLINE
 void *
__mempcpy_small
 (void *, char, 
__STRING2_COPY_ARR2
,

333 
__STRING2_COPY_ARR3
,

334 
__STRING2_COPY_ARR4
,

335 
__STRING2_COPY_ARR5
,

336 
__STRING2_COPY_ARR6
,

337 
__STRING2_COPY_ARR7
,

338 
__STRING2_COPY_ARR8
, 
size_t
);

339 
__STRING_INLINE
 void *

340 
	$__mempcpy_small
 (void *
__dest
, char 
__src1
,

341 
__STRING2_COPY_ARR2
 
__src2
, 
__STRING2_COPY_ARR3
 
__src3
,

342 
__STRING2_COPY_ARR4
 
__src4
, 
__STRING2_COPY_ARR5
 
__src5
,

343 
__STRING2_COPY_ARR6
 
__src6
, 
__STRING2_COPY_ARR7
 
__src7
,

344 
__STRING2_COPY_ARR8
 
__src8
, 
size_t
 
__srclen
)

347 char 
__c
;

348 
__STRING2_COPY_ARR2
 
__sca2
;

349 
__STRING2_COPY_ARR3
 
__sca3
;

350 
__STRING2_COPY_ARR4
 
__sca4
;

351 
__STRING2_COPY_ARR5
 
__sca5
;

352 
__STRING2_COPY_ARR6
 
__sca6
;

353 
__STRING2_COPY_ARR7
 
__sca7
;

354 
__STRING2_COPY_ARR8
 
__sca8
;

355 } *
__u
 = 
__dest
;

356 switch ((unsigned int) 
__srclen
)

359 
__u
->
__c
 = 
__src1
;

362 
__extension__
 
__u
->
__sca2
 = 
__src2
;

365 
__extension__
 
__u
->
__sca3
 = 
__src3
;

368 
__extension__
 
__u
->
__sca4
 = 
__src4
;

371 
__extension__
 
__u
->
__sca5
 = 
__src5
;

374 
__extension__
 
__u
->
__sca6
 = 
__src6
;

377 
__extension__
 
__u
->
__sca7
 = 
__src7
;

380 
__extension__
 
__u
->
__sca8
 = 
__src8
;

383 return 
	`__extension__
 ((void *) 
__u
 + 
__srclen
);

384 
	}
}

392 #ifndef 
_HAVE_STRING_ARCH_strchr


393 extern void *
__rawmemchr
 (const void *
__s
, int 
__c
);

394 #if 
__GNUC_PREREQ
 (3, 2)

395 #define 
	#strchr
(
s
, 
c
) \

396 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) && !__builtin_constant_p (
s
) \

397 && (
c
) == '\0' \

398 ? (char *) 
	`__rawmemchr
 (
s
, 
c
) \

399 : 
	`__builtin_strchr
 (
s
, 
c
)))

	)

401 #define 
	#strchr
(
s
, 
c
) \

402 (
	`__extension__
 (
	`__builtin_constant_p
 (
c
) && (c) == '\0' \

403 ? (char *) 
	`__rawmemchr
 (
s
, 
c
) \

404 : 
	`strchr
 (
s
, 
c
)))

	)

410 #if (!
defined
 
_HAVE_STRING_ARCH_strcpy
 && !
__GNUC_PREREQ
 (3, 0)) \

411 || 
defined
 
	g_FORCE_INLINES


412 #if !
defined
 
_HAVE_STRING_ARCH_strcpy
 && !
__GNUC_PREREQ
 (3, 0)

413 #define 
	#strcpy
(
dest
, 
src
) \

414 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

415 ? (
	`__string2_1bptr_p
 (
src
) && 
	`strlen
 (src) + 1 <= 8 \

416 ? 
	`__strcpy_small
 (
dest
, 
	`__strcpy_args
 (
src
), \

417 
	`strlen
 (
src
) + 1) \

418 : (char *) 
	`memcpy
 (
dest
, 
src
, 
	`strlen
 (src) + 1)) \

419 : 
	`strcpy
 (
dest
, 
src
)))

	)

422 #if 
_STRING_ARCH_unaligned


423 #ifndef 
_FORCE_INLINES


424 #define 
	#__strcpy_args
(
src
) \

425 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 0), \

426 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 4), \

427 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 0), \

428 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 4)

	)

430 
__STRING_INLINE
 char *
__strcpy_small
 (char *, 
__uint16_t
, __uint16_t,

431 
__uint32_t
, __uint32_t, 
size_t
);

432 
__STRING_INLINE
 char *

433 
	$__strcpy_small
 (char *
__dest
,

434 
__uint16_t
 
__src0_2
, __uint16_t 
__src4_2
,

435 
__uint32_t
 
__src0_4
, __uint32_t 
__src4_4
,

436 
size_t
 
__srclen
)

439 
__uint32_t
 
__ui
;

440 
__uint16_t
 
__usi
;

441 unsigned char 
__uc
;

442 } *
__u
 = (void *) 
__dest
;

443 switch ((unsigned int) 
__srclen
)

446 
__u
->
__uc
 = '\0';

449 
__u
->
__usi
 = 
__src0_2
;

452 
__u
->
__usi
 = 
__src0_2
;

453 
__u
 = 
	`__extension__
 ((void *) __u + 2);

454 
__u
->
__uc
 = '\0';

457 
__u
->
__ui
 = 
__src0_4
;

460 
__u
->
__ui
 = 
__src0_4
;

461 
__u
 = 
	`__extension__
 ((void *) __u + 4);

462 
__u
->
__uc
 = '\0';

465 
__u
->
__ui
 = 
__src0_4
;

466 
__u
 = 
	`__extension__
 ((void *) __u + 4);

467 
__u
->
__usi
 = 
__src4_2
;

470 
__u
->
__ui
 = 
__src0_4
;

471 
__u
 = 
	`__extension__
 ((void *) __u + 4);

472 
__u
->
__usi
 = 
__src4_2
;

473 
__u
 = 
	`__extension__
 ((void *) __u + 2);

474 
__u
->
__uc
 = '\0';

477 
__u
->
__ui
 = 
__src0_4
;

478 
__u
 = 
	`__extension__
 ((void *) __u + 4);

479 
__u
->
__ui
 = 
__src4_4
;

482 return 
__dest
;

483 
	}
}

485 #ifndef 
_FORCE_INLINES


486 #define 
	#__strcpy_args
(
src
) \

487 
	`__extension__
 ((
__STRING2_COPY_ARR2
) \

488 { { ((const char *) (
src
))[0], '\0' } }), \

489 
	`__extension__
 ((
__STRING2_COPY_ARR3
) \

490 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

492 
	`__extension__
 ((
__STRING2_COPY_ARR4
) \

493 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

494 ((const char *) (
src
))[2], '\0' } }), \

495 
	`__extension__
 ((
__STRING2_COPY_ARR5
) \

496 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

497 ((const char *) (
src
))[2], ((const char *) (src))[3], \

499 
	`__extension__
 ((
__STRING2_COPY_ARR6
) \

500 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

501 ((const char *) (
src
))[2], ((const char *) (src))[3], \

502 ((const char *) (
src
))[4], '\0' } }), \

503 
	`__extension__
 ((
__STRING2_COPY_ARR7
) \

504 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

505 ((const char *) (
src
))[2], ((const char *) (src))[3], \

506 ((const char *) (
src
))[4], ((const char *) (src))[5], \

508 
	`__extension__
 ((
__STRING2_COPY_ARR8
) \

509 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

510 ((const char *) (
src
))[2], ((const char *) (src))[3], \

511 ((const char *) (
src
))[4], ((const char *) (src))[5], \

512 ((const char *) (
src
))[6], '\0' } })

	)

514 
__STRING_INLINE
 char *
__strcpy_small
 (char *, 
__STRING2_COPY_ARR2
,

515 
__STRING2_COPY_ARR3
,

516 
__STRING2_COPY_ARR4
,

517 
__STRING2_COPY_ARR5
,

518 
__STRING2_COPY_ARR6
,

519 
__STRING2_COPY_ARR7
,

520 
__STRING2_COPY_ARR8
, 
size_t
);

521 
__STRING_INLINE
 char *

522 
	$__strcpy_small
 (char *
__dest
,

523 
__STRING2_COPY_ARR2
 
__src2
, 
__STRING2_COPY_ARR3
 
__src3
,

524 
__STRING2_COPY_ARR4
 
__src4
, 
__STRING2_COPY_ARR5
 
__src5
,

525 
__STRING2_COPY_ARR6
 
__src6
, 
__STRING2_COPY_ARR7
 
__src7
,

526 
__STRING2_COPY_ARR8
 
__src8
, 
size_t
 
__srclen
)

529 char 
__c
;

530 
__STRING2_COPY_ARR2
 
__sca2
;

531 
__STRING2_COPY_ARR3
 
__sca3
;

532 
__STRING2_COPY_ARR4
 
__sca4
;

533 
__STRING2_COPY_ARR5
 
__sca5
;

534 
__STRING2_COPY_ARR6
 
__sca6
;

535 
__STRING2_COPY_ARR7
 
__sca7
;

536 
__STRING2_COPY_ARR8
 
__sca8
;

537 } *
__u
 = (void *) 
__dest
;

538 switch ((unsigned int) 
__srclen
)

541 
__u
->
__c
 = '\0';

544 
__extension__
 
__u
->
__sca2
 = 
__src2
;

547 
__extension__
 
__u
->
__sca3
 = 
__src3
;

550 
__extension__
 
__u
->
__sca4
 = 
__src4
;

553 
__extension__
 
__u
->
__sca5
 = 
__src5
;

556 
__extension__
 
__u
->
__sca6
 = 
__src6
;

559 
__extension__
 
__u
->
__sca7
 = 
__src7
;

562 
__extension__
 
__u
->
__sca8
 = 
__src8
;

565 return 
__dest
;

566 
	}
}

572 #ifdef 
__USE_GNU


573 #if !
defined
 
_HAVE_STRING_ARCH_stpcpy
 || defined 
_FORCE_INLINES


574 #ifndef 
_HAVE_STRING_ARCH_stpcpy


575 #if 
__GNUC_PREREQ
 (3, 4)

576 #define 
	#__stpcpy
(
dest
, 
src
) 
	`__builtin_stpcpy
 (dest, src)

	)

577 #elif 
__GNUC_PREREQ
 (3, 0)

578 #define 
	#__stpcpy
(
dest
, 
src
) \

579 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

580 ? (
	`__string2_1bptr_p
 (
src
) && 
	`strlen
 (src) + 1 <= 8 \

581 ? 
	`__builtin_strcpy
 (
dest
, 
src
) + 
	`strlen
 (src) \

582 : ((char *) (
__mempcpy
) (
dest
, 
src
, 
	`strlen
 (src) + 1) \

584 : 
	`__stpcpy
 (
dest
, 
src
)))

	)

586 #define 
	#__stpcpy
(
dest
, 
src
) \

587 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) \

588 ? (
	`__string2_1bptr_p
 (
src
) && 
	`strlen
 (src) + 1 <= 8 \

589 ? 
	`__stpcpy_small
 (
dest
, 
	`__stpcpy_args
 (
src
), \

590 
	`strlen
 (
src
) + 1) \

591 : ((char *) (
__mempcpy
) (
dest
, 
src
, 
	`strlen
 (src) + 1) \

593 : 
	`__stpcpy
 (
dest
, 
src
)))

	)

597 #define 
	#stpcpy
(
dest
, 
src
) 
	`__stpcpy
 (dest, src)

	)

600 #if !
__GNUC_PREREQ
 (3, 0) || 
defined
 
_FORCE_INLINES


601 #if 
_STRING_ARCH_unaligned


602 #ifndef 
_FORCE_INLINES


603 #define 
	#__stpcpy_args
(
src
) \

604 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 0), \

605 
__extension__
 
	`__STRING2_SMALL_GET16
 (
src
, 4), \

606 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 0), \

607 
__extension__
 
	`__STRING2_SMALL_GET32
 (
src
, 4)

	)

609 
__STRING_INLINE
 char *
__stpcpy_small
 (char *, 
__uint16_t
, __uint16_t,

610 
__uint32_t
, __uint32_t, 
size_t
);

611 
__STRING_INLINE
 char *

612 
	$__stpcpy_small
 (char *
__dest
,

613 
__uint16_t
 
__src0_2
, __uint16_t 
__src4_2
,

614 
__uint32_t
 
__src0_4
, __uint32_t 
__src4_4
,

615 
size_t
 
__srclen
)

618 unsigned int 
__ui
;

619 unsigned short int 
__usi
;

620 unsigned char 
__uc
;

621 char 
__c
;

622 } *
__u
 = (void *) 
__dest
;

623 switch ((unsigned int) 
__srclen
)

626 
__u
->
__uc
 = '\0';

629 
__u
->
__usi
 = 
__src0_2
;

630 
__u
 = 
	`__extension__
 ((void *) __u + 1);

633 
__u
->
__usi
 = 
__src0_2
;

634 
__u
 = 
	`__extension__
 ((void *) __u + 2);

635 
__u
->
__uc
 = '\0';

638 
__u
->
__ui
 = 
__src0_4
;

639 
__u
 = 
	`__extension__
 ((void *) __u + 3);

642 
__u
->
__ui
 = 
__src0_4
;

643 
__u
 = 
	`__extension__
 ((void *) __u + 4);

644 
__u
->
__uc
 = '\0';

647 
__u
->
__ui
 = 
__src0_4
;

648 
__u
 = 
	`__extension__
 ((void *) __u + 4);

649 
__u
->
__usi
 = 
__src4_2
;

650 
__u
 = 
	`__extension__
 ((void *) __u + 1);

653 
__u
->
__ui
 = 
__src0_4
;

654 
__u
 = 
	`__extension__
 ((void *) __u + 4);

655 
__u
->
__usi
 = 
__src4_2
;

656 
__u
 = 
	`__extension__
 ((void *) __u + 2);

657 
__u
->
__uc
 = '\0';

660 
__u
->
__ui
 = 
__src0_4
;

661 
__u
 = 
	`__extension__
 ((void *) __u + 4);

662 
__u
->
__ui
 = 
__src4_4
;

663 
__u
 = 
	`__extension__
 ((void *) __u + 3);

666 return &
__u
->
__c
;

667 
	}
}

669 #ifndef 
_FORCE_INLINES


670 #define 
	#__stpcpy_args
(
src
) \

671 
	`__extension__
 ((
__STRING2_COPY_ARR2
) \

672 { { ((const char *) (
src
))[0], '\0' } }), \

673 
	`__extension__
 ((
__STRING2_COPY_ARR3
) \

674 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

676 
	`__extension__
 ((
__STRING2_COPY_ARR4
) \

677 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

678 ((const char *) (
src
))[2], '\0' } }), \

679 
	`__extension__
 ((
__STRING2_COPY_ARR5
) \

680 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

681 ((const char *) (
src
))[2], ((const char *) (src))[3], \

683 
	`__extension__
 ((
__STRING2_COPY_ARR6
) \

684 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

685 ((const char *) (
src
))[2], ((const char *) (src))[3], \

686 ((const char *) (
src
))[4], '\0' } }), \

687 
	`__extension__
 ((
__STRING2_COPY_ARR7
) \

688 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

689 ((const char *) (
src
))[2], ((const char *) (src))[3], \

690 ((const char *) (
src
))[4], ((const char *) (src))[5], \

692 
	`__extension__
 ((
__STRING2_COPY_ARR8
) \

693 { { ((const char *) (
src
))[0], ((const char *) (src))[1], \

694 ((const char *) (
src
))[2], ((const char *) (src))[3], \

695 ((const char *) (
src
))[4], ((const char *) (src))[5], \

696 ((const char *) (
src
))[6], '\0' } })

	)

698 
__STRING_INLINE
 char *
__stpcpy_small
 (char *, 
__STRING2_COPY_ARR2
,

699 
__STRING2_COPY_ARR3
,

700 
__STRING2_COPY_ARR4
,

701 
__STRING2_COPY_ARR5
,

702 
__STRING2_COPY_ARR6
,

703 
__STRING2_COPY_ARR7
,

704 
__STRING2_COPY_ARR8
, 
size_t
);

705 
__STRING_INLINE
 char *

706 
	$__stpcpy_small
 (char *
__dest
,

707 
__STRING2_COPY_ARR2
 
__src2
, 
__STRING2_COPY_ARR3
 
__src3
,

708 
__STRING2_COPY_ARR4
 
__src4
, 
__STRING2_COPY_ARR5
 
__src5
,

709 
__STRING2_COPY_ARR6
 
__src6
, 
__STRING2_COPY_ARR7
 
__src7
,

710 
__STRING2_COPY_ARR8
 
__src8
, 
size_t
 
__srclen
)

713 char 
__c
;

714 
__STRING2_COPY_ARR2
 
__sca2
;

715 
__STRING2_COPY_ARR3
 
__sca3
;

716 
__STRING2_COPY_ARR4
 
__sca4
;

717 
__STRING2_COPY_ARR5
 
__sca5
;

718 
__STRING2_COPY_ARR6
 
__sca6
;

719 
__STRING2_COPY_ARR7
 
__sca7
;

720 
__STRING2_COPY_ARR8
 
__sca8
;

721 } *
__u
 = (void *) 
__dest
;

722 switch ((unsigned int) 
__srclen
)

725 
__u
->
__c
 = '\0';

728 
__extension__
 
__u
->
__sca2
 = 
__src2
;

731 
__extension__
 
__u
->
__sca3
 = 
__src3
;

734 
__extension__
 
__u
->
__sca4
 = 
__src4
;

737 
__extension__
 
__u
->
__sca5
 = 
__src5
;

740 
__extension__
 
__u
->
__sca6
 = 
__src6
;

743 
__extension__
 
__u
->
__sca7
 = 
__src7
;

746 
__extension__
 
__u
->
__sca8
 = 
__src8
;

749 return 
__dest
 + 
__srclen
 - 1;

750 
	}
}

758 #ifndef 
_HAVE_STRING_ARCH_strncpy


759 #if 
__GNUC_PREREQ
 (3, 2)

760 #define 
	#strncpy
(
dest
, 
src
, 
n
) 
	`__builtin_strncpy
 (dest, src, n)

	)

762 #define 
	#strncpy
(
dest
, 
src
, 
n
) \

763 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

764 ? (
	`strlen
 (
src
) + 1 >= ((
size_t
) (
n
)) \

765 ? (char *) 
	`memcpy
 (
dest
, 
src
, 
n
) \

766 : 
	`strncpy
 (
dest
, 
src
, 
n
)) \

767 : 
	`strncpy
 (
dest
, 
src
, 
n
)))

	)

773 #ifndef 
_HAVE_STRING_ARCH_strncat


774 #ifdef 
_USE_STRING_ARCH_strchr


775 #define 
	#strncat
(
dest
, 
src
, 
n
) \

776 (
	`__extension__
 ({ char *
__dest
 = (
dest
); \

777 
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

778 ? (
	`strlen
 (
src
) < ((
size_t
) (
n
)) \

779 ? 
	`strcat
 (
__dest
, 
src
) \

780 : (*((char *) 
	`__mempcpy
 (
	`strchr
 (
__dest
, '\0'), \

781 
src
, 
n
)) = '\0', 
__dest
)) \

782 : 
	`strncat
 (
dest
, 
src
, 
n
); }))

	)

783 #elif 
__GNUC_PREREQ
 (3, 2)

784 #define 
	#strncat
(
dest
, 
src
, 
n
) 
	`__builtin_strncat
 (dest, src, n)

	)

786 #define 
	#strncat
(
dest
, 
src
, 
n
) \

787 (
	`__extension__
 (
	`__builtin_constant_p
 (
src
) && __builtin_constant_p (
n
) \

788 ? (
	`strlen
 (
src
) < ((
size_t
) (
n
)) \

789 ? 
	`strcat
 (
dest
, 
src
) \

790 : 
	`strncat
 (
dest
, 
src
, 
n
)) \

791 : 
	`strncat
 (
dest
, 
src
, 
n
)))

	)

797 #ifndef 
_HAVE_STRING_ARCH_strcmp


798 #if 
__GNUC_PREREQ
 (3, 2)

799 #define 
	#strcmp
(
s1
, 
s2
) \

800 
__extension__
 \

801 ({ 
size_t
 
__s1_len
, 
__s2_len
; \

802 (
	`__builtin_constant_p
 (
s1
) && __builtin_constant_p (
s2
) \

803 && (
__s1_len
 = 
	`__builtin_strlen
 (
s1
), 
__s2_len
 = __builtin_strlen (
s2
), \

804 (!
	`__string2_1bptr_p
 (
s1
) || 
__s1_len
 >= 4) \

805 && (!
	`__string2_1bptr_p
 (
s2
) || 
__s2_len
 >= 4)) \

806 ? 
	`__builtin_strcmp
 (
s1
, 
s2
) \

807 : (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

808 && (
__s1_len
 = 
	`__builtin_strlen
 (
s1
), __s1_len < 4) \

809 ? (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

810 ? 
	`__builtin_strcmp
 (
s1
, 
s2
) \

811 : 
	`__strcmp_cg
 (
s1
, 
s2
, 
__s1_len
)) \

812 : (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

813 && (
__s2_len
 = 
	`__builtin_strlen
 (
s2
), __s2_len < 4) \

814 ? (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

815 ? 
	`__builtin_strcmp
 (
s1
, 
s2
) \

816 : 
	`__strcmp_gc
 (
s1
, 
s2
, 
__s2_len
)) \

817 : 
	`__builtin_strcmp
 (
s1
, 
s2
)))); })

	)

819 #define 
	#strcmp
(
s1
, 
s2
) \

820 
__extension__
 \

821 ({ 
size_t
 
__s1_len
, 
__s2_len
; \

822 (
	`__builtin_constant_p
 (
s1
) && __builtin_constant_p (
s2
) \

823 && (
__s1_len
 = 
	`strlen
 (
s1
), 
__s2_len
 = strlen (
s2
), \

824 (!
	`__string2_1bptr_p
 (
s1
) || 
__s1_len
 >= 4) \

825 && (!
	`__string2_1bptr_p
 (
s2
) || 
__s2_len
 >= 4)) \

826 ? 
	`memcmp
 ((const char *) (
s1
), (const char *) (
s2
), \

827 (
__s1_len
 < 
__s2_len
 ? __s1_len : __s2_len) + 1) \

828 : (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

829 && (
__s1_len
 = 
	`strlen
 (
s1
), __s1_len < 4) \

830 ? (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

831 ? 
	`__strcmp_cc
 (
s1
, 
s2
, 
__s1_len
) \

832 : 
	`__strcmp_cg
 (
s1
, 
s2
, 
__s1_len
)) \

833 : (
	`__builtin_constant_p
 (
s2
) && 
	`__string2_1bptr_p
 (s2) \

834 && (
__s2_len
 = 
	`strlen
 (
s2
), __s2_len < 4) \

835 ? (
	`__builtin_constant_p
 (
s1
) && 
	`__string2_1bptr_p
 (s1) \

836 ? 
	`__strcmp_cc
 (
s1
, 
s2
, 
__s2_len
) \

837 : 
	`__strcmp_gc
 (
s1
, 
s2
, 
__s2_len
)) \

838 : 
	`strcmp
 (
s1
, 
s2
)))); })

	)

841 #define 
	#__strcmp_cc
(
s1
, 
s2
, 
l
) \

842 (
	`__extension__
 ({ int 
__result
 = \

843 (((const unsigned char *) (const char *) (
s1
))[0] \

844 - ((const unsigned char *) (const char *)(
s2
))[0]); \

845 if (
l
 > 0 && 
__result
 == 0) \

847 
__result
 = (((const unsigned char *) \

848 (const char *) (
s1
))[1] \

850 (const char *) (
s2
))[1]); \

851 if (
l
 > 1 && 
__result
 == 0) \

853 
__result
 = \

855 (const char *) (
s1
))[2] \

857 (const char *) (
s2
))[2]); \

858 if (
l
 > 2 && 
__result
 == 0) \

859 
__result
 = \

861 (const char *) (
s1
))[3] \

863 (const char *) (
s2
))[3]); \

866 
__result
; }))

	)

868 #define 
	#__strcmp_cg
(
s1
, 
s2
, 
l1
) \

869 (
	`__extension__
 ({ const unsigned char *
__s2
 = \

870 (const unsigned char *) (const char *) (
s2
); \

871 int 
__result
 = \

872 (((const unsigned char *) (const char *) (
s1
))[0] \

873 - 
__s2
[0]); \

874 if (
l1
 > 0 && 
__result
 == 0) \

876 
__result
 = (((const unsigned char *) \

877 (const char *) (
s1
))[1] - 
__s2
[1]); \

878 if (
l1
 > 1 && 
__result
 == 0) \

880 
__result
 = (((const unsigned char *) \

881 (const char *) (
s1
))[2] - 
__s2
[2]); \

882 if (
l1
 > 2 && 
__result
 == 0) \

883 
__result
 = (((const unsigned char *) \

884 (const char *) (
s1
))[3] \

885 - 
__s2
[3]); \

888 
__result
; }))

	)

890 #define 
	#__strcmp_gc
(
s1
, 
s2
, 
l2
) (- 
	`__strcmp_cg
 (s2, s1, l2))

	)

895 #ifndef 
_HAVE_STRING_ARCH_strncmp


896 #define 
	#strncmp
(
s1
, 
s2
, 
n
) \

897 (
	`__extension__
 (
	`__builtin_constant_p
 (
n
) \

898 && ((
	`__builtin_constant_p
 (
s1
) \

899 && 
	`strlen
 (
s1
) < ((
size_t
) (
n
))) \

900 || (
	`__builtin_constant_p
 (
s2
) \

901 && 
	`strlen
 (
s2
) < ((
size_t
) (
n
)))) \

902 ? 
	`strcmp
 (
s1
, 
s2
) : 
	`strncmp
 (s1, s2, 
n
)))

	)

908 #if !
defined
 
_HAVE_STRING_ARCH_strcspn
 || defined 
_FORCE_INLINES


909 #ifndef 
_HAVE_STRING_ARCH_strcspn


910 #if 
__GNUC_PREREQ
 (3, 2)

911 #define 
	#strcspn
(
s
, 
reject
) \

912 
__extension__
 \

913 ({ char 
__r0
, 
__r1
, 
__r2
; \

914 (
	`__builtin_constant_p
 (
reject
) && 
	`__string2_1bptr_p
 (reject) \

915 ? ((
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s)) \

916 ? 
	`__builtin_strcspn
 (
s
, 
reject
) \

917 : ((
__r0
 = ((const char *) (
reject
))[0], __r0 == '\0') \

918 ? 
	`strlen
 (
s
) \

919 : ((
__r1
 = ((const char *) (
reject
))[1], __r1 == '\0') \

920 ? 
	`__strcspn_c1
 (
s
, 
__r0
) \

921 : ((
__r2
 = ((const char *) (
reject
))[2], __r2 == '\0') \

922 ? 
	`__strcspn_c2
 (
s
, 
__r0
, 
__r1
) \

923 : (((const char *) (
reject
))[3] == '\0' \

924 ? 
	`__strcspn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

925 : 
	`__builtin_strcspn
 (
s
, 
reject
)))))) \

926 : 
	`__builtin_strcspn
 (
s
, 
reject
)); })

	)

928 #define 
	#strcspn
(
s
, 
reject
) \

929 
__extension__
 \

930 ({ char 
__r0
, 
__r1
, 
__r2
; \

931 (
	`__builtin_constant_p
 (
reject
) && 
	`__string2_1bptr_p
 (reject) \

932 ? ((
__r0
 = ((const char *) (
reject
))[0], __r0 == '\0') \

933 ? 
	`strlen
 (
s
) \

934 : ((
__r1
 = ((const char *) (
reject
))[1], __r1 == '\0') \

935 ? 
	`__strcspn_c1
 (
s
, 
__r0
) \

936 : ((
__r2
 = ((const char *) (
reject
))[2], __r2 == '\0') \

937 ? 
	`__strcspn_c2
 (
s
, 
__r0
, 
__r1
) \

938 : (((const char *) (
reject
))[3] == '\0' \

939 ? 
	`__strcspn_c3
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

940 : 
	`strcspn
 (
s
, 
reject
))))) \

941 : 
	`strcspn
 (
s
, 
reject
)); })

	)

945 
__STRING_INLINE
 
size_t
 
__strcspn_c1
 (const char *
__s
, int 
__reject
);

946 
__STRING_INLINE
 
size_t


947 
	$__strcspn_c1
 (const char *
__s
, int 
__reject
)

949 
size_t
 
__result
 = 0;

950 while (
__s
[
__result
] != '\0' && __s[__result] != 
__reject
)

951 ++
__result
;

952 return 
__result
;

953 
	}
}

955 
__STRING_INLINE
 
size_t
 
__strcspn_c2
 (const char *
__s
, int 
__reject1
,

956 int 
__reject2
);

957 
__STRING_INLINE
 
size_t


958 
	$__strcspn_c2
 (const char *
__s
, int 
__reject1
, int 
__reject2
)

960 
size_t
 
__result
 = 0;

961 while (
__s
[
__result
] != '\0' && __s[__result] != 
__reject1


962 && 
__s
[
__result
] != 
__reject2
)

963 ++
__result
;

964 return 
__result
;

965 
	}
}

967 
__STRING_INLINE
 
size_t
 
__strcspn_c3
 (const char *
__s
, int 
__reject1
,

968 int 
__reject2
, int 
__reject3
);

969 
__STRING_INLINE
 
size_t


970 
	$__strcspn_c3
 (const char *
__s
, int 
__reject1
, int 
__reject2
,

971 int 
__reject3
)

973 
size_t
 
__result
 = 0;

974 while (
__s
[
__result
] != '\0' && __s[__result] != 
__reject1


975 && 
__s
[
__result
] != 
__reject2
 && __s[__result] != 
__reject3
)

976 ++
__result
;

977 return 
__result
;

978 
	}
}

984 #if !
defined
 
_HAVE_STRING_ARCH_strspn
 || defined 
_FORCE_INLINES


985 #ifndef 
_HAVE_STRING_ARCH_strspn


986 #if 
__GNUC_PREREQ
 (3, 2)

987 #define 
	#strspn
(
s
, 
accept
) \

988 
__extension__
 \

989 ({ char 
__a0
, 
__a1
, 
__a2
; \

990 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

991 ? ((
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s)) \

992 ? 
	`__builtin_strspn
 (
s
, 
accept
) \

993 : ((
__a0
 = ((const char *) (
accept
))[0], __a0 == '\0') \

994 ? ((void) (
s
), (
size_t
) 0) \

995 : ((
__a1
 = ((const char *) (
accept
))[1], __a1 == '\0') \

996 ? 
	`__strspn_c1
 (
s
, 
__a0
) \

997 : ((
__a2
 = ((const char *) (
accept
))[2], __a2 == '\0') \

998 ? 
	`__strspn_c2
 (
s
, 
__a0
, 
__a1
) \

999 : (((const char *) (
accept
))[3] == '\0' \

1000 ? 
	`__strspn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1001 : 
	`__builtin_strspn
 (
s
, 
accept
)))))) \

1002 : 
	`__builtin_strspn
 (
s
, 
accept
)); })

	)

1004 #define 
	#strspn
(
s
, 
accept
) \

1005 
__extension__
 \

1006 ({ char 
__a0
, 
__a1
, 
__a2
; \

1007 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

1008 ? ((
__a0
 = ((const char *) (
accept
))[0], __a0 == '\0') \

1009 ? ((void) (
s
), (
size_t
) 0) \

1010 : ((
__a1
 = ((const char *) (
accept
))[1], __a1 == '\0') \

1011 ? 
	`__strspn_c1
 (
s
, 
__a0
) \

1012 : ((
__a2
 = ((const char *) (
accept
))[2], __a2 == '\0') \

1013 ? 
	`__strspn_c2
 (
s
, 
__a0
, 
__a1
) \

1014 : (((const char *) (
accept
))[3] == '\0' \

1015 ? 
	`__strspn_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1016 : 
	`strspn
 (
s
, 
accept
))))) \

1017 : 
	`strspn
 (
s
, 
accept
)); })

	)

1021 
__STRING_INLINE
 
size_t
 
__strspn_c1
 (const char *
__s
, int 
__accept
);

1022 
__STRING_INLINE
 
size_t


1023 
	$__strspn_c1
 (const char *
__s
, int 
__accept
)

1025 
size_t
 
__result
 = 0;

1027 while (
__s
[
__result
] == 
__accept
)

1028 ++
__result
;

1029 return 
__result
;

1030 
	}
}

1032 
__STRING_INLINE
 
size_t
 
__strspn_c2
 (const char *
__s
, int 
__accept1
,

1033 int 
__accept2
);

1034 
__STRING_INLINE
 
size_t


1035 
	$__strspn_c2
 (const char *
__s
, int 
__accept1
, int 
__accept2
)

1037 
size_t
 
__result
 = 0;

1039 while (
__s
[
__result
] == 
__accept1
 || __s[__result] == 
__accept2
)

1040 ++
__result
;

1041 return 
__result
;

1042 
	}
}

1044 
__STRING_INLINE
 
size_t
 
__strspn_c3
 (const char *
__s
, int 
__accept1
,

1045 int 
__accept2
, int 
__accept3
);

1046 
__STRING_INLINE
 
size_t


1047 
	$__strspn_c3
 (const char *
__s
, int 
__accept1
, int 
__accept2
, int 
__accept3
)

1049 
size_t
 
__result
 = 0;

1051 while (
__s
[
__result
] == 
__accept1
 || __s[__result] == 
__accept2


1052 || 
__s
[
__result
] == 
__accept3
)

1053 ++
__result
;

1054 return 
__result
;

1055 
	}
}

1060 #if !
defined
 
_HAVE_STRING_ARCH_strpbrk
 || defined 
_FORCE_INLINES


1061 #ifndef 
_HAVE_STRING_ARCH_strpbrk


1062 #if 
__GNUC_PREREQ
 (3, 2)

1063 #define 
	#strpbrk
(
s
, 
accept
) \

1064 
__extension__
 \

1065 ({ char 
__a0
, 
__a1
, 
__a2
; \

1066 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

1067 ? ((
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s)) \

1068 ? 
	`__builtin_strpbrk
 (
s
, 
accept
) \

1069 : ((
__a0
 = ((const char *) (
accept
))[0], __a0 == '\0') \

1070 ? ((void) (
s
), (char *) 
NULL
) \

1071 : ((
__a1
 = ((const char *) (
accept
))[1], __a1 == '\0') \

1072 ? 
	`__builtin_strchr
 (
s
, 
__a0
) \

1073 : ((
__a2
 = ((const char *) (
accept
))[2], __a2 == '\0') \

1074 ? 
	`__strpbrk_c2
 (
s
, 
__a0
, 
__a1
) \

1075 : (((const char *) (
accept
))[3] == '\0' \

1076 ? 
	`__strpbrk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1077 : 
	`__builtin_strpbrk
 (
s
, 
accept
)))))) \

1078 : 
	`__builtin_strpbrk
 (
s
, 
accept
)); })

	)

1080 #define 
	#strpbrk
(
s
, 
accept
) \

1081 
__extension__
 \

1082 ({ char 
__a0
, 
__a1
, 
__a2
; \

1083 (
	`__builtin_constant_p
 (
accept
) && 
	`__string2_1bptr_p
 (accept) \

1084 ? ((
__a0
 = ((const char *) (
accept
))[0], __a0 == '\0') \

1085 ? ((void) (
s
), (char *) 
NULL
) \

1086 : ((
__a1
 = ((const char *) (
accept
))[1], __a1 == '\0') \

1087 ? 
	`strchr
 (
s
, 
__a0
) \

1088 : ((
__a2
 = ((const char *) (
accept
))[2], __a2 == '\0') \

1089 ? 
	`__strpbrk_c2
 (
s
, 
__a0
, 
__a1
) \

1090 : (((const char *) (
accept
))[3] == '\0' \

1091 ? 
	`__strpbrk_c3
 (
s
, 
__a0
, 
__a1
, 
__a2
) \

1092 : 
	`strpbrk
 (
s
, 
accept
))))) \

1093 : 
	`strpbrk
 (
s
, 
accept
)); })

	)

1097 
__STRING_INLINE
 char *
__strpbrk_c2
 (const char *
__s
, int 
__accept1
,

1098 int 
__accept2
);

1099 
__STRING_INLINE
 char *

1100 
	$__strpbrk_c2
 (const char *
__s
, int 
__accept1
, int 
__accept2
)

1103 while (*
__s
 != '\0' && *__s != 
__accept1
 && *__s != 
__accept2
)

1104 ++
__s
;

1105 return *
__s
 == '\0' ? 
NULL
 : (char *) (
size_t
) __s;

1106 
	}
}

1108 
__STRING_INLINE
 char *
__strpbrk_c3
 (const char *
__s
, int 
__accept1
,

1109 int 
__accept2
, int 
__accept3
);

1110 
__STRING_INLINE
 char *

1111 
	$__strpbrk_c3
 (const char *
__s
, int 
__accept1
, int 
__accept2
, int 
__accept3
)

1114 while (*
__s
 != '\0' && *__s != 
__accept1
 && *__s != 
__accept2


1115 && *
__s
 != 
__accept3
)

1116 ++
__s
;

1117 return *
__s
 == '\0' ? 
NULL
 : (char *) (
size_t
) __s;

1118 
	}
}

1124 #if !
defined
 
_HAVE_STRING_ARCH_strstr
 && !
__GNUC_PREREQ
 (2, 97)

1125 #define 
	#strstr
(
haystack
, 
needle
) \

1126 (
	`__extension__
 (
	`__builtin_constant_p
 (
needle
) && 
	`__string2_1bptr_p
 (needle) \

1127 ? (((const char *) (
needle
))[0] == '\0' \

1128 ? (char *) (
size_t
) (
haystack
) \

1129 : (((const char *) (
needle
))[1] == '\0' \

1130 ? 
	`strchr
 (
haystack
, \

1131 ((const char *) (
needle
))[0]) \

1132 : 
	`strstr
 (
haystack
, 
needle
))) \

1133 : 
	`strstr
 (
haystack
, 
needle
)))

	)

1137 #if !
defined
 
_HAVE_STRING_ARCH_strtok_r
 || defined 
_FORCE_INLINES


1138 #ifndef 
_HAVE_STRING_ARCH_strtok_r


1139 #define 
	#__strtok_r
(
s
, 
sep
, 
nextp
) \

1140 (
	`__extension__
 (
	`__builtin_constant_p
 (
sep
) && 
	`__string2_1bptr_p
 (sep) \

1141 && ((const char *) (
sep
))[0] != '\0' \

1142 && ((const char *) (
sep
))[1] == '\0' \

1143 ? 
	`__strtok_r_1c
 (
s
, ((const char *) (
sep
))[0], 
nextp
) \

1144 : 
	`__strtok_r
 (
s
, 
sep
, 
nextp
)))

	)

1147 
__STRING_INLINE
 char *
__strtok_r_1c
 (char *
__s
, char 
__sep
, char **
__nextp
);

1148 
__STRING_INLINE
 char *

1149 
	$__strtok_r_1c
 (char *
__s
, char 
__sep
, char **
__nextp
)

1151 char *
__result
;

1152 if (
__s
 == 
NULL
)

1153 
__s
 = *
__nextp
;

1154 while (*
__s
 == 
__sep
)

1155 ++
__s
;

1156 
__result
 = 
NULL
;

1157 if (*
__s
 != '\0')

1159 
__result
 = 
__s
++;

1160 while (*
__s
 != '\0')

1161 if (*
__s
++ == 
__sep
)

1163 
__s
[-1] = '\0';

1167 *
__nextp
 = 
__s
;

1168 return 
__result
;

1169 
	}
}

1170 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


1171 #define 
	#strtok_r
(
s
, 
sep
, 
nextp
) 
	`__strtok_r
 (s, sep, nextp)

	)

1176 #if !
defined
 
_HAVE_STRING_ARCH_strsep
 || defined 
_FORCE_INLINES


1177 #ifndef 
_HAVE_STRING_ARCH_strsep


1179 extern char *
__strsep_g
 (char **
__stringp
, const char *
__delim
);

1180 #define 
	#__strsep
(
s
, 
reject
) \

1181 
__extension__
 \

1182 ({ char 
__r0
, 
__r1
, 
__r2
; \

1183 (
	`__builtin_constant_p
 (
reject
) && 
	`__string2_1bptr_p
 (reject) \

1184 && (
__r0
 = ((const char *) (
reject
))[0], \

1185 ((const char *) (
reject
))[0] != '\0') \

1186 ? ((
__r1
 = ((const char *) (
reject
))[1], \

1187 ((const char *) (
reject
))[1] == '\0') \

1188 ? 
	`__strsep_1c
 (
s
, 
__r0
) \

1189 : ((
__r2
 = ((const char *) (
reject
))[2], __r2 == '\0') \

1190 ? 
	`__strsep_2c
 (
s
, 
__r0
, 
__r1
) \

1191 : (((const char *) (
reject
))[3] == '\0' \

1192 ? 
	`__strsep_3c
 (
s
, 
__r0
, 
__r1
, 
__r2
) \

1193 : 
	`__strsep_g
 (
s
, 
reject
)))) \

1194 : 
	`__strsep_g
 (
s
, 
reject
)); })

	)

1197 
__STRING_INLINE
 char *
__strsep_1c
 (char **
__s
, char 
__reject
);

1198 
__STRING_INLINE
 char *

1199 
	$__strsep_1c
 (char **
__s
, char 
__reject
)

1201 char *
__retval
 = *
__s
;

1202 if (
__retval
 != 
NULL
 && (*
__s
 = 
	`strchr
 (__retval, 
__reject
)) != NULL)

1203 *(*
__s
)++ = '\0';

1204 return 
__retval
;

1205 
	}
}

1207 
__STRING_INLINE
 char *
__strsep_2c
 (char **
__s
, char 
__reject1
, char 
__reject2
);

1208 
__STRING_INLINE
 char *

1209 
	$__strsep_2c
 (char **
__s
, char 
__reject1
, char 
__reject2
)

1211 char *
__retval
 = *
__s
;

1212 if (
__retval
 != 
NULL
)

1214 char *
__cp
 = 
__retval
;

1217 if (*
__cp
 == '\0')

1219 
__cp
 = 
NULL
;

1222 if (*
__cp
 == 
__reject1
 || *__cp == 
__reject2
)

1224 *
__cp
++ = '\0';

1227 ++
__cp
;

1229 *
__s
 = 
__cp
;

1231 return 
__retval
;

1232 
	}
}

1234 
__STRING_INLINE
 char *
__strsep_3c
 (char **
__s
, char 
__reject1
, char 
__reject2
,

1235 char 
__reject3
);

1236 
__STRING_INLINE
 char *

1237 
	$__strsep_3c
 (char **
__s
, char 
__reject1
, char 
__reject2
, char 
__reject3
)

1239 char *
__retval
 = *
__s
;

1240 if (
__retval
 != 
NULL
)

1242 char *
__cp
 = 
__retval
;

1245 if (*
__cp
 == '\0')

1247 
__cp
 = 
NULL
;

1250 if (*
__cp
 == 
__reject1
 || *__cp == 
__reject2
 || *__cp == 
__reject3
)

1252 *
__cp
++ = '\0';

1255 ++
__cp
;

1257 *
__s
 = 
__cp
;

1259 return 
__retval
;

1260 
	}
}

1261 #ifdef 
__USE_BSD


1262 #define 
	#strsep
(
s
, 
reject
) 
	`__strsep
 (s, reject)

	)

1269 #ifdef 
__USE_MISC


1271 #if !
defined
 
_HAVE_STRING_ARCH_strdup
 || !defined 
_HAVE_STRING_ARCH_strndup


1272 #define 
	#__need_malloc_and_calloc


	)

1273 #include 
	~<stdlib.h
>

1276 #ifndef 
_HAVE_STRING_ARCH_strdup


1278 extern char *
	$__strdup
 (const char *
__string
) 
__THROW
 
__attribute_malloc__
;

1279 #define 
	#__strdup
(
s
) \

1280 (
	`__extension__
 (
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s) \

1281 ? (((const char *) (
s
))[0] == '\0' \

1282 ? (char *) 
	`calloc
 ((
size_t
) 1, (size_t) 1) \

1283 : ({ 
size_t
 
__len
 = 
	`strlen
 (
s
) + 1; \

1284 char *
__retval
 = (char *) 
	`malloc
 (
__len
); \

1285 if (
__retval
 != 
NULL
) \

1286 
__retval
 = (char *) 
	`memcpy
 (__retval, 
s
, 
__len
); \

1287 
__retval
; 
	}
})) \

1288 : 
	`__strdup
 (
s
)))

	)

1290 #if 
defined
 
__USE_SVID
 || defined 
__USE_BSD
 || defined 
__USE_XOPEN_EXTENDED


1291 #define 
	#strdup
(
s
) 
	`__strdup
 (s)

	)

1295 #ifndef 
_HAVE_STRING_ARCH_strndup


1297 extern char *
	$__strndup
 (const char *
__string
, 
size_t
 
__n
)

1298 
__THROW
 
__attribute_malloc__
;

1299 #define 
	#__strndup
(
s
, 
n
) \

1300 (
	`__extension__
 (
	`__builtin_constant_p
 (
s
) && 
	`__string2_1bptr_p
 (s) \

1301 ? (((const char *) (
s
))[0] == '\0' \

1302 ? (char *) 
	`calloc
 ((
size_t
) 1, (size_t) 1) \

1303 : ({ 
size_t
 
__len
 = 
	`strlen
 (
s
) + 1; \

1304 
size_t
 
__n
 = (
n
); \

1305 char *
__retval
; \

1306 if (
__n
 < 
__len
) \

1307 
__len
 = 
__n
 + 1; \

1308 
__retval
 = (char *) 
	`malloc
 (
__len
); \

1309 if (
__retval
 != 
NULL
) \

1311 
__retval
[
__len
 - 1] = '\0'; \

1312 
__retval
 = (char *) 
	`memcpy
 (__retval, 
s
, \

1313 
__len
 - 1); \

1315 
__retval
; 
	}
})) \

1316 : 
	`__strndup
 (
s
, 
n
)))

	)

1318 #ifdef 
__USE_GNU


1319 #define 
	#strndup
(
s
, 
n
) 
	`__strndup
 (s, n)

	)

1325 #ifndef 
_FORCE_INLINES


1326 #undef 
__STRING_INLINE


	@/usr/include/bits/string3.h

18 #ifndef 
_STRING_H


22 
__warndecl
 (
__warn_memset_zero_len
,

25 #ifndef 
__cplusplus


29 #undef 
memcpy


30 #undef 
memmove


31 #undef 
memset


32 #undef 
strcat


33 #undef 
strcpy


34 #undef 
strncat


35 #undef 
strncpy


36 #ifdef 
__USE_GNU


37 #undef 
mempcpy


38 #undef 
stpcpy


40 #ifdef 
__USE_BSD


41 #undef 
bcopy


42 #undef 
bzero


47 
__fortify_function
 void *

48 
__NTH
 (
	$memcpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

49 
size_t
 
__len
))

51 return 
	`__builtin___memcpy_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

52 
	}
}

54 
__fortify_function
 void *

55 
__NTH
 (
	$memmove
 (void *
__dest
, const void *
__src
, 
size_t
 
__len
))

57 return 
	`__builtin___memmove_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

58 
	}
}

60 #ifdef 
__USE_GNU


61 
__fortify_function
 void *

62 
__NTH
 (
	$mempcpy
 (void *
__restrict
 
__dest
, const void *__restrict 
__src
,

63 
size_t
 
__len
))

65 return 
	`__builtin___mempcpy_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

66 
	}
}

75 
__fortify_function
 void *

76 
__NTH
 (
	$memset
 (void *
__dest
, int 
__ch
, 
size_t
 
__len
))

78 if (
	`__builtin_constant_p
 (
__len
) && __len == 0

79 && (!
	`__builtin_constant_p
 (
__ch
) || __ch != 0))

81 
	`__warn_memset_zero_len
 ();

82 return 
__dest
;

84 return 
	`__builtin___memset_chk
 (
__dest
, 
__ch
, 
__len
, 
	`__bos0
 (__dest));

85 
	}
}

87 #ifdef 
__USE_BSD


88 
__fortify_function
 void

89 
__NTH
 (
	$bcopy
 (const void *
__src
, void *
__dest
, 
size_t
 
__len
))

91 (void) 
	`__builtin___memmove_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos0
 (__dest));

92 
	}
}

94 
__fortify_function
 void

95 
__NTH
 (
	$bzero
 (void *
__dest
, 
size_t
 
__len
))

97 (void) 
	`__builtin___memset_chk
 (
__dest
, '\0', 
__len
, 
	`__bos0
 (__dest));

98 
	}
}

101 
__fortify_function
 char *

102 
__NTH
 (
	$strcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
))

104 return 
	`__builtin___strcpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest));

105 
	}
}

107 #ifdef 
__USE_GNU


108 
__fortify_function
 char *

109 
__NTH
 (
	$stpcpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
))

111 return 
	`__builtin___stpcpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest));

112 
	}
}

116 
__fortify_function
 char *

117 
__NTH
 (
	$strncpy
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
,

118 
size_t
 
__len
))

120 return 
	`__builtin___strncpy_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos
 (__dest));

121 
	}
}

124 extern char *
	$__stpncpy_chk
 (char *
__dest
, const char *
__src
, 
size_t
 
__n
,

125 
size_t
 
__destlen
) 
__THROW
;

126 extern char *
	`__REDIRECT_NTH
 (
__stpncpy_alias
, (char *
__dest
, const char *
__src
,

127 
size_t
 
__n
), 
stpncpy
);

129 
__fortify_function
 char *

130 
	`__NTH
 (
	$stpncpy
 (char *
__dest
, const char *
__src
, 
size_t
 
__n
))

132 if (
	`__bos
 (
__dest
) != (
size_t
) -1

133 && (!
	`__builtin_constant_p
 (
__n
) || __n <= 
	`__bos
 (
__dest
)))

134 return 
	`__stpncpy_chk
 (
__dest
, 
__src
, 
__n
, 
	`__bos
 (__dest));

135 return 
	`__stpncpy_alias
 (
__dest
, 
__src
, 
__n
);

136 
	}
}

139 
__fortify_function
 char *

140 
__NTH
 (
	$strcat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
))

142 return 
	`__builtin___strcat_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest));

143 
	}
}

146 
__fortify_function
 char *

147 
__NTH
 (
	$strncat
 (char *
__restrict
 
__dest
, const char *__restrict 
__src
,

148 
size_t
 
__len
))

150 return 
	`__builtin___strncat_chk
 (
__dest
, 
__src
, 
__len
, 
	`__bos
 (__dest));

151 
	}
}

	@/usr/include/bits/sys_errlist.h

19 #ifndef 
_STDIO_H


25 #ifdef 
__USE_BSD


26 extern int 
sys_nerr
;

27 extern const char *const 
sys_errlist
[];

29 #ifdef 
__USE_GNU


30 extern int 
_sys_nerr
;

31 extern const char *const 
_sys_errlist
[];

	@/usr/include/bits/types.h

23 #ifndef 
_BITS_TYPES_H


24 #define 
	#_BITS_TYPES_H
 1

	)

26 #include 
	~<features.h
>

27 #include 
	~<bits/wordsize.h
>

30 typedef unsigned char 
	t__u_char
;

31 typedef unsigned short int 
	t__u_short
;

32 typedef unsigned int 
	t__u_int
;

33 typedef unsigned long int 
	t__u_long
;

36 typedef signed char 
	t__int8_t
;

37 typedef unsigned char 
	t__uint8_t
;

38 typedef signed short int 
	t__int16_t
;

39 typedef unsigned short int 
	t__uint16_t
;

40 typedef signed int 
	t__int32_t
;

41 typedef unsigned int 
	t__uint32_t
;

42 #if 
__WORDSIZE
 == 64

43 typedef signed long int 
	t__int64_t
;

44 typedef unsigned long int 
	t__uint64_t
;

46 
__extension__
 typedef signed long long int 
	t__int64_t
;

47 
__extension__
 typedef unsigned long long int 
	t__uint64_t
;

51 #if 
__WORDSIZE
 == 64

52 typedef long int 
	t__quad_t
;

53 typedef unsigned long int 
	t__u_quad_t
;

55 
__extension__
 typedef long long int 
	t__quad_t
;

56 
__extension__
 typedef unsigned long long int 
	t__u_quad_t
;

89 #define 
	#__S16_TYPE
 short int

	)

90 #define 
	#__U16_TYPE
 unsigned short int

	)

91 #define 
	#__S32_TYPE
 int

	)

92 #define 
	#__U32_TYPE
 unsigned int

	)

93 #define 
	#__SLONGWORD_TYPE
 long int

	)

94 #define 
	#__ULONGWORD_TYPE
 unsigned long int

	)

95 #if 
__WORDSIZE
 == 32

96 #define 
	#__SQUAD_TYPE
 
__quad_t


	)

97 #define 
	#__UQUAD_TYPE
 
__u_quad_t


	)

98 #define 
	#__SWORD_TYPE
 int

	)

99 #define 
	#__UWORD_TYPE
 unsigned int

	)

100 #define 
	#__SLONG32_TYPE
 long int

	)

101 #define 
	#__ULONG32_TYPE
 unsigned long int

	)

102 #define 
	#__S64_TYPE
 
__quad_t


	)

103 #define 
	#__U64_TYPE
 
__u_quad_t


	)

106 #define 
	#__STD_TYPE
 
__extension__
 typedef

	)

107 #elif 
__WORDSIZE
 == 64

108 #define 
	t__SQUAD_TYPE
 long int

	)

109 #define 
	t__UQUAD_TYPE
 unsigned long int

	)

110 #define 
	t__SWORD_TYPE
 long int

	)

111 #define 
	t__UWORD_TYPE
 unsigned long int

	)

112 #define 
	t__SLONG32_TYPE
 int

	)

113 #define 
	t__ULONG32_TYPE
 unsigned int

	)

114 #define 
	t__S64_TYPE
 long int

	)

115 #define 
	t__U64_TYPE
 unsigned long int

	)

117 #define 
	t__STD_TYPE
 typedef

	)

121 #include 
	~<bits/typesizes.h
>

124 
__STD_TYPE
 
	t__DEV_T_TYPE
 
	t__dev_t
;

125 
__STD_TYPE
 
__UID_T_TYPE
 
	g__uid_t
;

126 
__STD_TYPE
 
__GID_T_TYPE
 
	g__gid_t
;

127 
__STD_TYPE
 
__INO_T_TYPE
 
	g__ino_t
;

128 
__STD_TYPE
 
__INO64_T_TYPE
 
	g__ino64_t
;

129 
__STD_TYPE
 
__MODE_T_TYPE
 
	g__mode_t
;

130 
__STD_TYPE
 
__NLINK_T_TYPE
 
	g__nlink_t
;

131 
__STD_TYPE
 
__OFF_T_TYPE
 
	g__off_t
;

132 
__STD_TYPE
 
__OFF64_T_TYPE
 
	g__off64_t
;

133 
__STD_TYPE
 
__PID_T_TYPE
 
	g__pid_t
;

134 
__STD_TYPE
 
__FSID_T_TYPE
 
	g__fsid_t
;

135 
__STD_TYPE
 
__CLOCK_T_TYPE
 
	g__clock_t
;

136 
__STD_TYPE
 
__RLIM_T_TYPE
 
	g__rlim_t
;

137 
__STD_TYPE
 
__RLIM64_T_TYPE
 
	g__rlim64_t
;

138 
__STD_TYPE
 
__ID_T_TYPE
 
	g__id_t
;

139 
__STD_TYPE
 
__TIME_T_TYPE
 
	g__time_t
;

140 
__STD_TYPE
 
__USECONDS_T_TYPE
 
	g__useconds_t
;

141 
__STD_TYPE
 
__SUSECONDS_T_TYPE
 
	g__suseconds_t
;

143 
__STD_TYPE
 
__DADDR_T_TYPE
 
	g__daddr_t
;

144 
__STD_TYPE
 
__KEY_T_TYPE
 
	g__key_t
;

147 
__STD_TYPE
 
__CLOCKID_T_TYPE
 
	g__clockid_t
;

150 
__STD_TYPE
 
__TIMER_T_TYPE
 
	g__timer_t
;

153 
__STD_TYPE
 
__BLKSIZE_T_TYPE
 
	g__blksize_t
;

158 
__STD_TYPE
 
__BLKCNT_T_TYPE
 
	g__blkcnt_t
;

159 
__STD_TYPE
 
__BLKCNT64_T_TYPE
 
	g__blkcnt64_t
;

162 
__STD_TYPE
 
__FSBLKCNT_T_TYPE
 
	g__fsblkcnt_t
;

163 
__STD_TYPE
 
__FSBLKCNT64_T_TYPE
 
	g__fsblkcnt64_t
;

166 
__STD_TYPE
 
__FSFILCNT_T_TYPE
 
	g__fsfilcnt_t
;

167 
__STD_TYPE
 
__FSFILCNT64_T_TYPE
 
	g__fsfilcnt64_t
;

170 
__STD_TYPE
 
__FSWORD_T_TYPE
 
	g__fsword_t
;

172 
__STD_TYPE
 
__SSIZE_T_TYPE
 
	g__ssize_t
;

175 
__STD_TYPE
 
__SYSCALL_SLONG_TYPE
 
	g__syscall_slong_t
;

177 
__STD_TYPE
 
__SYSCALL_ULONG_TYPE
 
	g__syscall_ulong_t
;

181 typedef 
__off64_t
 
	t__loff_t
;

182 typedef 
__quad_t
 *
	t__qaddr_t
;

183 typedef char *
	t__caddr_t
;

186 
__STD_TYPE
 
__SWORD_TYPE
 
	g__intptr_t
;

189 
__STD_TYPE
 
__U32_TYPE
 
	g__socklen_t
;

192 #undef 
__STD_TYPE


	@/usr/include/bits/waitflags.h

19 #if !
defined
 
_SYS_WAIT_H
 && !defined 
_STDLIB_H


25 #define 
	#WNOHANG
 1

	)

26 #define 
	#WUNTRACED
 2

	)

29 #define 
	#WSTOPPED
 2

	)

30 #define 
	#WEXITED
 4

	)

31 #define 
	#WCONTINUED
 8

	)

32 #define 
	#WNOWAIT
 0x01000000

	)

34 #define 
	#__WNOTHREAD
 0x20000000

	)

36 #define 
	#__WALL
 0x40000000

	)

37 #define 
	#__WCLONE
 0x80000000

	)

40 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


41 #ifndef 
__ENUM_IDTYPE_T


42 #define 
	#__ENUM_IDTYPE_T
 1

	)

46 #undef 
P_ALL


47 #undef 
P_PID


48 #undef 
P_PGID


52 
	mP_ALL
,

53 
	mP_PID
,

54 
	mP_PGID


55 } 
	tidtype_t
;

	@/usr/include/bits/waitstatus.h

19 #if !
defined
 
_SYS_WAIT_H
 && !defined 
_STDLIB_H


28 #define 
	#__WEXITSTATUS
(
status
) (((status) & 0xff00) >> 8)

	)

31 #define 
	#__WTERMSIG
(
status
) ((status) & 0x7f)

	)

34 #define 
	#__WSTOPSIG
(
status
) 
	`__WEXITSTATUS
(status)

	)

37 #define 
	#__WIFEXITED
(
status
) (
	`__WTERMSIG
(status) == 0)

	)

40 #define 
	#__WIFSIGNALED
(
status
) \

41 (((signed char) (((
status
) & 0x7f) + 1) >> 1) > 0)

	)

44 #define 
	#__WIFSTOPPED
(
status
) (((status) & 0xff) == 0x7f)

	)

48 #ifdef 
WCONTINUED


49 #define 
	#__WIFCONTINUED
(
status
) ((status) == 
__W_CONTINUED
)

	)

53 #define 
	#__WCOREDUMP
(
status
) ((status) & 
__WCOREFLAG
)

	)

56 #define 
	#__W_EXITCODE
(
ret
, 
sig
) ((ret) << 8 | (sig))

	)

57 #define 
	#__W_STOPCODE
(
sig
) ((sig) << 8 | 0x7f)

	)

58 #define 
	#__W_CONTINUED
 0xffff

	)

59 #define 
	#__WCOREFLAG
 0x80

	)

62 #ifdef 
__USE_BSD


64 #include 
	~<endian.h
>

66 union 
	uwait


68 int 
	mw_status
;

71 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


72 unsigned int 
	m__w_termsig
:7;

73 unsigned int 
	m__w_coredump
:1;

74 unsigned int 
	m__w_retcode
:8;

77 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


79 unsigned int 
	m__w_retcode
:8;

80 unsigned int 
	m__w_coredump
:1;

81 unsigned int 
	m__w_termsig
:7;

83 } 
	m__wait_terminated
;

86 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


87 unsigned int 
	m__w_stopval
:8;

88 unsigned int 
	m__w_stopsig
:8;

91 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


93 unsigned int 
	m__w_stopsig
:8;

94 unsigned int 
	m__w_stopval
:8;

96 } 
	m__wait_stopped
;

99 #define 
	#w_termsig
 
__wait_terminated
.
__w_termsig


	)

100 #define 
	#w_coredump
 
__wait_terminated
.
__w_coredump


	)

101 #define 
	#w_retcode
 
__wait_terminated
.
__w_retcode


	)

102 #define 
	#w_stopsig
 
__wait_stopped
.
__w_stopsig


	)

103 #define 
	#w_stopval
 
__wait_stopped
.
__w_stopval


	)

	@/usr/include/bits/wchar.h

19 #ifndef 
_BITS_WCHAR_H


20 #define 
	#_BITS_WCHAR_H
 1

	)

33 #ifdef 
__WCHAR_MAX__


34 #define 
	#__WCHAR_MAX
 
__WCHAR_MAX__


	)

35 #elif 
L
'\0' - 1 > 0

36 #define 
	#__WCHAR_MAX
 (0xffffffffu + 
L
'\0')

	)

38 #define 
	#__WCHAR_MAX
 (0x7fffffff + 
L
'\0')

	)

41 #ifdef 
__WCHAR_MIN__


42 #define 
	#__WCHAR_MIN
 
__WCHAR_MIN__


	)

43 #elif 
L
'\0' - 1 > 0

44 #define 
	#__WCHAR_MIN
 (
L
'\0' + 0)

	)

46 #define 
	#__WCHAR_MIN
 (-
__WCHAR_MAX
 - 1)

	)

	@/usr/include/bits/wordsize.h

3 #if 
defined
 
__x86_64__
 && !defined 
__ILP32__


4 #define 
	#__WORDSIZE
 64

	)

6 #define 
	#__WORDSIZE
 32

	)

9 #ifdef 
__x86_64__


10 #define 
	#__WORDSIZE_TIME64_COMPAT32
 1

	)

12 #define 
	#__SYSCALL_WORDSIZE
 64

	)

	@/usr/include/endian.h

18 #ifndef 
_ENDIAN_H


19 #define 
	#_ENDIAN_H
 1

	)

21 #include 
	~<features.h
>

31 #define 
	#__LITTLE_ENDIAN
 1234

	)

32 #define 
	#__BIG_ENDIAN
 4321

	)

33 #define 
	#__PDP_ENDIAN
 3412

	)

36 #include 
	~<bits/endian.h
>

40 #ifndef 
__FLOAT_WORD_ORDER


41 #define 
	#__FLOAT_WORD_ORDER
 
__BYTE_ORDER


	)

44 #ifdef 
__USE_BSD


45 #define 
	#LITTLE_ENDIAN
 
__LITTLE_ENDIAN


	)

46 #define 
	#BIG_ENDIAN
 
__BIG_ENDIAN


	)

47 #define 
	#PDP_ENDIAN
 
__PDP_ENDIAN


	)

48 #define 
	#BYTE_ORDER
 
__BYTE_ORDER


	)

51 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


52 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) LO, 
	)
HI

53 #elif 
__BYTE_ORDER
 == 
__BIG_ENDIAN


54 #define 
	#__LONG_LONG_PAIR
(
HI
, 
LO
) HI, 
	)
LO

58 #if 
defined
 
__USE_BSD
 && !defined 
__ASSEMBLER__


60 #include 
	~<bits/byteswap.h
>

62 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


63 #define 
	#htobe16
(
x
) 
	`__bswap_16
 (x)

	)

64 #define 
	#htole16
(
x
) (x)

	)

65 #define 
	#be16toh
(
x
) 
	`__bswap_16
 (x)

	)

66 #define 
	#le16toh
(
x
) (x)

	)

68 #define 
	#htobe32
(
x
) 
	`__bswap_32
 (x)

	)

69 #define 
	#htole32
(
x
) (x)

	)

70 #define 
	#be32toh
(
x
) 
	`__bswap_32
 (x)

	)

71 #define 
	#le32toh
(
x
) (x)

	)

73 #define 
	#htobe64
(
x
) 
	`__bswap_64
 (x)

	)

74 #define 
	#htole64
(
x
) (x)

	)

75 #define 
	#be64toh
(
x
) 
	`__bswap_64
 (x)

	)

76 #define 
	#le64toh
(
x
) (x)

	)

79 #define 
	#htobe16
(
x
) (x)

	)

80 #define 
	#htole16
(
x
) 
	`__bswap_16
 (x)

	)

81 #define 
	#be16toh
(
x
) (x)

	)

82 #define 
	#le16toh
(
x
) 
	`__bswap_16
 (x)

	)

84 #define 
	#htobe32
(
x
) (x)

	)

85 #define 
	#htole32
(
x
) 
	`__bswap_32
 (x)

	)

86 #define 
	#be32toh
(
x
) (x)

	)

87 #define 
	#le32toh
(
x
) 
	`__bswap_32
 (x)

	)

89 #define 
	#htobe64
(
x
) (x)

	)

90 #define 
	#htole64
(
x
) 
	`__bswap_64
 (x)

	)

91 #define 
	#be64toh
(
x
) (x)

	)

92 #define 
	#le64toh
(
x
) 
	`__bswap_64
 (x)

	)

	@/usr/include/features.h

18 #ifndef 
_FEATURES_H


19 #define 
	#_FEATURES_H
 1

	)

101 #undef 
__USE_ISOC11


102 #undef 
__USE_ISOC99


103 #undef 
__USE_ISOC95


104 #undef 
__USE_ISOCXX11


105 #undef 
__USE_POSIX


106 #undef 
__USE_POSIX2


107 #undef 
__USE_POSIX199309


108 #undef 
__USE_POSIX199506


109 #undef 
__USE_XOPEN


110 #undef 
__USE_XOPEN_EXTENDED


111 #undef 
__USE_UNIX98


112 #undef 
__USE_XOPEN2K


113 #undef 
__USE_XOPEN2KXSI


114 #undef 
__USE_XOPEN2K8


115 #undef 
__USE_XOPEN2K8XSI


116 #undef 
__USE_LARGEFILE


117 #undef 
__USE_LARGEFILE64


118 #undef 
__USE_FILE_OFFSET64


119 #undef 
__USE_BSD


120 #undef 
__USE_SVID


121 #undef 
__USE_MISC


122 #undef 
__USE_ATFILE


123 #undef 
__USE_GNU


124 #undef 
__USE_REENTRANT


125 #undef 
__USE_FORTIFY_LEVEL


126 #undef 
__KERNEL_STRICT_NAMES


130 #ifndef 
_LOOSE_KERNEL_NAMES


131 #define 
	#__KERNEL_STRICT_NAMES


	)

141 #if 
defined
 
__GNUC__
 && defined 
__GNUC_MINOR__


142 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) \

143 ((
__GNUC__
 << 16) + 
__GNUC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

145 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) 0

	)

150 #ifdef 
_GNU_SOURCE


151 #undef 
_ISOC95_SOURCE


152 #define 
	#_ISOC95_SOURCE
 1

	)

153 #undef 
_ISOC99_SOURCE


154 #define 
	#_ISOC99_SOURCE
 1

	)

155 #undef 
_ISOC11_SOURCE


156 #define 
	#_ISOC11_SOURCE
 1

	)

157 #undef 
_POSIX_SOURCE


158 #define 
	#_POSIX_SOURCE
 1

	)

159 #undef 
_POSIX_C_SOURCE


160 #define 
	#_POSIX_C_SOURCE
 200809L

	)

161 #undef 
_XOPEN_SOURCE


162 #define 
	#_XOPEN_SOURCE
 700

	)

163 #undef 
_XOPEN_SOURCE_EXTENDED


164 #define 
	#_XOPEN_SOURCE_EXTENDED
 1

	)

165 #undef 
_LARGEFILE64_SOURCE


166 #define 
	#_LARGEFILE64_SOURCE
 1

	)

167 #undef 
_DEFAULT_SOURCE


168 #define 
	#_DEFAULT_SOURCE
 1

	)

169 #undef 
_BSD_SOURCE


170 #define 
	#_BSD_SOURCE
 1

	)

171 #undef 
_SVID_SOURCE


172 #define 
	#_SVID_SOURCE
 1

	)

173 #undef 
_ATFILE_SOURCE


174 #define 
	#_ATFILE_SOURCE
 1

	)

179 #if (
defined
 
_DEFAULT_SOURCE
 \

180 || (!
defined
 
	g__STRICT_ANSI__
 \

181 && !
defined
 
	g_ISOC99_SOURCE
 \

182 && !
defined
 
	g_POSIX_SOURCE
 && !defined 
	g_POSIX_C_SOURCE
 \

183 && !
defined
 
	g_XOPEN_SOURCE
 \

184 && !
defined
 
	g_BSD_SOURCE
 && !defined 
	g_SVID_SOURCE
))

185 #undef 
_DEFAULT_SOURCE


186 #define 
	#_DEFAULT_SOURCE
 1

	)

187 #undef 
_BSD_SOURCE


188 #define 
	#_BSD_SOURCE
 1

	)

189 #undef 
_SVID_SOURCE


190 #define 
	#_SVID_SOURCE
 1

	)

194 #if (
defined
 
_ISOC11_SOURCE
 \

195 || (
defined
 
	g__STDC_VERSION__
 && __STDC_VERSION__ >= 201112L))

196 #define 
	#__USE_ISOC11
 1

	)

200 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC11_SOURCE
 \

201 || (
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L))

202 #define 
	#__USE_ISOC99
 1

	)

206 #if (
defined
 
_ISOC99_SOURCE
 || defined 
_ISOC11_SOURCE
 \

207 || (
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199409L))

208 #define 
	#__USE_ISOC95
 1

	)

215 #if ((
defined
 
__cplusplus
 && __cplusplus >= 201103L) \

216 || 
defined
 
__GXX_EXPERIMENTAL_CXX0X__
)

217 #define 
	#__USE_ISOCXX11
 1

	)

223 #ifdef 
_DEFAULT_SOURCE


224 #if !
defined
 
_POSIX_SOURCE
 && !defined 
_POSIX_C_SOURCE


225 #define 
	#__USE_POSIX_IMPLICITLY
 1

	)

227 #undef 
_POSIX_SOURCE


228 #define 
	#_POSIX_SOURCE
 1

	)

229 #undef 
_POSIX_C_SOURCE


230 #define 
	#_POSIX_C_SOURCE
 200809L

	)

232 #if ((!
defined
 
__STRICT_ANSI__
 || (
_XOPEN_SOURCE
 - 0) >= 500) && \

233 !
defined
 
_POSIX_SOURCE
 && !defined 
_POSIX_C_SOURCE
)

234 #define 
	#_POSIX_SOURCE
 1

	)

235 #if 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 500

236 #define 
	#_POSIX_C_SOURCE
 2

	)

237 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 600

238 #define 
	#_POSIX_C_SOURCE
 199506L

	)

239 #elif 
defined
 
_XOPEN_SOURCE
 && (_XOPEN_SOURCE - 0) < 700

240 #define 
	#_POSIX_C_SOURCE
 200112L

	)

242 #define 
	#_POSIX_C_SOURCE
 200809L

	)

244 #define 
	#__USE_POSIX_IMPLICITLY
 1

	)

247 #if 
defined
 
_POSIX_SOURCE
 || 
_POSIX_C_SOURCE
 >= 1 || defined 
_XOPEN_SOURCE


248 #define 
	#__USE_POSIX
 1

	)

251 #if 
defined
 
_POSIX_C_SOURCE
 && _POSIX_C_SOURCE >= 2 || defined 
_XOPEN_SOURCE


252 #define 
	#__USE_POSIX2
 1

	)

255 #if (
_POSIX_C_SOURCE
 - 0) >= 199309L

256 #define 
	#__USE_POSIX199309
 1

	)

259 #if (
_POSIX_C_SOURCE
 - 0) >= 199506L

260 #define 
	#__USE_POSIX199506
 1

	)

263 #if (
_POSIX_C_SOURCE
 - 0) >= 200112L

264 #define 
	#__USE_XOPEN2K
 1

	)

265 #undef 
__USE_ISOC95


266 #define 
	#__USE_ISOC95
 1

	)

267 #undef 
__USE_ISOC99


268 #define 
	#__USE_ISOC99
 1

	)

271 #if (
_POSIX_C_SOURCE
 - 0) >= 200809L

272 #define 
	#__USE_XOPEN2K8
 1

	)

273 #undef 
_ATFILE_SOURCE


274 #define 
	#_ATFILE_SOURCE
 1

	)

277 #ifdef 
_XOPEN_SOURCE


278 #define 
	#__USE_XOPEN
 1

	)

279 #if (
_XOPEN_SOURCE
 - 0) >= 500

280 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

281 #define 
	#__USE_UNIX98
 1

	)

282 #undef 
_LARGEFILE_SOURCE


283 #define 
	#_LARGEFILE_SOURCE
 1

	)

284 #if (
_XOPEN_SOURCE
 - 0) >= 600

285 #if (
_XOPEN_SOURCE
 - 0) >= 700

286 #define 
	#__USE_XOPEN2K8
 1

	)

287 #define 
	#__USE_XOPEN2K8XSI
 1

	)

289 #define 
	#__USE_XOPEN2K
 1

	)

290 #define 
	#__USE_XOPEN2KXSI
 1

	)

291 #undef 
__USE_ISOC95


292 #define 
	#__USE_ISOC95
 1

	)

293 #undef 
__USE_ISOC99


294 #define 
	#__USE_ISOC99
 1

	)

297 #ifdef 
_XOPEN_SOURCE_EXTENDED


298 #define 
	#__USE_XOPEN_EXTENDED
 1

	)

303 #ifdef 
_LARGEFILE_SOURCE


304 #define 
	#__USE_LARGEFILE
 1

	)

307 #ifdef 
_LARGEFILE64_SOURCE


308 #define 
	#__USE_LARGEFILE64
 1

	)

311 #if 
defined
 
_FILE_OFFSET_BITS
 && _FILE_OFFSET_BITS == 64

312 #define 
	#__USE_FILE_OFFSET64
 1

	)

315 #if 
defined
 
_BSD_SOURCE
 || defined 
_SVID_SOURCE


316 #define 
	#__USE_MISC
 1

	)

319 #ifdef 
_BSD_SOURCE


320 #define 
	#__USE_BSD
 1

	)

323 #ifdef 
_SVID_SOURCE


324 #define 
	#__USE_SVID
 1

	)

327 #ifdef 
_ATFILE_SOURCE


328 #define 
	#__USE_ATFILE
 1

	)

331 #ifdef 
_GNU_SOURCE


332 #define 
	#__USE_GNU
 1

	)

335 #if 
defined
 
_REENTRANT
 || defined 
_THREAD_SAFE


336 #define 
	#__USE_REENTRANT
 1

	)

339 #if 
defined
 
_FORTIFY_SOURCE
 && _FORTIFY_SOURCE > 0 \

340 && 
__GNUC_PREREQ
 (4, 1) && 
defined
 
	g__OPTIMIZE__
 && __OPTIMIZE__ > 0

341 #if 
_FORTIFY_SOURCE
 > 1

342 #define 
	#__USE_FORTIFY_LEVEL
 2

	)

344 #define 
	#__USE_FORTIFY_LEVEL
 1

	)

347 #define 
	#__USE_FORTIFY_LEVEL
 0

	)

352 #include 
	~<stdc-predef.h
>

360 #undef 
__GNU_LIBRARY__


361 #define 
	#__GNU_LIBRARY__
 6

	)

365 #define 
	#__GLIBC__
 2

	)

366 #define 
	#__GLIBC_MINOR__
 19

	)

368 #define 
	#__GLIBC_PREREQ
(
maj
, 
min
) \

369 ((
__GLIBC__
 << 16) + 
__GLIBC_MINOR__
 >= ((
maj
) << 16) + (
min
))

	)

372 #ifndef 
__ASSEMBLER__


373 #ifndef 
_SYS_CDEFS_H


374 #include 
	~<sys/cdefs.h
>

379 #if 
defined
 
__USE_FILE_OFFSET64
 && !defined 
__REDIRECT


380 #define 
	#__USE_LARGEFILE
 1

	)

381 #define 
	#__USE_LARGEFILE64
 1

	)

387 #if 
__GNUC_PREREQ
 (2, 7) && 
defined
 
__OPTIMIZE__
 \

388 && !
defined
 
	g__OPTIMIZE_SIZE__
 && !defined 
	g__NO_INLINE__
 \

389 && 
defined
 
	g__extern_inline


390 #define 
	#__USE_EXTERN_INLINES
 1

	)

398 #include 
	~<gnu/stubs.h
>

	@/usr/include/getopt.h

19 #ifndef 
_GETOPT_H


21 #ifndef 
__need_getopt


22 #define 
	#_GETOPT_H
 1

	)

32 #if !
defined
 
__GNU_LIBRARY__


33 #include 
	~<ctype.h
>

36 #ifndef 
__THROW


37 #ifndef 
__GNUC_PREREQ


38 #define 
	#__GNUC_PREREQ
(
maj
, 
min
) (0)

	)

40 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,8)

41 #define 
	#__THROW
 
	`throw
 ()

	)

43 #define 
	#__THROW


	)

47 #ifdef 
__cplusplus


57 extern char *
optarg
;

71 extern int 
optind
;

76 extern int 
opterr
;

80 extern int 
optopt
;

82 #ifndef 
__need_getopt


104 struct 
	soption


106 const char *
	gname
;

109 int 
	ghas_arg
;

110 int *
	gflag
;

111 int 
	gval
;

116 #define 
	#no_argument
 0

	)

117 #define 
	#required_argument
 1

	)

118 #define 
	#optional_argument
 2

	)

146 #ifdef 
__GNU_LIBRARY__


150 extern int 
getopt
 (int 
___argc
, char *const *
___argv
, const char *
__shortopts
)

151 
__THROW
;

153 #if 
defined
 
__need_getopt
 && defined 
__USE_POSIX2
 \

154 && !
defined
 
	g__USE_POSIX_IMPLICITLY
 && !defined 
	g__USE_GNU


158 #ifdef 
__REDIRECT


159 extern int 
__REDIRECT_NTH
 (
getopt
, (int 
___argc
, char *const *
___argv
,

160 const char *
__shortopts
),

161 
__posix_getopt
);

163 extern int 
__posix_getopt
 (int 
___argc
, char *const *
___argv
,

164 const char *
__shortopts
) 
__THROW
;

165 #define 
	#getopt
 
__posix_getopt


	)

169 extern int 
getopt
 ();

172 #ifndef 
__need_getopt


173 extern int 
getopt_long
 (int 
___argc
, char *const *
___argv
,

174 const char *
__shortopts
,

175 const struct 
option
 *
__longopts
, int *
__longind
)

176 
__THROW
;

177 extern int 
getopt_long_only
 (int 
___argc
, char *const *
___argv
,

178 const char *
__shortopts
,

179 const struct 
option
 *
__longopts
, int *
__longind
)

180 
__THROW
;

184 #ifdef 
__cplusplus


189 #undef 
__need_getopt


	@/usr/include/libio.h

28 #ifndef 
_IO_STDIO_H


29 #define 
	#_IO_STDIO_H


	)

31 #include 
	~<_G_config.h
>

33 #define 
	#_IO_fpos_t
 
_G_fpos_t


	)

34 #define 
	#_IO_fpos64_t
 
_G_fpos64_t


	)

35 #define 
	#_IO_size_t
 
size_t


	)

36 #define 
	#_IO_ssize_t
 
__ssize_t


	)

37 #define 
	#_IO_off_t
 
__off_t


	)

38 #define 
	#_IO_off64_t
 
__off64_t


	)

39 #define 
	#_IO_pid_t
 
__pid_t


	)

40 #define 
	#_IO_uid_t
 
__uid_t


	)

41 #define 
	#_IO_iconv_t
 
_G_iconv_t


	)

42 #define 
	#_IO_HAVE_ST_BLKSIZE
 
_G_HAVE_ST_BLKSIZE


	)

43 #define 
	#_IO_BUFSIZ
 
_G_BUFSIZ


	)

44 #define 
	#_IO_va_list
 
_G_va_list


	)

45 #define 
	#_IO_wint_t
 
wint_t


	)

48 #define 
	#__need___va_list


	)

49 #include 
	~<stdarg.h
>

50 #ifdef 
__GNUC_VA_LIST


51 #undef 
_IO_va_list


52 #define 
	#_IO_va_list
 
__gnuc_va_list


	)

55 #ifndef 
__P


56 #include 
	~<sys/cdefs.h
>

59 #define 
	#_IO_UNIFIED_JUMPTABLES
 1

	)

61 #ifndef 
EOF


62 #define 
	#EOF
 (-1)

	)

64 #ifndef 
NULL


65 #if 
defined
 
__GNUG__
 && \

66 (
	g__GNUC__
 > 2 || (__GNUC__ == 2 && 
__GNUC_MINOR__
 >= 8))

67 #define 
	#NULL
 (
__null
)

	)

69 #if !
defined
(
__cplusplus
)

70 #define 
	#NULL
 ((void*)0)

	)

72 #define 
	#NULL
 (0)

	)

77 #define 
	#_IOS_INPUT
 1

	)

78 #define 
	#_IOS_OUTPUT
 2

	)

79 #define 
	#_IOS_ATEND
 4

	)

80 #define 
	#_IOS_APPEND
 8

	)

81 #define 
	#_IOS_TRUNC
 16

	)

82 #define 
	#_IOS_NOCREATE
 32

	)

83 #define 
	#_IOS_NOREPLACE
 64

	)

84 #define 
	#_IOS_BIN
 128

	)

92 #define 
	#_IO_MAGIC
 0xFBAD0000

	)

93 #define 
	#_OLD_STDIO_MAGIC
 0xFABC0000

	)

94 #define 
	#_IO_MAGIC_MASK
 0xFFFF0000

	)

95 #define 
	#_IO_USER_BUF
 1

	)

96 #define 
	#_IO_UNBUFFERED
 2

	)

97 #define 
	#_IO_NO_READS
 4

	)

98 #define 
	#_IO_NO_WRITES
 8

	)

99 #define 
	#_IO_EOF_SEEN
 0x10

	)

100 #define 
	#_IO_ERR_SEEN
 0x20

	)

101 #define 
	#_IO_DELETE_DONT_CLOSE
 0x40

	)

102 #define 
	#_IO_LINKED
 0x80

	)

103 #define 
	#_IO_IN_BACKUP
 0x100

	)

104 #define 
	#_IO_LINE_BUF
 0x200

	)

105 #define 
	#_IO_TIED_PUT_GET
 0x400

	)

106 #define 
	#_IO_CURRENTLY_PUTTING
 0x800

	)

107 #define 
	#_IO_IS_APPENDING
 0x1000

	)

108 #define 
	#_IO_IS_FILEBUF
 0x2000

	)

109 #define 
	#_IO_BAD_SEEN
 0x4000

	)

110 #define 
	#_IO_USER_LOCK
 0x8000

	)

112 #define 
	#_IO_FLAGS2_MMAP
 1

	)

113 #define 
	#_IO_FLAGS2_NOTCANCEL
 2

	)

114 #ifdef 
_LIBC


115 #define 
	#_IO_FLAGS2_FORTIFY
 4

	)

117 #define 
	#_IO_FLAGS2_USER_WBUF
 8

	)

118 #ifdef 
_LIBC


119 #define 
	#_IO_FLAGS2_SCANF_STD
 16

	)

120 #define 
	#_IO_FLAGS2_NOCLOSE
 32

	)

121 #define 
	#_IO_FLAGS2_CLOEXEC
 64

	)

125 #define 
	#_IO_SKIPWS
 01

	)

126 #define 
	#_IO_LEFT
 02

	)

127 #define 
	#_IO_RIGHT
 04

	)

128 #define 
	#_IO_INTERNAL
 010

	)

129 #define 
	#_IO_DEC
 020

	)

130 #define 
	#_IO_OCT
 040

	)

131 #define 
	#_IO_HEX
 0100

	)

132 #define 
	#_IO_SHOWBASE
 0200

	)

133 #define 
	#_IO_SHOWPOINT
 0400

	)

134 #define 
	#_IO_UPPERCASE
 01000

	)

135 #define 
	#_IO_SHOWPOS
 02000

	)

136 #define 
	#_IO_SCIENTIFIC
 04000

	)

137 #define 
	#_IO_FIXED
 010000

	)

138 #define 
	#_IO_UNITBUF
 020000

	)

139 #define 
	#_IO_STDIO
 040000

	)

140 #define 
	#_IO_DONT_CLOSE
 0100000

	)

141 #define 
	#_IO_BOOLALPHA
 0200000

	)

144 struct 
_IO_jump_t
; struct 
	g_IO_FILE
;

147 #ifdef 
_IO_MTSAFE_IO


148 #if 
defined
 
__GLIBC__
 && __GLIBC__ >= 2

149 #include 
	~<bits/stdio-lock.h
>

154 typedef void 
	t_IO_lock_t
;

160 struct 
	s_IO_marker
 {

161 struct 
_IO_marker
 *
	m_next
;

162 struct 
_IO_FILE
 *
	m_sbuf
;

166 int 
	m_pos
;

168 void 
set_streampos
(
streampos
 
sp
) { 
	m_spos
 = sp; }

169 void 
set_offset
(int 
offset
) { 
	m_pos
 = offset; 
	m_spos
 = (
streampos
)(-2); }

170 
	mpublic
:

171 
streammarker
(
streambuf
 *
sb
);

172 ~
streammarker
();

173 int 
saving
() { return 
	m_spos
 == -2; }

174 int 
delta
(
streammarker
&);

175 int 
delta
();

180 enum 
	e__codecvt_result


182 
	m__codecvt_ok
,

183 
	m__codecvt_partial
,

184 
	m__codecvt_error
,

185 
	m__codecvt_noconv


188 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


191 struct 
	s_IO_codecvt


193 void (*
	m__codecvt_destr
) (struct 
	m_IO_codecvt
 *);

194 enum 
__codecvt_result
 (*
__codecvt_do_out
) (struct 
	m_IO_codecvt
 *,

195 
	m__mbstate_t
 *,

196 const 
	mwchar_t
 *,

197 const 
	mwchar_t
 *,

198 const 
	mwchar_t
 **, char *,

200 enum 
__codecvt_result
 (*
__codecvt_do_unshift
) (struct 
	m_IO_codecvt
 *,

201 
	m__mbstate_t
 *, char *,

203 enum 
__codecvt_result
 (*
__codecvt_do_in
) (struct 
	m_IO_codecvt
 *,

204 
	m__mbstate_t
 *,

206 const char **, 
	mwchar_t
 *,

207 
	mwchar_t
 *, wchar_t **);

208 int (*
	m__codecvt_do_encoding
) (struct 
	m_IO_codecvt
 *);

209 int (*
	m__codecvt_do_always_noconv
) (struct 
	m_IO_codecvt
 *);

210 int (*
	m__codecvt_do_length
) (struct 
	m_IO_codecvt
 *, 
	m__mbstate_t
 *,

211 const char *, const char *, 
	m_IO_size_t
);

212 int (*
	m__codecvt_do_max_length
) (struct 
	m_IO_codecvt
 *);

214 
_IO_iconv_t
 
	m__cd_in
;

215 
_IO_iconv_t
 
	m__cd_out
;

219 struct 
	s_IO_wide_data


221 
wchar_t
 *
	m_IO_read_ptr
;

222 
wchar_t
 *
	m_IO_read_end
;

223 
wchar_t
 *
	m_IO_read_base
;

224 
wchar_t
 *
	m_IO_write_base
;

225 
wchar_t
 *
	m_IO_write_ptr
;

226 
wchar_t
 *
	m_IO_write_end
;

227 
wchar_t
 *
	m_IO_buf_base
;

228 
wchar_t
 *
	m_IO_buf_end
;

230 
wchar_t
 *
	m_IO_save_base
;

231 
wchar_t
 *
	m_IO_backup_base
;

233 
wchar_t
 *
	m_IO_save_end
;

235 
__mbstate_t
 
	m_IO_state
;

236 
__mbstate_t
 
	m_IO_last_state
;

237 struct 
_IO_codecvt
 
	m_codecvt
;

239 
wchar_t
 
	m_shortbuf
[1];

241 const struct 
_IO_jump_t
 *
	m_wide_vtable
;

245 struct 
	s_IO_FILE
 {

246 int 
	m_flags
;

247 #define 
	#_IO_file_flags
 
_flags


	)

251 char* 
	m_IO_read_ptr
;

252 char* 
	m_IO_read_end
;

253 char* 
	m_IO_read_base
;

254 char* 
	m_IO_write_base
;

255 char* 
	m_IO_write_ptr
;

256 char* 
	m_IO_write_end
;

257 char* 
	m_IO_buf_base
;

258 char* 
	m_IO_buf_end
;

260 char *
	m_IO_save_base
;

261 char *
	m_IO_backup_base
;

262 char *
	m_IO_save_end
;

264 struct 
_IO_marker
 *
	m_markers
;

266 struct 
_IO_FILE
 *
	m_chain
;

268 int 
	m_fileno
;

270 int 
	m_blksize
;

272 int 
	m_flags2
;

274 
_IO_off_t
 
	m_old_offset
;

276 #define 
	#__HAVE_COLUMN


	)

278 unsigned short 
	m_cur_column
;

279 signed char 
	m_vtable_offset
;

280 char 
	m_shortbuf
[1];

284 
_IO_lock_t
 *
	m_lock
;

285 #ifdef 
_IO_USE_OLD_IO_FILE


288 struct 
	s_IO_FILE_complete


290 struct 
_IO_FILE
 
	m_file
;

292 #if 
defined
 
_G_IO_IO_FILE_VERSION
 && _G_IO_IO_FILE_VERSION == 0x20001

293 
_IO_off64_t
 
	m_offset
;

294 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


296 struct 
_IO_codecvt
 *
	m_codecvt
;

297 struct 
_IO_wide_data
 *
	m_wide_data
;

298 struct 
_IO_FILE
 *
	m_freeres_list
;

299 void *
	m_freeres_buf
;

300 
size_t
 
	m_freeres_size
;

302 void *
	m__pad1
;

303 void *
	m__pad2
;

304 void *
	m__pad3
;

305 void *
	m__pad4
;

306 
size_t
 
	m__pad5
;

308 int 
	m_mode
;

310 char 
	m_unused2
[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (
size_t
)];

314 #ifndef 
__cplusplus


315 typedef struct 
_IO_FILE
 
	t_IO_FILE
;

318 struct 
	g_IO_FILE_plus
;

320 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdin_
;

321 extern struct 
_IO_FILE_plus
 
_IO_2_1_stdout_
;

322 extern struct 
_IO_FILE_plus
 
_IO_2_1_stderr_
;

323 #ifndef 
_LIBC


324 #define 
	#_IO_stdin
 ((
_IO_FILE
*)(&
_IO_2_1_stdin_
))

	)

325 #define 
	#_IO_stdout
 ((
_IO_FILE
*)(&
_IO_2_1_stdout_
))

	)

326 #define 
	#_IO_stderr
 ((
_IO_FILE
*)(&
_IO_2_1_stderr_
))

	)

328 extern 
_IO_FILE
 *
_IO_stdin
 
attribute_hidden
;

329 extern 
_IO_FILE
 *
_IO_stdout
 
attribute_hidden
;

330 extern 
_IO_FILE
 *
_IO_stderr
 
attribute_hidden
;

338 typedef 
__ssize_t
 
	t__io_read_fn
 (void *
	t__cookie
, char *
	t__buf
, 
	tsize_t
 
	t__nbytes
);

346 typedef 
__ssize_t
 
	t__io_write_fn
 (void *
	t__cookie
, const char *
	t__buf
,

347 
	tsize_t
 
	t__n
);

355 typedef int 
	t__io_seek_fn
 (void *
	t__cookie
, 
	t_IO_off64_t
 *
	t__pos
, int 
	t__w
);

358 typedef int 
	t__io_close_fn
 (void *
	t__cookie
);

361 #ifdef 
_GNU_SOURCE


363 typedef 
__io_read_fn
 
	tcookie_read_function_t
;

364 typedef 
__io_write_fn
 
	tcookie_write_function_t
;

365 typedef 
__io_seek_fn
 
	tcookie_seek_function_t
;

366 typedef 
__io_close_fn
 
	tcookie_close_function_t
;

371 
__io_read_fn
 *
	mread
;

372 
__io_write_fn
 *
	mwrite
;

373 
__io_seek_fn
 *
	mseek
;

374 
__io_close_fn
 *
	mclose
;

375 } 
	t_IO_cookie_io_functions_t
;

376 typedef 
_IO_cookie_io_functions_t
 
	tcookie_io_functions_t
;

378 struct 
	g_IO_cookie_file
;

381 extern void 
_IO_cookie_init
 (struct 
_IO_cookie_file
 *
__cfile
, int 
__read_write
,

382 void *
__cookie
, 
_IO_cookie_io_functions_t
 
__fns
);

386 #ifdef 
__cplusplus


390 extern int 
__underflow
 (
_IO_FILE
 *);

391 extern int 
__uflow
 (
_IO_FILE
 *);

392 extern int 
__overflow
 (
_IO_FILE
 *, int);

393 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


394 extern 
_IO_wint_t
 
__wunderflow
 (
_IO_FILE
 *);

395 extern 
_IO_wint_t
 
__wuflow
 (
_IO_FILE
 *);

396 extern 
_IO_wint_t
 
__woverflow
 (
_IO_FILE
 *, _IO_wint_t);

399 #if 
__GNUC__
 >= 3

400 #define 
	#_IO_BE
(
expr
, 
res
) 
	`__builtin_expect
 ((expr), res)

	)

402 #define 
	#_IO_BE
(
expr
, 
res
) (expr)

	)

405 #define 
	#_IO_getc_unlocked
(
_fp
) \

406 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

407 ? 
	`__uflow
 (
_fp
) : *(unsigned char *) (_fp)->
_IO_read_ptr
++)

	)

408 #define 
	#_IO_peekc_unlocked
(
_fp
) \

409 (
	`_IO_BE
 ((
_fp
)->
_IO_read_ptr
 >= (_fp)->
_IO_read_end
, 0) \

410 && 
	`__underflow
 (
_fp
) == 
EOF
 ? EOF \

411 : *(unsigned char *) (
_fp
)->
_IO_read_ptr
)

	)

412 #define 
	#_IO_putc_unlocked
(
_ch
, 
_fp
) \

413 (
	`_IO_BE
 ((
_fp
)->
_IO_write_ptr
 >= (_fp)->
_IO_write_end
, 0) \

414 ? 
	`__overflow
 (
_fp
, (unsigned char) (
_ch
)) \

415 : (unsigned char) (*(
_fp
)->
_IO_write_ptr
++ = (
_ch
)))

	)

417 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


418 #define 
	#_IO_getwc_unlocked
(
_fp
) \

419 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

420 || ((
_fp
)->
_wide_data
->
_IO_read_ptr
 \

421 >= (
_fp
)->
_wide_data
->
_IO_read_end
), 0) \

422 ? 
	`__wuflow
 (
_fp
) : (
_IO_wint_t
) *(_fp)->
_wide_data
->
_IO_read_ptr
++)

	)

423 #define 
	#_IO_putwc_unlocked
(
_wch
, 
_fp
) \

424 (
	`_IO_BE
 ((
_fp
)->
_wide_data
 == 
NULL
 \

425 || ((
_fp
)->
_wide_data
->
_IO_write_ptr
 \

426 >= (
_fp
)->
_wide_data
->
_IO_write_end
), 0) \

427 ? 
	`__woverflow
 (
_fp
, 
_wch
) \

428 : (
_IO_wint_t
) (*(
_fp
)->
_wide_data
->
_IO_write_ptr
++ = (
_wch
)))

	)

431 #define 
	#_IO_feof_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_EOF_SEEN
) != 0)

	)

432 #define 
	#_IO_ferror_unlocked
(
__fp
) (((__fp)->
_flags
 & 
_IO_ERR_SEEN
) != 0)

	)

434 extern int 
_IO_getc
 (
_IO_FILE
 *
__fp
);

435 extern int 
_IO_putc
 (int 
__c
, 
_IO_FILE
 *
__fp
);

436 extern int 
_IO_feof
 (
_IO_FILE
 *
__fp
) 
__THROW
;

437 extern int 
_IO_ferror
 (
_IO_FILE
 *
__fp
) 
__THROW
;

439 extern int 
_IO_peekc_locked
 (
_IO_FILE
 *
__fp
);

442 #define 
	#_IO_PENDING_OUTPUT_COUNT
(
_fp
) \

443 ((
_fp
)->
_IO_write_ptr
 - (_fp)->
_IO_write_base
)

	)

445 extern void 
_IO_flockfile
 (
_IO_FILE
 *) 
__THROW
;

446 extern void 
_IO_funlockfile
 (
_IO_FILE
 *) 
__THROW
;

447 extern int 
_IO_ftrylockfile
 (
_IO_FILE
 *) 
__THROW
;

449 #ifdef 
_IO_MTSAFE_IO


450 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_locked
 (_fp)

	)

451 #define 
	#_IO_flockfile
(
_fp
) \

452 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_flockfile
 (_fp)

	)

453 #define 
	#_IO_funlockfile
(
_fp
) \

454 if (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0) 
	`_IO_funlockfile
 (_fp)

	)

456 #define 
	#_IO_peekc
(
_fp
) 
	`_IO_peekc_unlocked
 (_fp)

	)

457 #define 
	#_IO_flockfile
(
_fp
)

	)

458 #define 
	#_IO_funlockfile
(
_fp
)

	)

459 #define 
	#_IO_ftrylockfile
(
_fp
)

	)

460 #define 
	#_IO_cleanup_region_start
(
_fct
, 
_fp
)

	)

461 #define 
	#_IO_cleanup_region_end
(
_Doit
)

	)

464 extern int 
_IO_vfscanf
 (
_IO_FILE
 * 
__restrict
, const char * __restrict,

465 
_IO_va_list
, int *
__restrict
);

466 extern int 
_IO_vfprintf
 (
_IO_FILE
 *
__restrict
, const char *__restrict,

467 
_IO_va_list
);

468 extern 
_IO_ssize_t
 
_IO_padn
 (
_IO_FILE
 *, int, _IO_ssize_t);

469 extern 
_IO_size_t
 
_IO_sgetn
 (
_IO_FILE
 *, void *, _IO_size_t);

471 extern 
_IO_off64_t
 
_IO_seekoff
 (
_IO_FILE
 *, _IO_off64_t, int, int);

472 extern 
_IO_off64_t
 
_IO_seekpos
 (
_IO_FILE
 *, _IO_off64_t, int);

474 extern void 
_IO_free_backup_area
 (
_IO_FILE
 *) 
__THROW
;

476 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


477 extern 
_IO_wint_t
 
_IO_getwc
 (
_IO_FILE
 *
__fp
);

478 extern 
_IO_wint_t
 
_IO_putwc
 (
wchar_t
 
__wc
, 
_IO_FILE
 *
__fp
);

479 extern int 
_IO_fwide
 (
_IO_FILE
 *
__fp
, int 
__mode
) 
__THROW
;

480 #if 
__GNUC__
 >= 2

483 #if 
defined
 
_LIBC
 && defined 
SHARED


484 #include 
	~<shlib-compat.h
>

485 #if 
SHLIB_COMPAT
 (
libc
, 
GLIBC_2_0
, 
GLIBC_2_1
)

486 #define 
	#_IO_fwide_maybe_incompatible
 \

487 (
	`__builtin_expect
 (&
_IO_stdin_used
 == 
NULL
, 0))

	)

488 extern const int 
_IO_stdin_used
;

489 
weak_extern
 (
_IO_stdin_used
);

492 #ifndef 
_IO_fwide_maybe_incompatible


493 #define 
	#_IO_fwide_maybe_incompatible
 (0)

	)

497 #define 
	#_IO_fwide
(
__fp
, 
__mode
) \

498 ({ int 
__result
 = (
__mode
); \

499 if (
__result
 < 0 && ! 
_IO_fwide_maybe_incompatible
) \

501 if ((
__fp
)->
_mode
 == 0) \

503 (
__fp
)->
_mode
 = -1; \

504 
__result
 = (
__fp
)->
_mode
; \

506 else if (
	`__builtin_constant_p
 (
__mode
) && (__mode) == 0) \

507 
__result
 = 
_IO_fwide_maybe_incompatible
 ? -1 : (
__fp
)->
_mode
; \

509 
__result
 = 
	`_IO_fwide
 (
__fp
, __result); \

510 
__result
; })

	)

513 extern int 
_IO_vfwscanf
 (
_IO_FILE
 * 
__restrict
, const 
wchar_t
 * __restrict,

514 
_IO_va_list
, int *
__restrict
);

515 extern int 
_IO_vfwprintf
 (
_IO_FILE
 *
__restrict
, const 
wchar_t
 *__restrict,

516 
_IO_va_list
);

517 extern 
_IO_ssize_t
 
_IO_wpadn
 (
_IO_FILE
 *, 
wint_t
, _IO_ssize_t);

518 extern void 
_IO_free_wbackup_area
 (
_IO_FILE
 *) 
__THROW
;

521 #ifdef 
__LDBL_COMPAT


522 #include 
	~<bits/libio-ldbl.h
>

525 #ifdef 
__cplusplus


	@/usr/include/sys/types.h

22 #ifndef 
_SYS_TYPES_H


23 #define 
	#_SYS_TYPES_H
 1

	)

25 #include 
	~<features.h
>

27 
	g__BEGIN_DECLS


29 #include 
	~<bits/types.h
>

31 #ifdef 
__USE_BSD


32 #ifndef 
__u_char_defined


33 typedef 
__u_char
 
	tu_char
;

34 typedef 
__u_short
 
	tu_short
;

35 typedef 
__u_int
 
	tu_int
;

36 typedef 
__u_long
 
	tu_long
;

37 typedef 
__quad_t
 
	tquad_t
;

38 typedef 
__u_quad_t
 
	tu_quad_t
;

39 typedef 
__fsid_t
 
	tfsid_t
;

40 #define 
	#__u_char_defined


	)

44 typedef 
__loff_t
 
	tloff_t
;

46 #ifndef 
__ino_t_defined


47 #ifndef 
__USE_FILE_OFFSET64


48 typedef 
__ino_t
 
	tino_t
;

50 typedef 
__ino64_t
 
	tino_t
;

52 #define 
	#__ino_t_defined


	)

54 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__ino64_t_defined


55 typedef 
__ino64_t
 
	tino64_t
;

56 #define 
	#__ino64_t_defined


	)

59 #ifndef 
__dev_t_defined


60 typedef 
__dev_t
 
	tdev_t
;

61 #define 
	#__dev_t_defined


	)

64 #ifndef 
__gid_t_defined


65 typedef 
__gid_t
 
	tgid_t
;

66 #define 
	#__gid_t_defined


	)

69 #ifndef 
__mode_t_defined


70 typedef 
__mode_t
 
	tmode_t
;

71 #define 
	#__mode_t_defined


	)

74 #ifndef 
__nlink_t_defined


75 typedef 
__nlink_t
 
	tnlink_t
;

76 #define 
	#__nlink_t_defined


	)

79 #ifndef 
__uid_t_defined


80 typedef 
__uid_t
 
	tuid_t
;

81 #define 
	#__uid_t_defined


	)

84 #ifndef 
__off_t_defined


85 #ifndef 
__USE_FILE_OFFSET64


86 typedef 
__off_t
 
	toff_t
;

88 typedef 
__off64_t
 
	toff_t
;

90 #define 
	#__off_t_defined


	)

92 #if 
defined
 
__USE_LARGEFILE64
 && !defined 
__off64_t_defined


93 typedef 
__off64_t
 
	toff64_t
;

94 #define 
	#__off64_t_defined


	)

97 #ifndef 
__pid_t_defined


98 typedef 
__pid_t
 
	tpid_t
;

99 #define 
	#__pid_t_defined


	)

102 #if (
defined
 
__USE_SVID
 || defined 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8
) \

103 && !
defined
 
__id_t_defined


104 typedef 
__id_t
 
	tid_t
;

105 #define 
	#__id_t_defined


	)

108 #ifndef 
__ssize_t_defined


109 typedef 
__ssize_t
 
	tssize_t
;

110 #define 
	#__ssize_t_defined


	)

113 #ifdef 
__USE_BSD


114 #ifndef 
__daddr_t_defined


115 typedef 
__daddr_t
 
	tdaddr_t
;

116 typedef 
__caddr_t
 
	tcaddr_t
;

117 #define 
	#__daddr_t_defined


	)

121 #if (
defined
 
__USE_SVID
 || defined 
__USE_XOPEN
) && !defined 
__key_t_defined


122 typedef 
__key_t
 
	tkey_t
;

123 #define 
	#__key_t_defined


	)

126 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_XOPEN2K8


127 #define 
	#__need_clock_t


	)

129 #define 
	#__need_time_t


	)

130 #define 
	#__need_timer_t


	)

131 #define 
	#__need_clockid_t


	)

132 #include 
	~<time.h
>

134 #ifdef 
__USE_XOPEN


135 #ifndef 
__useconds_t_defined


136 typedef 
__useconds_t
 
	tuseconds_t
;

137 #define 
	#__useconds_t_defined


	)

139 #ifndef 
__suseconds_t_defined


140 typedef 
__suseconds_t
 
	tsuseconds_t
;

141 #define 
	#__suseconds_t_defined


	)

145 #define 
	#__need_size_t


	)

146 #include 
	~<stddef.h
>

148 #ifdef 
__USE_MISC


150 typedef unsigned long int 
	tulong
;

151 typedef unsigned short int 
	tushort
;

152 typedef unsigned int 
	tuint
;

157 #if !
__GNUC_PREREQ
 (2, 7)

160 #ifndef 
__int8_t_defined


161 #define 
	#__int8_t_defined


	)

162 typedef char 
	tint8_t
;

163 typedef short int 
	tint16_t
;

164 typedef int 
	tint32_t
;

165 #if 
__WORDSIZE
 == 64

166 typedef long int 
	tint64_t
;

168 
__extension__
 typedef long long int 
	tint64_t
;

173 typedef unsigned char 
	tu_int8_t
;

174 typedef unsigned short int 
	tu_int16_t
;

175 typedef unsigned int 
	tu_int32_t
;

176 #if 
__WORDSIZE
 == 64

177 typedef unsigned long int 
	tu_int64_t
;

179 
__extension__
 typedef unsigned long long int 
	tu_int64_t
;

182 typedef int 
	tregister_t
;

187 #define 
	#__intN_t
(
N
, 
MODE
) \

188 typedef int int##
	tN
##
	t_t
 
	t__attribute__
 ((
	t__mode__
 (
	tMODE
)))

	)

189 #define 
	t__u_intN_t
(
	tN
, 
	tMODE
) \

190 typedef unsigned int 
	tu_int
##
	tN
##
	t_t
 
	t__attribute__
 ((
	t__mode__
 (
	tMODE
)))

	)

192 #ifndef 
	t__int8_t_defined


193 #define 
	t__int8_t_defined


	)

194 
	t__intN_t
 (8, 
	t__QI__
);

195 
__intN_t
 (16, 
__HI__
);

196 
__intN_t
 (32, 
__SI__
);

197 
__intN_t
 (64, 
__DI__
);

200 
__u_intN_t
 (8, 
__QI__
);

201 
__u_intN_t
 (16, 
__HI__
);

202 
__u_intN_t
 (32, 
__SI__
);

203 
__u_intN_t
 (64, 
__DI__
);

205 typedef int 
	tregister_t
 
	t__attribute__
 ((
	t__mode__
 (
	t__word__
)));

211 #define 
	#__BIT_TYPES_DEFINED__
 1

	)

214 #ifdef 
__USE_BSD


216 #include 
	~<endian.h
>

219 #include 
	~<sys/select.h
>

222 #include 
	~<sys/sysmacros.h
>

226 #if (
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8
) \

227 && !
defined
 
__blksize_t_defined


228 typedef 
__blksize_t
 
	tblksize_t
;

229 #define 
	#__blksize_t_defined


	)

233 #ifndef 
__USE_FILE_OFFSET64


234 #ifndef 
__blkcnt_t_defined


235 typedef 
__blkcnt_t
 
	tblkcnt_t
;

236 #define 
	#__blkcnt_t_defined


	)

238 #ifndef 
__fsblkcnt_t_defined


239 typedef 
__fsblkcnt_t
 
	tfsblkcnt_t
;

240 #define 
	#__fsblkcnt_t_defined


	)

242 #ifndef 
__fsfilcnt_t_defined


243 typedef 
__fsfilcnt_t
 
	tfsfilcnt_t
;

244 #define 
	#__fsfilcnt_t_defined


	)

247 #ifndef 
__blkcnt_t_defined


248 typedef 
__blkcnt64_t
 
	tblkcnt_t
;

249 #define 
	#__blkcnt_t_defined


	)

251 #ifndef 
__fsblkcnt_t_defined


252 typedef 
__fsblkcnt64_t
 
	tfsblkcnt_t
;

253 #define 
	#__fsblkcnt_t_defined


	)

255 #ifndef 
__fsfilcnt_t_defined


256 typedef 
__fsfilcnt64_t
 
	tfsfilcnt_t
;

257 #define 
	#__fsfilcnt_t_defined


	)

261 #ifdef 
__USE_LARGEFILE64


262 typedef 
__blkcnt64_t
 
	tblkcnt64_t
;

263 typedef 
__fsblkcnt64_t
 
	tfsblkcnt64_t
;

264 typedef 
__fsfilcnt64_t
 
	tfsfilcnt64_t
;

269 #if 
defined
 
__USE_POSIX199506
 || defined 
__USE_UNIX98


270 #include 
	~<bits/pthreadtypes.h
>

273 
	g__END_DECLS


	@/usr/include/xlocale.h

20 #ifndef 
_XLOCALE_H


21 #define 
	#_XLOCALE_H
 1

	)

27 typedef struct 
	s__locale_struct


30 struct 
__locale_data
 *
	m__locales
[13];

33 const unsigned short int *
	m__ctype_b
;

34 const int *
	m__ctype_tolower
;

35 const int *
	m__ctype_toupper
;

38 const char *
	m__names
[13];

39 } *
	t__locale_t
;

42 typedef 
__locale_t
 
	tlocale_t
;

	@/usr/include/_G_config.h

4 #ifndef 
_G_config_h


5 #define 
	#_G_config_h
 1

	)

9 #include 
	~<bits/types.h
>

10 #define 
	#__need_size_t


	)

11 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


12 #define 
	#__need_wchar_t


	)

14 #define 
	#__need_NULL


	)

15 #include 
	~<stddef.h
>

16 #define 
	#__need_mbstate_t


	)

17 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


18 #define 
	#__need_wint_t


	)

20 #include 
	~<wchar.h
>

23 
__off_t
 
	m__pos
;

24 
__mbstate_t
 
	m__state
;

25 } 
	t_G_fpos_t
;

28 
__off64_t
 
	m__pos
;

29 
__mbstate_t
 
	m__state
;

30 } 
	t_G_fpos64_t
;

31 #if 
defined
 
_LIBC
 || defined 
_GLIBCPP_USE_WCHAR_T


32 #include 
	~<gconv.h
>

35 struct 
__gconv_info
 
	m__cd
;

38 struct 
__gconv_info
 
	m__cd
;

39 struct 
__gconv_step_data
 
	m__data
;

40 } 
	m__combined
;

41 } 
	t_G_iconv_t
;

46 #define 
	#_G_va_list
 
__gnuc_va_list


	)

48 #define 
	#_G_HAVE_MMAP
 1

	)

49 #define 
	#_G_HAVE_MREMAP
 1

	)

51 #define 
	#_G_IO_IO_FILE_VERSION
 0x20001

	)

54 #define 
	#_G_HAVE_ST_BLKSIZE
 
	`defined
 (
_STATBUF_ST_BLKSIZE
)

	)

56 #define 
	#_G_BUFSIZ
 8192

	)

	@/usr/include/bits/byteswap.h

19 #if !
defined
 
_BYTESWAP_H
 && !defined 
_NETINET_IN_H
 && !defined 
_ENDIAN_H


23 #ifndef 
_BITS_BYTESWAP_H


24 #define 
	#_BITS_BYTESWAP_H
 1

	)

26 #include 
	~<features.h
>

27 #include 
	~<bits/types.h
>

28 #include 
	~<bits/wordsize.h
>

31 #define 
	#__bswap_constant_16
(
x
) \

32 ((unsigned short int) ((((
x
) >> 8) & 0xff) | (((x) & 0xff) << 8)))

	)

35 #include 
	~<bits/byteswap-16.h
>

38 #define 
	#__bswap_constant_32
(
x
) \

39 ((((
x
) & 0xff000000) >> 24) | (((x) & 0x00ff0000) >> 8) | \

40 (((
x
) & 0x0000ff00) << 8) | (((x) & 0x000000ff) << 24))

	)

42 #ifdef 
__GNUC__


43 #if 
__GNUC_PREREQ
 (4, 3)

44 static 
__inline
 unsigned int

45 
	$__bswap_32
 (unsigned int 
__bsx
)

47 return 
	`__builtin_bswap32
 (
__bsx
);

48 
	}
}

49 #elif 
__GNUC__
 >= 2

50 #if 
__WORDSIZE
 == 64 || (
defined
 
__i486__
 || defined 
__pentium__
 \

51 || 
defined
 
	g__pentiumpro__
 || defined 
	g__pentium4__
 \

52 || 
defined
 
	g__k8__
 || defined 
	g__athlon__
 \

53 || 
defined
 
	g__k6__
 || defined 
	g__nocona__
 \

54 || 
defined
 
	g__core2__
 || defined 
	g__geode__
 \

55 || 
defined
 
	g__amdfam10__
)

58 #define 
	#__bswap_32
(
x
) \

59 (
__extension__
 \

60 ({ unsigned int 
__v
, 
__x
 = (
x
); \

61 if (
	`__builtin_constant_p
 (
__x
)) \

62 
__v
 = 
	`__bswap_constant_32
 (
__x
); \

64 
	`__asm__
 ("bswap %0" : "=r" (
__v
) : "0" (
__x
)); \

65 
__v
; }))

	)

67 #define 
	#__bswap_32
(
x
) \

68 (
__extension__
 \

69 ({ unsigned int 
__v
, 
__x
 = (
x
); \

70 if (
	`__builtin_constant_p
 (
__x
)) \

71 
__v
 = 
	`__bswap_constant_32
 (
__x
); \

73 
	`__asm__
 ("rorw $8, %w0;" \

76 : "=r" (
__v
) \

77 : "0" (
__x
) \

79 
__v
; }))

	)

82 #define 
	#__bswap_32
(
x
) \

83 (
__extension__
 \

84 ({ unsigned int 
__x
 = (
x
); 
	`__bswap_constant_32
 (__x); }))

	)

87 static 
__inline
 unsigned int

88 
	$__bswap_32
 (unsigned int 
__bsx
)

90 return 
	`__bswap_constant_32
 (
__bsx
);

91 
	}
}

95 #if 
__GNUC_PREREQ
 (2, 0)

97 #define 
	#__bswap_constant_64
(
x
) \

98 (
	`__extension__
 ((((
x
) & 0xff00000000000000ull) >> 56) \

99 | (((
x
) & 0x00ff000000000000ull) >> 40) \

100 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

101 | (((
x
) & 0x000000ff00000000ull) >> 8) \

102 | (((
x
) & 0x00000000ff000000ull) << 8) \

103 | (((
x
) & 0x0000000000ff0000ull) << 24) \

104 | (((
x
) & 0x000000000000ff00ull) << 40) \

105 | (((
x
) & 0x00000000000000ffull) << 56)))

	)

107 #if 
__GNUC_PREREQ
 (4, 3)

108 static 
__inline
 
__uint64_t


109 
	$__bswap_64
 (
__uint64_t
 
__bsx
)

111 return 
	`__builtin_bswap64
 (
__bsx
);

112 
	}
}

113 #elif 
__WORDSIZE
 == 64

114 #define 
	#__bswap_64
(
x
) \

115 (
__extension__
 \

116 ({ 
__uint64_t
 
__v
, 
__x
 = (
x
); \

117 if (
	`__builtin_constant_p
 (
__x
)) \

118 
__v
 = 
	`__bswap_constant_64
 (
__x
); \

120 
	`__asm__
 ("bswap %q0" : "=r" (
__v
) : "0" (
__x
)); \

121 
__v
; }))

	)

123 #define 
	#__bswap_64
(
x
) \

124 (
__extension__
 \

125 ({ union { 
__extension__
 
__uint64_t
 
__ll
; \

126 unsigned int 
__l
[2]; } 
__w
, 
__r
; \

127 if (
	`__builtin_constant_p
 (
x
)) \

128 
__r
.
__ll
 = 
	`__bswap_constant_64
 (
x
); \

131 
__w
.
__ll
 = (
x
); \

132 
__r
.
__l
[0] = 
	`__bswap_32
 (
__w
.__l[1]); \

133 
__r
.
__l
[1] = 
	`__bswap_32
 (
__w
.__l[0]); \

135 
__r
.
__ll
; }))

	)

138 #define 
	#__bswap_constant_64
(
x
) \

139 ((((
x
) & 0xff00000000000000ull) >> 56) \

140 | (((
x
) & 0x00ff000000000000ull) >> 40) \

141 | (((
x
) & 0x0000ff0000000000ull) >> 24) \

142 | (((
x
) & 0x000000ff00000000ull) >> 8) \

143 | (((
x
) & 0x00000000ff000000ull) << 8) \

144 | (((
x
) & 0x0000000000ff0000ull) << 24) \

145 | (((
x
) & 0x000000000000ff00ull) << 40) \

146 | (((
x
) & 0x00000000000000ffull) << 56))

	)

148 static 
__inline
 
__uint64_t


149 
	$__bswap_64
 (
__uint64_t
 
__bsx
)

151 return 
	`__bswap_constant_64
 (
__bsx
);

152 
	}
}

	@/usr/include/bits/endian.h

3 #ifndef 
_ENDIAN_H


7 #define 
	#__BYTE_ORDER
 
__LITTLE_ENDIAN


	)

	@/usr/include/bits/libio-ldbl.h

19 #ifndef 
_IO_STDIO_H


23 
	$__LDBL_REDIR_DECL
 (
_IO_vfscanf
)

24 
	`__LDBL_REDIR_DECL
 (
_IO_vfprintf
)

	@/usr/include/bits/pthreadtypes.h

18 #ifndef 
_BITS_PTHREADTYPES_H


19 #define 
	#_BITS_PTHREADTYPES_H
 1

	)

21 #include 
	~<bits/wordsize.h
>

23 #ifdef 
__x86_64__


24 #if 
__WORDSIZE
 == 64

25 #define 
	#__SIZEOF_PTHREAD_ATTR_T
 56

	)

26 #define 
	#__SIZEOF_PTHREAD_MUTEX_T
 40

	)

27 #define 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

28 #define 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

29 #define 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

30 #define 
	#__SIZEOF_PTHREAD_RWLOCK_T
 56

	)

31 #define 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

32 #define 
	#__SIZEOF_PTHREAD_BARRIER_T
 32

	)

33 #define 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

35 #define 
	#__SIZEOF_PTHREAD_ATTR_T
 32

	)

36 #define 
	#__SIZEOF_PTHREAD_MUTEX_T
 32

	)

37 #define 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

38 #define 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

39 #define 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

40 #define 
	#__SIZEOF_PTHREAD_RWLOCK_T
 44

	)

41 #define 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

42 #define 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

43 #define 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

46 #define 
	#__SIZEOF_PTHREAD_ATTR_T
 36

	)

47 #define 
	#__SIZEOF_PTHREAD_MUTEX_T
 24

	)

48 #define 
	#__SIZEOF_PTHREAD_MUTEXATTR_T
 4

	)

49 #define 
	#__SIZEOF_PTHREAD_COND_T
 48

	)

50 #define 
	#__SIZEOF_PTHREAD_CONDATTR_T
 4

	)

51 #define 
	#__SIZEOF_PTHREAD_RWLOCK_T
 32

	)

52 #define 
	#__SIZEOF_PTHREAD_RWLOCKATTR_T
 8

	)

53 #define 
	#__SIZEOF_PTHREAD_BARRIER_T
 20

	)

54 #define 
	#__SIZEOF_PTHREAD_BARRIERATTR_T
 4

	)

60 typedef unsigned long int 
	tpthread_t
;

63 union 
	upthread_attr_t


65 char 
	m__size
[
__SIZEOF_PTHREAD_ATTR_T
];

66 long int 
	m__align
;

68 #ifndef 
__have_pthread_attr_t


69 typedef union 
pthread_attr_t
 
	tpthread_attr_t
;

70 #define 
	#__have_pthread_attr_t
 1

	)

74 #ifdef 
__x86_64__


75 typedef struct 
	s__pthread_internal_list


77 struct 
__pthread_internal_list
 *
	m__prev
;

78 struct 
__pthread_internal_list
 *
	m__next
;

79 } 
	t__pthread_list_t
;

81 typedef struct 
	s__pthread_internal_slist


83 struct 
__pthread_internal_slist
 *
	m__next
;

84 } 
	t__pthread_slist_t
;

92 struct 
	s__pthread_mutex_s


94 int 
	m__lock
;

95 unsigned int 
	m__count
;

96 int 
	m__owner
;

97 #ifdef 
__x86_64__


98 unsigned int 
	m__nusers
;

102 int 
	m__kind
;

103 #ifdef 
__x86_64__


104 short 
	m__spins
;

105 short 
	m__elision
;

106 
__pthread_list_t
 
	m__list
;

107 #define 
	#__PTHREAD_MUTEX_HAVE_PREV
 1

	)

108 #define 
	#__PTHREAD_MUTEX_HAVE_ELISION
 1

	)

110 unsigned int 
	m__nusers
;

111 
__extension__
 union

115 short 
	m__espins
;

116 short 
	m__elision
;

117 #define 
	#__spins
 
d
.
__espins


	)

118 #define 
	#__elision
 
d
.
__elision


	)

119 #define 
	#__PTHREAD_MUTEX_HAVE_ELISION
 2

	)

120 } 
	md
;

121 
__pthread_slist_t
 
	m__list
;

124 } 
	m__data
;

125 char 
	m__size
[
__SIZEOF_PTHREAD_MUTEX_T
];

126 long int 
	m__align
;

127 } 
	tpthread_mutex_t
;

131 char 
	m__size
[
__SIZEOF_PTHREAD_MUTEXATTR_T
];

132 int 
	m__align
;

133 } 
	tpthread_mutexattr_t
;

142 int 
	m__lock
;

143 unsigned int 
	m__futex
;

144 
__extension__
 unsigned long long int 
	m__total_seq
;

145 
__extension__
 unsigned long long int 
	m__wakeup_seq
;

146 
__extension__
 unsigned long long int 
	m__woken_seq
;

147 void *
	m__mutex
;

148 unsigned int 
	m__nwaiters
;

149 unsigned int 
	m__broadcast_seq
;

150 } 
	m__data
;

151 char 
	m__size
[
__SIZEOF_PTHREAD_COND_T
];

152 
__extension__
 long long int 
	m__align
;

153 } 
	tpthread_cond_t
;

157 char 
	m__size
[
__SIZEOF_PTHREAD_CONDATTR_T
];

158 int 
	m__align
;

159 } 
	tpthread_condattr_t
;

163 typedef unsigned int 
	tpthread_key_t
;

167 typedef int 
	tpthread_once_t
;

170 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


175 #ifdef 
__x86_64__


178 int 
	m__lock
;

179 unsigned int 
	m__nr_readers
;

180 unsigned int 
	m__readers_wakeup
;

181 unsigned int 
	m__writer_wakeup
;

182 unsigned int 
	m__nr_readers_queued
;

183 unsigned int 
	m__nr_writers_queued
;

184 int 
	m__writer
;

185 int 
	m__shared
;

186 unsigned long int 
	m__pad1
;

187 unsigned long int 
	m__pad2
;

190 unsigned int 
	m__flags
;

191 #define 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

192 } 
	m__data
;

196 int 
	m__lock
;

197 unsigned int 
	m__nr_readers
;

198 unsigned int 
	m__readers_wakeup
;

199 unsigned int 
	m__writer_wakeup
;

200 unsigned int 
	m__nr_readers_queued
;

201 unsigned int 
	m__nr_writers_queued
;

204 unsigned char 
	m__flags
;

205 unsigned char 
	m__shared
;

206 unsigned char 
	m__pad1
;

207 unsigned char 
	m__pad2
;

208 int 
	m__writer
;

209 } 
	m__data
;

211 char 
	m__size
[
__SIZEOF_PTHREAD_RWLOCK_T
];

212 long int 
	m__align
;

213 } 
	tpthread_rwlock_t
;

217 char 
	m__size
[
__SIZEOF_PTHREAD_RWLOCKATTR_T
];

218 long int 
	m__align
;

219 } 
	tpthread_rwlockattr_t
;

223 #ifdef 
__USE_XOPEN2K


225 typedef volatile int 
	tpthread_spinlock_t
;

232 char 
	m__size
[
__SIZEOF_PTHREAD_BARRIER_T
];

233 long int 
	m__align
;

234 } 
	tpthread_barrier_t
;

238 char 
	m__size
[
__SIZEOF_PTHREAD_BARRIERATTR_T
];

239 int 
	m__align
;

240 } 
	tpthread_barrierattr_t
;

244 #ifndef 
__x86_64__


246 #define 
	#__cleanup_fct_attribute
 
	`__attribute__
 ((
	`__regparm__
 (1)))

	)

	@/usr/include/bits/stdio-lock.h

19 #ifndef 
_BITS_STDIO_LOCK_H


20 #define 
	#_BITS_STDIO_LOCK_H
 1

	)

22 #include 
	~<bits/libc-lock.h
>

23 #include 
	~<lowlevellock.h
>

27 #define 
	#_IO_lock_inexpensive
 1

	)

29 typedef struct { int 
	mlock
; int 
	mcnt
; void *
	mowner
; } 
	t_IO_lock_t
;

31 #define 
	#_IO_lock_initializer
 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

33 #define 
	#_IO_lock_init
(
_name
) \

34 ((
_name
) = (
_IO_lock_t
) 
_IO_lock_initializer
 , 0)

	)

36 #define 
	#_IO_lock_fini
(
_name
) \

37 ((void) 0)

	)

39 #define 
	#_IO_lock_lock
(
_name
) \

41 void *
__self
 = 
THREAD_SELF
; \

42 if ((
_name
).
owner
 != 
__self
) \

44 
	`lll_lock
 ((
_name
).
lock
, 
LLL_PRIVATE
); \

45 (
_name
).
owner
 = 
__self
; \

47 ++(
_name
).
cnt
; \

48 } while (0)

	)

50 #define 
	#_IO_lock_trylock
(
_name
) \

52 int 
__result
 = 0; \

53 void *
__self
 = 
THREAD_SELF
; \

54 if ((
_name
).
owner
 != 
__self
) \

56 if (
	`lll_trylock
 ((
_name
).
lock
) == 0) \

58 (
_name
).
owner
 = 
__self
; \

59 (
_name
).
cnt
 = 1; \

62 
__result
 = 
EBUSY
; \

65 ++(
_name
).
cnt
; \

66 
__result
; \

67 })

	)

69 #define 
	#_IO_lock_unlock
(
_name
) \

71 if (--(
_name
).
cnt
 == 0) \

73 (
_name
).
owner
 = 
NULL
; \

74 
	`lll_unlock
 ((
_name
).
lock
, 
LLL_PRIVATE
); \

76 } while (0)

	)

80 #define 
	#_IO_cleanup_region_start
(
_fct
, 
_fp
) \

81 
	`__libc_cleanup_region_start
 (((
_fp
)->
_flags
 & 
_IO_USER_LOCK
) == 0, 
_fct
, _fp)

	)

82 #define 
	#_IO_cleanup_region_start_noarg
(
_fct
) \

83 
	`__libc_cleanup_region_start
 (1, 
_fct
, 
NULL
)

	)

84 #define 
	#_IO_cleanup_region_end
(
_doit
) \

85 
	`__libc_cleanup_region_end
 (
_doit
)

	)

87 #if 
defined
 
_LIBC
 && !defined 
NOT_IN_libc


89 #ifdef 
__EXCEPTIONS


90 #define 
	#_IO_acquire_lock
(
_fp
) \

92 
_IO_FILE
 *
_IO_acquire_lock_file
 \

93 
	`__attribute__
((
	`cleanup
 (
_IO_acquire_lock_fct
))) \

94 = (
_fp
); \

95 
	`_IO_flockfile
 (
_IO_acquire_lock_file
);

	)

96 #define 
	#_IO_acquire_lock_clear_flags2
(
_fp
) \

98 
_IO_FILE
 *
_IO_acquire_lock_file
 \

99 
	`__attribute__
((
	`cleanup
 (
_IO_acquire_lock_clear_flags2_fct
))) \

100 = (
_fp
); \

101 
	`_IO_flockfile
 (
_IO_acquire_lock_file
);

	)

103 #define 
	#_IO_acquire_lock
(
_fp
) 
_IO_acquire_lock_needs_exceptions_enabled


	)

104 #define 
	#_IO_acquire_lock_clear_flags2
(
_fp
) 
	`_IO_acquire_lock
 (_fp)

	)

106 #define 
	#_IO_release_lock
(
_fp
) ; } while (0)

	)

	@/usr/include/bits/typesizes.h

19 #ifndef 
_BITS_TYPES_H


23 #ifndef 
_BITS_TYPESIZES_H


24 #define 
	#_BITS_TYPESIZES_H
 1

	)

30 #if 
defined
 
__x86_64__
 && defined 
__ILP32__


31 #define 
	#__SYSCALL_SLONG_TYPE
 
__SQUAD_TYPE


	)

32 #define 
	#__SYSCALL_ULONG_TYPE
 
__UQUAD_TYPE


	)

34 #define 
	#__SYSCALL_SLONG_TYPE
 
__SLONGWORD_TYPE


	)

35 #define 
	#__SYSCALL_ULONG_TYPE
 
__ULONGWORD_TYPE


	)

38 #define 
	#__DEV_T_TYPE
 
__UQUAD_TYPE


	)

39 #define 
	#__UID_T_TYPE
 
__U32_TYPE


	)

40 #define 
	#__GID_T_TYPE
 
__U32_TYPE


	)

41 #define 
	#__INO_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

42 #define 
	#__INO64_T_TYPE
 
__UQUAD_TYPE


	)

43 #define 
	#__MODE_T_TYPE
 
__U32_TYPE


	)

44 #ifdef 
__x86_64__


45 #define 
	#__NLINK_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

46 #define 
	#__FSWORD_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

48 #define 
	#__NLINK_T_TYPE
 
__UWORD_TYPE


	)

49 #define 
	#__FSWORD_T_TYPE
 
__SWORD_TYPE


	)

51 #define 
	#__OFF_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

52 #define 
	#__OFF64_T_TYPE
 
__SQUAD_TYPE


	)

53 #define 
	#__PID_T_TYPE
 
__S32_TYPE


	)

54 #define 
	#__RLIM_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

55 #define 
	#__RLIM64_T_TYPE
 
__UQUAD_TYPE


	)

56 #define 
	#__BLKCNT_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

57 #define 
	#__BLKCNT64_T_TYPE
 
__SQUAD_TYPE


	)

58 #define 
	#__FSBLKCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

59 #define 
	#__FSBLKCNT64_T_TYPE
 
__UQUAD_TYPE


	)

60 #define 
	#__FSFILCNT_T_TYPE
 
__SYSCALL_ULONG_TYPE


	)

61 #define 
	#__FSFILCNT64_T_TYPE
 
__UQUAD_TYPE


	)

62 #define 
	#__ID_T_TYPE
 
__U32_TYPE


	)

63 #define 
	#__CLOCK_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

64 #define 
	#__TIME_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

65 #define 
	#__USECONDS_T_TYPE
 
__U32_TYPE


	)

66 #define 
	#__SUSECONDS_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

67 #define 
	#__DADDR_T_TYPE
 
__S32_TYPE


	)

68 #define 
	#__KEY_T_TYPE
 
__S32_TYPE


	)

69 #define 
	#__CLOCKID_T_TYPE
 
__S32_TYPE


	)

70 #define 
	#__TIMER_T_TYPE
 void *

	)

71 #define 
	#__BLKSIZE_T_TYPE
 
__SYSCALL_SLONG_TYPE


	)

72 #define 
	#__FSID_T_TYPE
 struct { int 
__val
[2]; }

	)

73 #define 
	#__SSIZE_T_TYPE
 
__SWORD_TYPE


	)

75 #ifdef 
__x86_64__


79 #define 
	#__OFF_T_MATCHES_OFF64_T
 1

	)

82 #define 
	#__INO_T_MATCHES_INO64_T
 1

	)

86 #define 
	#__FD_SETSIZE
 1024

	)

	@/usr/include/gnu/stubs.h

6 #if !
defined
 
__x86_64__


7 #include 
	~<gnu/stubs-32.h
>

9 #if 
defined
 
__x86_64__
 && defined 
__LP64__


10 #include 
	~<gnu/stubs-64.h
>

12 #if 
defined
 
__x86_64__
 && defined 
__ILP32__


13 #include 
	~<gnu/stubs-x32.h
>

	@/usr/include/stdc-predef.h

18 #ifndef 
_STDC_PREDEF_H


19 #define 
	#_STDC_PREDEF_H
 1

	)

36 #ifdef 
__GCC_IEC_559


37 #if 
__GCC_IEC_559
 > 0

38 #define 
	#__STDC_IEC_559__
 1

	)

41 #define 
	#__STDC_IEC_559__
 1

	)

44 #ifdef 
__GCC_IEC_559_COMPLEX


45 #if 
__GCC_IEC_559_COMPLEX
 > 0

46 #define 
	#__STDC_IEC_559_COMPLEX__
 1

	)

49 #define 
	#__STDC_IEC_559_COMPLEX__
 1

	)

54 #define 
	#__STDC_ISO_10646__
 201103L

	)

57 #define 
	#__STDC_NO_THREADS__
 1

	)

	@/usr/include/sys/cdefs.h

18 #ifndef 
_SYS_CDEFS_H


19 #define 
	#_SYS_CDEFS_H
 1

	)

22 #ifndef 
_FEATURES_H


23 #include 
	~<features.h
>

29 #if 
defined
 
__GNUC__
 && !defined 
__STDC__


34 #undef 
__P


35 #undef 
__PMT


37 #ifdef 
__GNUC__


41 #if 
__GNUC_PREREQ
 (4, 6) && !
defined
 
_LIBC


42 #define 
	#__LEAF
 , 
__leaf__


	)

43 #define 
	#__LEAF_ATTR
 
	`__attribute__
 ((
__leaf__
))

	)

45 #define 
	#__LEAF


	)

46 #define 
	#__LEAF_ATTR


	)

54 #if !
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (3, 3)

55 #define 
	#__THROW
 
	`__attribute__
 ((
__nothrow__
 
__LEAF
))

	)

56 #define 
	#__THROWNL
 
	`__attribute__
 ((
__nothrow__
))

	)

57 #define 
	#__NTH
(
fct
) 
	`__attribute__
 ((
__nothrow__
 
__LEAF
)) 
	)
fct

59 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (2,8)

60 #define 
	#__THROW
 
	`throw
 ()

	)

61 #define 
	#__THROWNL
 
	`throw
 ()

	)

62 #define 
	#__NTH
(
fct
) 
__LEAF_ATTR
 fct 
	`throw
 ()

	)

64 #define 
	#__THROW


	)

65 #define 
	#__THROWNL


	)

66 #define 
	#__NTH
(
fct
) 
	)
fct

72 #define 
	#__inline


	)

74 #define 
	#__THROW


	)

75 #define 
	#__THROWNL


	)

76 #define 
	#__NTH
(
fct
) 
	)
fct

82 #define 
	#__P
(
args
) 
	)
args

83 #define 
	#__PMT
(
args
) 
	)
args

88 #define 
	#__CONCAT
(
x
,
y
) x ## 
	)
y

89 #define 
	#__STRING
(
x
) #x

	)

92 #define 
	#__ptr_t
 void *

	)

93 #define 
	#__long_double_t
 long double

	)

97 #ifdef 
__cplusplus


98 #define 
	#__BEGIN_DECLS
 extern "C" {

	)

99 #define 
	#__END_DECLS
 }

	)

101 #define 
	#__BEGIN_DECLS


	)

102 #define 
	#__END_DECLS


	)

111 #if 
defined
 
__cplusplus
 && defined 
_GLIBCPP_USE_NAMESPACES


112 #define 
	#__BEGIN_NAMESPACE_STD
 
namespace
 
std
 {

	)

113 #define 
	#__END_NAMESPACE_STD
 }

	)

114 #define 
	#__USING_NAMESPACE_STD
(
name
) 
using
 
std
::name;

	)

115 #define 
	#__BEGIN_NAMESPACE_C99
 
namespace
 
__c99
 {

	)

116 #define 
	#__END_NAMESPACE_C99
 }

	)

117 #define 
	#__USING_NAMESPACE_C99
(
name
) 
using
 
__c99
::name;

	)

122 #define 
	#__BEGIN_NAMESPACE_STD


	)

123 #define 
	#__END_NAMESPACE_STD


	)

124 #define 
	#__USING_NAMESPACE_STD
(
name
)

	)

125 #define 
	#__BEGIN_NAMESPACE_C99


	)

126 #define 
	#__END_NAMESPACE_C99


	)

127 #define 
	#__USING_NAMESPACE_C99
(
name
)

	)

132 #define 
	#__bos
(
ptr
) 
	`__builtin_object_size
 (ptr, 
__USE_FORTIFY_LEVEL
 > 1)

	)

133 #define 
	#__bos0
(
ptr
) 
	`__builtin_object_size
 (ptr, 0)

	)

134 #define 
	#__fortify_function
 
__extern_always_inline
 
__attribute_artificial__


	)

136 #if 
__GNUC_PREREQ
 (4,3)

137 #define 
	#__warndecl
(
name
, 
msg
) \

138 extern void 
	`name
 (void) 
	`__attribute__
((
	`__warning__
 (
msg
)))

	)

139 #define 
	#__warnattr
(
msg
) 
	`__attribute__
((
	`__warning__
 (msg)))

	)

140 #define 
	#__errordecl
(
name
, 
msg
) \

141 extern void 
	`name
 (void) 
	`__attribute__
((
	`__error__
 (
msg
)))

	)

143 #define 
	#__warndecl
(
name
, 
msg
) extern void 
	`name
 (void)

	)

144 #define 
	#__warnattr
(
msg
)

	)

145 #define 
	#__errordecl
(
name
, 
msg
) extern void 
	`name
 (void)

	)

149 #if 
__GNUC_PREREQ
 (2,97)

151 #define 
	#__flexarr
 []

	)

153 #ifdef 
__GNUC__


154 #define 
	#__flexarr
 [0]

	)

156 #if 
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

157 #define 
	#__flexarr
 []

	)

160 #define 
	#__flexarr
 [1]

	)

176 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

178 #define 
	#__REDIRECT
(
name
, 
proto
, 
alias
) name proto 
	`__asm__
 (
	`__ASMNAME
 (#alias))

	)

179 #ifdef 
__cplusplus


180 #define 
	#__REDIRECT_NTH
(
name
, 
proto
, 
alias
) \

181 
name
 
proto
 
__THROW
 
	`__asm__
 (
	`__ASMNAME
 (#alias))

	)

182 #define 
	#__REDIRECT_NTHNL
(
name
, 
proto
, 
alias
) \

183 
name
 
proto
 
__THROWNL
 
	`__asm__
 (
	`__ASMNAME
 (#alias))

	)

185 #define 
	#__REDIRECT_NTH
(
name
, 
proto
, 
alias
) \

186 
name
 
proto
 
	`__asm__
 (
	`__ASMNAME
 (#alias)) 
__THROW


	)

187 #define 
	#__REDIRECT_NTHNL
(
name
, 
proto
, 
alias
) \

188 
name
 
proto
 
	`__asm__
 (
	`__ASMNAME
 (#alias)) 
__THROWNL


	)

190 #define 
	#__ASMNAME
(
cname
) 
	`__ASMNAME2
 (
__USER_LABEL_PREFIX__
, cname)

	)

191 #define 
	#__ASMNAME2
(
prefix
, 
cname
) 
	`__STRING
 (prefix) 
	)
cname

204 #if !
defined
 
__GNUC__
 || __GNUC__ < 2

205 #define 
	#__attribute__
(
xyz
)

	)

211 #if 
__GNUC_PREREQ
 (2,96)

212 #define 
	#__attribute_malloc__
 
	`__attribute__
 ((
__malloc__
))

	)

214 #define 
	#__attribute_malloc__


	)

219 #if 
__GNUC_PREREQ
 (4, 3)

220 #define 
	#__attribute_alloc_size__
(
params
) \

221 
	`__attribute__
 ((
__alloc_size__
 
params
))

	)

223 #define 
	#__attribute_alloc_size__
(
params
)

	)

229 #if 
__GNUC_PREREQ
 (2,96)

230 #define 
	#__attribute_pure__
 
	`__attribute__
 ((
__pure__
))

	)

232 #define 
	#__attribute_pure__


	)

236 #if 
__GNUC_PREREQ
 (2,5)

237 #define 
	#__attribute_const__
 
	`__attribute__
 ((
__const__
))

	)

239 #define 
	#__attribute_const__


	)

245 #if 
__GNUC_PREREQ
 (3,1)

246 #define 
	#__attribute_used__
 
	`__attribute__
 ((
__used__
))

	)

247 #define 
	#__attribute_noinline__
 
	`__attribute__
 ((
__noinline__
))

	)

249 #define 
	#__attribute_used__
 
	`__attribute__
 ((
__unused__
))

	)

250 #define 
	#__attribute_noinline__


	)

254 #if 
__GNUC_PREREQ
 (3,2)

255 #define 
	#__attribute_deprecated__
 
	`__attribute__
 ((
__deprecated__
))

	)

257 #define 
	#__attribute_deprecated__


	)

266 #if 
__GNUC_PREREQ
 (2,8)

267 #define 
	#__attribute_format_arg__
(
x
) 
	`__attribute__
 ((
	`__format_arg__
 (x)))

	)

269 #define 
	#__attribute_format_arg__
(
x
)

	)

276 #if 
__GNUC_PREREQ
 (2,97)

277 #define 
	#__attribute_format_strfmon__
(
a
,
b
) \

278 
	`__attribute__
 ((
	`__format__
 (
__strfmon__
, 
a
, 
b
)))

	)

280 #define 
	#__attribute_format_strfmon__
(
a
,
b
)

	)

285 #if 
__GNUC_PREREQ
 (3,3)

286 #define 
	#__nonnull
(
params
) 
	`__attribute__
 ((
__nonnull__
 params))

	)

288 #define 
	#__nonnull
(
params
)

	)

293 #if 
__GNUC_PREREQ
 (3,4)

294 #define 
	#__attribute_warn_unused_result__
 \

295 
	`__attribute__
 ((
__warn_unused_result__
))

	)

296 #if 
__USE_FORTIFY_LEVEL
 > 0

297 #define 
	#__wur
 
__attribute_warn_unused_result__


	)

300 #define 
	#__attribute_warn_unused_result__


	)

302 #ifndef 
__wur


303 #define 
	#__wur


	)

307 #if 
__GNUC_PREREQ
 (3,2)

308 #define 
	#__always_inline
 
__inline
 
	`__attribute__
 ((
__always_inline__
))

	)

310 #define 
	#__always_inline
 
__inline


	)

315 #if 
__GNUC_PREREQ
 (4,3)

316 #define 
	#__attribute_artificial__
 
	`__attribute__
 ((
__artificial__
))

	)

318 #define 
	#__attribute_artificial__


	)

321 #ifdef 
__GNUC__


326 #if 
defined
 
__GNUC_STDC_INLINE__
 || defined 
__GNUC_GNU_INLINE__


327 #define 
	#__extern_inline
 extern 
__inline
 
	`__attribute__
 ((
__gnu_inline__
))

	)

328 #define 
	#__extern_always_inline
 \

329 extern 
__always_inline
 
	`__attribute__
 ((
__gnu_inline__
))

	)

331 #define 
	#__extern_inline
 extern 
__inline


	)

332 #define 
	#__extern_always_inline
 extern 
__always_inline


	)

335 #define 
	#__extern_inline


	)

336 #define 
	#__extern_always_inline


	)

341 #if 
__GNUC_PREREQ
 (4,3)

342 #define 
	#__va_arg_pack
() 
	`__builtin_va_arg_pack
 ()

	)

343 #define 
	#__va_arg_pack_len
() 
	`__builtin_va_arg_pack_len
 ()

	)

350 #if !
__GNUC_PREREQ
 (2,8)

351 #define 
	#__extension__


	)

355 #if !
__GNUC_PREREQ
 (2,92)

356 #define 
	#__restrict


	)

362 #if 
__GNUC_PREREQ
 (3,1) && !
defined
 
__GNUG__


363 #define 
	#__restrict_arr
 
__restrict


	)

365 #ifdef 
__GNUC__


366 #define 
	#__restrict_arr


	)

368 #if 
defined
 
__STDC_VERSION__
 && __STDC_VERSION__ >= 199901L

369 #define 
	#__restrict_arr
 
restrict


	)

372 #define 
	#__restrict_arr


	)

377 #if 
__GNUC__
 >= 3

378 #define 
	#__glibc_unlikely
(
cond
) 
	`__builtin_expect
 ((cond), 0)

	)

379 #define 
	#__glibc_likely
(
cond
) 
	`__builtin_expect
 ((cond), 1)

	)

381 #define 
	#__glibc_unlikely
(
cond
) (cond)

	)

382 #define 
	#__glibc_likely
(
cond
) (cond)

	)

385 #include 
	~<bits/wordsize.h
>

387 #if 
defined
 
__LONG_DOUBLE_MATH_OPTIONAL
 && defined 
__NO_LONG_DOUBLE_MATH


388 #define 
	#__LDBL_COMPAT
 1

	)

389 #ifdef 
__REDIRECT


390 #define 
	#__LDBL_REDIR1
(
name
, 
proto
, 
alias
) 
	`__REDIRECT
 (name, proto, alias)

	)

391 #define 
	#__LDBL_REDIR
(
name
, 
proto
) \

392 
	`__LDBL_REDIR1
 (
name
, 
proto
, 
__nldbl_
##name)

	)

393 #define 
	#__LDBL_REDIR1_NTH
(
name
, 
proto
, 
alias
) 
	`__REDIRECT_NTH
 (name, proto, alias)

	)

394 #define 
	#__LDBL_REDIR_NTH
(
name
, 
proto
) \

395 
	`__LDBL_REDIR1_NTH
 (
name
, 
proto
, 
__nldbl_
##name)

	)

396 #define 
	#__LDBL_REDIR1_DECL
(
name
, 
alias
) \

397 extern 
	`__typeof
 (
name
) name 
	`__asm
 (
	`__ASMNAME
 (#alias));

	)

398 #define 
	#__LDBL_REDIR_DECL
(
name
) \

399 extern 
	`__typeof
 (
name
) name 
	`__asm
 (
	`__ASMNAME
 ("__nldbl_" #name));

	)

400 #define 
	#__REDIRECT_LDBL
(
name
, 
proto
, 
alias
) \

401 
	`__LDBL_REDIR1
 (
name
, 
proto
, 
__nldbl_
##
alias
)

	)

402 #define 
	#__REDIRECT_NTH_LDBL
(
name
, 
proto
, 
alias
) \

403 
	`__LDBL_REDIR1_NTH
 (
name
, 
proto
, 
__nldbl_
##
alias
)

	)

406 #if !
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT


407 #define 
	#__LDBL_REDIR1
(
name
, 
proto
, 
alias
) name 
	)
proto

408 #define 
	#__LDBL_REDIR
(
name
, 
proto
) name 
	)
proto

409 #define 
	#__LDBL_REDIR1_NTH
(
name
, 
proto
, 
alias
) name proto 
__THROW


	)

410 #define 
	#__LDBL_REDIR_NTH
(
name
, 
proto
) name proto 
__THROW


	)

411 #define 
	#__LDBL_REDIR_DECL
(
name
)

	)

412 #ifdef 
__REDIRECT


413 #define 
	#__REDIRECT_LDBL
(
name
, 
proto
, 
alias
) 
	`__REDIRECT
 (name, proto, alias)

	)

414 #define 
	#__REDIRECT_NTH_LDBL
(
name
, 
proto
, 
alias
) \

415 
	`__REDIRECT_NTH
 (
name
, 
proto
, 
alias
)

	)

	@/usr/include/sys/select.h

21 #ifndef 
_SYS_SELECT_H


22 #define 
	#_SYS_SELECT_H
 1

	)

24 #include 
	~<features.h
>

27 #include 
	~<bits/types.h
>

30 #include 
	~<bits/select.h
>

33 #include 
	~<bits/sigset.h
>

35 #ifndef 
__sigset_t_defined


36 #define 
	#__sigset_t_defined


	)

37 typedef 
__sigset_t
 
	tsigset_t
;

41 #define 
	#__need_time_t


	)

42 #define 
	#__need_timespec


	)

43 #include 
	~<time.h
>

44 #define 
	#__need_timeval


	)

45 #include 
	~<bits/time.h
>

47 #ifndef 
__suseconds_t_defined


48 typedef 
__suseconds_t
 
	tsuseconds_t
;

49 #define 
	#__suseconds_t_defined


	)

54 typedef long int 
	t__fd_mask
;

57 #undef 
__NFDBITS


59 #define 
	#__NFDBITS
 (8 * (int) sizeof (
__fd_mask
))

	)

60 #define 
	#__FD_ELT
(
d
) ((d) / 
__NFDBITS
)

	)

61 #define 
	#__FD_MASK
(
d
) ((
__fd_mask
) 1 << ((d) % 
__NFDBITS
))

	)

68 #ifdef 
__USE_XOPEN


69 
__fd_mask
 
	mfds_bits
[
__FD_SETSIZE
 / 
__NFDBITS
];

70 #define 
	#__FDS_BITS
(
set
) ((set)->
fds_bits
)

	)

72 
__fd_mask
 
	m__fds_bits
[
__FD_SETSIZE
 / 
__NFDBITS
];

73 #define 
	#__FDS_BITS
(
set
) ((set)->
__fds_bits
)

	)

75 } 
	tfd_set
;

78 #define 
	#FD_SETSIZE
 
__FD_SETSIZE


	)

80 #ifdef 
__USE_MISC


82 typedef 
__fd_mask
 
	tfd_mask
;

85 #define 
	#NFDBITS
 
__NFDBITS


	)

90 #define 
	#FD_SET
(
fd
, 
fdsetp
) 
	`__FD_SET
 (fd, fdsetp)

	)

91 #define 
	#FD_CLR
(
fd
, 
fdsetp
) 
	`__FD_CLR
 (fd, fdsetp)

	)

92 #define 
	#FD_ISSET
(
fd
, 
fdsetp
) 
	`__FD_ISSET
 (fd, fdsetp)

	)

93 #define 
	#FD_ZERO
(
fdsetp
) 
	`__FD_ZERO
 (fdsetp)

	)

96 
__BEGIN_DECLS


106 extern int 
select
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

107 
fd_set
 *
__restrict
 
__writefds
,

108 
fd_set
 *
__restrict
 
__exceptfds
,

109 struct 
timeval
 *
__restrict
 
__timeout
);

111 #ifdef 
__USE_XOPEN2K


118 extern int 
pselect
 (int 
__nfds
, 
fd_set
 *
__restrict
 
__readfds
,

119 
fd_set
 *
__restrict
 
__writefds
,

120 
fd_set
 *
__restrict
 
__exceptfds
,

121 const struct 
timespec
 *
__restrict
 
__timeout
,

122 const 
__sigset_t
 *
__restrict
 
__sigmask
);

127 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__GNUC__


128 #include 
	~<bits/select2.h
>

131 
	g__END_DECLS


	@/usr/include/sys/sysmacros.h

19 #ifndef 
_SYS_SYSMACROS_H


20 #define 
	#_SYS_SYSMACROS_H
 1

	)

22 #include 
	~<features.h
>

24 
__BEGIN_DECLS


26 
__extension__


27 extern unsigned int 
	$gnu_dev_major
 (unsigned long long int 
__dev
)

28 
__THROW
 
__attribute_const__
;

29 
__extension__


30 extern unsigned int 
	$gnu_dev_minor
 (unsigned long long int 
__dev
)

31 
__THROW
 
__attribute_const__
;

32 
__extension__


33 extern unsigned long long int 
	$gnu_dev_makedev
 (unsigned int 
__major
,

34 unsigned int 
__minor
)

35 
__THROW
 
__attribute_const__
;

37 #ifdef 
__USE_EXTERN_INLINES


38 
__extension__
 
__extern_inline
 
__attribute_const__
 unsigned int

39 
	`__NTH
 (
	$gnu_dev_major
 (unsigned long long int 
__dev
))

41 return ((
__dev
 >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);

42 
	}
}

44 
__extension__
 
__extern_inline
 
__attribute_const__
 unsigned int

45 
__NTH
 (
	$gnu_dev_minor
 (unsigned long long int 
__dev
))

47 return (
__dev
 & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);

48 
	}
}

50 
__extension__
 
__extern_inline
 
__attribute_const__
 unsigned long long int

51 
__NTH
 (
	$gnu_dev_makedev
 (unsigned int 
__major
, unsigned int 
__minor
))

53 return ((
__minor
 & 0xff) | ((
__major
 & 0xfff) << 8)

54 | (((unsigned long long int) (
__minor
 & ~0xff)) << 12)

55 | (((unsigned long long int) (
__major
 & ~0xfff)) << 32));

56 
	}
}

58 
	g__END_DECLS


61 #define 
	#major
(
dev
) 
	`gnu_dev_major
 (dev)

	)

62 #define 
	#minor
(
dev
) 
	`gnu_dev_minor
 (dev)

	)

63 #define 
	#makedev
(
maj
, 
min
) 
	`gnu_dev_makedev
 (maj, min)

	)

	@/usr/include/time.h

22 #ifndef 
_TIME_H


24 #if (! 
defined
 
__need_time_t
 && !defined 
__need_clock_t
 && \

25 ! 
defined
 
	g__need_timespec
)

26 #define 
	#_TIME_H
 1

	)

27 #include 
	~<features.h
>

29 
	g__BEGIN_DECLS


33 #ifdef 
_TIME_H


35 #define 
	#__need_size_t


	)

36 #define 
	#__need_NULL


	)

37 #include 
	~<stddef.h
>

41 #include 
	~<bits/time.h
>

44 #if !
defined
 
__STRICT_ANSI__
 && !defined 
__USE_XOPEN2K


45 #ifndef 
CLK_TCK


46 #define 
	#CLK_TCK
 
CLOCKS_PER_SEC


	)

52 #if !
defined
 
__clock_t_defined
 && (defined 
_TIME_H
 || defined 
__need_clock_t
)

53 #define 
	#__clock_t_defined
 1

	)

55 #include 
	~<bits/types.h
>

57 
__BEGIN_NAMESPACE_STD


59 typedef 
__clock_t
 
	tclock_t
;

60 
	g__END_NAMESPACE_STD


61 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_POSIX
 || defined 
__USE_MISC


62 
	$__USING_NAMESPACE_STD
(
clock_t
)

66 #undef 
__need_clock_t


68 #if !
defined
 
__time_t_defined
 && (defined 
_TIME_H
 || defined 
__need_time_t
)

69 #define 
	#__time_t_defined
 1

	)

71 #include 
	~<bits/types.h
>

73 
__BEGIN_NAMESPACE_STD


75 typedef 
__time_t
 
	ttime_t
;

76 
__END_NAMESPACE_STD


77 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC
 || defined 
__USE_SVID


78 
	$__USING_NAMESPACE_STD
(
time_t
)

82 #undef 
__need_time_t


84 #if !
defined
 
__clockid_t_defined
 && \

85 ((
defined
 
_TIME_H
 && defined 
__USE_POSIX199309
) || defined 
__need_clockid_t
)

86 #define 
	#__clockid_t_defined
 1

	)

88 #include 
	~<bits/types.h
>

91 typedef 
__clockid_t
 
	tclockid_t
;

94 #undef 
__clockid_time_t


96 #if !
defined
 
__timer_t_defined
 && \

97 ((
defined
 
_TIME_H
 && defined 
__USE_POSIX199309
) || defined 
__need_timer_t
)

98 #define 
	#__timer_t_defined
 1

	)

100 #include 
	~<bits/types.h
>

103 typedef 
__timer_t
 
	ttimer_t
;

106 #undef 
__need_timer_t


109 #if (!
defined
 
__timespec_defined
 \

110 && ((
defined
 
_TIME_H
 \

111 && (
defined
 
__USE_POSIX199309
 || defined 
__USE_MISC
 \

112 || 
defined
 
__USE_ISOC11
)) \

113 || 
defined
 
__need_timespec
))

114 #define 
	#__timespec_defined
 1

	)

116 #include 
	~<bits/types.h
>

120 struct 
	stimespec


122 
__time_t
 
tv_sec
;

123 
__syscall_slong_t
 
tv_nsec
;

127 #undef 
__need_timespec


130 #ifdef 
_TIME_H


131 
__BEGIN_NAMESPACE_STD


133 struct 
	stm


135 int 
tm_sec
;

136 int 
tm_min
;

137 int 
tm_hour
;

138 int 
tm_mday
;

139 int 
tm_mon
;

140 int 
tm_year
;

141 int 
tm_wday
;

142 int 
tm_yday
;

143 int 
tm_isdst
;

145 #ifdef 
__USE_BSD


146 long int 
tm_gmtoff
;

147 const char *
tm_zone
;

149 long int 
__tm_gmtoff
;

150 const char *
__tm_zone
;

153 
__END_NAMESPACE_STD


154 #if 
defined
 
__USE_XOPEN
 || defined 
__USE_POSIX
 || defined 
__USE_MISC


155 
	$__USING_NAMESPACE_STD
(
tm
)

159 #ifdef 
__USE_POSIX199309


161 struct 
	sitimerspec


163 struct 
timespec
 
it_interval
;

164 struct 
timespec
 
it_value
;

168 struct 
sigevent
;

172 #ifdef 
__USE_XOPEN2K


173 #ifndef 
__pid_t_defined


174 typedef 
__pid_t
 
	tpid_t
;

175 #define 
	#__pid_t_defined


	)

180 #ifdef 
__USE_ISOC11


182 #define 
	#TIME_UTC
 1

	)

186 
__BEGIN_NAMESPACE_STD


189 extern 
clock_t
 
	$clock
 (void) 
__THROW
;

192 extern 
time_t
 
	$time
 (
time_t
 *
__timer
) 
__THROW
;

195 extern double 
	$difftime
 (
time_t
 
__time1
, time_t 
__time0
)

196 
__THROW
 
	`__attribute__
 ((
__const__
));

199 extern 
time_t
 
	$mktime
 (struct 
tm
 *
__tp
) 
__THROW
;

205 extern 
size_t
 
	$strftime
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

206 const char *
__restrict
 
__format
,

207 const struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

208 
__END_NAMESPACE_STD


210 #ifdef 
__USE_XOPEN


213 extern char *
	$strptime
 (const char *
__restrict
 
__s
,

214 const char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
)

215 
__THROW
;

218 #ifdef 
__USE_XOPEN2K8


221 #include 
	~<xlocale.h
>

223 extern 
size_t
 
	$strftime_l
 (char *
__restrict
 
__s
, 
size_t
 
__maxsize
,

224 const char *
__restrict
 
__format
,

225 const struct 
tm
 *
__restrict
 
__tp
,

226 
__locale_t
 
__loc
) 
__THROW
;

229 #ifdef 
__USE_GNU


230 extern char *
	$strptime_l
 (const char *
__restrict
 
__s
,

231 const char *
__restrict
 
__fmt
, struct 
tm
 *
__tp
,

232 
__locale_t
 
__loc
) 
__THROW
;

236 
__BEGIN_NAMESPACE_STD


239 extern struct 
tm
 *
	$gmtime
 (const 
time_t
 *
__timer
) 
__THROW
;

243 extern struct 
tm
 *
	$localtime
 (const 
time_t
 *
__timer
) 
__THROW
;

244 
__END_NAMESPACE_STD


246 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


249 extern struct 
tm
 *
	$gmtime_r
 (const 
time_t
 *
__restrict
 
__timer
,

250 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

254 extern struct 
tm
 *
	$localtime_r
 (const 
time_t
 *
__restrict
 
__timer
,

255 struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

258 
__BEGIN_NAMESPACE_STD


261 extern char *
	$asctime
 (const struct 
tm
 *
__tp
) 
__THROW
;

264 extern char *
	$ctime
 (const 
time_t
 *
__timer
) 
__THROW
;

265 
__END_NAMESPACE_STD


267 #if 
defined
 
__USE_POSIX
 || defined 
__USE_MISC


272 extern char *
	$asctime_r
 (const struct 
tm
 *
__restrict
 
__tp
,

273 char *
__restrict
 
__buf
) 
__THROW
;

276 extern char *
	$ctime_r
 (const 
time_t
 *
__restrict
 
__timer
,

277 char *
__restrict
 
__buf
) 
__THROW
;

282 extern char *
__tzname
[2];

283 extern int 
__daylight
;

284 extern long int 
__timezone
;

287 #ifdef 
__USE_POSIX


289 extern char *
tzname
[2];

293 extern void 
	$tzset
 (void) 
__THROW
;

296 #if 
defined
 
__USE_SVID
 || defined 
__USE_XOPEN


297 extern int 
daylight
;

298 extern long int 
timezone
;

301 #ifdef 
__USE_SVID


304 extern int 
	$stime
 (const 
time_t
 *
__when
) 
__THROW
;

310 #define 
	#__isleap
(
year
) \

311 ((
year
) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0))

	)

314 #ifdef 
__USE_MISC


319 extern 
time_t
 
	$timegm
 (struct 
tm
 *
__tp
) 
__THROW
;

322 extern 
time_t
 
	$timelocal
 (struct 
tm
 *
__tp
) 
__THROW
;

325 extern int 
	$dysize
 (int 
__year
) 
__THROW
 
	`__attribute__
 ((
__const__
));

329 #ifdef 
__USE_POSIX199309


334 extern int 
	`nanosleep
 (const struct 
timespec
 *
__requested_time
,

335 struct 
timespec
 *
__remaining
);

339 extern int 
	$clock_getres
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__res
) 
__THROW
;

342 extern int 
	$clock_gettime
 (
clockid_t
 
__clock_id
, struct 
timespec
 *
__tp
) 
__THROW
;

345 extern int 
	$clock_settime
 (
clockid_t
 
__clock_id
, const struct 
timespec
 *
__tp
)

346 
__THROW
;

348 #ifdef 
__USE_XOPEN2K


353 extern int 
	`clock_nanosleep
 (
clockid_t
 
__clock_id
, int 
__flags
,

354 const struct 
timespec
 *
__req
,

355 struct 
timespec
 *
__rem
);

358 extern int 
	$clock_getcpuclockid
 (
pid_t
 
__pid
, 
clockid_t
 *
__clock_id
) 
__THROW
;

363 extern int 
	$timer_create
 (
clockid_t
 
__clock_id
,

364 struct 
sigevent
 *
__restrict
 
__evp
,

365 
timer_t
 *
__restrict
 
__timerid
) 
__THROW
;

368 extern int 
	$timer_delete
 (
timer_t
 
__timerid
) 
__THROW
;

371 extern int 
	$timer_settime
 (
timer_t
 
__timerid
, int 
__flags
,

372 const struct 
itimerspec
 *
__restrict
 
__value
,

373 struct 
itimerspec
 *
__restrict
 
__ovalue
) 
__THROW
;

376 extern int 
	$timer_gettime
 (
timer_t
 
__timerid
, struct 
itimerspec
 *
__value
)

377 
__THROW
;

380 extern int 
	$timer_getoverrun
 (
timer_t
 
__timerid
) 
__THROW
;

384 #ifdef 
__USE_ISOC11


386 extern int 
	$timespec_get
 (struct 
timespec
 *
__ts
, int 
__base
)

387 
__THROW
 
	`__nonnull
 ((1));

391 #ifdef 
__USE_XOPEN_EXTENDED


403 extern int 
getdate_err
;

412 extern struct 
tm
 *
	`getdate
 (const char *
__string
);

415 #ifdef 
__USE_GNU


426 extern int 
	`getdate_r
 (const char *
__restrict
 
__string
,

427 struct 
tm
 *
__restrict
 
__resbufp
);

430 
__END_DECLS


	@/usr/include/bits/byteswap-16.h

19 #ifndef 
_BITS_BYTESWAP_H


23 #ifdef 
__GNUC__


24 #if 
__GNUC__
 >= 2

25 #define 
	#__bswap_16
(
x
) \

26 (
__extension__
 \

27 ({ unsigned short int 
__v
, 
__x
 = (unsigned short int) (
x
); \

28 if (
	`__builtin_constant_p
 (
__x
)) \

29 
__v
 = 
	`__bswap_constant_16
 (
__x
); \

31 
	`__asm__
 ("rorw $8, %w0" \

32 : "=r" (
__v
) \

33 : "0" (
__x
) \

35 
__v
; }))

	)

38 #define 
	#__bswap_16
(
x
) \

39 (
__extension__
 \

40 ({ unsigned short int 
__x
 = (unsigned short int) (
x
); \

41 
	`__bswap_constant_16
 (
__x
); }))

	)

44 static 
__inline
 unsigned short int

45 
	$__bswap_16
 (unsigned short int 
__bsx
)

47 return 
	`__bswap_constant_16
 (
__bsx
);

48 
	}
}

	@/usr/include/bits/libc-lock.h

19 #ifndef 
_BITS_LIBC_LOCK_H


20 #define 
	#_BITS_LIBC_LOCK_H
 1

	)

22 #include 
	~<pthread.h
>

23 #define 
	#__need_NULL


	)

24 #include 
	~<stddef.h
>

27 #ifdef 
_LIBC


28 #include 
	~<lowlevellock.h
>

29 #include 
	~<tls.h
>

30 #include 
	~<pthread-functions.h
>

31 #include 
	~<errno.h
>

32 #include 
	~<gnu/option-groups.h
>

36 #if 
defined
 
_LIBC
 || defined 
_IO_MTSAFE_IO


37 #if (
defined
 
NOT_IN_libc
 && !defined 
IS_IN_libpthread
) || !defined 
_LIBC


38 typedef struct { 
pthread_mutex_t
 
	mmutex
; } 
	t__libc_lock_recursive_t
;

40 typedef struct { int 
	mlock
; int 
	mcnt
; void *
	mowner
; } 
	t__libc_lock_recursive_t
;

43 typedef struct 
__libc_lock_recursive_opaque__
 
	t__libc_lock_recursive_t
;

53 #define 
	#__libc_lock_define_recursive
(
CLASS
,
NAME
) \

54 
CLASS
 
__libc_lock_recursive_t
 
NAME
;

	)

58 #if 
defined
 
_LIBC
 && (!defined 
NOT_IN_libc
 || defined 
IS_IN_libpthread
)

59 #if 
LLL_LOCK_INITIALIZER
 == 0

60 #define 
	#__libc_lock_define_initialized_recursive
(
CLASS
,
NAME
) \

61 
CLASS
 
__libc_lock_recursive_t
 
NAME
;

	)

63 #define 
	#__libc_lock_define_initialized_recursive
(
CLASS
,
NAME
) \

64 
CLASS
 
__libc_lock_recursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

66 #define 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

67 { 
LLL_LOCK_INITIALIZER
, 0, 
NULL
 }

	)

69 #define 
	#__libc_lock_define_initialized_recursive
(
CLASS
,
NAME
) \

70 
CLASS
 
__libc_lock_recursive_t
 
NAME
 = 
_LIBC_LOCK_RECURSIVE_INITIALIZER
;

	)

71 #define 
	#_LIBC_LOCK_RECURSIVE_INITIALIZER
 \

72 {
PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
}

	)

76 #if 
defined
 
_LIBC
 && (!defined 
NOT_IN_libc
 || defined 
IS_IN_libpthread
)

77 #define 
	#__libc_lock_init_recursive
(
NAME
) \

78 ((
NAME
) = (
__libc_lock_recursive_t
) 
_LIBC_LOCK_RECURSIVE_INITIALIZER
, 0)

	)

80 #define 
	#__libc_lock_init_recursive
(
NAME
) \

82 if (
__pthread_mutex_init
 != 
NULL
) \

84 
pthread_mutexattr_t
 
__attr
; \

85 
	`__pthread_mutexattr_init
 (&
__attr
); \

86 
	`__pthread_mutexattr_settype
 (&
__attr
, 
PTHREAD_MUTEX_RECURSIVE_NP
); \

87 
	`__pthread_mutex_init
 (&(
NAME
).
mutex
, &
__attr
); \

88 
	`__pthread_mutexattr_destroy
 (&
__attr
); \

90 } while (0)

	)

94 #if 
defined
 
_LIBC
 && (!defined 
NOT_IN_libc
 || defined 
IS_IN_libpthread
)

95 #define 
	#__libc_lock_fini_recursive
(
NAME
) ((void) 0)

	)

97 #define 
	#__libc_lock_fini_recursive
(
NAME
) \

98 
	`__libc_maybe_call
 (
__pthread_mutex_destroy
, (&(
NAME
).
mutex
), 0)

	)

102 #if 
defined
 
_LIBC
 && (!defined 
NOT_IN_libc
 || defined 
IS_IN_libpthread
)

103 #if 
__OPTION_EGLIBC_BIG_MACROS
 != 1

107 extern void 
__libc_lock_lock_recursive_fn
 (
__libc_lock_recursive_t
 *);

108 
libc_hidden_proto
 (
__libc_lock_lock_recursive_fn
);

110 #if 
__OPTION_EGLIBC_BIG_MACROS


111 #define 
	#__libc_lock_lock_recursive
(
NAME
) \

113 void *
self
 = 
THREAD_SELF
; \

114 if ((
NAME
).
owner
 != 
self
) \

116 
	`lll_lock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

117 (
NAME
).
owner
 = 
self
; \

119 ++(
NAME
).
cnt
; \

120 } while (0)

	)

122 #define 
	#__libc_lock_lock_recursive
(
NAME
) \

123 
	`__libc_lock_lock_recursive_fn
 (&(
NAME
))

	)

126 #define 
	#__libc_lock_lock_recursive
(
NAME
) \

127 
	`__libc_maybe_call
 (
__pthread_mutex_lock
, (&(
NAME
).
mutex
), 0)

	)

131 #if 
defined
 
_LIBC
 && (!defined 
NOT_IN_libc
 || defined 
IS_IN_libpthread
)

132 #if 
__OPTION_EGLIBC_BIG_MACROS
 != 1

136 extern int 
__libc_lock_trylock_recursive_fn
 (
__libc_lock_recursive_t
 *);

137 
libc_hidden_proto
 (
__libc_lock_trylock_recursive_fn
);

139 #if 
__OPTION_EGLIBC_BIG_MACROS


140 #define 
	#__libc_lock_trylock_recursive
(
NAME
) \

142 int 
result
 = 0; \

143 void *
self
 = 
THREAD_SELF
; \

144 if ((
NAME
).
owner
 != 
self
) \

146 if (
	`lll_trylock
 ((
NAME
).
lock
) == 0) \

148 (
NAME
).
owner
 = 
self
; \

149 (
NAME
).
cnt
 = 1; \

152 
result
 = 
EBUSY
; \

155 ++(
NAME
).
cnt
; \

156 
result
; \

157 })

	)

159 #define 
	#__libc_lock_trylock_recursive
(
NAME
) \

160 
	`__libc_lock_trylock_recursive_fn
 (&(
NAME
))

	)

163 #define 
	#__libc_lock_trylock_recursive
(
NAME
) \

164 
	`__libc_maybe_call
 (
__pthread_mutex_trylock
, (&(
NAME
).
mutex
), 0)

	)

168 #if 
defined
 
_LIBC
 && (!defined 
NOT_IN_libc
 || defined 
IS_IN_libpthread
)

169 #if 
__OPTION_EGLIBC_BIG_MACROS
 != 1

173 extern void 
__libc_lock_unlock_recursive_fn
 (
__libc_lock_recursive_t
 *);

174 
libc_hidden_proto
 (
__libc_lock_unlock_recursive_fn
);

176 #if 
__OPTION_EGLIBC_BIG_MACROS


178 #define 
	#__libc_lock_unlock_recursive
(
NAME
) \

180 if (--(
NAME
).
cnt
 == 0) \

182 (
NAME
).
owner
 = 
NULL
; \

183 
	`lll_unlock
 ((
NAME
).
lock
, 
LLL_PRIVATE
); \

185 } while (0)

	)

187 #define 
	#__libc_lock_unlock_recursive
(
NAME
) \

188 
	`__libc_lock_unlock_recursive_fn
 (&(
NAME
))

	)

191 #define 
	#__libc_lock_unlock_recursive
(
NAME
) \

192 
	`__libc_maybe_call
 (
__pthread_mutex_unlock
, (&(
NAME
).
mutex
), 0)

	)

199 extern void 
_pthread_cleanup_push_defer
 (struct 
_pthread_cleanup_buffer
 *
buffer
,

200 void (*
routine
) (void *), void *
arg
);

201 extern void 
	`_pthread_cleanup_pop_restore
 (struct 
_pthread_cleanup_buffer
 *
buffer
,

202 int 
execute
);

205 #define 
	#__libc_cleanup_region_start
(
DOIT
, 
FCT
, 
ARG
) \

206 { struct 
_pthread_cleanup_buffer
 
_buffer
; \

207 int 
_avail
; \

208 if (
DOIT
) { \

209 
_avail
 = 
	`PTFAVAIL
 (
_pthread_cleanup_push_defer
); \

210 if (
_avail
) { \

211 
	`__libc_ptf_call_always
 (
_pthread_cleanup_push_defer
, (&
_buffer
, 
FCT
, \

212 
ARG
)); \

214 
_buffer
.
__routine
 = (
FCT
); \

215 
_buffer
.
__arg
 = (
ARG
); \

218 
_avail
 = 0; \

219 }

	)

222 #define 
	#__libc_cleanup_region_end
(
DOIT
) \

223 if (
_avail
) { \

224 
	`__libc_ptf_call_always
 (
_pthread_cleanup_pop_restore
, (&
_buffer
, 
DOIT
));\

225 } else if (
DOIT
) \

226 
_buffer
.
	`__routine
 (_buffer.
__arg
); \

227 
	}

	)
}

232 #ifdef 
_LIBC


233 #include 
	~"libc-lockP.h
"

	@/usr/include/bits/select.h

18 #ifndef 
_SYS_SELECT_H


22 #include 
	~<bits/wordsize.h
>

25 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

27 #if 
__WORDSIZE
 == 64

28 #define 
	#__FD_ZERO_STOS
 "stosq"

	)

30 #define 
	#__FD_ZERO_STOS
 "stosl"

	)

33 #define 
	#__FD_ZERO
(
fdsp
) \

35 int 
__d0
, 
__d1
; \

36 
__asm__
 
	`__volatile__
 ("cld; rep; " 
__FD_ZERO_STOS
 \

37 : "=c" (
__d0
), "=D" (
__d1
) \

38 : "a" (0), "0" (sizeof (
fd_set
) \

39 / sizeof (
__fd_mask
)), \

40 "1" (&
	`__FDS_BITS
 (
fdsp
)[0]) \

42 } while (0)

	)

48 #define 
	#__FD_ZERO
(
set
) \

50 unsigned int 
__i
; \

51 
fd_set
 *
__arr
 = (
set
); \

52 for (
__i
 = 0; __i < sizeof (
fd_set
) / sizeof (
__fd_mask
); ++__i) \

53 
	`__FDS_BITS
 (
__arr
)[
__i
] = 0; \

54 } while (0)

	)

58 #define 
	#__FD_SET
(
d
, 
set
) \

59 ((void) (
	`__FDS_BITS
 (
set
)[
	`__FD_ELT
 (
d
)] |= 
	`__FD_MASK
 (d)))

	)

60 #define 
	#__FD_CLR
(
d
, 
set
) \

61 ((void) (
	`__FDS_BITS
 (
set
)[
	`__FD_ELT
 (
d
)] &= ~
	`__FD_MASK
 (d)))

	)

62 #define 
	#__FD_ISSET
(
d
, 
set
) \

63 ((
	`__FDS_BITS
 (
set
)[
	`__FD_ELT
 (
d
)] & 
	`__FD_MASK
 (d)) != 0)

	)

	@/usr/include/bits/select2.h

19 #ifndef 
_SYS_SELECT_H


24 extern long int 
__fdelt_chk
 (long int 
__d
);

25 extern long int 
	$__fdelt_warn
 (long int 
__d
)

26 
	`__warnattr
 ("bit outside of fd_set selected");

27 #undef 
__FD_ELT


28 #define 
	#__FD_ELT
(
d
) \

29 
__extension__
 \

30 ({ long int 
__d
 = (
d
); \

31 (
	`__builtin_constant_p
 (
__d
) \

32 ? (0 <= 
__d
 && __d < 
__FD_SETSIZE
 \

33 ? (
__d
 / 
__NFDBITS
) \

34 : 
	`__fdelt_warn
 (
__d
)) \

35 : 
	`__fdelt_chk
 (
__d
)); 
	}
})

	)

	@/usr/include/bits/sigset.h

19 #ifndef 
_SIGSET_H_types


20 #define 
	#_SIGSET_H_types
 1

	)

22 typedef int 
	t__sig_atomic_t
;

26 #define 
	#_SIGSET_NWORDS
 (1024 / (8 * sizeof (unsigned long int)))

	)

29 unsigned long int 
	m__val
[
_SIGSET_NWORDS
];

30 } 
	t__sigset_t
;

41 #if !
defined
 
_SIGSET_H_fns
 && defined 
_SIGNAL_H


42 #define 
	#_SIGSET_H_fns
 1

	)

44 #ifndef 
_EXTERN_INLINE


45 #define 
	#_EXTERN_INLINE
 
__extern_inline


	)

49 #define 
	#__sigmask
(
sig
) \

50 (((unsigned long int) 1) << (((
sig
) - 1) % (8 * sizeof (unsigned long int))))

	)

53 #define 
	#__sigword
(
sig
) (((sig) - 1) / (8 * sizeof (unsigned long int)))

	)

55 #if 
defined
 
__GNUC__
 && __GNUC__ >= 2

56 #define 
	#__sigemptyset
(
set
) \

57 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

58 
sigset_t
 *
__set
 = (
set
); \

59 while (--
__cnt
 >= 0) 
__set
->
__val
[__cnt] = 0; \

60 0; }))

	)

61 #define 
	#__sigfillset
(
set
) \

62 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

63 
sigset_t
 *
__set
 = (
set
); \

64 while (--
__cnt
 >= 0) 
__set
->
__val
[__cnt] = ~0UL; \

65 0; }))

	)

67 #ifdef 
__USE_GNU


71 #define 
	#__sigisemptyset
(
set
) \

72 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

73 const 
sigset_t
 *
__set
 = (
set
); \

74 int 
__ret
 = 
__set
->
__val
[--
__cnt
]; \

75 while (!
__ret
 && --
__cnt
 >= 0) \

76 
__ret
 = 
__set
->
__val
[
__cnt
]; \

77 
__ret
 == 0; }))

	)

78 #define 
	#__sigandset
(
dest
, 
left
, 
right
) \

79 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

80 
sigset_t
 *
__dest
 = (
dest
); \

81 const 
sigset_t
 *
__left
 = (
left
); \

82 const 
sigset_t
 *
__right
 = (
right
); \

83 while (--
__cnt
 >= 0) \

84 
__dest
->
__val
[
__cnt
] = (
__left
->__val[__cnt] \

85 & 
__right
->
__val
[
__cnt
]); \

86 0; }))

	)

87 #define 
	#__sigorset
(
dest
, 
left
, 
right
) \

88 (
	`__extension__
 ({ int 
__cnt
 = 
_SIGSET_NWORDS
; \

89 
sigset_t
 *
__dest
 = (
dest
); \

90 const 
sigset_t
 *
__left
 = (
left
); \

91 const 
sigset_t
 *
__right
 = (
right
); \

92 while (--
__cnt
 >= 0) \

93 
__dest
->
__val
[
__cnt
] = (
__left
->__val[__cnt] \

94 | 
__right
->
__val
[
__cnt
]); \

95 0; }))

	)

102 extern int 
__sigismember
 (const 
__sigset_t
 *, int);

103 extern int 
__sigaddset
 (
__sigset_t
 *, int);

104 extern int 
__sigdelset
 (
__sigset_t
 *, int);

106 #ifdef 
__USE_EXTERN_INLINES


107 #define 
	#__SIGSETFN
(
NAME
, 
BODY
, 
CONST
) \

108 
_EXTERN_INLINE
 int \

109 
	`NAME
 (
CONST
 
__sigset_t
 *
__set
, int 
__sig
) \

111 unsigned long int 
__mask
 = 
	`__sigmask
 (
__sig
); \

112 unsigned long int 
__word
 = 
	`__sigword
 (
__sig
); \

113 return 
BODY
; \

114 }

	)

116 
__SIGSETFN
 (
__sigismember
, (
__set
->
__val
[
__word
] & 
__mask
) ? 1 : 0, const)

117 
__SIGSETFN
 (
__sigaddset
, ((
__set
->
__val
[
__word
] |= 
__mask
), 0), )

118 
__SIGSETFN
 (
__sigdelset
, ((
__set
->
__val
[
__word
] &= ~
__mask
), 0), )

120 #undef 
__SIGSETFN


	@/usr/include/bits/time.h

23 #if 
defined
 
__need_timeval
 || defined 
__USE_GNU


24 #ifndef 
_STRUCT_TIMEVAL


25 #define 
	#_STRUCT_TIMEVAL
 1

	)

26 #include 
	~<bits/types.h
>

30 struct 
	stimeval


32 
__time_t
 
	mtv_sec
;

33 
__suseconds_t
 
	mtv_usec
;

38 #ifndef 
__need_timeval


39 #ifndef 
_BITS_TIME_H


40 #define 
	#_BITS_TIME_H
 1

	)

48 #define 
	#CLOCKS_PER_SEC
 1000000l

	)

50 #if (!
defined
 
__STRICT_ANSI__
 || defined 
__USE_POSIX
) \

51 && !
defined
 
	g__USE_XOPEN2K


54 #include 
	~<bits/types.h
>

55 extern long int 
__sysconf
 (int);

56 #define 
	#CLK_TCK
 ((
__clock_t
) 
	`__sysconf
 (2))

	)

59 #ifdef 
__USE_POSIX199309


61 #define 
	#CLOCK_REALTIME
 0

	)

63 #define 
	#CLOCK_MONOTONIC
 1

	)

65 #define 
	#CLOCK_PROCESS_CPUTIME_ID
 2

	)

67 #define 
	#CLOCK_THREAD_CPUTIME_ID
 3

	)

69 #define 
	#CLOCK_MONOTONIC_RAW
 4

	)

71 #define 
	#CLOCK_REALTIME_COARSE
 5

	)

73 #define 
	#CLOCK_MONOTONIC_COARSE
 6

	)

75 #define 
	#CLOCK_BOOTTIME
 7

	)

77 #define 
	#CLOCK_REALTIME_ALARM
 8

	)

79 #define 
	#CLOCK_BOOTTIME_ALARM
 9

	)

82 #define 
	#TIMER_ABSTIME
 1

	)

85 #ifdef 
__USE_GNU


86 #include 
	~<bits/timex.h
>

88 
__BEGIN_DECLS


91 extern int 
	$clock_adjtime
 (
__clockid_t
 
__clock_id
, struct 
timex
 *
__utx
) 
__THROW
;

93 
__END_DECLS


99 #undef 
__need_timeval


	@/usr/include/gconv.h

22 #ifndef 
_GCONV_H


23 #define 
	#_GCONV_H
 1

	)

25 #include 
	~<features.h
>

26 #define 
	#__need_mbstate_t


	)

27 #define 
	#__need_wint_t


	)

28 #include 
	~<wchar.h
>

29 #define 
	#__need_size_t


	)

30 #define 
	#__need_wchar_t


	)

31 #include 
	~<stddef.h
>

34 #define 
	#__UNKNOWN_10646_CHAR
 ((
wchar_t
) 0xfffd)

	)

39 
	m__GCONV_OK
 = 0,

40 
	m__GCONV_NOCONV
,

41 
	m__GCONV_NODB
,

42 
	m__GCONV_NOMEM
,

44 
	m__GCONV_EMPTY_INPUT
,

45 
	m__GCONV_FULL_OUTPUT
,

46 
	m__GCONV_ILLEGAL_INPUT
,

47 
	m__GCONV_INCOMPLETE_INPUT
,

49 
	m__GCONV_ILLEGAL_DESCRIPTOR
,

50 
	m__GCONV_INTERNAL_ERROR


57 
	m__GCONV_IS_LAST
 = 0x0001,

58 
	m__GCONV_IGNORE_ERRORS
 = 0x0002,

59 
	m__GCONV_SWAP
 = 0x0004

64 struct 
	g__gconv_step
;

65 struct 
	g__gconv_step_data
;

66 struct 
	g__gconv_loaded_object
;

67 struct 
	g__gconv_trans_data
;

71 typedef int (*
	t__gconv_fct
) (struct 
	t__gconv_step
 *, struct 
	t__gconv_step_data
 *,

73 unsigned char **, 
	tsize_t
 *, int, int);

76 typedef 
	$wint_t
 (*
	t__gconv_btowc_fct
) (struct 
	t__gconv_step
 *, unsigned char);

79 typedef int (*
	t__gconv_init_fct
) (struct 
	t__gconv_step
 *);

80 typedef void (*
	t__gconv_end_fct
) (struct 
	t__gconv_step
 *);

84 typedef int (*
	t__gconv_trans_fct
) (struct 
	t__gconv_step
 *,

85 struct 
	t__gconv_step_data
 *, void *,

89 
	tsize_t
 *);

92 typedef int (*
	t__gconv_trans_context_fct
) (void *, const unsigned char *,

97 typedef int (*
	t__gconv_trans_query_fct
) (const char *, const char ***,

98 
	tsize_t
 *);

101 typedef int (*
	t__gconv_trans_init_fct
) (void **, const char *);

102 typedef void (*
	t__gconv_trans_end_fct
) (void *);

104 struct 
	s__gconv_trans_data


107 
__gconv_trans_fct
 
__trans_fct
;

108 
__gconv_trans_context_fct
 
__trans_context_fct
;

109 
__gconv_trans_end_fct
 
__trans_end_fct
;

110 void *
__data
;

111 struct 
__gconv_trans_data
 *
__next
;

116 struct 
	s__gconv_step


118 struct 
__gconv_loaded_object
 *
__shlib_handle
;

119 const char *
__modname
;

121 int 
__counter
;

123 char *
__from_name
;

124 char *
__to_name
;

126 
__gconv_fct
 
__fct
;

127 
__gconv_btowc_fct
 
__btowc_fct
;

128 
__gconv_init_fct
 
__init_fct
;

129 
__gconv_end_fct
 
__end_fct
;

133 int 
__min_needed_from
;

134 int 
__max_needed_from
;

135 int 
__min_needed_to
;

136 int 
__max_needed_to
;

139 int 
__stateful
;

141 void *
__data
;

146 struct 
	s__gconv_step_data


148 unsigned char *
__outbuf
;

149 unsigned char *
__outbufend
;

153 int 
__flags
;

157 int 
__invocation_counter
;

161 int 
__internal_use
;

163 
__mbstate_t
 *
__statep
;

164 
__mbstate_t
 
__state
;

168 struct 
__gconv_trans_data
 *
__trans
;

173 typedef struct 
	s__gconv_info


175 
size_t
 
__nsteps
;

176 struct 
__gconv_step
 *
__steps
;

177 
__extension__
 struct 
__gconv_step_data
 
__data
 
__flexarr
;

178 } *
	t__gconv_t
;

	@/usr/include/gnu/stubs-32.h

6 #ifdef 
_LIBC


7 #error 
Applications
 
may
 
not
 
define
 
the
 
macro
 
_LIBC


10 #define 
	#__stub_chflags


	)

11 #define 
	#__stub_fattach


	)

12 #define 
	#__stub_fchflags


	)

13 #define 
	#__stub_fdetach


	)

14 #define 
	#__stub_gtty


	)

15 #define 
	#__stub_lchmod


	)

16 #define 
	#__stub_revoke


	)

17 #define 
	#__stub_setlogin


	)

18 #define 
	#__stub_sigreturn


	)

19 #define 
	#__stub_sstk


	)

20 #define 
	#__stub_stty


	)

	@/usr/include/gnu/stubs-64.h

6 #ifdef 
_LIBC


7 #error 
Applications
 
may
 
not
 
define
 
the
 
macro
 
_LIBC


10 #define 
	#__stub_bdflush


	)

11 #define 
	#__stub_chflags


	)

12 #define 
	#__stub_fattach


	)

13 #define 
	#__stub_fchflags


	)

14 #define 
	#__stub_fdetach


	)

15 #define 
	#__stub_getmsg


	)

16 #define 
	#__stub_gtty


	)

17 #define 
	#__stub_lchmod


	)

18 #define 
	#__stub_putmsg


	)

19 #define 
	#__stub_revoke


	)

20 #define 
	#__stub_setlogin


	)

21 #define 
	#__stub_sigreturn


	)

22 #define 
	#__stub_sstk


	)

23 #define 
	#__stub_stty


	)

	@/usr/include/gnu/stubs-x32.h

6 #ifdef 
_LIBC


7 #error 
Applications
 
may
 
not
 
define
 
the
 
macro
 
_LIBC


10 #define 
	#__stub_bdflush


	)

11 #define 
	#__stub_chflags


	)

12 #define 
	#__stub_create_module


	)

13 #define 
	#__stub_fattach


	)

14 #define 
	#__stub_fchflags


	)

15 #define 
	#__stub_fdetach


	)

16 #define 
	#__stub_get_kernel_syms


	)

17 #define 
	#__stub_getmsg


	)

18 #define 
	#__stub_gtty


	)

19 #define 
	#__stub_lchmod


	)

20 #define 
	#__stub_nfsservctl


	)

21 #define 
	#__stub_putmsg


	)

22 #define 
	#__stub_query_module


	)

23 #define 
	#__stub_revoke


	)

24 #define 
	#__stub_setlogin


	)

25 #define 
	#__stub_sigreturn


	)

26 #define 
	#__stub_sstk


	)

27 #define 
	#__stub_stty


	)

28 #define 
	#__stub_uselib


	)

	@/usr/include/wchar.h

23 #ifndef 
_WCHAR_H


25 #if !
defined
 
__need_mbstate_t
 && !defined 
__need_wint_t


26 #define 
	#_WCHAR_H
 1

	)

27 #include 
	~<features.h
>

30 #ifdef 
_WCHAR_H


32 #define 
	#__need___FILE


	)

33 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


34 #define 
	#__need_FILE


	)

36 #include 
	~<stdio.h
>

38 #define 
	#__need___va_list


	)

39 #include 
	~<stdarg.h
>

41 #include 
	~<bits/wchar.h
>

44 #define 
	#__need_size_t


	)

45 #define 
	#__need_wchar_t


	)

46 #define 
	#__need_NULL


	)

48 #if 
defined
 
_WCHAR_H
 || defined 
__need_wint_t
 || !defined 
__WINT_TYPE__


49 #undef 
__need_wint_t


50 #define 
	#__need_wint_t


	)

51 #include 
	~<stddef.h
>

55 #ifndef 
_WINT_T


60 #define 
	#_WINT_T


	)

61 typedef unsigned int 
	twint_t
;

65 #if 
defined
 
__cplusplus
 && defined 
_GLIBCPP_USE_NAMESPACES
 \

66 && 
defined
 
__WINT_TYPE__


67 
__BEGIN_NAMESPACE_STD


68 typedef 
__WINT_TYPE__
 
	twint_t
;

69 
	g__END_NAMESPACE_STD


74 #if 
defined
 
__cplusplus
 && 
__GNUC_PREREQ
 (4, 4)

75 #define 
	#__CORRECT_ISO_CPP_WCHAR_H_PROTO


	)

79 #if (
defined
 
_WCHAR_H
 || defined 
__need_mbstate_t
) && !defined 
____mbstate_t_defined


80 #define 
	#____mbstate_t_defined
 1

	)

84 int 
	m__count
;

87 #ifdef 
__WINT_TYPE__


88 
__WINT_TYPE__
 
	m__wch
;

90 
wint_t
 
	m__wch
;

92 char 
	m__wchb
[4];

93 } 
	m__value
;

94 } 
	t__mbstate_t
;

96 #undef 
__need_mbstate_t


101 #ifdef 
_WCHAR_H


103 #ifndef 
__mbstate_t_defined


104 
__BEGIN_NAMESPACE_C99


106 typedef 
__mbstate_t
 
	tmbstate_t
;

107 
	g__END_NAMESPACE_C99


108 #define 
	#__mbstate_t_defined
 1

	)

111 #ifdef 
__USE_GNU


112 
	$__USING_NAMESPACE_C99
(
mbstate_t
)

115 #ifndef 
WCHAR_MIN


117 #define 
	#WCHAR_MIN
 
__WCHAR_MIN


	)

118 #define 
	#WCHAR_MAX
 
__WCHAR_MAX


	)

121 #ifndef 
WEOF


122 #define 
	#WEOF
 (0xffffffffu)

	)

127 #if 
defined
 
__USE_XOPEN
 && !defined 
__USE_UNIX98


128 #include 
	~<wctype.h
>

132 
__BEGIN_DECLS


134 
__BEGIN_NAMESPACE_STD


137 struct 
tm
;

138 
__END_NAMESPACE_STD


142 
	$__USING_NAMESPACE_STD
(
tm
)

145 
__BEGIN_NAMESPACE_STD


147 extern 
wchar_t
 *
	$wcscpy
 (
wchar_t
 *
__restrict
 
__dest
,

148 const 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

150 extern 
wchar_t
 *
	$wcsncpy
 (
wchar_t
 *
__restrict
 
__dest
,

151 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

152 
__THROW
;

155 extern 
wchar_t
 *
	$wcscat
 (
wchar_t
 *
__restrict
 
__dest
,

156 const 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

158 extern 
wchar_t
 *
	$wcsncat
 (
wchar_t
 *
__restrict
 
__dest
,

159 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

160 
__THROW
;

163 extern int 
	$wcscmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
)

164 
__THROW
 
__attribute_pure__
;

166 extern int 
	$wcsncmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
, 
size_t
 
__n
)

167 
__THROW
 
__attribute_pure__
;

168 
__END_NAMESPACE_STD


170 #ifdef 
__USE_XOPEN2K8


172 extern int 
	$wcscasecmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
) 
__THROW
;

175 extern int 
	$wcsncasecmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

176 
size_t
 
__n
) 
__THROW
;

180 #include 
	~<xlocale.h
>

182 extern int 
	$wcscasecmp_l
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

183 
__locale_t
 
__loc
) 
__THROW
;

185 extern int 
	$wcsncasecmp_l
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

186 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

189 
__BEGIN_NAMESPACE_STD


192 extern int 
	$wcscoll
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
) 
__THROW
;

196 extern 
size_t
 
	$wcsxfrm
 (
wchar_t
 *
__restrict
 
__s1
,

197 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

198 
__END_NAMESPACE_STD


200 #ifdef 
__USE_XOPEN2K8


206 extern int 
	$wcscoll_l
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
,

207 
__locale_t
 
__loc
) 
__THROW
;

212 extern 
size_t
 
	$wcsxfrm_l
 (
wchar_t
 *
__s1
, const wchar_t *
__s2
,

213 
size_t
 
__n
, 
__locale_t
 
__loc
) 
__THROW
;

216 extern 
wchar_t
 *
	$wcsdup
 (const 
wchar_t
 *
__s
) 
__THROW
 
__attribute_malloc__
;

219 
__BEGIN_NAMESPACE_STD


221 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


222 extern "C++" 
wchar_t
 *
	$wcschr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

223 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

224 extern "C++" const 
wchar_t
 *
	$wcschr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

225 
__THROW
 
	`__asm
 ("wcschr") 
__attribute_pure__
;

227 extern 
wchar_t
 *
	$wcschr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

228 
__THROW
 
__attribute_pure__
;

231 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


232 extern "C++" 
wchar_t
 *
	$wcsrchr
 (
wchar_t
 *
__wcs
, wchar_t 
__wc
)

233 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

234 extern "C++" const 
wchar_t
 *
	$wcsrchr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

235 
__THROW
 
	`__asm
 ("wcsrchr") 
__attribute_pure__
;

237 extern 
wchar_t
 *
	$wcsrchr
 (const 
wchar_t
 *
__wcs
, wchar_t 
__wc
)

238 
__THROW
 
__attribute_pure__
;

240 
__END_NAMESPACE_STD


242 #ifdef 
__USE_GNU


245 extern 
wchar_t
 *
	$wcschrnul
 (const 
wchar_t
 *
__s
, wchar_t 
__wc
)

246 
__THROW
 
__attribute_pure__
;

249 
__BEGIN_NAMESPACE_STD


252 extern 
size_t
 
	$wcscspn
 (const 
wchar_t
 *
__wcs
, const wchar_t *
__reject
)

253 
__THROW
 
__attribute_pure__
;

256 extern 
size_t
 
	$wcsspn
 (const 
wchar_t
 *
__wcs
, const wchar_t *
__accept
)

257 
__THROW
 
__attribute_pure__
;

259 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


260 extern "C++" 
wchar_t
 *
	$wcspbrk
 (
wchar_t
 *
__wcs
, const wchar_t *
__accept
)

261 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

262 extern "C++" const 
wchar_t
 *
	$wcspbrk
 (const 
wchar_t
 *
__wcs
,

263 const 
wchar_t
 *
__accept
)

264 
__THROW
 
	`__asm
 ("wcspbrk") 
__attribute_pure__
;

266 extern 
wchar_t
 *
	$wcspbrk
 (const 
wchar_t
 *
__wcs
, const wchar_t *
__accept
)

267 
__THROW
 
__attribute_pure__
;

270 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


271 extern "C++" 
wchar_t
 *
	$wcsstr
 (
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

272 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

273 extern "C++" const 
wchar_t
 *
	$wcsstr
 (const 
wchar_t
 *
__haystack
,

274 const 
wchar_t
 *
__needle
)

275 
__THROW
 
	`__asm
 ("wcsstr") 
__attribute_pure__
;

277 extern 
wchar_t
 *
	$wcsstr
 (const 
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

278 
__THROW
 
__attribute_pure__
;

282 extern 
wchar_t
 *
	$wcstok
 (
wchar_t
 *
__restrict
 
__s
,

283 const 
wchar_t
 *
__restrict
 
__delim
,

284 
wchar_t
 **
__restrict
 
__ptr
) 
__THROW
;

287 extern 
size_t
 
	$wcslen
 (const 
wchar_t
 *
__s
) 
__THROW
 
__attribute_pure__
;

288 
__END_NAMESPACE_STD


290 #ifdef 
__USE_XOPEN


292 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


293 extern "C++" 
wchar_t
 *
	$wcswcs
 (
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

294 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

295 extern "C++" const 
wchar_t
 *
	$wcswcs
 (const 
wchar_t
 *
__haystack
,

296 const 
wchar_t
 *
__needle
)

297 
__THROW
 
	`__asm
 ("wcswcs") 
__attribute_pure__
;

299 extern 
wchar_t
 *
	$wcswcs
 (const 
wchar_t
 *
__haystack
, const wchar_t *
__needle
)

300 
__THROW
 
__attribute_pure__
;

304 #ifdef 
__USE_XOPEN2K8


306 extern 
size_t
 
	$wcsnlen
 (const 
wchar_t
 *
__s
, 
size_t
 
__maxlen
)

307 
__THROW
 
__attribute_pure__
;

311 
__BEGIN_NAMESPACE_STD


313 #ifdef 
__CORRECT_ISO_CPP_WCHAR_H_PROTO


314 extern "C++" 
wchar_t
 *
	$wmemchr
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

315 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

316 extern "C++" const 
wchar_t
 *
	$wmemchr
 (const 
wchar_t
 *
__s
, wchar_t 
__c
,

317 
size_t
 
__n
)

318 
__THROW
 
	`__asm
 ("wmemchr") 
__attribute_pure__
;

320 extern 
wchar_t
 *
	$wmemchr
 (const 
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
)

321 
__THROW
 
__attribute_pure__
;

325 extern int 
	$wmemcmp
 (const 
wchar_t
 *
__s1
, const wchar_t *
__s2
, 
size_t
 
__n
)

326 
__THROW
 
__attribute_pure__
;

329 extern 
wchar_t
 *
	$wmemcpy
 (
wchar_t
 *
__restrict
 
__s1
,

330 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
) 
__THROW
;

334 extern 
wchar_t
 *
	$wmemmove
 (
wchar_t
 *
__s1
, const wchar_t *
__s2
, 
size_t
 
__n
)

335 
__THROW
;

338 extern 
wchar_t
 *
	$wmemset
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
) 
__THROW
;

339 
__END_NAMESPACE_STD


341 #ifdef 
__USE_GNU


344 extern 
wchar_t
 *
	$wmempcpy
 (
wchar_t
 *
__restrict
 
__s1
,

345 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
)

346 
__THROW
;

350 
__BEGIN_NAMESPACE_STD


353 extern 
wint_t
 
	$btowc
 (int 
__c
) 
__THROW
;

357 extern int 
	$wctob
 (
wint_t
 
__c
) 
__THROW
;

361 extern int 
	$mbsinit
 (const 
mbstate_t
 *
__ps
) 
__THROW
 
__attribute_pure__
;

365 extern 
size_t
 
	$mbrtowc
 (
wchar_t
 *
__restrict
 
__pwc
,

366 const char *
__restrict
 
__s
, 
size_t
 
__n
,

367 
mbstate_t
 *
__restrict
 
__p
) 
__THROW
;

370 extern 
size_t
 
	$wcrtomb
 (char *
__restrict
 
__s
, 
wchar_t
 
__wc
,

371 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

374 extern 
size_t
 
	$__mbrlen
 (const char *
__restrict
 
__s
, 
size_t
 
__n
,

375 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

376 extern 
size_t
 
	$mbrlen
 (const char *
__restrict
 
__s
, 
size_t
 
__n
,

377 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

378 
__END_NAMESPACE_STD


380 #ifdef 
__USE_EXTERN_INLINES


386 extern 
wint_t
 
	$__btowc_alias
 (int 
__c
) 
	`__asm
 ("btowc");

387 
__extern_inline
 
wint_t


388 
	`__NTH
 (
	$btowc
 (int 
__c
))

389 { return (
	`__builtin_constant_p
 (
__c
) && __c >= '\0' && __c <= '\x7f'

390 ? (
wint_t
) 
__c
 : 
	`__btowc_alias
 (__c)); 
	}
}

392 extern int 
	$__wctob_alias
 (
wint_t
 
__c
) 
	`__asm
 ("wctob");

393 
__extern_inline
 int

394 
	`__NTH
 (
	$wctob
 (
wint_t
 
__wc
))

395 { return (
	`__builtin_constant_p
 (
__wc
) && __wc >= 
L
'\0' && __wc <= L'\x7f'

396 ? (int) 
__wc
 : 
	`__wctob_alias
 (__wc)); 
	}
}

398 
__extern_inline
 
size_t


399 
__NTH
 (
	$mbrlen
 (const char *
__restrict
 
__s
, 
size_t
 
__n
,

400 
mbstate_t
 *
__restrict
 
__ps
))

401 { return (
__ps
 != 
NULL


402 ? 
	`mbrtowc
 (
NULL
, 
__s
, 
__n
, 
__ps
) : 
	`__mbrlen
 (__s, __n, NULL)); 
	}
}

405 
__BEGIN_NAMESPACE_STD


408 extern 
size_t
 
	$mbsrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

409 const char **
__restrict
 
__src
, 
size_t
 
__len
,

410 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

414 extern 
size_t
 
	$wcsrtombs
 (char *
__restrict
 
__dst
,

415 const 
wchar_t
 **
__restrict
 
__src
, 
size_t
 
__len
,

416 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

417 
__END_NAMESPACE_STD


420 #ifdef 
__USE_XOPEN2K8


423 extern 
size_t
 
	$mbsnrtowcs
 (
wchar_t
 *
__restrict
 
__dst
,

424 const char **
__restrict
 
__src
, 
size_t
 
__nmc
,

425 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

429 extern 
size_t
 
	$wcsnrtombs
 (char *
__restrict
 
__dst
,

430 const 
wchar_t
 **
__restrict
 
__src
,

431 
size_t
 
__nwc
, size_t 
__len
,

432 
mbstate_t
 *
__restrict
 
__ps
) 
__THROW
;

437 #ifdef 
__USE_XOPEN


439 extern int 
	$wcwidth
 (
wchar_t
 
__c
) 
__THROW
;

443 extern int 
	$wcswidth
 (const 
wchar_t
 *
__s
, 
size_t
 
__n
) 
__THROW
;

447 
__BEGIN_NAMESPACE_STD


450 extern double 
	$wcstod
 (const 
wchar_t
 *
__restrict
 
__nptr
,

451 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

452 
__END_NAMESPACE_STD


454 #ifdef 
__USE_ISOC99


455 
__BEGIN_NAMESPACE_C99


457 extern float 
	$wcstof
 (const 
wchar_t
 *
__restrict
 
__nptr
,

458 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

459 extern long double 
	$wcstold
 (const 
wchar_t
 *
__restrict
 
__nptr
,

460 
wchar_t
 **
__restrict
 
__endptr
) 
__THROW
;

461 
__END_NAMESPACE_C99


465 
__BEGIN_NAMESPACE_STD


468 extern long int 
	$wcstol
 (const 
wchar_t
 *
__restrict
 
__nptr
,

469 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
) 
__THROW
;

473 extern unsigned long int 
	$wcstoul
 (const 
wchar_t
 *
__restrict
 
__nptr
,

474 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

475 
__THROW
;

476 
__END_NAMESPACE_STD


478 #ifdef 
__USE_ISOC99


479 
__BEGIN_NAMESPACE_C99


482 
__extension__


483 extern long long int 
	$wcstoll
 (const 
wchar_t
 *
__restrict
 
__nptr
,

484 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

485 
__THROW
;

489 
__extension__


490 extern unsigned long long int 
	$wcstoull
 (const 
wchar_t
 *
__restrict
 
__nptr
,

491 
wchar_t
 **
__restrict
 
__endptr
,

492 int 
__base
) 
__THROW
;

493 
__END_NAMESPACE_C99


496 #ifdef 
__USE_GNU


499 
__extension__


500 extern long long int 
	$wcstoq
 (const 
wchar_t
 *
__restrict
 
__nptr
,

501 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
)

502 
__THROW
;

506 
__extension__


507 extern unsigned long long int 
	$wcstouq
 (const 
wchar_t
 *
__restrict
 
__nptr
,

508 
wchar_t
 **
__restrict
 
__endptr
,

509 int 
__base
) 
__THROW
;

512 #ifdef 
__USE_GNU


526 #include 
	~<xlocale.h
>

530 extern long int 
	$wcstol_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

531 
wchar_t
 **
__restrict
 
__endptr
, int 
__base
,

532 
__locale_t
 
__loc
) 
__THROW
;

534 extern unsigned long int 
	$wcstoul_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

535 
wchar_t
 **
__restrict
 
__endptr
,

536 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

538 
__extension__


539 extern long long int 
	$wcstoll_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

540 
wchar_t
 **
__restrict
 
__endptr
,

541 int 
__base
, 
__locale_t
 
__loc
) 
__THROW
;

543 
__extension__


544 extern unsigned long long int 
	$wcstoull_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

545 
wchar_t
 **
__restrict
 
__endptr
,

546 int 
__base
, 
__locale_t
 
__loc
)

547 
__THROW
;

549 extern double 
	$wcstod_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

550 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

551 
__THROW
;

553 extern float 
	$wcstof_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

554 
wchar_t
 **
__restrict
 
__endptr
, 
__locale_t
 
__loc
)

555 
__THROW
;

557 extern long double 
	$wcstold_l
 (const 
wchar_t
 *
__restrict
 
__nptr
,

558 
wchar_t
 **
__restrict
 
__endptr
,

559 
__locale_t
 
__loc
) 
__THROW
;

563 #ifdef 
__USE_XOPEN2K8


566 extern 
wchar_t
 *
	$wcpcpy
 (
wchar_t
 *
__restrict
 
__dest
,

567 const 
wchar_t
 *
__restrict
 
__src
) 
__THROW
;

571 extern 
wchar_t
 *
	$wcpncpy
 (
wchar_t
 *
__restrict
 
__dest
,

572 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
)

573 
__THROW
;

580 extern 
__FILE
 *
	$open_wmemstream
 (
wchar_t
 **
__bufloc
, 
size_t
 *
__sizeloc
) 
__THROW
;

583 #if 
defined
 
__USE_ISOC95
 || defined 
__USE_UNIX98


584 
__BEGIN_NAMESPACE_STD


587 extern int 
	$fwide
 (
__FILE
 *
__fp
, int 
__mode
) 
__THROW
;

594 extern int 
	`fwprintf
 (
__FILE
 *
__restrict
 
__stream
,

595 const 
wchar_t
 *
__restrict
 
__format
, ...)

601 extern int 
	`wprintf
 (const 
wchar_t
 *
__restrict
 
__format
, ...)

604 extern int 
	$swprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

605 const 
wchar_t
 *
__restrict
 
__format
, ...)

606 
__THROW
 ;

612 extern int 
	`vfwprintf
 (
__FILE
 *
__restrict
 
__s
,

613 const 
wchar_t
 *
__restrict
 
__format
,

614 
__gnuc_va_list
 
__arg
)

620 extern int 
	`vwprintf
 (const 
wchar_t
 *
__restrict
 
__format
,

621 
__gnuc_va_list
 
__arg
)

625 extern int 
	$vswprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

626 const 
wchar_t
 *
__restrict
 
__format
,

627 
__gnuc_va_list
 
__arg
)

628 
__THROW
 ;

635 extern int 
	`fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

636 const 
wchar_t
 *
__restrict
 
__format
, ...)

642 extern int 
	`wscanf
 (const 
wchar_t
 *
__restrict
 
__format
, ...)

645 extern int 
	$swscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

646 const 
wchar_t
 *
__restrict
 
__format
, ...)

647 
__THROW
 ;

649 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

650 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

651 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

652 #ifdef 
__REDIRECT


656 extern int 
	`__REDIRECT
 (
fwscanf
, (
__FILE
 *
__restrict
 
__stream
,

657 const 
wchar_t
 *
__restrict
 
__format
, ...),

658 
__isoc99_fwscanf
)

660 extern int 
	`__REDIRECT
 (
wscanf
, (const 
wchar_t
 *
__restrict
 
__format
, ...),

661 
__isoc99_wscanf
)

663 extern int 
	`__REDIRECT_NTH
 (
swscanf
, (const 
wchar_t
 *
__restrict
 
__s
,

664 const 
wchar_t
 *
__restrict
 
__format
,

665 ...), 
__isoc99_swscanf
)

668 extern int 
	`__isoc99_fwscanf
 (
__FILE
 *
__restrict
 
__stream
,

669 const 
wchar_t
 *
__restrict
 
__format
, ...);

670 extern int 
	`__isoc99_wscanf
 (const 
wchar_t
 *
__restrict
 
__format
, ...);

671 extern int 
	$__isoc99_swscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

672 const 
wchar_t
 *
__restrict
 
__format
, ...)

673 
__THROW
;

674 #define 
	#fwscanf
 
__isoc99_fwscanf


	)

675 #define 
	#wscanf
 
__isoc99_wscanf


	)

676 #define 
	#swscanf
 
__isoc99_swscanf


	)

680 
__END_NAMESPACE_STD


683 #ifdef 
__USE_ISOC99


684 
__BEGIN_NAMESPACE_C99


689 extern int 
	`vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

690 const 
wchar_t
 *
__restrict
 
__format
,

691 
__gnuc_va_list
 
__arg
)

697 extern int 
	`vwscanf
 (const 
wchar_t
 *
__restrict
 
__format
,

698 
__gnuc_va_list
 
__arg
)

701 extern int 
	$vswscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

702 const 
wchar_t
 *
__restrict
 
__format
,

703 
__gnuc_va_list
 
__arg
)

704 
__THROW
 ;

706 #if !
defined
 
__USE_GNU
 \

707 && (!
defined
 
__LDBL_COMPAT
 || !defined 
__REDIRECT
) \

708 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

709 #ifdef 
__REDIRECT


710 extern int 
	`__REDIRECT
 (
vfwscanf
, (
__FILE
 *
__restrict
 
__s
,

711 const 
wchar_t
 *
__restrict
 
__format
,

712 
__gnuc_va_list
 
__arg
), 
__isoc99_vfwscanf
)

714 extern int 
	`__REDIRECT
 (
vwscanf
, (const 
wchar_t
 *
__restrict
 
__format
,

715 
__gnuc_va_list
 
__arg
), 
__isoc99_vwscanf
)

717 extern int 
	`__REDIRECT_NTH
 (
vswscanf
, (const 
wchar_t
 *
__restrict
 
__s
,

718 const 
wchar_t
 *
__restrict
 
__format
,

719 
__gnuc_va_list
 
__arg
), 
__isoc99_vswscanf
)

722 extern int 
	`__isoc99_vfwscanf
 (
__FILE
 *
__restrict
 
__s
,

723 const 
wchar_t
 *
__restrict
 
__format
,

724 
__gnuc_va_list
 
__arg
);

725 extern int 
	`__isoc99_vwscanf
 (const 
wchar_t
 *
__restrict
 
__format
,

726 
__gnuc_va_list
 
__arg
);

727 extern int 
	$__isoc99_vswscanf
 (const 
wchar_t
 *
__restrict
 
__s
,

728 const 
wchar_t
 *
__restrict
 
__format
,

729 
__gnuc_va_list
 
__arg
) 
__THROW
;

730 #define 
	#vfwscanf
 
__isoc99_vfwscanf


	)

731 #define 
	#vwscanf
 
__isoc99_vwscanf


	)

732 #define 
	#vswscanf
 
__isoc99_vswscanf


	)

736 
__END_NAMESPACE_C99


740 
__BEGIN_NAMESPACE_STD


745 extern 
wint_t
 
	`fgetwc
 (
__FILE
 *
__stream
);

746 extern 
wint_t
 
	`getwc
 (
__FILE
 *
__stream
);

752 extern 
wint_t
 
	`getwchar
 (void);

759 extern 
wint_t
 
	`fputwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

760 extern 
wint_t
 
	`putwc
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

766 extern 
wint_t
 
	`putwchar
 (
wchar_t
 
__wc
);

774 extern 
wchar_t
 *
	`fgetws
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

775 
__FILE
 *
__restrict
 
__stream
);

781 extern int 
	`fputws
 (const 
wchar_t
 *
__restrict
 
__ws
,

782 
__FILE
 *
__restrict
 
__stream
);

789 extern 
wint_t
 
	`ungetwc
 (wint_t 
__wc
, 
__FILE
 *
__stream
);

790 
__END_NAMESPACE_STD


793 #ifdef 
__USE_GNU


801 extern 
wint_t
 
	`getwc_unlocked
 (
__FILE
 *
__stream
);

802 extern 
wint_t
 
	`getwchar_unlocked
 (void);

810 extern 
wint_t
 
	`fgetwc_unlocked
 (
__FILE
 *
__stream
);

818 extern 
wint_t
 
	`fputwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

827 extern 
wint_t
 
	`putwc_unlocked
 (
wchar_t
 
__wc
, 
__FILE
 *
__stream
);

828 extern 
wint_t
 
	`putwchar_unlocked
 (
wchar_t
 
__wc
);

837 extern 
wchar_t
 *
	`fgetws_unlocked
 (wchar_t *
__restrict
 
__ws
, int 
__n
,

838 
__FILE
 *
__restrict
 
__stream
);

846 extern int 
	`fputws_unlocked
 (const 
wchar_t
 *
__restrict
 
__ws
,

847 
__FILE
 *
__restrict
 
__stream
);

851 
__BEGIN_NAMESPACE_C99


855 extern 
size_t
 
	$wcsftime
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

856 const 
wchar_t
 *
__restrict
 
__format
,

857 const struct 
tm
 *
__restrict
 
__tp
) 
__THROW
;

858 
__END_NAMESPACE_C99


860 #ifdef 
__USE_GNU


861 #include 
	~<xlocale.h
>

865 extern 
size_t
 
	$wcsftime_l
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__maxsize
,

866 const 
wchar_t
 *
__restrict
 
__format
,

867 const struct 
tm
 *
__restrict
 
__tp
,

868 
__locale_t
 
__loc
) 
__THROW
;

877 #if 
defined
 
__USE_UNIX98
 && !defined 
__USE_GNU


878 #define 
	#__need_iswxxx


	)

879 #include 
	~<wctype.h
>

883 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


884 #include 
	~<bits/wchar2.h
>

887 #ifdef 
__LDBL_COMPAT


888 #include 
	~<bits/wchar-ldbl.h
>

891 
__END_DECLS


899 #undef 
__need_mbstate_t


900 #undef 
__need_wint_t


	@/usr/include/bits/timex.h

18 #ifndef 
_BITS_TIMEX_H


19 #define 
	#_BITS_TIMEX_H
 1

	)

21 #include 
	~<bits/types.h
>

25 struct 
	stimex


27 unsigned int 
	mmodes
;

28 
__syscall_slong_t
 
	moffset
;

29 
__syscall_slong_t
 
	mfreq
;

30 
__syscall_slong_t
 
	mmaxerror
;

31 
__syscall_slong_t
 
	mesterror
;

32 int 
	mstatus
;

33 
__syscall_slong_t
 
	mconstant
;

34 
__syscall_slong_t
 
	mprecision
;

35 
__syscall_slong_t
 
	mtolerance
;

36 struct 
timeval
 
	mtime
;

37 
__syscall_slong_t
 
	mtick
;

38 
__syscall_slong_t
 
	mppsfreq
;

39 
__syscall_slong_t
 
	mjitter
;

40 int 
	mshift
;

41 
__syscall_slong_t
 
	mstabil
;

42 
__syscall_slong_t
 
	mjitcnt
;

43 
__syscall_slong_t
 
	mcalcnt
;

44 
__syscall_slong_t
 
	merrcnt
;

45 
__syscall_slong_t
 
	mstbcnt
;

47 int 
	mtai
;

56 #define 
	#ADJ_OFFSET
 0x0001

	)

57 #define 
	#ADJ_FREQUENCY
 0x0002

	)

58 #define 
	#ADJ_MAXERROR
 0x0004

	)

59 #define 
	#ADJ_ESTERROR
 0x0008

	)

60 #define 
	#ADJ_STATUS
 0x0010

	)

61 #define 
	#ADJ_TIMECONST
 0x0020

	)

62 #define 
	#ADJ_TAI
 0x0080

	)

63 #define 
	#ADJ_MICRO
 0x1000

	)

64 #define 
	#ADJ_NANO
 0x2000

	)

65 #define 
	#ADJ_TICK
 0x4000

	)

66 #define 
	#ADJ_OFFSET_SINGLESHOT
 0x8001

	)

67 #define 
	#ADJ_OFFSET_SS_READ
 0xa001

	)

70 #define 
	#MOD_OFFSET
 
ADJ_OFFSET


	)

71 #define 
	#MOD_FREQUENCY
 
ADJ_FREQUENCY


	)

72 #define 
	#MOD_MAXERROR
 
ADJ_MAXERROR


	)

73 #define 
	#MOD_ESTERROR
 
ADJ_ESTERROR


	)

74 #define 
	#MOD_STATUS
 
ADJ_STATUS


	)

75 #define 
	#MOD_TIMECONST
 
ADJ_TIMECONST


	)

76 #define 
	#MOD_CLKB
 
ADJ_TICK


	)

77 #define 
	#MOD_CLKA
 
ADJ_OFFSET_SINGLESHOT


	)

78 #define 
	#MOD_TAI
 
ADJ_TAI


	)

79 #define 
	#MOD_MICRO
 
ADJ_MICRO


	)

80 #define 
	#MOD_NANO
 
ADJ_NANO


	)

84 #define 
	#STA_PLL
 0x0001

	)

85 #define 
	#STA_PPSFREQ
 0x0002

	)

86 #define 
	#STA_PPSTIME
 0x0004

	)

87 #define 
	#STA_FLL
 0x0008

	)

89 #define 
	#STA_INS
 0x0010

	)

90 #define 
	#STA_DEL
 0x0020

	)

91 #define 
	#STA_UNSYNC
 0x0040

	)

92 #define 
	#STA_FREQHOLD
 0x0080

	)

94 #define 
	#STA_PPSSIGNAL
 0x0100

	)

95 #define 
	#STA_PPSJITTER
 0x0200

	)

96 #define 
	#STA_PPSWANDER
 0x0400

	)

97 #define 
	#STA_PPSERROR
 0x0800

	)

99 #define 
	#STA_CLOCKERR
 0x1000

	)

100 #define 
	#STA_NANO
 0x2000

	)

101 #define 
	#STA_MODE
 0x4000

	)

102 #define 
	#STA_CLK
 0x8000

	)

105 #define 
	#STA_RONLY
 (
STA_PPSSIGNAL
 | 
STA_PPSJITTER
 | 
STA_PPSWANDER
 | \

106 
STA_PPSERROR
 | 
STA_CLOCKERR
 | 
STA_NANO
 | 
STA_MODE
 | 
STA_CLK
)

	)

	@/usr/include/bits/wchar-ldbl.h

19 #ifndef 
_WCHAR_H


23 #if 
defined
 
__USE_ISOC95
 || defined 
__USE_UNIX98


24 
__BEGIN_NAMESPACE_C99


25 
__LDBL_REDIR_DECL
 (
fwprintf
);

26 
__LDBL_REDIR_DECL
 (
wprintf
);

27 
__LDBL_REDIR_DECL
 (
swprintf
);

28 
__LDBL_REDIR_DECL
 (
vfwprintf
);

29 
__LDBL_REDIR_DECL
 (
vwprintf
);

30 
__LDBL_REDIR_DECL
 (
vswprintf
);

31 #if 
defined
 
__USE_ISOC99
 && !defined 
__USE_GNU
 \

32 && !
defined
 
	g__REDIRECT
 \

33 && (
defined
 
	g__STRICT_ANSI__
 || defined 
	g__USE_XOPEN2K
)

34 
	$__LDBL_REDIR1_DECL
 (
fwscanf
, 
__nldbl___isoc99_fwscanf
)

35 
	$__LDBL_REDIR1_DECL
 (
wscanf
, 
__nldbl___isoc99_wscanf
)

36 
	$__LDBL_REDIR1_DECL
 (
swscanf
, 
__nldbl___isoc99_swscanf
)

38 
	`__LDBL_REDIR_DECL
 (
fwscanf
);

39 
	`__LDBL_REDIR_DECL
 (
wscanf
);

40 
	`__LDBL_REDIR_DECL
 (
swscanf
);

42 
__END_NAMESPACE_C99


45 #ifdef 
__USE_ISOC99


46 
__BEGIN_NAMESPACE_C99


47 
	`__LDBL_REDIR1_DECL
 (
wcstold
, 
wcstod
);

48 #if !
defined
 
__USE_GNU
 && !defined 
__REDIRECT
 \

49 && (
defined
 
__STRICT_ANSI__
 || defined 
__USE_XOPEN2K
)

50 
	$__LDBL_REDIR1_DECL
 (
vfwscanf
, 
__nldbl___isoc99_vfwscanf
)

51 
	$__LDBL_REDIR1_DECL
 (
vwscanf
, 
__nldbl___isoc99_vwscanf
)

52 
	$__LDBL_REDIR1_DECL
 (
vswscanf
, 
__nldbl___isoc99_vswscanf
)

54 
	`__LDBL_REDIR_DECL
 (
vfwscanf
);

55 
	`__LDBL_REDIR_DECL
 (
vwscanf
);

56 
	`__LDBL_REDIR_DECL
 (
vswscanf
);

58 
__END_NAMESPACE_C99


61 #ifdef 
__USE_GNU


62 
	`__LDBL_REDIR1_DECL
 (
wcstold_l
, 
wcstod_l
);

65 #if 
__USE_FORTIFY_LEVEL
 > 0 && 
defined
 
__fortify_function


66 
	$__LDBL_REDIR_DECL
 (
__swprintf_chk
)

67 
	$__LDBL_REDIR_DECL
 (
__vswprintf_chk
)

68 #if 
__USE_FORTIFY_LEVEL
 > 1

69 
	$__LDBL_REDIR_DECL
 (
__fwprintf_chk
)

70 
	$__LDBL_REDIR_DECL
 (
__wprintf_chk
)

71 
	$__LDBL_REDIR_DECL
 (
__vfwprintf_chk
)

72 
	$__LDBL_REDIR_DECL
 (
__vwprintf_chk
)

	@/usr/include/bits/wchar2.h

19 #ifndef 
_WCHAR_H


24 extern 
wchar_t
 *
	$__wmemcpy_chk
 (
wchar_t
 *
__restrict
 
__s1
,

25 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

26 
size_t
 
__ns1
) 
__THROW
;

27 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemcpy_alias
,

28 (
wchar_t
 *
__restrict
 
__s1
,

29 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
),

30 
wmemcpy
);

31 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemcpy_chk_warn
,

32 (
wchar_t
 *
__restrict
 
__s1
,

33 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

34 
size_t
 
__ns1
), 
__wmemcpy_chk
)

35 
	`__warnattr
 ("wmemcpy called with length bigger than size of destination "

38 
__fortify_function
 
wchar_t
 *

39 
	`__NTH
 (
	$wmemcpy
 (
wchar_t
 *
__restrict
 
__s1
, const wchar_t *__restrict 
__s2
,

40 
size_t
 
__n
))

42 if (
	`__bos0
 (
__s1
) != (
size_t
) -1)

44 if (!
	`__builtin_constant_p
 (
__n
))

45 return 
	`__wmemcpy_chk
 (
__s1
, 
__s2
, 
__n
,

46 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

48 if (
__n
 > 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
))

49 return 
	`__wmemcpy_chk_warn
 (
__s1
, 
__s2
, 
__n
,

50 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

52 return 
	`__wmemcpy_alias
 (
__s1
, 
__s2
, 
__n
);

53 
	}
}

56 extern 
wchar_t
 *
	$__wmemmove_chk
 (
wchar_t
 *
__s1
, const wchar_t *
__s2
,

57 
size_t
 
__n
, size_t 
__ns1
) 
__THROW
;

58 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_alias
, (wchar_t *
__s1
,

59 const 
wchar_t
 *
__s2
,

60 
size_t
 
__n
), 
wmemmove
);

61 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemmove_chk_warn
,

62 (
wchar_t
 *
__s1
, const wchar_t *
__s2
,

63 
size_t
 
__n
, size_t 
__ns1
), 
__wmemmove_chk
)

64 
	`__warnattr
 ("wmemmove called with length bigger than size of destination "

67 
__fortify_function
 
wchar_t
 *

68 
	`__NTH
 (
	$wmemmove
 (
wchar_t
 *
__s1
, const wchar_t *
__s2
, 
size_t
 
__n
))

70 if (
	`__bos0
 (
__s1
) != (
size_t
) -1)

72 if (!
	`__builtin_constant_p
 (
__n
))

73 return 
	`__wmemmove_chk
 (
__s1
, 
__s2
, 
__n
,

74 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

76 if (
__n
 > 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
))

77 return 
	`__wmemmove_chk_warn
 (
__s1
, 
__s2
, 
__n
,

78 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

80 return 
	`__wmemmove_alias
 (
__s1
, 
__s2
, 
__n
);

81 
	}
}

84 #ifdef 
__USE_GNU


85 extern 
wchar_t
 *
	$__wmempcpy_chk
 (
wchar_t
 *
__restrict
 
__s1
,

86 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

87 
size_t
 
__ns1
) 
__THROW
;

88 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmempcpy_alias
,

89 (
wchar_t
 *
__restrict
 
__s1
,

90 const 
wchar_t
 *
__restrict
 
__s2
,

91 
size_t
 
__n
), 
wmempcpy
);

92 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmempcpy_chk_warn
,

93 (
wchar_t
 *
__restrict
 
__s1
,

94 const 
wchar_t
 *
__restrict
 
__s2
, 
size_t
 
__n
,

95 
size_t
 
__ns1
), 
__wmempcpy_chk
)

96 
	`__warnattr
 ("wmempcpy called with length bigger than size of destination "

99 
__fortify_function
 
wchar_t
 *

100 
	`__NTH
 (
	$wmempcpy
 (
wchar_t
 *
__restrict
 
__s1
, const wchar_t *__restrict 
__s2
,

101 
size_t
 
__n
))

103 if (
	`__bos0
 (
__s1
) != (
size_t
) -1)

105 if (!
	`__builtin_constant_p
 (
__n
))

106 return 
	`__wmempcpy_chk
 (
__s1
, 
__s2
, 
__n
,

107 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

109 if (
__n
 > 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
))

110 return 
	`__wmempcpy_chk_warn
 (
__s1
, 
__s2
, 
__n
,

111 
	`__bos0
 (
__s1
) / sizeof (
wchar_t
));

113 return 
	`__wmempcpy_alias
 (
__s1
, 
__s2
, 
__n
);

114 
	}
}

118 extern 
wchar_t
 *
	$__wmemset_chk
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
,

119 
size_t
 
__ns
) 
__THROW
;

120 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemset_alias
, (wchar_t *
__s
, wchar_t 
__c
,

121 
size_t
 
__n
), 
wmemset
);

122 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wmemset_chk_warn
,

123 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
,

124 
size_t
 
__ns
), 
__wmemset_chk
)

125 
	`__warnattr
 ("wmemset called with length bigger than size of destination "

128 
__fortify_function
 
wchar_t
 *

129 
	`__NTH
 (
	$wmemset
 (
wchar_t
 *
__s
, wchar_t 
__c
, 
size_t
 
__n
))

131 if (
	`__bos0
 (
__s
) != (
size_t
) -1)

133 if (!
	`__builtin_constant_p
 (
__n
))

134 return 
	`__wmemset_chk
 (
__s
, 
__c
, 
__n
, 
	`__bos0
 (__s) / sizeof (
wchar_t
));

136 if (
__n
 > 
	`__bos0
 (
__s
) / sizeof (
wchar_t
))

137 return 
	`__wmemset_chk_warn
 (
__s
, 
__c
, 
__n
,

138 
	`__bos0
 (
__s
) / sizeof (
wchar_t
));

140 return 
	`__wmemset_alias
 (
__s
, 
__c
, 
__n
);

141 
	}
}

144 extern 
wchar_t
 *
	$__wcscpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

145 const 
wchar_t
 *
__restrict
 
__src
,

146 
size_t
 
__n
) 
__THROW
;

147 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcscpy_alias
,

148 (
wchar_t
 *
__restrict
 
__dest
,

149 const 
wchar_t
 *
__restrict
 
__src
), 
wcscpy
);

151 
__fortify_function
 
wchar_t
 *

152 
	`__NTH
 (
	$wcscpy
 (
wchar_t
 *
__restrict
 
__dest
, const wchar_t *__restrict 
__src
))

154 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

155 return 
	`__wcscpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest) / sizeof (
wchar_t
));

156 return 
	`__wcscpy_alias
 (
__dest
, 
__src
);

157 
	}
}

160 extern 
wchar_t
 *
	$__wcpcpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

161 const 
wchar_t
 *
__restrict
 
__src
,

162 
size_t
 
__destlen
) 
__THROW
;

163 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcpcpy_alias
,

164 (
wchar_t
 *
__restrict
 
__dest
,

165 const 
wchar_t
 *
__restrict
 
__src
), 
wcpcpy
);

167 
__fortify_function
 
wchar_t
 *

168 
	`__NTH
 (
	$wcpcpy
 (
wchar_t
 *
__restrict
 
__dest
, const wchar_t *__restrict 
__src
))

170 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

171 return 
	`__wcpcpy_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest) / sizeof (
wchar_t
));

172 return 
	`__wcpcpy_alias
 (
__dest
, 
__src
);

173 
	}
}

176 extern 
wchar_t
 *
	$__wcsncpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

177 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
,

178 
size_t
 
__destlen
) 
__THROW
;

179 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcsncpy_alias
,

180 (
wchar_t
 *
__restrict
 
__dest
,

181 const 
wchar_t
 *
__restrict
 
__src
,

182 
size_t
 
__n
), 
wcsncpy
);

183 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcsncpy_chk_warn
,

184 (
wchar_t
 *
__restrict
 
__dest
,

185 const 
wchar_t
 *
__restrict
 
__src
,

186 
size_t
 
__n
, size_t 
__destlen
), 
__wcsncpy_chk
)

187 
	`__warnattr
 ("wcsncpy called with length bigger than size of destination "

190 
__fortify_function
 
wchar_t
 *

191 
	`__NTH
 (
	$wcsncpy
 (
wchar_t
 *
__restrict
 
__dest
, const wchar_t *__restrict 
__src
,

192 
size_t
 
__n
))

194 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

196 if (!
	`__builtin_constant_p
 (
__n
))

197 return 
	`__wcsncpy_chk
 (
__dest
, 
__src
, 
__n
,

198 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

199 if (
__n
 > 
	`__bos
 (
__dest
) / sizeof (
wchar_t
))

200 return 
	`__wcsncpy_chk_warn
 (
__dest
, 
__src
, 
__n
,

201 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

203 return 
	`__wcsncpy_alias
 (
__dest
, 
__src
, 
__n
);

204 
	}
}

207 extern 
wchar_t
 *
	$__wcpncpy_chk
 (
wchar_t
 *
__restrict
 
__dest
,

208 const 
wchar_t
 *
__restrict
 
__src
, 
size_t
 
__n
,

209 
size_t
 
__destlen
) 
__THROW
;

210 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcpncpy_alias
,

211 (
wchar_t
 *
__restrict
 
__dest
,

212 const 
wchar_t
 *
__restrict
 
__src
,

213 
size_t
 
__n
), 
wcpncpy
);

214 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcpncpy_chk_warn
,

215 (
wchar_t
 *
__restrict
 
__dest
,

216 const 
wchar_t
 *
__restrict
 
__src
,

217 
size_t
 
__n
, size_t 
__destlen
), 
__wcpncpy_chk
)

218 
	`__warnattr
 ("wcpncpy called with length bigger than size of destination "

221 
__fortify_function
 
wchar_t
 *

222 
	`__NTH
 (
	$wcpncpy
 (
wchar_t
 *
__restrict
 
__dest
, const wchar_t *__restrict 
__src
,

223 
size_t
 
__n
))

225 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

227 if (!
	`__builtin_constant_p
 (
__n
))

228 return 
	`__wcpncpy_chk
 (
__dest
, 
__src
, 
__n
,

229 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

230 if (
__n
 > 
	`__bos
 (
__dest
) / sizeof (
wchar_t
))

231 return 
	`__wcpncpy_chk_warn
 (
__dest
, 
__src
, 
__n
,

232 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

234 return 
	`__wcpncpy_alias
 (
__dest
, 
__src
, 
__n
);

235 
	}
}

238 extern 
wchar_t
 *
	$__wcscat_chk
 (
wchar_t
 *
__restrict
 
__dest
,

239 const 
wchar_t
 *
__restrict
 
__src
,

240 
size_t
 
__destlen
) 
__THROW
;

241 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcscat_alias
,

242 (
wchar_t
 *
__restrict
 
__dest
,

243 const 
wchar_t
 *
__restrict
 
__src
), 
wcscat
);

245 
__fortify_function
 
wchar_t
 *

246 
	`__NTH
 (
	$wcscat
 (
wchar_t
 *
__restrict
 
__dest
, const wchar_t *__restrict 
__src
))

248 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

249 return 
	`__wcscat_chk
 (
__dest
, 
__src
, 
	`__bos
 (__dest) / sizeof (
wchar_t
));

250 return 
	`__wcscat_alias
 (
__dest
, 
__src
);

251 
	}
}

254 extern 
wchar_t
 *
	$__wcsncat_chk
 (
wchar_t
 *
__restrict
 
__dest
,

255 const 
wchar_t
 *
__restrict
 
__src
,

256 
size_t
 
__n
, size_t 
__destlen
) 
__THROW
;

257 extern 
wchar_t
 *
	`__REDIRECT_NTH
 (
__wcsncat_alias
,

258 (
wchar_t
 *
__restrict
 
__dest
,

259 const 
wchar_t
 *
__restrict
 
__src
,

260 
size_t
 
__n
), 
wcsncat
);

262 
__fortify_function
 
wchar_t
 *

263 
	`__NTH
 (
	$wcsncat
 (
wchar_t
 *
__restrict
 
__dest
, const wchar_t *__restrict 
__src
,

264 
size_t
 
__n
))

266 if (
	`__bos
 (
__dest
) != (
size_t
) -1)

267 return 
	`__wcsncat_chk
 (
__dest
, 
__src
, 
__n
,

268 
	`__bos
 (
__dest
) / sizeof (
wchar_t
));

269 return 
	`__wcsncat_alias
 (
__dest
, 
__src
, 
__n
);

270 
	}
}

273 extern int 
	$__swprintf_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

274 int 
__flag
, 
size_t
 
__s_len
,

275 const 
wchar_t
 *
__restrict
 
__format
, ...)

276 
__THROW
 ;

278 extern int 
	`__REDIRECT_NTH_LDBL
 (
__swprintf_alias
,

279 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

280 const 
wchar_t
 *
__restrict
 
__fmt
, ...),

281 
swprintf
);

283 #ifdef 
__va_arg_pack


284 
__fortify_function
 int

285 
	`__NTH
 (
	$swprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

286 const 
wchar_t
 *
__restrict
 
__fmt
, ...))

288 if (
	`__bos
 (
__s
) != (
size_t
) -1 || 
__USE_FORTIFY_LEVEL
 > 1)

289 return 
	`__swprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

290 
	`__bos
 (
__s
) / sizeof (
wchar_t
),

291 
__fmt
, 
	`__va_arg_pack
 ());

292 return 
	`__swprintf_alias
 (
__s
, 
__n
, 
__fmt
, 
	`__va_arg_pack
 ());

293 
	}
}

294 #elif !
defined
 
__cplusplus


296 #define 
	#swprintf
(
s
, 
n
, ...) \

297 (
	`__bos
 (
s
) != (
size_t
) -1 || 
__USE_FORTIFY_LEVEL
 > 1 \

298 ? 
	`__swprintf_chk
 (
s
, 
n
, 
__USE_FORTIFY_LEVEL
 - 1, \

299 
	`__bos
 (
s
) / sizeof (
wchar_t
), 
__VA_ARGS__
) \

300 : 
	`swprintf
 (
s
, 
n
, 
__VA_ARGS__
))

	)

303 extern int 
	$__vswprintf_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

304 int 
__flag
, 
size_t
 
__s_len
,

305 const 
wchar_t
 *
__restrict
 
__format
,

306 
__gnuc_va_list
 
__arg
)

307 
__THROW
 ;

309 extern int 
	`__REDIRECT_NTH_LDBL
 (
__vswprintf_alias
,

310 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

311 const 
wchar_t
 *
__restrict
 
__fmt
,

312 
__gnuc_va_list
 
__ap
), 
vswprintf
);

314 
__fortify_function
 int

315 
	`__NTH
 (
	$vswprintf
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__n
,

316 const 
wchar_t
 *
__restrict
 
__fmt
, 
__gnuc_va_list
 
__ap
))

318 if (
	`__bos
 (
__s
) != (
size_t
) -1 || 
__USE_FORTIFY_LEVEL
 > 1)

319 return 
	`__vswprintf_chk
 (
__s
, 
__n
, 
__USE_FORTIFY_LEVEL
 - 1,

320 
	`__bos
 (
__s
) / sizeof (
wchar_t
), 
__fmt
, 
__ap
);

321 return 
	`__vswprintf_alias
 (
__s
, 
__n
, 
__fmt
, 
__ap
);

322 
	}
}

325 #if 
__USE_FORTIFY_LEVEL
 > 1

327 extern int 
__fwprintf_chk
 (
__FILE
 *
__restrict
 
__stream
, int 
__flag
,

328 const 
wchar_t
 *
__restrict
 
__format
, ...);

329 extern int 
__wprintf_chk
 (int 
__flag
, const 
wchar_t
 *
__restrict
 
__format
,

331 extern int 
__vfwprintf_chk
 (
__FILE
 *
__restrict
 
__stream
, int 
__flag
,

332 const 
wchar_t
 *
__restrict
 
__format
,

333 
__gnuc_va_list
 
__ap
);

334 extern int 
__vwprintf_chk
 (int 
__flag
, const 
wchar_t
 *
__restrict
 
__format
,

335 
__gnuc_va_list
 
__ap
);

337 #ifdef 
__va_arg_pack


338 
__fortify_function
 int

339 
	$wprintf
 (const 
wchar_t
 *
__restrict
 
__fmt
, ...)

341 return 
	`__wprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
	`__va_arg_pack
 ());

342 
	}
}

344 
__fortify_function
 int

345 
	$fwprintf
 (
__FILE
 *
__restrict
 
__stream
, const 
wchar_t
 *__restrict 
__fmt
, ...)

347 return 
	`__fwprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
,

348 
	`__va_arg_pack
 ());

349 
	}
}

350 #elif !
defined
 
__cplusplus


351 #define 
	#wprintf
(...) \

352 
	`__wprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

353 #define 
	#fwprintf
(
stream
, ...) \

354 
	`__fwprintf_chk
 (
stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__VA_ARGS__
)

	)

357 
__fortify_function
 int

358 
	$vwprintf
 (const 
wchar_t
 *
__restrict
 
__fmt
, 
__gnuc_va_list
 
__ap
)

360 return 
	`__vwprintf_chk
 (
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

361 
	}
}

363 
__fortify_function
 int

364 
	$vfwprintf
 (
__FILE
 *
__restrict
 
__stream
,

365 const 
wchar_t
 *
__restrict
 
__fmt
, 
__gnuc_va_list
 
__ap
)

367 return 
	`__vfwprintf_chk
 (
__stream
, 
__USE_FORTIFY_LEVEL
 - 1, 
__fmt
, 
__ap
);

368 
	}
}

372 extern 
wchar_t
 *
	$__fgetws_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

373 
__FILE
 *
__restrict
 
__stream
) 
__wur
;

374 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_alias
,

375 (
wchar_t
 *
__restrict
 
__s
, int 
__n
,

376 
__FILE
 *
__restrict
 
__stream
), 
fgetws
) 
__wur
;

377 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_chk_warn
,

378 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

379 
__FILE
 *
__restrict
 
__stream
), 
__fgetws_chk
)

380 
__wur
 
	`__warnattr
 ("fgetws called with bigger size than length "

383 
__fortify_function
 
__wur
 
wchar_t
 *

384 
	$fgetws
 (
wchar_t
 *
__restrict
 
__s
, int 
__n
, 
__FILE
 *__restrict 
__stream
)

386 if (
	`__bos
 (
__s
) != (
size_t
) -1)

388 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

389 return 
	`__fgetws_chk
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

390 
__n
, 
__stream
);

392 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
) / sizeof (
wchar_t
))

393 return 
	`__fgetws_chk_warn
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

394 
__n
, 
__stream
);

396 return 
	`__fgetws_alias
 (
__s
, 
__n
, 
__stream
);

397 
	}
}

399 #ifdef 
__USE_GNU


400 extern 
wchar_t
 *
	$__fgetws_unlocked_chk
 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
,

401 int 
__n
, 
__FILE
 *
__restrict
 
__stream
)

402 
__wur
;

403 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_unlocked_alias
,

404 (
wchar_t
 *
__restrict
 
__s
, int 
__n
,

405 
__FILE
 *
__restrict
 
__stream
), 
fgetws_unlocked
)

406 
__wur
;

407 extern 
wchar_t
 *
	`__REDIRECT
 (
__fgetws_unlocked_chk_warn
,

408 (
wchar_t
 *
__restrict
 
__s
, 
size_t
 
__size
, int 
__n
,

409 
__FILE
 *
__restrict
 
__stream
),

410 
__fgetws_unlocked_chk
)

411 
__wur
 
	`__warnattr
 ("fgetws_unlocked called with bigger size than length "

414 
__fortify_function
 
__wur
 
wchar_t
 *

415 
	$fgetws_unlocked
 (
wchar_t
 *
__restrict
 
__s
, int 
__n
, 
__FILE
 *__restrict 
__stream
)

417 if (
	`__bos
 (
__s
) != (
size_t
) -1)

419 if (!
	`__builtin_constant_p
 (
__n
) || __n <= 0)

420 return 
	`__fgetws_unlocked_chk
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

421 
__n
, 
__stream
);

423 if ((
size_t
) 
__n
 > 
	`__bos
 (
__s
) / sizeof (
wchar_t
))

424 return 
	`__fgetws_unlocked_chk_warn
 (
__s
, 
	`__bos
 (__s) / sizeof (
wchar_t
),

425 
__n
, 
__stream
);

427 return 
	`__fgetws_unlocked_alias
 (
__s
, 
__n
, 
__stream
);

428 
	}
}

432 extern 
size_t
 
	$__wcrtomb_chk
 (char *
__restrict
 
__s
, 
wchar_t
 
__wchar
,

433 
mbstate_t
 *
__restrict
 
__p
,

434 
size_t
 
__buflen
) 
__THROW
 
__wur
;

435 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcrtomb_alias
,

436 (char *
__restrict
 
__s
, 
wchar_t
 
__wchar
,

437 
mbstate_t
 *
__restrict
 
__ps
), 
wcrtomb
) 
__wur
;

439 
__fortify_function
 
__wur
 
size_t


440 
	`__NTH
 (
	$wcrtomb
 (char *
__restrict
 
__s
, 
wchar_t
 
__wchar
,

441 
mbstate_t
 *
__restrict
 
__ps
))

446 #define 
	#__WCHAR_MB_LEN_MAX
 16

	)

447 #if 
defined
 
MB_LEN_MAX
 && MB_LEN_MAX != 
__WCHAR_MB_LEN_MAX


450 if (
	`__bos
 (
__s
) != (
size_t
) -1 && 
__WCHAR_MB_LEN_MAX
 > __bos (__s))

451 return 
	`__wcrtomb_chk
 (
__s
, 
__wchar
, 
__ps
, 
	`__bos
 (__s));

452 return 
	`__wcrtomb_alias
 (
__s
, 
__wchar
, 
__ps
);

453 
	}
}

456 extern 
size_t
 
	$__mbsrtowcs_chk
 (
wchar_t
 *
__restrict
 
__dst
,

457 const char **
__restrict
 
__src
,

458 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

459 
size_t
 
__dstlen
) 
__THROW
;

460 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsrtowcs_alias
,

461 (
wchar_t
 *
__restrict
 
__dst
,

462 const char **
__restrict
 
__src
,

463 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
),

464 
mbsrtowcs
);

465 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsrtowcs_chk_warn
,

466 (
wchar_t
 *
__restrict
 
__dst
,

467 const char **
__restrict
 
__src
,

468 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

469 
size_t
 
__dstlen
), 
__mbsrtowcs_chk
)

470 
	`__warnattr
 ("mbsrtowcs called with dst buffer smaller than len "

473 
__fortify_function
 
size_t


474 
	`__NTH
 (
	$mbsrtowcs
 (
wchar_t
 *
__restrict
 
__dst
, const char **__restrict 
__src
,

475 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

477 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

479 if (!
	`__builtin_constant_p
 (
__len
))

480 return 
	`__mbsrtowcs_chk
 (
__dst
, 
__src
, 
__len
, 
__ps
,

481 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

483 if (
__len
 > 
	`__bos
 (
__dst
) / sizeof (
wchar_t
))

484 return 
	`__mbsrtowcs_chk_warn
 (
__dst
, 
__src
, 
__len
, 
__ps
,

485 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

487 return 
	`__mbsrtowcs_alias
 (
__dst
, 
__src
, 
__len
, 
__ps
);

488 
	}
}

491 extern 
size_t
 
	$__wcsrtombs_chk
 (char *
__restrict
 
__dst
,

492 const 
wchar_t
 **
__restrict
 
__src
,

493 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

494 
size_t
 
__dstlen
) 
__THROW
;

495 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsrtombs_alias
,

496 (char *
__restrict
 
__dst
,

497 const 
wchar_t
 **
__restrict
 
__src
,

498 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
),

499 
wcsrtombs
);

500 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsrtombs_chk_warn
,

501 (char *
__restrict
 
__dst
,

502 const 
wchar_t
 **
__restrict
 
__src
,

503 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

504 
size_t
 
__dstlen
), 
__wcsrtombs_chk
)

505 
	`__warnattr
 ("wcsrtombs called with dst buffer smaller than len");

507 
__fortify_function
 
size_t


508 
	`__NTH
 (
	$wcsrtombs
 (char *
__restrict
 
__dst
, const 
wchar_t
 **__restrict 
__src
,

509 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

511 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

513 if (!
	`__builtin_constant_p
 (
__len
))

514 return 
	`__wcsrtombs_chk
 (
__dst
, 
__src
, 
__len
, 
__ps
, 
	`__bos
 (__dst));

516 if (
__len
 > 
	`__bos
 (
__dst
))

517 return 
	`__wcsrtombs_chk_warn
 (
__dst
, 
__src
, 
__len
, 
__ps
, 
	`__bos
 (__dst));

519 return 
	`__wcsrtombs_alias
 (
__dst
, 
__src
, 
__len
, 
__ps
);

520 
	}
}

523 #ifdef 
__USE_GNU


524 extern 
size_t
 
	$__mbsnrtowcs_chk
 (
wchar_t
 *
__restrict
 
__dst
,

525 const char **
__restrict
 
__src
, 
size_t
 
__nmc
,

526 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

527 
size_t
 
__dstlen
) 
__THROW
;

528 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsnrtowcs_alias
,

529 (
wchar_t
 *
__restrict
 
__dst
,

530 const char **
__restrict
 
__src
, 
size_t
 
__nmc
,

531 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
),

532 
mbsnrtowcs
);

533 extern 
size_t
 
	`__REDIRECT_NTH
 (
__mbsnrtowcs_chk_warn
,

534 (
wchar_t
 *
__restrict
 
__dst
,

535 const char **
__restrict
 
__src
, 
size_t
 
__nmc
,

536 
size_t
 
__len
, 
mbstate_t
 *
__restrict
 
__ps
,

537 
size_t
 
__dstlen
), 
__mbsnrtowcs_chk
)

538 
	`__warnattr
 ("mbsnrtowcs called with dst buffer smaller than len "

541 
__fortify_function
 
size_t


542 
	`__NTH
 (
	$mbsnrtowcs
 (
wchar_t
 *
__restrict
 
__dst
, const char **__restrict 
__src
,

543 
size_t
 
__nmc
, size_t 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

545 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

547 if (!
	`__builtin_constant_p
 (
__len
))

548 return 
	`__mbsnrtowcs_chk
 (
__dst
, 
__src
, 
__nmc
, 
__len
, 
__ps
,

549 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

551 if (
__len
 > 
	`__bos
 (
__dst
) / sizeof (
wchar_t
))

552 return 
	`__mbsnrtowcs_chk_warn
 (
__dst
, 
__src
, 
__nmc
, 
__len
, 
__ps
,

553 
	`__bos
 (
__dst
) / sizeof (
wchar_t
));

555 return 
	`__mbsnrtowcs_alias
 (
__dst
, 
__src
, 
__nmc
, 
__len
, 
__ps
);

556 
	}
}

559 extern 
size_t
 
	$__wcsnrtombs_chk
 (char *
__restrict
 
__dst
,

560 const 
wchar_t
 **
__restrict
 
__src
,

561 
size_t
 
__nwc
, size_t 
__len
,

562 
mbstate_t
 *
__restrict
 
__ps
, 
size_t
 
__dstlen
)

563 
__THROW
;

564 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsnrtombs_alias
,

565 (char *
__restrict
 
__dst
,

566 const 
wchar_t
 **
__restrict
 
__src
,

567 
size_t
 
__nwc
, size_t 
__len
,

568 
mbstate_t
 *
__restrict
 
__ps
), 
wcsnrtombs
);

569 extern 
size_t
 
	`__REDIRECT_NTH
 (
__wcsnrtombs_chk_warn
,

570 (char *
__restrict
 
__dst
,

571 const 
wchar_t
 **
__restrict
 
__src
,

572 
size_t
 
__nwc
, size_t 
__len
,

573 
mbstate_t
 *
__restrict
 
__ps
,

574 
size_t
 
__dstlen
), 
__wcsnrtombs_chk
)

575 
	`__warnattr
 ("wcsnrtombs called with dst buffer smaller than len");

577 
__fortify_function
 
size_t


578 
	`__NTH
 (
	$wcsnrtombs
 (char *
__restrict
 
__dst
, const 
wchar_t
 **__restrict 
__src
,

579 
size_t
 
__nwc
, size_t 
__len
, 
mbstate_t
 *
__restrict
 
__ps
))

581 if (
	`__bos
 (
__dst
) != (
size_t
) -1)

583 if (!
	`__builtin_constant_p
 (
__len
))

584 return 
	`__wcsnrtombs_chk
 (
__dst
, 
__src
, 
__nwc
, 
__len
, 
__ps
,

585 
	`__bos
 (
__dst
));

587 if (
__len
 > 
	`__bos
 (
__dst
))

588 return 
	`__wcsnrtombs_chk_warn
 (
__dst
, 
__src
, 
__nwc
, 
__len
, 
__ps
,

589 
	`__bos
 (
__dst
));

591 return 
	`__wcsnrtombs_alias
 (
__dst
, 
__src
, 
__nwc
, 
__len
, 
__ps
);

592 
	}
}

	@/usr/include/errno.h

22 #ifndef 
_ERRNO_H


26 #ifndef 
__need_Emath


27 #define 
	#_ERRNO_H
 1

	)

28 #include 
	~<features.h
>

31 
	g__BEGIN_DECLS


35 #include 
	~<bits/errno.h
>

36 #undef 
__need_Emath


38 #ifdef 
_ERRNO_H


45 #ifndef 
errno


46 extern int 
errno
;

49 #ifdef 
__USE_GNU


54 extern char *
program_invocation_name
, *
program_invocation_short_name
;

58 
	g__END_DECLS


66 #if 
defined
 
__USE_GNU
 || defined 
__need_error_t


67 #ifndef 
__error_t_defined


68 typedef int 
	terror_t
;

69 #define 
	#__error_t_defined
 1

	)

71 #undef 
__need_error_t


	@/usr/include/gnu/option-groups.h

10 #ifndef 
__GNU_OPTION_GROUPS_H


11 #define 
	#__GNU_OPTION_GROUPS_H


	)

13 #define 
	#__OPTION_EGLIBC_ADVANCED_INET6
 1

	)

14 #define 
	#__OPTION_EGLIBC_BACKTRACE
 1

	)

15 #define 
	#__OPTION_EGLIBC_BIG_MACROS
 1

	)

16 #define 
	#__OPTION_EGLIBC_BSD
 1

	)

17 #define 
	#__OPTION_EGLIBC_CATGETS
 1

	)

18 #define 
	#__OPTION_EGLIBC_CHARSETS
 1

	)

19 #define 
	#__OPTION_EGLIBC_CRYPT
 1

	)

20 #define 
	#__OPTION_EGLIBC_CRYPT_UFC
 1

	)

21 #define 
	#__OPTION_EGLIBC_CXX_TESTS
 1

	)

22 #define 
	#__OPTION_EGLIBC_DB_ALIASES
 1

	)

23 #define 
	#__OPTION_EGLIBC_ENVZ
 1

	)

24 #define 
	#__OPTION_EGLIBC_FCVT
 1

	)

25 #define 
	#__OPTION_EGLIBC_FMTMSG
 1

	)

26 #define 
	#__OPTION_EGLIBC_FSTAB
 1

	)

27 #define 
	#__OPTION_EGLIBC_FTRAVERSE
 1

	)

28 #define 
	#__OPTION_EGLIBC_GETLOGIN
 1

	)

29 #define 
	#__OPTION_EGLIBC_IDN
 1

	)

30 #define 
	#__OPTION_EGLIBC_INET
 1

	)

31 #define 
	#__OPTION_EGLIBC_INET_ANL
 1

	)

32 #define 
	#__OPTION_EGLIBC_LIBM
 1

	)

33 #define 
	#__OPTION_EGLIBC_LOCALES
 1

	)

34 #define 
	#__OPTION_EGLIBC_LOCALE_CODE
 1

	)

35 #define 
	#__OPTION_EGLIBC_MEMUSAGE
 1

	)

36 #define 
	#__OPTION_EGLIBC_NIS
 1

	)

37 #define 
	#__OPTION_EGLIBC_NSSWITCH
 1

	)

38 #define 
	#__OPTION_EGLIBC_RCMD
 1

	)

39 #define 
	#__OPTION_EGLIBC_RTLD_DEBUG
 1

	)

40 #define 
	#__OPTION_EGLIBC_SPAWN
 1

	)

41 #define 
	#__OPTION_EGLIBC_STREAMS
 1

	)

42 #define 
	#__OPTION_EGLIBC_SUNRPC
 1

	)

43 #define 
	#__OPTION_EGLIBC_UTMP
 1

	)

44 #define 
	#__OPTION_EGLIBC_UTMPX
 1

	)

45 #define 
	#__OPTION_EGLIBC_WORDEXP
 1

	)

46 #define 
	#__OPTION_POSIX_C_LANG_WIDE_CHAR
 1

	)

47 #define 
	#__OPTION_POSIX_REGEXP
 1

	)

48 #define 
	#__OPTION_POSIX_REGEXP_GLIBC
 1

	)

49 #define 
	#__OPTION_POSIX_WIDE_CHAR_DEVICE_IO
 1

	)

	@/usr/include/pthread.h

18 #ifndef 
_PTHREAD_H


19 #define 
	#_PTHREAD_H
 1

	)

21 #include 
	~<features.h
>

22 #include 
	~<endian.h
>

23 #include 
	~<sched.h
>

24 #include 
	~<time.h
>

26 #include 
	~<bits/pthreadtypes.h
>

27 #include 
	~<bits/setjmp.h
>

28 #include 
	~<bits/wordsize.h
>

34 
	mPTHREAD_CREATE_JOINABLE
,

35 #define 
	#PTHREAD_CREATE_JOINABLE
 
PTHREAD_CREATE_JOINABLE


	)

36 
	mPTHREAD_CREATE_DETACHED


37 #define 
	#PTHREAD_CREATE_DETACHED
 
PTHREAD_CREATE_DETACHED


	)

44 
	mPTHREAD_MUTEX_TIMED_NP
,

45 
	mPTHREAD_MUTEX_RECURSIVE_NP
,

46 
	mPTHREAD_MUTEX_ERRORCHECK_NP
,

47 
	mPTHREAD_MUTEX_ADAPTIVE_NP


48 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


50 
	mPTHREAD_MUTEX_NORMAL
 = 
PTHREAD_MUTEX_TIMED_NP
,

51 
	mPTHREAD_MUTEX_RECURSIVE
 = 
PTHREAD_MUTEX_RECURSIVE_NP
,

52 
	mPTHREAD_MUTEX_ERRORCHECK
 = 
PTHREAD_MUTEX_ERRORCHECK_NP
,

53 
	mPTHREAD_MUTEX_DEFAULT
 = 
PTHREAD_MUTEX_NORMAL


55 #ifdef 
__USE_GNU


57 , 
	mPTHREAD_MUTEX_FAST_NP
 = 
PTHREAD_MUTEX_TIMED_NP


62 #ifdef 
__USE_XOPEN2K


66 
	mPTHREAD_MUTEX_STALLED
,

67 
	mPTHREAD_MUTEX_STALLED_NP
 = 
PTHREAD_MUTEX_STALLED
,

68 
	mPTHREAD_MUTEX_ROBUST
,

69 
	mPTHREAD_MUTEX_ROBUST_NP
 = 
PTHREAD_MUTEX_ROBUST


74 #if 
defined
 
__USE_POSIX199506
 || defined 
__USE_UNIX98


78 
	mPTHREAD_PRIO_NONE
,

79 
	mPTHREAD_PRIO_INHERIT
,

80 
	mPTHREAD_PRIO_PROTECT


86 #if 
__PTHREAD_MUTEX_HAVE_ELISION
 == 1

87 #define 
	#__PTHREAD_SPINS
 0, 0

	)

88 #elif 
__PTHREAD_MUTEX_HAVE_ELISION
 == 2

89 #define 
	#__PTHREAD_SPINS
 { 0, 0 }

	)

91 #define 
	#__PTHREAD_SPINS
 0

	)

94 #ifdef 
__PTHREAD_MUTEX_HAVE_PREV


95 #define 
	#PTHREAD_MUTEX_INITIALIZER
 \

96 { { 0, 0, 0, 0, 0, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

97 #ifdef 
__USE_GNU


98 #define 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

99 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

100 #define 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

101 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

102 #define 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

103 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

104 #define 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

105 { { 0, 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 
__PTHREAD_SPINS
, { 0, 0 } } }

	)

109 #define 
	#PTHREAD_MUTEX_INITIALIZER
 \

110 { { 0, 0, 0, 0, 0, { 
__PTHREAD_SPINS
 } } }

	)

111 #ifdef 
__USE_GNU


112 #define 
	#PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
 \

113 { { 0, 0, 0, 
PTHREAD_MUTEX_RECURSIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

114 #define 
	#PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
 \

115 { { 0, 0, 0, 
PTHREAD_MUTEX_ERRORCHECK_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

116 #define 
	#PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP
 \

117 { { 0, 0, 0, 
PTHREAD_MUTEX_ADAPTIVE_NP
, 0, { 
__PTHREAD_SPINS
 } } }

	)

124 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


127 
	mPTHREAD_RWLOCK_PREFER_READER_NP
,

128 
	mPTHREAD_RWLOCK_PREFER_WRITER_NP
,

129 
	mPTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,

130 
	mPTHREAD_RWLOCK_DEFAULT_NP
 = 
PTHREAD_RWLOCK_PREFER_READER_NP


136 #ifndef 
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


137 #if 
__WORDSIZE
 == 64

138 #define 
	#__PTHREAD_RWLOCK_INT_FLAGS_SHARED
 1

	)

143 #define 
	#PTHREAD_RWLOCK_INITIALIZER
 \

144 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 } }

	)

145 #ifdef 
__USE_GNU


146 #ifdef 
__PTHREAD_RWLOCK_INT_FLAGS_SHARED


147 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

149 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
 } }

	)

151 #if 
__BYTE_ORDER
 == 
__LITTLE_ENDIAN


152 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

153 { { 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
, \

154 0, 0, 0, 0 } }

	)

156 #define 
	#PTHREAD_RWLOCK_WRITER_NONRECURSIVE_INITIALIZER_NP
 \

157 { { 0, 0, 0, 0, 0, 0, 0, 0, 0, 
PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP
,\

158 0 } }

	)

168 
	mPTHREAD_INHERIT_SCHED
,

169 #define 
	#PTHREAD_INHERIT_SCHED
 
PTHREAD_INHERIT_SCHED


	)

170 
	mPTHREAD_EXPLICIT_SCHED


171 #define 
	#PTHREAD_EXPLICIT_SCHED
 
PTHREAD_EXPLICIT_SCHED


	)

178 
	mPTHREAD_SCOPE_SYSTEM
,

179 #define 
	#PTHREAD_SCOPE_SYSTEM
 
PTHREAD_SCOPE_SYSTEM


	)

180 
	mPTHREAD_SCOPE_PROCESS


181 #define 
	#PTHREAD_SCOPE_PROCESS
 
PTHREAD_SCOPE_PROCESS


	)

188 
	mPTHREAD_PROCESS_PRIVATE
,

189 #define 
	#PTHREAD_PROCESS_PRIVATE
 
PTHREAD_PROCESS_PRIVATE


	)

190 
	mPTHREAD_PROCESS_SHARED


191 #define 
	#PTHREAD_PROCESS_SHARED
 
PTHREAD_PROCESS_SHARED


	)

197 #define 
	#PTHREAD_COND_INITIALIZER
 { { 0, 0, 0, 0, 0, (void *) 0, 0, 0 } }

	)

201 struct 
	s_pthread_cleanup_buffer


203 void (*
	m__routine
) (void *);

204 void *
	m__arg
;

205 int 
	m__canceltype
;

206 struct 
_pthread_cleanup_buffer
 *
	m__prev
;

212 
	mPTHREAD_CANCEL_ENABLE
,

213 #define 
	#PTHREAD_CANCEL_ENABLE
 
PTHREAD_CANCEL_ENABLE


	)

214 
	mPTHREAD_CANCEL_DISABLE


215 #define 
	#PTHREAD_CANCEL_DISABLE
 
PTHREAD_CANCEL_DISABLE


	)

219 
	mPTHREAD_CANCEL_DEFERRED
,

220 #define 
	#PTHREAD_CANCEL_DEFERRED
 
PTHREAD_CANCEL_DEFERRED


	)

221 
	mPTHREAD_CANCEL_ASYNCHRONOUS


222 #define 
	#PTHREAD_CANCEL_ASYNCHRONOUS
 
PTHREAD_CANCEL_ASYNCHRONOUS


	)

224 #define 
	#PTHREAD_CANCELED
 ((void *) -1)

	)

228 #define 
	#PTHREAD_ONCE_INIT
 0

	)

231 #ifdef 
__USE_XOPEN2K


235 #define 
	#PTHREAD_BARRIER_SERIAL_THREAD
 -1

	)

239 
__BEGIN_DECLS


244 extern int 
pthread_create
 (
pthread_t
 *
__restrict
 
__newthread
,

245 const 
pthread_attr_t
 *
__restrict
 
__attr
,

246 void *(*
__start_routine
) (void *),

247 void *
__restrict
 
__arg
) 
__THROWNL
 
__nonnull
 ((1, 3));

253 extern void 
	$pthread_exit
 (void *
__retval
) 
	`__attribute__
 ((
__noreturn__
));

261 extern int 
	`pthread_join
 (
pthread_t
 
__th
, void **
__thread_return
);

263 #ifdef 
__USE_GNU


266 extern int 
	$pthread_tryjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
) 
__THROW
;

274 extern int 
	`pthread_timedjoin_np
 (
pthread_t
 
__th
, void **
__thread_return
,

275 const struct 
timespec
 *
__abstime
);

282 extern int 
	$pthread_detach
 (
pthread_t
 
__th
) 
__THROW
;

286 extern 
pthread_t
 
	$pthread_self
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

289 extern int 
	$pthread_equal
 (
pthread_t
 
__thread1
, pthread_t 
__thread2
)

290 
__THROW
 
	`__attribute__
 ((
__const__
));

298 extern int 
	$pthread_attr_init
 (
pthread_attr_t
 *
__attr
) 
__THROW
 
	`__nonnull
 ((1));

301 extern int 
	$pthread_attr_destroy
 (
pthread_attr_t
 *
__attr
)

302 
__THROW
 
	`__nonnull
 ((1));

305 extern int 
	$pthread_attr_getdetachstate
 (const 
pthread_attr_t
 *
__attr
,

306 int *
__detachstate
)

307 
__THROW
 
	`__nonnull
 ((1, 2));

310 extern int 
	$pthread_attr_setdetachstate
 (
pthread_attr_t
 *
__attr
,

311 int 
__detachstate
)

312 
__THROW
 
	`__nonnull
 ((1));

316 extern int 
	$pthread_attr_getguardsize
 (const 
pthread_attr_t
 *
__attr
,

317 
size_t
 *
__guardsize
)

318 
__THROW
 
	`__nonnull
 ((1, 2));

321 extern int 
	$pthread_attr_setguardsize
 (
pthread_attr_t
 *
__attr
,

322 
size_t
 
__guardsize
)

323 
__THROW
 
	`__nonnull
 ((1));

327 extern int 
	$pthread_attr_getschedparam
 (const 
pthread_attr_t
 *
__restrict
 
__attr
,

328 struct 
sched_param
 *
__restrict
 
__param
)

329 
__THROW
 
	`__nonnull
 ((1, 2));

332 extern int 
	$pthread_attr_setschedparam
 (
pthread_attr_t
 *
__restrict
 
__attr
,

333 const struct 
sched_param
 *
__restrict


334 
__param
) 
__THROW
 
	`__nonnull
 ((1, 2));

337 extern int 
	$pthread_attr_getschedpolicy
 (const 
pthread_attr_t
 *
__restrict


338 
__attr
, int *
__restrict
 
__policy
)

339 
__THROW
 
	`__nonnull
 ((1, 2));

342 extern int 
	$pthread_attr_setschedpolicy
 (
pthread_attr_t
 *
__attr
, int 
__policy
)

343 
__THROW
 
	`__nonnull
 ((1));

346 extern int 
	$pthread_attr_getinheritsched
 (const 
pthread_attr_t
 *
__restrict


347 
__attr
, int *
__restrict
 
__inherit
)

348 
__THROW
 
	`__nonnull
 ((1, 2));

351 extern int 
	$pthread_attr_setinheritsched
 (
pthread_attr_t
 *
__attr
,

352 int 
__inherit
)

353 
__THROW
 
	`__nonnull
 ((1));

357 extern int 
	$pthread_attr_getscope
 (const 
pthread_attr_t
 *
__restrict
 
__attr
,

358 int *
__restrict
 
__scope
)

359 
__THROW
 
	`__nonnull
 ((1, 2));

362 extern int 
	$pthread_attr_setscope
 (
pthread_attr_t
 *
__attr
, int 
__scope
)

363 
__THROW
 
	`__nonnull
 ((1));

366 extern int 
	$pthread_attr_getstackaddr
 (const 
pthread_attr_t
 *
__restrict


367 
__attr
, void **
__restrict
 
__stackaddr
)

368 
__THROW
 
	`__nonnull
 ((1, 2)) 
__attribute_deprecated__
;

374 extern int 
	$pthread_attr_setstackaddr
 (
pthread_attr_t
 *
__attr
,

375 void *
__stackaddr
)

376 
__THROW
 
	`__nonnull
 ((1)) 
__attribute_deprecated__
;

379 extern int 
	$pthread_attr_getstacksize
 (const 
pthread_attr_t
 *
__restrict


380 
__attr
, 
size_t
 *
__restrict
 
__stacksize
)

381 
__THROW
 
	`__nonnull
 ((1, 2));

386 extern int 
	$pthread_attr_setstacksize
 (
pthread_attr_t
 *
__attr
,

387 
size_t
 
__stacksize
)

388 
__THROW
 
	`__nonnull
 ((1));

390 #ifdef 
__USE_XOPEN2K


392 extern int 
	$pthread_attr_getstack
 (const 
pthread_attr_t
 *
__restrict
 
__attr
,

393 void **
__restrict
 
__stackaddr
,

394 
size_t
 *
__restrict
 
__stacksize
)

395 
__THROW
 
	`__nonnull
 ((1, 2, 3));

400 extern int 
	$pthread_attr_setstack
 (
pthread_attr_t
 *
__attr
, void *
__stackaddr
,

401 
size_t
 
__stacksize
) 
__THROW
 
	`__nonnull
 ((1));

404 #ifdef 
__USE_GNU


407 extern int 
	$pthread_attr_setaffinity_np
 (
pthread_attr_t
 *
__attr
,

408 
size_t
 
__cpusetsize
,

409 const 
cpu_set_t
 *
__cpuset
)

410 
__THROW
 
	`__nonnull
 ((1, 3));

414 extern int 
	$pthread_attr_getaffinity_np
 (const 
pthread_attr_t
 *
__attr
,

415 
size_t
 
__cpusetsize
,

416 
cpu_set_t
 *
__cpuset
)

417 
__THROW
 
	`__nonnull
 ((1, 3));

420 extern int 
	$pthread_getattr_default_np
 (
pthread_attr_t
 *
__attr
)

421 
__THROW
 
	`__nonnull
 ((1));

425 extern int 
	$pthread_setattr_default_np
 (const 
pthread_attr_t
 *
__attr
)

426 
__THROW
 
	`__nonnull
 ((1));

431 extern int 
	$pthread_getattr_np
 (
pthread_t
 
__th
, 
pthread_attr_t
 *
__attr
)

432 
__THROW
 
	`__nonnull
 ((2));

440 extern int 
	$pthread_setschedparam
 (
pthread_t
 
__target_thread
, int 
__policy
,

441 const struct 
sched_param
 *
__param
)

442 
__THROW
 
	`__nonnull
 ((3));

445 extern int 
	$pthread_getschedparam
 (
pthread_t
 
__target_thread
,

446 int *
__restrict
 
__policy
,

447 struct 
sched_param
 *
__restrict
 
__param
)

448 
__THROW
 
	`__nonnull
 ((2, 3));

451 extern int 
	$pthread_setschedprio
 (
pthread_t
 
__target_thread
, int 
__prio
)

452 
__THROW
;

455 #ifdef 
__USE_GNU


457 extern int 
	$pthread_getname_np
 (
pthread_t
 
__target_thread
, char *
__buf
,

458 
size_t
 
__buflen
)

459 
__THROW
 
	`__nonnull
 ((2));

462 extern int 
	$pthread_setname_np
 (
pthread_t
 
__target_thread
, const char *
__name
)

463 
__THROW
 
	`__nonnull
 ((2));

467 #ifdef 
__USE_UNIX98


469 extern int 
	$pthread_getconcurrency
 (void) 
__THROW
;

472 extern int 
	$pthread_setconcurrency
 (int 
__level
) 
__THROW
;

475 #ifdef 
__USE_GNU


480 extern int 
	$pthread_yield
 (void) 
__THROW
;

485 extern int 
	$pthread_setaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

486 const 
cpu_set_t
 *
__cpuset
)

487 
__THROW
 
	`__nonnull
 ((3));

490 extern int 
	$pthread_getaffinity_np
 (
pthread_t
 
__th
, 
size_t
 
__cpusetsize
,

491 
cpu_set_t
 *
__cpuset
)

492 
__THROW
 
	`__nonnull
 ((3));

505 extern int 
	`pthread_once
 (
pthread_once_t
 *
__once_control
,

506 void (*
__init_routine
) (void)) 
	`__nonnull
 ((1, 2));

517 extern int 
	`pthread_setcancelstate
 (int 
__state
, int *
__oldstate
);

521 extern int 
	`pthread_setcanceltype
 (int 
__type
, int *
__oldtype
);

524 extern int 
	`pthread_cancel
 (
pthread_t
 
__th
);

529 extern void 
	`pthread_testcancel
 (void);

538 
__jmp_buf
 
__cancel_jmp_buf
;

539 int 
__mask_was_saved
;

540 } 
__cancel_jmp_buf
[1];

541 void *
__pad
[4];

542 } 
	t__pthread_unwind_buf_t
 
	t__attribute__
 ((
	t__aligned__
));

545 #ifndef 
__cleanup_fct_attribute


546 #define 
	#__cleanup_fct_attribute


	)

551 struct 
	s__pthread_cleanup_frame


553 void (*
__cancel_routine
) (void *);

554 void *
__cancel_arg
;

555 int 
__do_it
;

556 int 
__cancel_type
;

559 #if 
defined
 
__GNUC__
 && defined 
__EXCEPTIONS


560 #ifdef 
__cplusplus


562 class 
	c__pthread_cleanup_class


564 void (*
__cancel_routine
) (void *);

565 void *
__cancel_arg
;

566 int 
__do_it
;

567 int 
__cancel_type
;

569 
public
:

570 
	`__pthread_cleanup_class
 (void (*
__fct
) (void *), void *
__arg
)

571 : 
	`__cancel_routine
 (
__fct
), 
	`__cancel_arg
 (
__arg
), 
	$__do_it
 (1) { }

572 ~
	$__pthread_cleanup_class
 () { if (
__do_it
) 
	`__cancel_routine
 (
__cancel_arg
); 
	}
}

573 void 
	$__setdoit
 (int 
__newval
) { 
__do_it
 = __newval; 
	}
}

574 void 
	$__defer
 () { 
	`pthread_setcanceltype
 (
PTHREAD_CANCEL_DEFERRED
,

575 &
__cancel_type
); 
	}
}

576 void 
	$__restore
 () const { 
	`pthread_setcanceltype
 (
__cancel_type
, 0); 
	}
}

586 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

588 
__pthread_cleanup_class
 
	`__clframe
 (
routine
, 
arg
)

	)

592 #define 
	#pthread_cleanup_pop
(
execute
) \

593 
__clframe
.
	`__setdoit
 (
execute
); \

594 } while (0)

	)

596 #ifdef 
__USE_GNU


600 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

602 
__pthread_cleanup_class
 
	`__clframe
 (
routine
, 
arg
); \

603 
__clframe
.
	`__defer
 ()

	)

608 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

609 
__clframe
.
	`__restore
 (); \

610 
__clframe
.
	`__setdoit
 (
execute
); \

611 } while (0)

	)

618 
__extern_inline
 void

619 
	$__pthread_cleanup_routine
 (struct 
__pthread_cleanup_frame
 *
__frame
)

621 if (
__frame
->
__do_it
)

622 
__frame
->
	`__cancel_routine
 (__frame->
__cancel_arg
);

623 
	}
}

632 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

634 struct 
__pthread_cleanup_frame
 
__clframe
 \

635 
	`__attribute__
 ((
	`__cleanup__
 (
__pthread_cleanup_routine
))) \

636 = { .
__cancel_routine
 = (
routine
), .
__cancel_arg
 = (
arg
), \

637 .
__do_it
 = 1 };

	)

641 #define 
	#pthread_cleanup_pop
(
execute
) \

642 
__clframe
.
__do_it
 = (
execute
); \

643 } while (0)

	)

645 #ifdef 
__USE_GNU


649 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

651 struct 
__pthread_cleanup_frame
 
__clframe
 \

652 
	`__attribute__
 ((
	`__cleanup__
 (
__pthread_cleanup_routine
))) \

653 = { .
__cancel_routine
 = (
routine
), .
__cancel_arg
 = (
arg
), \

654 .
__do_it
 = 1 }; \

655 (void) 
	`pthread_setcanceltype
 (
PTHREAD_CANCEL_DEFERRED
, \

656 &
__clframe
.
__cancel_type
)

	)

661 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

662 (void) 
	`pthread_setcanceltype
 (
__clframe
.
__cancel_type
, 
NULL
); \

663 
__clframe
.
__do_it
 = (
execute
); \

664 } while (0)

	)

675 #define 
	#pthread_cleanup_push
(
routine
, 
arg
) \

677 
__pthread_unwind_buf_t
 
__cancel_buf
; \

678 void (*
__cancel_routine
) (void *) = (
routine
); \

679 void *
__cancel_arg
 = (
arg
); \

680 int 
__not_first_call
 = 
	`__sigsetjmp
 ((struct 
__jmp_buf_tag
 *) (void *) \

681 
__cancel_buf
.
__cancel_jmp_buf
, 0); \

682 if (
	`__glibc_unlikely
 (
__not_first_call
)) \

684 
	`__cancel_routine
 (
__cancel_arg
); \

685 
	`__pthread_unwind_next
 (&
__cancel_buf
); \

689 
	`__pthread_register_cancel
 (&
__cancel_buf
); \

690 do {

	)

691 extern void 
__pthread_register_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

692 
__cleanup_fct_attribute
;

696 #define 
	#pthread_cleanup_pop
(
execute
) \

699 
	`__pthread_unregister_cancel
 (&
__cancel_buf
); \

700 if (
execute
) \

701 
	`__cancel_routine
 (
__cancel_arg
); \

702 } while (0)

	)

703 extern void 
	$__pthread_unregister_cancel
 (
__pthread_unwind_buf_t
 *
__buf
)

704 
__cleanup_fct_attribute
;

706 #ifdef 
__USE_GNU


710 #define 
	#pthread_cleanup_push_defer_np
(
routine
, 
arg
) \

712 
__pthread_unwind_buf_t
 
__cancel_buf
; \

713 void (*
__cancel_routine
) (void *) = (
routine
); \

714 void *
__cancel_arg
 = (
arg
); \

715 int 
__not_first_call
 = 
	`__sigsetjmp
 ((struct 
__jmp_buf_tag
 *) (void *) \

716 
__cancel_buf
.
__cancel_jmp_buf
, 0); \

717 if (
	`__glibc_unlikely
 (
__not_first_call
)) \

719 
	`__cancel_routine
 (
__cancel_arg
); \

720 
	`__pthread_unwind_next
 (&
__cancel_buf
); \

724 
	`__pthread_register_cancel_defer
 (&
__cancel_buf
); \

725 do {

	)

726 extern void 
	`__pthread_register_cancel_defer
 (
__pthread_unwind_buf_t
 *
__buf
)

727 
__cleanup_fct_attribute
;

732 #define 
	#pthread_cleanup_pop_restore_np
(
execute
) \

735 
	`__pthread_unregister_cancel_restore
 (&
__cancel_buf
); \

736 if (
execute
) \

737 
	`__cancel_routine
 (
__cancel_arg
); \

738 
	}
} while (0)

	)

739 extern void 
	$__pthread_unregister_cancel_restore
 (
__pthread_unwind_buf_t
 *
__buf
)

740 
__cleanup_fct_attribute
;

744 extern void 
	$__pthread_unwind_next
 (
__pthread_unwind_buf_t
 *
__buf
)

745 
__cleanup_fct_attribute
 
	`__attribute__
 ((
__noreturn__
))

746 #ifndef 
SHARED


747 
	`__attribute__
 ((
__weak__
))

753 struct 
__jmp_buf_tag
;

754 extern int 
	$__sigsetjmp
 (struct 
__jmp_buf_tag
 *
__env
, int 
__savemask
) 
__THROWNL
;

760 extern int 
	$pthread_mutex_init
 (
pthread_mutex_t
 *
__mutex
,

761 const 
pthread_mutexattr_t
 *
__mutexattr
)

762 
__THROW
 
	`__nonnull
 ((1));

765 extern int 
	$pthread_mutex_destroy
 (
pthread_mutex_t
 *
__mutex
)

766 
__THROW
 
	`__nonnull
 ((1));

769 extern int 
	$pthread_mutex_trylock
 (
pthread_mutex_t
 *
__mutex
)

770 
__THROWNL
 
	`__nonnull
 ((1));

773 extern int 
	$pthread_mutex_lock
 (
pthread_mutex_t
 *
__mutex
)

774 
__THROWNL
 
	`__nonnull
 ((1));

776 #ifdef 
__USE_XOPEN2K


778 extern int 
	$pthread_mutex_timedlock
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

779 const struct 
timespec
 *
__restrict


780 
__abstime
) 
__THROWNL
 
	`__nonnull
 ((1, 2));

784 extern int 
	$pthread_mutex_unlock
 (
pthread_mutex_t
 *
__mutex
)

785 
__THROWNL
 
	`__nonnull
 ((1));

789 extern int 
	$pthread_mutex_getprioceiling
 (const 
pthread_mutex_t
 *

790 
__restrict
 
__mutex
,

791 int *
__restrict
 
__prioceiling
)

792 
__THROW
 
	`__nonnull
 ((1, 2));

796 extern int 
	$pthread_mutex_setprioceiling
 (
pthread_mutex_t
 *
__restrict
 
__mutex
,

797 int 
__prioceiling
,

798 int *
__restrict
 
__old_ceiling
)

799 
__THROW
 
	`__nonnull
 ((1, 3));

802 #ifdef 
__USE_XOPEN2K8


804 extern int 
	$pthread_mutex_consistent
 (
pthread_mutex_t
 *
__mutex
)

805 
__THROW
 
	`__nonnull
 ((1));

806 #ifdef 
__USE_GNU


807 extern int 
	$pthread_mutex_consistent_np
 (
pthread_mutex_t
 *
__mutex
)

808 
__THROW
 
	`__nonnull
 ((1));

817 extern int 
	$pthread_mutexattr_init
 (
pthread_mutexattr_t
 *
__attr
)

818 
__THROW
 
	`__nonnull
 ((1));

821 extern int 
	$pthread_mutexattr_destroy
 (
pthread_mutexattr_t
 *
__attr
)

822 
__THROW
 
	`__nonnull
 ((1));

825 extern int 
	$pthread_mutexattr_getpshared
 (const 
pthread_mutexattr_t
 *

826 
__restrict
 
__attr
,

827 int *
__restrict
 
__pshared
)

828 
__THROW
 
	`__nonnull
 ((1, 2));

831 extern int 
	$pthread_mutexattr_setpshared
 (
pthread_mutexattr_t
 *
__attr
,

832 int 
__pshared
)

833 
__THROW
 
	`__nonnull
 ((1));

835 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K8


837 extern int 
	$pthread_mutexattr_gettype
 (const 
pthread_mutexattr_t
 *
__restrict


838 
__attr
, int *
__restrict
 
__kind
)

839 
__THROW
 
	`__nonnull
 ((1, 2));

844 extern int 
	$pthread_mutexattr_settype
 (
pthread_mutexattr_t
 *
__attr
, int 
__kind
)

845 
__THROW
 
	`__nonnull
 ((1));

849 extern int 
	$pthread_mutexattr_getprotocol
 (const 
pthread_mutexattr_t
 *

850 
__restrict
 
__attr
,

851 int *
__restrict
 
__protocol
)

852 
__THROW
 
	`__nonnull
 ((1, 2));

856 extern int 
	$pthread_mutexattr_setprotocol
 (
pthread_mutexattr_t
 *
__attr
,

857 int 
__protocol
)

858 
__THROW
 
	`__nonnull
 ((1));

861 extern int 
	$pthread_mutexattr_getprioceiling
 (const 
pthread_mutexattr_t
 *

862 
__restrict
 
__attr
,

863 int *
__restrict
 
__prioceiling
)

864 
__THROW
 
	`__nonnull
 ((1, 2));

867 extern int 
	$pthread_mutexattr_setprioceiling
 (
pthread_mutexattr_t
 *
__attr
,

868 int 
__prioceiling
)

869 
__THROW
 
	`__nonnull
 ((1));

871 #ifdef 
__USE_XOPEN2K


873 extern int 
	$pthread_mutexattr_getrobust
 (const 
pthread_mutexattr_t
 *
__attr
,

874 int *
__robustness
)

875 
__THROW
 
	`__nonnull
 ((1, 2));

876 #ifdef 
__USE_GNU


877 extern int 
	$pthread_mutexattr_getrobust_np
 (const 
pthread_mutexattr_t
 *
__attr
,

878 int *
__robustness
)

879 
__THROW
 
	`__nonnull
 ((1, 2));

883 extern int 
	$pthread_mutexattr_setrobust
 (
pthread_mutexattr_t
 *
__attr
,

884 int 
__robustness
)

885 
__THROW
 
	`__nonnull
 ((1));

886 #ifdef 
__USE_GNU


887 extern int 
	$pthread_mutexattr_setrobust_np
 (
pthread_mutexattr_t
 *
__attr
,

888 int 
__robustness
)

889 
__THROW
 
	`__nonnull
 ((1));

894 #if 
defined
 
__USE_UNIX98
 || defined 
__USE_XOPEN2K


899 extern int 
	$pthread_rwlock_init
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

900 const 
pthread_rwlockattr_t
 *
__restrict


901 
__attr
) 
__THROW
 
	`__nonnull
 ((1));

904 extern int 
	$pthread_rwlock_destroy
 (
pthread_rwlock_t
 *
__rwlock
)

905 
__THROW
 
	`__nonnull
 ((1));

908 extern int 
	$pthread_rwlock_rdlock
 (
pthread_rwlock_t
 *
__rwlock
)

909 
__THROWNL
 
	`__nonnull
 ((1));

912 extern int 
	$pthread_rwlock_tryrdlock
 (
pthread_rwlock_t
 *
__rwlock
)

913 
__THROWNL
 
	`__nonnull
 ((1));

915 #ifdef 
__USE_XOPEN2K


917 extern int 
	$pthread_rwlock_timedrdlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

918 const struct 
timespec
 *
__restrict


919 
__abstime
) 
__THROWNL
 
	`__nonnull
 ((1, 2));

923 extern int 
	$pthread_rwlock_wrlock
 (
pthread_rwlock_t
 *
__rwlock
)

924 
__THROWNL
 
	`__nonnull
 ((1));

927 extern int 
	$pthread_rwlock_trywrlock
 (
pthread_rwlock_t
 *
__rwlock
)

928 
__THROWNL
 
	`__nonnull
 ((1));

930 #ifdef 
__USE_XOPEN2K


932 extern int 
	$pthread_rwlock_timedwrlock
 (
pthread_rwlock_t
 *
__restrict
 
__rwlock
,

933 const struct 
timespec
 *
__restrict


934 
__abstime
) 
__THROWNL
 
	`__nonnull
 ((1, 2));

938 extern int 
	$pthread_rwlock_unlock
 (
pthread_rwlock_t
 *
__rwlock
)

939 
__THROWNL
 
	`__nonnull
 ((1));

945 extern int 
	$pthread_rwlockattr_init
 (
pthread_rwlockattr_t
 *
__attr
)

946 
__THROW
 
	`__nonnull
 ((1));

949 extern int 
	$pthread_rwlockattr_destroy
 (
pthread_rwlockattr_t
 *
__attr
)

950 
__THROW
 
	`__nonnull
 ((1));

953 extern int 
	$pthread_rwlockattr_getpshared
 (const 
pthread_rwlockattr_t
 *

954 
__restrict
 
__attr
,

955 int *
__restrict
 
__pshared
)

956 
__THROW
 
	`__nonnull
 ((1, 2));

959 extern int 
	$pthread_rwlockattr_setpshared
 (
pthread_rwlockattr_t
 *
__attr
,

960 int 
__pshared
)

961 
__THROW
 
	`__nonnull
 ((1));

964 extern int 
	$pthread_rwlockattr_getkind_np
 (const 
pthread_rwlockattr_t
 *

965 
__restrict
 
__attr
,

966 int *
__restrict
 
__pref
)

967 
__THROW
 
	`__nonnull
 ((1, 2));

970 extern int 
	$pthread_rwlockattr_setkind_np
 (
pthread_rwlockattr_t
 *
__attr
,

971 int 
__pref
) 
__THROW
 
	`__nonnull
 ((1));

979 extern int 
	$pthread_cond_init
 (
pthread_cond_t
 *
__restrict
 
__cond
,

980 const 
pthread_condattr_t
 *
__restrict
 
__cond_attr
)

981 
__THROW
 
	`__nonnull
 ((1));

984 extern int 
	$pthread_cond_destroy
 (
pthread_cond_t
 *
__cond
)

985 
__THROW
 
	`__nonnull
 ((1));

988 extern int 
	$pthread_cond_signal
 (
pthread_cond_t
 *
__cond
)

989 
__THROWNL
 
	`__nonnull
 ((1));

992 extern int 
	$pthread_cond_broadcast
 (
pthread_cond_t
 *
__cond
)

993 
__THROWNL
 
	`__nonnull
 ((1));

1000 extern int 
	$pthread_cond_wait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

1001 
pthread_mutex_t
 *
__restrict
 
__mutex
)

1002 
	`__nonnull
 ((1, 2));

1011 extern int 
	$pthread_cond_timedwait
 (
pthread_cond_t
 *
__restrict
 
__cond
,

1012 
pthread_mutex_t
 *
__restrict
 
__mutex
,

1013 const struct 
timespec
 *
__restrict
 
__abstime
)

1014 
	`__nonnull
 ((1, 2, 3));

1019 extern int 
	$pthread_condattr_init
 (
pthread_condattr_t
 *
__attr
)

1020 
__THROW
 
	`__nonnull
 ((1));

1023 extern int 
	$pthread_condattr_destroy
 (
pthread_condattr_t
 *
__attr
)

1024 
__THROW
 
	`__nonnull
 ((1));

1027 extern int 
	$pthread_condattr_getpshared
 (const 
pthread_condattr_t
 *

1028 
__restrict
 
__attr
,

1029 int *
__restrict
 
__pshared
)

1030 
__THROW
 
	`__nonnull
 ((1, 2));

1033 extern int 
	$pthread_condattr_setpshared
 (
pthread_condattr_t
 *
__attr
,

1034 int 
__pshared
) 
__THROW
 
	`__nonnull
 ((1));

1036 #ifdef 
__USE_XOPEN2K


1038 extern int 
	$pthread_condattr_getclock
 (const 
pthread_condattr_t
 *

1039 
__restrict
 
__attr
,

1040 
__clockid_t
 *
__restrict
 
__clock_id
)

1041 
__THROW
 
	`__nonnull
 ((1, 2));

1044 extern int 
	$pthread_condattr_setclock
 (
pthread_condattr_t
 *
__attr
,

1045 
__clockid_t
 
__clock_id
)

1046 
__THROW
 
	`__nonnull
 ((1));

1050 #ifdef 
__USE_XOPEN2K


1055 extern int 
	$pthread_spin_init
 (
pthread_spinlock_t
 *
__lock
, int 
__pshared
)

1056 
__THROW
 
	`__nonnull
 ((1));

1059 extern int 
	$pthread_spin_destroy
 (
pthread_spinlock_t
 *
__lock
)

1060 
__THROW
 
	`__nonnull
 ((1));

1063 extern int 
	$pthread_spin_lock
 (
pthread_spinlock_t
 *
__lock
)

1064 
__THROWNL
 
	`__nonnull
 ((1));

1067 extern int 
	$pthread_spin_trylock
 (
pthread_spinlock_t
 *
__lock
)

1068 
__THROWNL
 
	`__nonnull
 ((1));

1071 extern int 
	$pthread_spin_unlock
 (
pthread_spinlock_t
 *
__lock
)

1072 
__THROWNL
 
	`__nonnull
 ((1));

1079 extern int 
	$pthread_barrier_init
 (
pthread_barrier_t
 *
__restrict
 
__barrier
,

1080 const 
pthread_barrierattr_t
 *
__restrict


1081 
__attr
, unsigned int 
__count
)

1082 
__THROW
 
	`__nonnull
 ((1));

1085 extern int 
	$pthread_barrier_destroy
 (
pthread_barrier_t
 *
__barrier
)

1086 
__THROW
 
	`__nonnull
 ((1));

1089 extern int 
	$pthread_barrier_wait
 (
pthread_barrier_t
 *
__barrier
)

1090 
__THROWNL
 
	`__nonnull
 ((1));

1094 extern int 
	$pthread_barrierattr_init
 (
pthread_barrierattr_t
 *
__attr
)

1095 
__THROW
 
	`__nonnull
 ((1));

1098 extern int 
	$pthread_barrierattr_destroy
 (
pthread_barrierattr_t
 *
__attr
)

1099 
__THROW
 
	`__nonnull
 ((1));

1102 extern int 
	$pthread_barrierattr_getpshared
 (const 
pthread_barrierattr_t
 *

1103 
__restrict
 
__attr
,

1104 int *
__restrict
 
__pshared
)

1105 
__THROW
 
	`__nonnull
 ((1, 2));

1108 extern int 
	$pthread_barrierattr_setpshared
 (
pthread_barrierattr_t
 *
__attr
,

1109 int 
__pshared
)

1110 
__THROW
 
	`__nonnull
 ((1));

1122 extern int 
	`pthread_key_create
 (
pthread_key_t
 *
__key
,

1123 void (*
__destr_function
) (void *))

1124 
__THROW
 
	`__nonnull
 ((1));

1127 extern int 
	$pthread_key_delete
 (
pthread_key_t
 
__key
) 
__THROW
;

1130 extern void *
	$pthread_getspecific
 (
pthread_key_t
 
__key
) 
__THROW
;

1133 extern int 
	$pthread_setspecific
 (
pthread_key_t
 
__key
,

1134 const void *
__pointer
) 
__THROW
 ;

1137 #ifdef 
__USE_XOPEN2K


1139 extern int 
	$pthread_getcpuclockid
 (
pthread_t
 
__thread_id
,

1140 
__clockid_t
 *
__clock_id
)

1141 
__THROW
 
	`__nonnull
 ((2));

1156 extern int 
	`pthread_atfork
 (void (*
__prepare
) (void),

1157 void (*
__parent
) (void),

1158 void (*
__child
) (void)) 
__THROW
;

1161 #ifdef 
__USE_EXTERN_INLINES


1163 
__extern_inline
 int

1164 
	`__NTH
 (
	$pthread_equal
 (
pthread_t
 
__thread1
, pthread_t 
__thread2
))

1166 return 
__thread1
 == 
__thread2
;

1167 
	}
}

1170 
	g__END_DECLS


	@/usr/include/wctype.h

23 #ifndef 
_WCTYPE_H


25 #include 
	~<features.h
>

26 #include 
	~<bits/types.h
>

28 #ifndef 
__need_iswxxx


29 #define 
	#_WCTYPE_H
 1

	)

32 #define 
	#__need_wint_t


	)

33 #include 
	~<wchar.h
>

37 #ifndef 
WEOF


38 #define 
	#WEOF
 (0xffffffffu)

	)

41 #undef 
__need_iswxxx


46 #ifndef 
__iswxxx_defined


47 #define 
	#__iswxxx_defined
 1

	)

49 
__BEGIN_NAMESPACE_C99


52 typedef unsigned long int 
	twctype_t
;

53 
	g__END_NAMESPACE_C99


55 #ifndef 
_ISwbit


60 #include 
	~<endian.h
>

61 #if 
__BYTE_ORDER
 == 
__BIG_ENDIAN


62 #define 
	#_ISwbit
(
bit
) (1 << (bit))

	)

64 #define 
	#_ISwbit
(
bit
) \

65 ((
bit
) < 8 ? (int) ((1UL << (bit)) << 24) \

66 : ((
bit
) < 16 ? (int) ((1UL << (bit)) << 8) \

67 : ((
bit
) < 24 ? (int) ((1UL << (bit)) >> 8) \

68 : (int) ((1UL << (
bit
)) >> 24))))

	)

73 
	m__ISwupper
 = 0,

74 
	m__ISwlower
 = 1,

75 
	m__ISwalpha
 = 2,

76 
	m__ISwdigit
 = 3,

77 
	m__ISwxdigit
 = 4,

78 
	m__ISwspace
 = 5,

79 
	m__ISwprint
 = 6,

80 
	m__ISwgraph
 = 7,

81 
	m__ISwblank
 = 8,

82 
	m__ISwcntrl
 = 9,

83 
	m__ISwpunct
 = 10,

84 
	m__ISwalnum
 = 11,

86 
	m_ISwupper
 = 
_ISwbit
 (
__ISwupper
),

87 
	m_ISwlower
 = 
_ISwbit
 (
__ISwlower
),

88 
	m_ISwalpha
 = 
_ISwbit
 (
__ISwalpha
),

89 
	m_ISwdigit
 = 
_ISwbit
 (
__ISwdigit
),

90 
	m_ISwxdigit
 = 
_ISwbit
 (
__ISwxdigit
),

91 
	m_ISwspace
 = 
_ISwbit
 (
__ISwspace
),

92 
	m_ISwprint
 = 
_ISwbit
 (
__ISwprint
),

93 
	m_ISwgraph
 = 
_ISwbit
 (
__ISwgraph
),

94 
	m_ISwblank
 = 
_ISwbit
 (
__ISwblank
),

95 
	m_ISwcntrl
 = 
_ISwbit
 (
__ISwcntrl
),

96 
	m_ISwpunct
 = 
_ISwbit
 (
__ISwpunct
),

97 
	m_ISwalnum
 = 
_ISwbit
 (
__ISwalnum
)

102 
__BEGIN_DECLS


104 
__BEGIN_NAMESPACE_C99


111 extern int 
	$iswalnum
 (
wint_t
 
__wc
) 
__THROW
;

117 extern int 
	$iswalpha
 (
wint_t
 
__wc
) 
__THROW
;

120 extern int 
	$iswcntrl
 (
wint_t
 
__wc
) 
__THROW
;

124 extern int 
	$iswdigit
 (
wint_t
 
__wc
) 
__THROW
;

128 extern int 
	$iswgraph
 (
wint_t
 
__wc
) 
__THROW
;

133 extern int 
	$iswlower
 (
wint_t
 
__wc
) 
__THROW
;

136 extern int 
	$iswprint
 (
wint_t
 
__wc
) 
__THROW
;

141 extern int 
	$iswpunct
 (
wint_t
 
__wc
) 
__THROW
;

146 extern int 
	$iswspace
 (
wint_t
 
__wc
) 
__THROW
;

151 extern int 
	$iswupper
 (
wint_t
 
__wc
) 
__THROW
;

156 extern int 
	$iswxdigit
 (
wint_t
 
__wc
) 
__THROW
;

161 #ifdef 
__USE_ISOC99


162 extern int 
	$iswblank
 (
wint_t
 
__wc
) 
__THROW
;

171 extern 
wctype_t
 
	$wctype
 (const char *
__property
) 
__THROW
;

175 extern int 
	$iswctype
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
) 
__THROW
;

176 
__END_NAMESPACE_C99


183 
__BEGIN_NAMESPACE_C99


186 typedef const 
	t__int32_t
 *
	twctrans_t
;

187 
__END_NAMESPACE_C99


188 #ifdef 
__USE_GNU


189 
	$__USING_NAMESPACE_C99
(
wctrans_t
)

192 
__BEGIN_NAMESPACE_C99


194 extern 
wint_t
 
	$towlower
 (
wint_t
 
__wc
) 
__THROW
;

197 extern 
wint_t
 
	$towupper
 (
wint_t
 
__wc
) 
__THROW
;

198 
__END_NAMESPACE_C99


200 
__END_DECLS


207 #ifdef 
_WCTYPE_H


213 
__BEGIN_DECLS


215 
__BEGIN_NAMESPACE_C99


218 extern 
wctrans_t
 
	$wctrans
 (const char *
__property
) 
__THROW
;

221 extern 
wint_t
 
	$towctrans
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
) 
__THROW
;

222 
__END_NAMESPACE_C99


224 #ifdef 
__USE_XOPEN2K8


226 #include 
	~<xlocale.h
>

230 extern int 
	$iswalnum_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

236 extern int 
	$iswalpha_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

239 extern int 
	$iswcntrl_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

243 extern int 
	$iswdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

247 extern int 
	$iswgraph_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

252 extern int 
	$iswlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

255 extern int 
	$iswprint_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

260 extern int 
	$iswpunct_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

265 extern int 
	$iswspace_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

270 extern int 
	$iswupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

275 extern int 
	$iswxdigit_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

280 extern int 
	$iswblank_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

284 extern 
wctype_t
 
	$wctype_l
 (const char *
__property
, 
__locale_t
 
__locale
)

285 
__THROW
;

289 extern int 
	$iswctype_l
 (
wint_t
 
__wc
, 
wctype_t
 
__desc
, 
__locale_t
 
__locale
)

290 
__THROW
;

298 extern 
wint_t
 
	$towlower_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

301 extern 
wint_t
 
	$towupper_l
 (
wint_t
 
__wc
, 
__locale_t
 
__locale
) 
__THROW
;

305 extern 
wctrans_t
 
	$wctrans_l
 (const char *
__property
, 
__locale_t
 
__locale
)

306 
__THROW
;

309 extern 
wint_t
 
	$towctrans_l
 (
wint_t
 
__wc
, 
wctrans_t
 
__desc
,

310 
__locale_t
 
__locale
) 
__THROW
;

314 
__END_DECLS


	@/usr/include/bits/errno.h

19 #ifdef 
_ERRNO_H


21 #undef 
EDOM


22 #undef 
EILSEQ


23 #undef 
ERANGE


24 #include 
	~<linux/errno.h
>

27 #define 
	#ENOTSUP
 
EOPNOTSUPP


	)

30 #ifndef 
ECANCELED


31 #define 
	#ECANCELED
 125

	)

35 #ifndef 
EOWNERDEAD


36 #define 
	#EOWNERDEAD
 130

	)

37 #define 
	#ENOTRECOVERABLE
 131

	)

40 #ifndef 
ERFKILL


41 #define 
	#ERFKILL
 132

	)

44 #ifndef 
EHWPOISON


45 #define 
	#EHWPOISON
 133

	)

48 #ifndef 
__ASSEMBLER__


50 extern int *
	$__errno_location
 (void) 
__THROW
 
	`__attribute__
 ((
__const__
));

52 #if !
defined
 
_LIBC
 || defined 
_LIBC_REENTRANT


54 #define 
	#errno
 (*
	`__errno_location
 ())

	)

59 #if !
defined
 
_ERRNO_H
 && defined 
__need_Emath


63 #define 
	#EDOM
 33

	)

64 #define 
	#EILSEQ
 84

	)

65 #define 
	#ERANGE
 34

	)

	@/usr/include/bits/setjmp.h

19 #ifndef 
_BITS_SETJMP_H


20 #define 
	#_BITS_SETJMP_H
 1

	)

22 #if !
defined
 
_SETJMP_H
 && !defined 
_PTHREAD_H


26 #include 
	~<bits/wordsize.h
>

28 #ifndef 
_ASM


30 #if 
__WORDSIZE
 == 64

31 typedef long int 
	t__jmp_buf
[8];

32 #elif 
defined
 
__x86_64__


33 
__extension__
 typedef long long int 
	t__jmp_buf
[8];

35 typedef int 
	t__jmp_buf
[6];

	@/usr/include/sched.h

19 #ifndef 
_SCHED_H


20 #define 
	#_SCHED_H
 1

	)

22 #include 
	~<features.h
>

25 #include 
	~<bits/types.h
>

27 #define 
	#__need_size_t


	)

28 #include 
	~<stddef.h
>

30 #define 
	#__need_time_t


	)

31 #define 
	#__need_timespec


	)

32 #include 
	~<time.h
>

34 #ifndef 
__pid_t_defined


35 typedef 
__pid_t
 
	tpid_t
;

36 #define 
	#__pid_t_defined


	)

41 #include 
	~<bits/sched.h
>

43 #define 
	#sched_priority
 
__sched_priority


	)

46 
__BEGIN_DECLS


49 extern int 
	$sched_setparam
 (
__pid_t
 
__pid
, const struct 
sched_param
 *
__param
)

50 
__THROW
;

53 extern int 
	$sched_getparam
 (
__pid_t
 
__pid
, struct 
sched_param
 *
__param
) 
__THROW
;

56 extern int 
	$sched_setscheduler
 (
__pid_t
 
__pid
, int 
__policy
,

57 const struct 
sched_param
 *
__param
) 
__THROW
;

60 extern int 
	$sched_getscheduler
 (
__pid_t
 
__pid
) 
__THROW
;

63 extern int 
	$sched_yield
 (void) 
__THROW
;

66 extern int 
	$sched_get_priority_max
 (int 
__algorithm
) 
__THROW
;

69 extern int 
	$sched_get_priority_min
 (int 
__algorithm
) 
__THROW
;

72 extern int 
	$sched_rr_get_interval
 (
__pid_t
 
__pid
, struct 
timespec
 *
__t
) 
__THROW
;

75 #ifdef 
__USE_GNU


77 #define 
	#CPU_SETSIZE
 
__CPU_SETSIZE


	)

78 #define 
	#CPU_SET
(
cpu
, 
cpusetp
) 
	`__CPU_SET_S
 (cpu, sizeof (
cpu_set_t
), cpusetp)

	)

79 #define 
	#CPU_CLR
(
cpu
, 
cpusetp
) 
	`__CPU_CLR_S
 (cpu, sizeof (
cpu_set_t
), cpusetp)

	)

80 #define 
	#CPU_ISSET
(
cpu
, 
cpusetp
) 
	`__CPU_ISSET_S
 (cpu, sizeof (
cpu_set_t
), \

81 
cpusetp
)

	)

82 #define 
	#CPU_ZERO
(
cpusetp
) 
	`__CPU_ZERO_S
 (sizeof (
cpu_set_t
), cpusetp)

	)

83 #define 
	#CPU_COUNT
(
cpusetp
) 
	`__CPU_COUNT_S
 (sizeof (
cpu_set_t
), cpusetp)

	)

85 #define 
	#CPU_SET_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_SET_S
 (cpu, setsize, cpusetp)

	)

86 #define 
	#CPU_CLR_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_CLR_S
 (cpu, setsize, cpusetp)

	)

87 #define 
	#CPU_ISSET_S
(
cpu
, 
setsize
, 
cpusetp
) 
	`__CPU_ISSET_S
 (cpu, setsize, \

88 
cpusetp
)

	)

89 #define 
	#CPU_ZERO_S
(
setsize
, 
cpusetp
) 
	`__CPU_ZERO_S
 (setsize, cpusetp)

	)

90 #define 
	#CPU_COUNT_S
(
setsize
, 
cpusetp
) 
	`__CPU_COUNT_S
 (setsize, cpusetp)

	)

92 #define 
	#CPU_EQUAL
(
cpusetp1
, 
cpusetp2
) \

93 
	`__CPU_EQUAL_S
 (sizeof (
cpu_set_t
), 
cpusetp1
, 
cpusetp2
)

	)

94 #define 
	#CPU_EQUAL_S
(
setsize
, 
cpusetp1
, 
cpusetp2
) \

95 
	`__CPU_EQUAL_S
 (
setsize
, 
cpusetp1
, 
cpusetp2
)

	)

97 #define 
	#CPU_AND
(
destset
, 
srcset1
, 
srcset2
) \

98 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, &)

	)

99 #define 
	#CPU_OR
(
destset
, 
srcset1
, 
srcset2
) \

100 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, |)

	)

101 #define 
	#CPU_XOR
(
destset
, 
srcset1
, 
srcset2
) \

102 
	`__CPU_OP_S
 (sizeof (
cpu_set_t
), 
destset
, 
srcset1
, 
srcset2
, ^)

	)

103 #define 
	#CPU_AND_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

104 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, &)

	)

105 #define 
	#CPU_OR_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

106 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, |)

	)

107 #define 
	#CPU_XOR_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
) \

108 
	`__CPU_OP_S
 (
setsize
, 
destset
, 
srcset1
, 
srcset2
, ^)

	)

110 #define 
	#CPU_ALLOC_SIZE
(
count
) 
	`__CPU_ALLOC_SIZE
 (count)

	)

111 #define 
	#CPU_ALLOC
(
count
) 
	`__CPU_ALLOC
 (count)

	)

112 #define 
	#CPU_FREE
(
cpuset
) 
	`__CPU_FREE
 (cpuset)

	)

116 extern int 
	$sched_setaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

117 const 
cpu_set_t
 *
__cpuset
) 
__THROW
;

120 extern int 
	$sched_getaffinity
 (
__pid_t
 
__pid
, 
size_t
 
__cpusetsize
,

121 
cpu_set_t
 *
__cpuset
) 
__THROW
;

124 
__END_DECLS


	@/usr/include/bits/sched.h

20 #ifndef 
__need_schedparam


22 #ifndef 
_SCHED_H


28 #define 
	#SCHED_OTHER
 0

	)

29 #define 
	#SCHED_FIFO
 1

	)

30 #define 
	#SCHED_RR
 2

	)

31 #ifdef 
__USE_GNU


32 #define 
	#SCHED_BATCH
 3

	)

33 #define 
	#SCHED_IDLE
 5

	)

35 #define 
	#SCHED_RESET_ON_FORK
 0x40000000

	)

38 #ifdef 
__USE_GNU


40 #define 
	#CSIGNAL
 0x000000ff

	)

41 #define 
	#CLONE_VM
 0x00000100

	)

42 #define 
	#CLONE_FS
 0x00000200

	)

43 #define 
	#CLONE_FILES
 0x00000400

	)

44 #define 
	#CLONE_SIGHAND
 0x00000800

	)

45 #define 
	#CLONE_PTRACE
 0x00002000

	)

46 #define 
	#CLONE_VFORK
 0x00004000

	)

48 #define 
	#CLONE_PARENT
 0x00008000

	)

50 #define 
	#CLONE_THREAD
 0x00010000

	)

51 #define 
	#CLONE_NEWNS
 0x00020000

	)

52 #define 
	#CLONE_SYSVSEM
 0x00040000

	)

53 #define 
	#CLONE_SETTLS
 0x00080000

	)

54 #define 
	#CLONE_PARENT_SETTID
 0x00100000

	)

56 #define 
	#CLONE_CHILD_CLEARTID
 0x00200000

	)

58 #define 
	#CLONE_DETACHED
 0x00400000

	)

59 #define 
	#CLONE_UNTRACED
 0x00800000

	)

61 #define 
	#CLONE_CHILD_SETTID
 0x01000000

	)

63 #define 
	#CLONE_NEWUTS
 0x04000000

	)

64 #define 
	#CLONE_NEWIPC
 0x08000000

	)

65 #define 
	#CLONE_NEWUSER
 0x10000000

	)

66 #define 
	#CLONE_NEWPID
 0x20000000

	)

67 #define 
	#CLONE_NEWNET
 0x40000000

	)

68 #define 
	#CLONE_IO
 0x80000000

	)

72 struct 
	ssched_param


74 int 
	m__sched_priority
;

77 
	g__BEGIN_DECLS


79 #ifdef 
__USE_GNU


81 extern int 
clone
 (int (*
__fn
) (void *
__arg
), void *
__child_stack
,

82 int 
__flags
, void *
__arg
, ...) 
__THROW
;

85 extern int 
	$unshare
 (int 
__flags
) 
__THROW
;

88 extern int 
	$sched_getcpu
 (void) 
__THROW
;

91 extern int 
	$setns
 (int 
__fd
, int 
__nstype
) 
__THROW
;

95 
__END_DECLS


99 #if !
defined
 
__defined_schedparam
 \

100 && (
defined
 
__need_schedparam
 || defined 
_SCHED_H
)

101 #define 
	#__defined_schedparam
 1

	)

103 struct 
	s__sched_param


105 int 
__sched_priority
;

107 #undef 
__need_schedparam


111 #if 
defined
 
_SCHED_H
 && !defined 
__cpu_set_t_defined


112 #define 
	#__cpu_set_t_defined


	)

114 #define 
	#__CPU_SETSIZE
 1024

	)

115 #define 
	#__NCPUBITS
 (8 * sizeof (
__cpu_mask
))

	)

118 typedef unsigned long int 
	t__cpu_mask
;

121 #define 
	#__CPUELT
(
cpu
) ((cpu) / 
__NCPUBITS
)

	)

122 #define 
	#__CPUMASK
(
cpu
) ((
__cpu_mask
) 1 << ((cpu) % 
__NCPUBITS
))

	)

127 
__cpu_mask
 
__bits
[
__CPU_SETSIZE
 / 
__NCPUBITS
];

128 } 
	tcpu_set_t
;

131 #if 
	`__GNUC_PREREQ
 (2, 91)

132 #define 
	#__CPU_ZERO_S
(
setsize
, 
cpusetp
) \

133 do 
	`__builtin_memset
 (
cpusetp
, '\0', 
setsize
); while (0)

	)

135 #define 
	#__CPU_ZERO_S
(
setsize
, 
cpusetp
) \

137 
size_t
 
__i
; \

138 
size_t
 
__imax
 = (
setsize
) / sizeof (
__cpu_mask
); \

139 
__cpu_mask
 *
__bits
 = (
cpusetp
)->__bits; \

140 for (
__i
 = 0; __i < 
__imax
; ++__i) \

141 
__bits
[
__i
] = 0; \

142 
	}
} while (0)

	)

144 #define 
	#__CPU_SET_S
(
cpu
, 
setsize
, 
cpusetp
) \

145 (
__extension__
 \

146 ({ 
size_t
 
__cpu
 = (
cpu
); \

147 
__cpu
 / 8 < (
setsize
) \

148 ? (((
__cpu_mask
 *) ((
cpusetp
)->
__bits
))[
	`__CPUELT
 (
__cpu
)] \

149 |= 
	`__CPUMASK
 (
__cpu
)) \

150 : 0; }))

	)

151 #define 
	#__CPU_CLR_S
(
cpu
, 
setsize
, 
cpusetp
) \

152 (
__extension__
 \

153 ({ 
size_t
 
__cpu
 = (
cpu
); \

154 
__cpu
 / 8 < (
setsize
) \

155 ? (((
__cpu_mask
 *) ((
cpusetp
)->
__bits
))[
	`__CPUELT
 (
__cpu
)] \

156 &= ~
	`__CPUMASK
 (
__cpu
)) \

157 : 0; }))

	)

158 #define 
	#__CPU_ISSET_S
(
cpu
, 
setsize
, 
cpusetp
) \

159 (
__extension__
 \

160 ({ 
size_t
 
__cpu
 = (
cpu
); \

161 
__cpu
 / 8 < (
setsize
) \

162 ? ((((const 
__cpu_mask
 *) ((
cpusetp
)->
__bits
))[
	`__CPUELT
 (
__cpu
)] \

163 & 
	`__CPUMASK
 (
__cpu
))) != 0 \

164 : 0; }))

	)

166 #define 
	#__CPU_COUNT_S
(
setsize
, 
cpusetp
) \

167 
	`__sched_cpucount
 (
setsize
, 
cpusetp
)

	)

169 #if 
__GNUC_PREREQ
 (2, 91)

170 #define 
	#__CPU_EQUAL_S
(
setsize
, 
cpusetp1
, 
cpusetp2
) \

171 (
	`__builtin_memcmp
 (
cpusetp1
, 
cpusetp2
, 
setsize
) == 0)

	)

173 #define 
	#__CPU_EQUAL_S
(
setsize
, 
cpusetp1
, 
cpusetp2
) \

174 (
__extension__
 \

175 ({ const 
__cpu_mask
 *
__arr1
 = (
cpusetp1
)->
__bits
; \

176 const 
__cpu_mask
 *
__arr2
 = (
cpusetp2
)->
__bits
; \

177 
size_t
 
__imax
 = (
setsize
) / sizeof (
__cpu_mask
); \

178 
size_t
 
__i
; \

179 for (
__i
 = 0; __i < 
__imax
; ++__i) \

180 if (
__arr1
[
__i
] != 
__arr2
[__i]) \

182 
__i
 == 
__imax
; }))

	)

185 #define 
	#__CPU_OP_S
(
setsize
, 
destset
, 
srcset1
, 
srcset2
, 
op
) \

186 (
__extension__
 \

187 ({ 
cpu_set_t
 *
__dest
 = (
destset
); \

188 const 
__cpu_mask
 *
__arr1
 = (
srcset1
)->
__bits
; \

189 const 
__cpu_mask
 *
__arr2
 = (
srcset2
)->
__bits
; \

190 
size_t
 
__imax
 = (
setsize
) / sizeof (
__cpu_mask
); \

191 
size_t
 
__i
; \

192 for (
__i
 = 0; __i < 
__imax
; ++__i) \

193 ((
__cpu_mask
 *) 
__dest
->
__bits
)[
__i
] = 
__arr1
[__i] 
op
 
__arr2
[__i]; \

194 
__dest
; }))

	)

196 #define 
	#__CPU_ALLOC_SIZE
(
count
) \

197 ((((
count
) + 
__NCPUBITS
 - 1) / __NCPUBITS) * sizeof (
__cpu_mask
))

	)

198 #define 
	#__CPU_ALLOC
(
count
) 
	`__sched_cpualloc
 (count)

	)

199 #define 
	#__CPU_FREE
(
cpuset
) 
	`__sched_cpufree
 (cpuset)

	)

201 
__BEGIN_DECLS


203 extern int 
	$__sched_cpucount
 (
size_t
 
__setsize
, const 
cpu_set_t
 *
__setp
)

204 
__THROW
;

205 extern 
cpu_set_t
 *
	$__sched_cpualloc
 (
size_t
 
__count
) 
__THROW
 
__wur
;

206 extern void 
	$__sched_cpufree
 (
cpu_set_t
 *
__set
) 
__THROW
;

208 
__END_DECLS


	@/usr/include/linux/errno.h

1 #include 
	~<asm/errno.h
>

	@/usr/include/asm/errno.h

1 #include 
	~<asm-generic/errno.h
>

	@/usr/include/asm-generic/errno.h

1 #ifndef 
_ASM_GENERIC_ERRNO_H


2 #define 
	#_ASM_GENERIC_ERRNO_H


	)

4 #include 
	~<asm-generic/errno-base.h
>

6 #define 
	#EDEADLK
 35

	)

7 #define 
	#ENAMETOOLONG
 36

	)

8 #define 
	#ENOLCK
 37

	)

9 #define 
	#ENOSYS
 38

	)

10 #define 
	#ENOTEMPTY
 39

	)

11 #define 
	#ELOOP
 40

	)

12 #define 
	#EWOULDBLOCK
 
EAGAIN


	)

13 #define 
	#ENOMSG
 42

	)

14 #define 
	#EIDRM
 43

	)

15 #define 
	#ECHRNG
 44

	)

16 #define 
	#EL2NSYNC
 45

	)

17 #define 
	#EL3HLT
 46

	)

18 #define 
	#EL3RST
 47

	)

19 #define 
	#ELNRNG
 48

	)

20 #define 
	#EUNATCH
 49

	)

21 #define 
	#ENOCSI
 50

	)

22 #define 
	#EL2HLT
 51

	)

23 #define 
	#EBADE
 52

	)

24 #define 
	#EBADR
 53

	)

25 #define 
	#EXFULL
 54

	)

26 #define 
	#ENOANO
 55

	)

27 #define 
	#EBADRQC
 56

	)

28 #define 
	#EBADSLT
 57

	)

30 #define 
	#EDEADLOCK
 
EDEADLK


	)

32 #define 
	#EBFONT
 59

	)

33 #define 
	#ENOSTR
 60

	)

34 #define 
	#ENODATA
 61

	)

35 #define 
	#ETIME
 62

	)

36 #define 
	#ENOSR
 63

	)

37 #define 
	#ENONET
 64

	)

38 #define 
	#ENOPKG
 65

	)

39 #define 
	#EREMOTE
 66

	)

40 #define 
	#ENOLINK
 67

	)

41 #define 
	#EADV
 68

	)

42 #define 
	#ESRMNT
 69

	)

43 #define 
	#ECOMM
 70

	)

44 #define 
	#EPROTO
 71

	)

45 #define 
	#EMULTIHOP
 72

	)

46 #define 
	#EDOTDOT
 73

	)

47 #define 
	#EBADMSG
 74

	)

48 #define 
	#EOVERFLOW
 75

	)

49 #define 
	#ENOTUNIQ
 76

	)

50 #define 
	#EBADFD
 77

	)

51 #define 
	#EREMCHG
 78

	)

52 #define 
	#ELIBACC
 79

	)

53 #define 
	#ELIBBAD
 80

	)

54 #define 
	#ELIBSCN
 81

	)

55 #define 
	#ELIBMAX
 82

	)

56 #define 
	#ELIBEXEC
 83

	)

57 #define 
	#EILSEQ
 84

	)

58 #define 
	#ERESTART
 85

	)

59 #define 
	#ESTRPIPE
 86

	)

60 #define 
	#EUSERS
 87

	)

61 #define 
	#ENOTSOCK
 88

	)

62 #define 
	#EDESTADDRREQ
 89

	)

63 #define 
	#EMSGSIZE
 90

	)

64 #define 
	#EPROTOTYPE
 91

	)

65 #define 
	#ENOPROTOOPT
 92

	)

66 #define 
	#EPROTONOSUPPORT
 93

	)

67 #define 
	#ESOCKTNOSUPPORT
 94

	)

68 #define 
	#EOPNOTSUPP
 95

	)

69 #define 
	#EPFNOSUPPORT
 96

	)

70 #define 
	#EAFNOSUPPORT
 97

	)

71 #define 
	#EADDRINUSE
 98

	)

72 #define 
	#EADDRNOTAVAIL
 99

	)

73 #define 
	#ENETDOWN
 100

	)

74 #define 
	#ENETUNREACH
 101

	)

75 #define 
	#ENETRESET
 102

	)

76 #define 
	#ECONNABORTED
 103

	)

77 #define 
	#ECONNRESET
 104

	)

78 #define 
	#ENOBUFS
 105

	)

79 #define 
	#EISCONN
 106

	)

80 #define 
	#ENOTCONN
 107

	)

81 #define 
	#ESHUTDOWN
 108

	)

82 #define 
	#ETOOMANYREFS
 109

	)

83 #define 
	#ETIMEDOUT
 110

	)

84 #define 
	#ECONNREFUSED
 111

	)

85 #define 
	#EHOSTDOWN
 112

	)

86 #define 
	#EHOSTUNREACH
 113

	)

87 #define 
	#EALREADY
 114

	)

88 #define 
	#EINPROGRESS
 115

	)

89 #define 
	#ESTALE
 116

	)

90 #define 
	#EUCLEAN
 117

	)

91 #define 
	#ENOTNAM
 118

	)

92 #define 
	#ENAVAIL
 119

	)

93 #define 
	#EISNAM
 120

	)

94 #define 
	#EREMOTEIO
 121

	)

95 #define 
	#EDQUOT
 122

	)

97 #define 
	#ENOMEDIUM
 123

	)

98 #define 
	#EMEDIUMTYPE
 124

	)

99 #define 
	#ECANCELED
 125

	)

100 #define 
	#ENOKEY
 126

	)

101 #define 
	#EKEYEXPIRED
 127

	)

102 #define 
	#EKEYREVOKED
 128

	)

103 #define 
	#EKEYREJECTED
 129

	)

106 #define 
	#EOWNERDEAD
 130

	)

107 #define 
	#ENOTRECOVERABLE
 131

	)

109 #define 
	#ERFKILL
 132

	)

111 #define 
	#EHWPOISON
 133

	)

	@/usr/include/asm-generic/errno-base.h

1 #ifndef 
_ASM_GENERIC_ERRNO_BASE_H


2 #define 
	#_ASM_GENERIC_ERRNO_BASE_H


	)

4 #define 
	#EPERM
 1

	)

5 #define 
	#ENOENT
 2

	)

6 #define 
	#ESRCH
 3

	)

7 #define 
	#EINTR
 4

	)

8 #define 
	#EIO
 5

	)

9 #define 
	#ENXIO
 6

	)

10 #define 
	#E2BIG
 7

	)

11 #define 
	#ENOEXEC
 8

	)

12 #define 
	#EBADF
 9

	)

13 #define 
	#ECHILD
 10

	)

14 #define 
	#EAGAIN
 11

	)

15 #define 
	#ENOMEM
 12

	)

16 #define 
	#EACCES
 13

	)

17 #define 
	#EFAULT
 14

	)

18 #define 
	#ENOTBLK
 15

	)

19 #define 
	#EBUSY
 16

	)

20 #define 
	#EEXIST
 17

	)

21 #define 
	#EXDEV
 18

	)

22 #define 
	#ENODEV
 19

	)

23 #define 
	#ENOTDIR
 20

	)

24 #define 
	#EISDIR
 21

	)

25 #define 
	#EINVAL
 22

	)

26 #define 
	#ENFILE
 23

	)

27 #define 
	#EMFILE
 24

	)

28 #define 
	#ENOTTY
 25

	)

29 #define 
	#ETXTBSY
 26

	)

30 #define 
	#EFBIG
 27

	)

31 #define 
	#ENOSPC
 28

	)

32 #define 
	#ESPIPE
 29

	)

33 #define 
	#EROFS
 30

	)

34 #define 
	#EMLINK
 31

	)

35 #define 
	#EPIPE
 32

	)

36 #define 
	#EDOM
 33

	)

37 #define 
	#ERANGE
 34

	)

	@
1
.
1
/usr/include
212
7305
FreeRTOS/croutine.c
FreeRTOS/include/FreeRTOS.h
FreeRTOS/include/FreeRTOSConfig.h
FreeRTOS/include/StackMacros.h
FreeRTOS/include/croutine.h
FreeRTOS/include/list.h
FreeRTOS/include/mpu_wrappers.h
FreeRTOS/include/portable.h
FreeRTOS/include/projdefs.h
FreeRTOS/include/queue.h
FreeRTOS/include/semphr.h
FreeRTOS/include/task.h
FreeRTOS/include/timers.h
FreeRTOS/list.c
FreeRTOS/portable/GCC/ARM_CM4F/port.c
FreeRTOS/portable/GCC/ARM_CM4F/portmacro.h
FreeRTOS/portable/MemMang/heap_1.c
FreeRTOS/queue.c
FreeRTOS/tasks.c
FreeRTOS/timers.c
Libraries/CMSIS/Include/core_cm4.h
Libraries/CMSIS/Include/core_cm4_simd.h
Libraries/CMSIS/Include/core_cmFunc.h
Libraries/CMSIS/Include/core_cmInstr.h
Libraries/Device/STM32F4xx/Include/stm32f4xx.h
Libraries/Device/STM32F4xx/Include/system_stm32f4xx.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/misc.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_adc.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_can.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_crc.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_cryp.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dac.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dbgmcu.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dcmi.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_dma.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_exti.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_flash.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_fsmc.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_gpio.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_hash.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_i2c.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_iwdg.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_pwr.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rcc.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rng.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_rtc.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_sdio.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_spi.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_syscfg.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_tim.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_usart.h
Libraries/STM32F4xx_StdPeriph_Driver/inc/stm32f4xx_wwdg.h
Libraries/STM32F4xx_StdPeriph_Driver/src/misc.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_adc.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_can.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_crc.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_aes.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_des.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_cryp_tdes.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dac.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dbgmcu.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dcmi.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_dma.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_exti.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_flash.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_fsmc.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_gpio.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_md5.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_hash_sha1.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_i2c.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_iwdg.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_pwr.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rcc.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rng.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_rtc.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_sdio.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_spi.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_syscfg.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_tim.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_usart.c
Libraries/STM32F4xx_StdPeriph_Driver/src/stm32f4xx_wwdg.c
Utilities/stm32f4_discovery.c
Utilities/stm32f4_discovery.h
Utilities/stm32f4_discovery_lis302dl.c
Utilities/stm32f4_discovery_lis302dl.h
config/nvicconf.h
drivers/inc/adc.h
drivers/inc/exti.h
drivers/inc/i2cdev.h
drivers/inc/i2croutines.h
drivers/inc/motors.h
drivers/inc/mpu6050.h
drivers/inc/nRF24L01reg.h
drivers/inc/nrf24l01.h
drivers/inc/nvic.h
drivers/inc/px4flow.h
drivers/src/adc.c
drivers/src/exti.c
drivers/src/i2cdev.c
drivers/src/i2croutines.c
drivers/src/motors.c
drivers/src/mpu6050.c
drivers/src/nrf24l01.c
drivers/src/nvic.c
drivers/src/px4flow.c
hal/interface/imu.h
hal/src/imu.c
modules/interface/sensfusion6.h
modules/interface/stabilizer.h
modules/src/sensfusion6.c
modules/src/stabilizer.c
src/debug.c
src/debug.h
src/hw_config.c
src/hw_config.h
src/main.c
src/serial_tasks.c
src/serial_tasks.h
src/stdbool.h
src/stm32f4xx_conf.h
src/stm32f4xx_it.c
src/stm32f4xx_it.h
src/system_stm32f4xx.c
src/tiny_printf.c
utils/interface/cfassert.h
utils/interface/debug.h
utils/interface/filter.h
utils/interface/version.h
utils/src/cfassert.c
utils/src/debug.c
utils/src/filter.c
/usr/include/ctype.h
/usr/include/inttypes.h
/usr/include/math.h
/usr/include/stdint.h
/usr/include/stdio.h
/usr/include/stdlib.h
/usr/include/string.h
/usr/include/alloca.h
/usr/include/bits/huge_val.h
/usr/include/bits/huge_valf.h
/usr/include/bits/huge_vall.h
/usr/include/bits/inf.h
/usr/include/bits/math-finite.h
/usr/include/bits/mathcalls.h
/usr/include/bits/mathdef.h
/usr/include/bits/mathinline.h
/usr/include/bits/nan.h
/usr/include/bits/stdio-ldbl.h
/usr/include/bits/stdio.h
/usr/include/bits/stdio2.h
/usr/include/bits/stdio_lim.h
/usr/include/bits/stdlib-bsearch.h
/usr/include/bits/stdlib-float.h
/usr/include/bits/stdlib-ldbl.h
/usr/include/bits/stdlib.h
/usr/include/bits/string.h
/usr/include/bits/string2.h
/usr/include/bits/string3.h
/usr/include/bits/sys_errlist.h
/usr/include/bits/types.h
/usr/include/bits/waitflags.h
/usr/include/bits/waitstatus.h
/usr/include/bits/wchar.h
/usr/include/bits/wordsize.h
/usr/include/endian.h
/usr/include/features.h
/usr/include/getopt.h
/usr/include/libio.h
/usr/include/sys/types.h
/usr/include/xlocale.h
/usr/include/_G_config.h
/usr/include/bits/byteswap.h
/usr/include/bits/endian.h
/usr/include/bits/libio-ldbl.h
/usr/include/bits/pthreadtypes.h
/usr/include/bits/stdio-lock.h
/usr/include/bits/typesizes.h
/usr/include/gnu/stubs.h
/usr/include/stdc-predef.h
/usr/include/sys/cdefs.h
/usr/include/sys/select.h
/usr/include/sys/sysmacros.h
/usr/include/time.h
/usr/include/bits/byteswap-16.h
/usr/include/bits/libc-lock.h
/usr/include/bits/select.h
/usr/include/bits/select2.h
/usr/include/bits/sigset.h
/usr/include/bits/time.h
/usr/include/gconv.h
/usr/include/gnu/stubs-32.h
/usr/include/gnu/stubs-64.h
/usr/include/gnu/stubs-x32.h
/usr/include/wchar.h
/usr/include/bits/timex.h
/usr/include/bits/wchar-ldbl.h
/usr/include/bits/wchar2.h
/usr/include/errno.h
/usr/include/gnu/option-groups.h
/usr/include/pthread.h
/usr/include/wctype.h
/usr/include/bits/errno.h
/usr/include/bits/setjmp.h
/usr/include/sched.h
/usr/include/bits/sched.h
/usr/include/linux/errno.h
/usr/include/asm/errno.h
/usr/include/asm-generic/errno.h
/usr/include/asm-generic/errno-base.h
